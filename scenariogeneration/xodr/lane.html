<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xodr.lane API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.lane</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xodr.lane.ExplicitRoadLine"><code class="flex name class">
<span>class <span class="ident">ExplicitRoadLine</span></span>
<span>(</span><span>width: float = 0,<br>length: float = 0,<br>toffset: float = 0,<br>soffset: float = 0,<br>rule: <a title="scenariogeneration.xodr.enumerations.MarkRule" href="enumerations.html#scenariogeneration.xodr.enumerations.MarkRule">MarkRule</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExplicitRoadLine(XodrBase):
    &#34;&#34;&#34;Create an Explicit RoadLine type to be used in roadmark.

    Parameters
    ----------
    width : float, optional
        The width of the line. Default is 0.
    length : float, optional
        The length of the line. Default is 0.
    toffset : float, optional
        The offset in the `t` direction. Default is 0.
    soffset : float, optional
        The offset in the `s` direction. Default is 0.
    rule : MarkRule, optional
        The marking rule. Default is None.

    Attributes
    ----------
    length : float
        The length of the line.
    toffset : float
        The offset in the `t` direction.
    soffset : float
        The offset in the `s` direction.
    rule : MarkRule
        The marking rule.
    width : float
        The width of the line.

    Methods
    -------
    get_element()
        Return the ElementTree representation of the `ExplicitRoadLine`.
    get_attributes()
        Return the attributes of the `ExplicitRoadLine` as a dictionary.
    &#34;&#34;&#34;

    # TODO: check this for 1.5
    def __init__(
        self,
        width: float = 0,
        length: float = 0,
        toffset: float = 0,
        soffset: float = 0,
        rule: Optional[MarkRule] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `ExplicitRoadLine` class.

        Parameters
        ----------
        width : float, optional
            The width of the line. Default is 0.
        length : float, optional
            The length of the line. Default is 0.
        toffset : float, optional
            The offset in the `t` direction. Default is 0.
        soffset : float, optional
            The offset in the `s` direction. Default is 0.
        rule : MarkRule, optional
            The marking rule. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.length = length
        self.toffset = toffset
        self.rule = enumchecker(rule, MarkRule, True)
        self.soffset = soffset
        self.width = width
        self._remainder = 0

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ExplicitRoadLine) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `ExplicitRoadLine` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            `ExplicitRoadLine`.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;tOffset&#34;] = str(self.toffset)
        retdict[&#34;width&#34;] = str(self.width)
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        if self.rule:
            retdict[&#34;rule&#34;] = enum2str(self.rule)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `ExplicitRoadLine`.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `ExplicitRoadLine`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>Create an Explicit RoadLine type to be used in roadmark.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the line. Default is 0.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the line. Default is 0.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the line.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>t</code> direction.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>s</code> direction.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code></dt>
<dd>The marking rule.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The width of the line.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code>.
get_attributes()
Return the attributes of the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code> as a dictionary.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the line. Default is 0.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the line. Default is 0.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.ExplicitRoadLine.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `ExplicitRoadLine` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        `ExplicitRoadLine`.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;length&#34;] = str(self.length)
    retdict[&#34;tOffset&#34;] = str(self.toffset)
    retdict[&#34;width&#34;] = str(self.width)
    retdict[&#34;sOffset&#34;] = str(self.soffset)
    if self.rule:
        retdict[&#34;rule&#34;] = enum2str(self.rule)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
<code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.ExplicitRoadLine.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `ExplicitRoadLine`.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `ExplicitRoadLine`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code>.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane"><code class="flex name class">
<span>class <span class="ident">Lane</span></span>
<span>(</span><span>lane_type: <a title="scenariogeneration.xodr.enumerations.LaneType" href="enumerations.html#scenariogeneration.xodr.enumerations.LaneType">LaneType</a> = LaneType.driving,<br>a: float = 0,<br>b: float = 0,<br>c: float = 0,<br>d: float = 0,<br>soffset: float = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lane(XodrBase):
    &#34;&#34;&#34;Create a Lane element of OpenDRIVE.

    The lane is defined using a polynomial of the form:
        f(s) = a + b * s + c * s^2 + d * s^3

    Parameters
    ----------
    lane_type : LaneType, optional
        The type of the lane. Default is `LaneType.driving`.
    a : float, optional
        The `a` coefficient of the polynomial. Default is 0.
    b : float, optional
        The `b` coefficient of the polynomial. Default is 0.
    c : float, optional
        The `c` coefficient of the polynomial. Default is 0.
    d : float, optional
        The `d` coefficient of the polynomial. Default is 0.
    soffset : float, optional
        The `s` offset of the lane. Default is 0.

    Attributes
    ----------
    lane_id : int
        The ID of the lane (automatically assigned by `LaneSection`).
    lane_type : LaneType
        The type of the lane.
    widths : list of _poly3struct
        The width elements of the lane.
    heights : list of dict
        The height entries of the lane.
    roadmark : list of RoadMark
        The roadmarks associated with the lane.
    links : _Links
        The lane links associated with the lane.
    materials : list of dict
        The material descriptions of the lane.

    Methods
    -------
    add_lane_width(a, b, c, d, soffset)
        Add an additional width element to the lane.
    get_width(s)
        Calculate the width of the lane at a given `s` value.
    add_link(link_type, id)
        Add a link to the lane.
    get_linked_lane_id(link_type)
        Get the ID of the linked lane for a given link type.
    add_roadmark(roadmark)
        Add a roadmark to the lane.
    add_height(inner, outer=None, soffset=0)
        Add a height entry to the lane.
    add_lane_material(friction, roughness=None, soffset=0, surface=None)
        Add a material description entry to the lane.
    get_attributes()
        Return the attributes of the lane as a dictionary.
    get_element()
        Return the ElementTree representation of the lane.
    &#34;&#34;&#34;

    def __init__(
        self,
        lane_type: LaneType = LaneType.driving,
        a: float = 0,
        b: float = 0,
        c: float = 0,
        d: float = 0,
        soffset: float = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `Lane` class.

        Parameters
        ----------
        lane_type : LaneType, optional
            The type of the lane. Default is `LaneType.driving`.
        a : float, optional
            The `a` coefficient of the polynomial. Default is 0.
        b : float, optional
            The `b` coefficient of the polynomial. Default is 0.
        c : float, optional
            The `c` coefficient of the polynomial. Default is 0.
        d : float, optional
            The `d` coefficient of the polynomial. Default is 0.
        soffset : float, optional
            The `s` offset of the lane. Default is 0.
        &#34;&#34;&#34;
        super().__init__()
        self.lane_id = None
        self.lane_type = enumchecker(lane_type, LaneType)
        self.widths = []
        self.add_lane_width(a, b, c, d, soffset)

        self.soffset = soffset
        # TODO: enable multiple widths records per lane (only then soffset really makes sense! ASAM requires one width record to have sOffset=0)
        self.heights = (
            []
        )  # height entries to elevate the lane independent from the road elevation
        self.roadmark = []
        self.links = _Links()
        self.materials = []

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Lane) and super().__eq__(other):
            if (
                self.links == other.links
                and self.get_attributes() == other.get_attributes()
                and self.widths == other.widths
                and self.heights == other.heights
                and self.roadmark == other.roadmark
                and self.materials == other.materials
            ):
                return True
        return False

        # TODO: add more features to add for lane

    def add_lane_width(
        self,
        a: float = 0,
        b: float = 0,
        c: float = 0,
        d: float = 0,
        soffset: float = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Add an additional width element to the lane.

        Parameters
        ----------
        a : float, optional
            The `a` coefficient of the polynomial. Default is 0.
        b : float, optional
            The `b` coefficient of the polynomial. Default is 0.
        c : float, optional
            The `c` coefficient of the polynomial. Default is 0.
        d : float, optional
            The `d` coefficient of the polynomial. Default is 0.
        soffset : float, optional
            The `s` offset of the lane. Default is 0.
        &#34;&#34;&#34;
        self.widths.append(_poly3struct(a, b, c, d, soffset))

    def get_width(self, s: float) -&gt; float:
        &#34;&#34;&#34;Calculate the width of the lane at a given `s` value.

        Parameters
        ----------
        s : float
            The `s` value at which to calculate the width.

        Returns
        -------
        float
            The width of the lane at the given `s` value.
        &#34;&#34;&#34;
        index_to_calc = 0
        for i in range(len(self.widths)):
            if s &gt;= self.widths[i].soffset:
                index_to_calc = i
            else:
                break
        return self.widths[index_to_calc].get_width(s)

    def add_link(self, link_type: str, id: Union[str, int]) -&gt; &#34;Lane&#34;:
        &#34;&#34;&#34;Add a link to the lane.

        Parameters
        ----------
        link_type : str
            The type of the link (e.g., &#34;successor&#34; or &#34;predecessor&#34;).
        id : str or int
            The ID of the linked lane.

        Returns
        -------
        Lane
            The updated `Lane` object.
        &#34;&#34;&#34;
        self.links.add_link(_Link(link_type, str(id)))
        return self

    def get_linked_lane_id(self, link_type: str) -&gt; Optional[int]:
        &#34;&#34;&#34;Get the ID of the linked lane for a given link type.

        Parameters
        ----------
        link_type : str
            The type of the link (e.g., &#34;successor&#34; or &#34;predecessor&#34;).

        Returns
        -------
        int or None
            The ID of the linked lane, or None if no link exists.
        &#34;&#34;&#34;
        for link in self.links.links:
            if link.link_type == link_type:
                return int(link.element_id)
        return None

    def _set_lane_id(self, lane_id: int) -&gt; None:
        &#34;&#34;&#34;Set the lane ID of the lane and update the lane type to &#39;none&#39; if it
        is a center lane.

        Parameters
        ----------
        lane_id : int
            The ID to assign to the lane.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.lane_id = lane_id
        if self.lane_id == 0:
            self.lane_type = LaneType.none

    def add_roadmark(self, roadmark: &#34;RoadMark&#34;) -&gt; &#34;Lane&#34;:
        &#34;&#34;&#34;Add a roadmark to the lane.

        Parameters
        ----------
        roadmark : RoadMark
            The roadmark to add.

        Returns
        -------
        Lane
            The updated `Lane` object.

        Raises
        ------
        TypeError
            If `roadmark` is not of type `RoadMark`.
        &#34;&#34;&#34;
        if not isinstance(roadmark, RoadMark):
            raise TypeError(&#34;roadmark input is not of type RoadMark&#34;)
        self.roadmark.append(roadmark)
        return self

    def add_height(
        self, inner: float, outer: Optional[float] = None, soffset: float = 0
    ) -&gt; &#34;Lane&#34;:
        &#34;&#34;&#34;Add a height entry to the lane.

        Parameters
        ----------
        inner : float
            The inner height of the lane.
        outer : float, optional
            The outer height of the lane. If not provided, the inner
            height is used. Default is None.
        soffset : float, optional
            The `s` offset of the height record. Default is 0.

        Returns
        -------
        Lane
            The updated `Lane` object.
        &#34;&#34;&#34;
        heightdict = {}
        heightdict[&#34;inner&#34;] = str(inner)
        if outer is not None:
            heightdict[&#34;outer&#34;] = str(outer)
        else:
            heightdict[&#34;outer&#34;] = str(inner)
        heightdict[&#34;sOffset&#34;] = str(soffset)

        self.heights.append(heightdict)
        return self

    def add_lane_material(
        self,
        friction: float,
        roughness: Optional[float] = None,
        soffset: float = 0,
        surface: Optional[str] = None,
    ) -&gt; &#34;Lane&#34;:
        &#34;&#34;&#34;Add a material description entry to the lane.

        Parameters
        ----------
        friction : float
            The friction coefficient of the material.
        roughness : float, optional
            The roughness of the material. Default is None.
        soffset : float, optional
            The `s` offset of the material. Default is 0.
        surface : str, optional
            The surface material code. Default is None.

        Returns
        -------
        Lane
            The updated `Lane` object.
        &#34;&#34;&#34;
        materialdict = {}
        materialdict[&#34;friction&#34;] = str(friction)
        if roughness is not None:
            materialdict[&#34;roughness&#34;] = str(roughness)
        materialdict[&#34;sOffset&#34;] = str(soffset)
        if surface is not None:
            materialdict[&#34;surface&#34;] = str(surface)
        self.materials.append(materialdict)
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the lane as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the lane.

        Raises
        ------
        ValueError
            If the lane ID is not set.
        &#34;&#34;&#34;
        retdict = {}
        if self.lane_id == None:
            raise ValueError(&#34;lane id is not set correctly.&#34;)
        retdict[&#34;id&#34;] = str(self.lane_id)
        retdict[&#34;type&#34;] = enum2str(self.lane_type)
        retdict[&#34;level&#34;] = &#34;false&#34;
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the lane.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the lane.
        &#34;&#34;&#34;
        element = ET.Element(&#34;lane&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        # according to standard if lane is centerlane it should
        # not have a width record and omit the link record
        if self.lane_id != 0:
            element.append(self.links.get_element())
            for w in sorted(self.widths, key=lambda x: x.soffset):
                ET.SubElement(element, &#34;width&#34;, attrib=w.get_attributes())
        # use polynomial dict for laneOffset in case of center lane (only if values provided)
        # removed, should not be here..
        # elif any([self.a,self.b,self.c,self.d]):
        #     polynomialdict[&#39;s&#39;] = polynomialdict.pop(&#39;sOffset&#39;)
        #     ET.SubElement(element,&#39;laneOffset&#39;,attrib=polynomialdict)

        if self.roadmark:
            for r in sorted(self.roadmark, key=lambda x: x.soffset):
                element.append(r.get_element())

        for height in self.heights:
            ET.SubElement(element, &#34;height&#34;, attrib=height)

        for material in sorted(self.materials, key=lambda x: x[&#34;sOffset&#34;]):
            ET.SubElement(element, &#34;material&#34;, attrib=material)

        return element</code></pre>
</details>
<div class="desc"><p>Create a Lane element of OpenDRIVE.</p>
<p>The lane is defined using a polynomial of the form:
f(s) = a + b * s + c * s^2 + d * s^3</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane_type</code></strong> :&ensp;<code>LaneType</code>, optional</dt>
<dd>The type of the lane. Default is <code>LaneType.driving</code>.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>a</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>b</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>c</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>d</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> offset of the lane. Default is 0.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the lane (automatically assigned by <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>).</dd>
<dt><strong><code>lane_type</code></strong> :&ensp;<code>LaneType</code></dt>
<dd>The type of the lane.</dd>
<dt><strong><code>widths</code></strong> :&ensp;<code>list</code> of <code>_poly3struct</code></dt>
<dd>The width elements of the lane.</dd>
<dt><strong><code>heights</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>The height entries of the lane.</dd>
<dt><strong><code>roadmark</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></dt>
<dd>The roadmarks associated with the lane.</dd>
<dt><strong><code>links</code></strong> :&ensp;<code>_Links</code></dt>
<dd>The lane links associated with the lane.</dd>
<dt><strong><code>materials</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>The material descriptions of the lane.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>add_lane_width(a, b, c, d, soffset)
Add an additional width element to the lane.
get_width(s)
Calculate the width of the lane at a given <code>s</code> value.
add_link(link_type, id)
Add a link to the lane.
get_linked_lane_id(link_type)
Get the ID of the linked lane for a given link type.
add_roadmark(roadmark)
Add a roadmark to the lane.
add_height(inner, outer=None, soffset=0)
Add a height entry to the lane.
add_lane_material(friction, roughness=None, soffset=0, surface=None)
Add a material description entry to the lane.
get_attributes()
Return the attributes of the lane as a dictionary.
get_element()
Return the ElementTree representation of the lane.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>lane_type</code></strong> :&ensp;<code>LaneType</code>, optional</dt>
<dd>The type of the lane. Default is <code>LaneType.driving</code>.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>a</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>b</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>c</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>d</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> offset of the lane. Default is 0.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.Lane.add_height"><code class="name flex">
<span>def <span class="ident">add_height</span></span>(<span>self, inner: float, outer: float | None = None, soffset: float = 0) ‑> <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_height(
    self, inner: float, outer: Optional[float] = None, soffset: float = 0
) -&gt; &#34;Lane&#34;:
    &#34;&#34;&#34;Add a height entry to the lane.

    Parameters
    ----------
    inner : float
        The inner height of the lane.
    outer : float, optional
        The outer height of the lane. If not provided, the inner
        height is used. Default is None.
    soffset : float, optional
        The `s` offset of the height record. Default is 0.

    Returns
    -------
    Lane
        The updated `Lane` object.
    &#34;&#34;&#34;
    heightdict = {}
    heightdict[&#34;inner&#34;] = str(inner)
    if outer is not None:
        heightdict[&#34;outer&#34;] = str(outer)
    else:
        heightdict[&#34;outer&#34;] = str(inner)
    heightdict[&#34;sOffset&#34;] = str(soffset)

    self.heights.append(heightdict)
    return self</code></pre>
</details>
<div class="desc"><p>Add a height entry to the lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inner</code></strong> :&ensp;<code>float</code></dt>
<dd>The inner height of the lane.</dd>
<dt><strong><code>outer</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The outer height of the lane. If not provided, the inner
height is used. Default is None.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> offset of the height record. Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code> object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_lane_material"><code class="name flex">
<span>def <span class="ident">add_lane_material</span></span>(<span>self,<br>friction: float,<br>roughness: float | None = None,<br>soffset: float = 0,<br>surface: str | None = None) ‑> <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lane_material(
    self,
    friction: float,
    roughness: Optional[float] = None,
    soffset: float = 0,
    surface: Optional[str] = None,
) -&gt; &#34;Lane&#34;:
    &#34;&#34;&#34;Add a material description entry to the lane.

    Parameters
    ----------
    friction : float
        The friction coefficient of the material.
    roughness : float, optional
        The roughness of the material. Default is None.
    soffset : float, optional
        The `s` offset of the material. Default is 0.
    surface : str, optional
        The surface material code. Default is None.

    Returns
    -------
    Lane
        The updated `Lane` object.
    &#34;&#34;&#34;
    materialdict = {}
    materialdict[&#34;friction&#34;] = str(friction)
    if roughness is not None:
        materialdict[&#34;roughness&#34;] = str(roughness)
    materialdict[&#34;sOffset&#34;] = str(soffset)
    if surface is not None:
        materialdict[&#34;surface&#34;] = str(surface)
    self.materials.append(materialdict)
    return self</code></pre>
</details>
<div class="desc"><p>Add a material description entry to the lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>friction</code></strong> :&ensp;<code>float</code></dt>
<dd>The friction coefficient of the material.</dd>
<dt><strong><code>roughness</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The roughness of the material. Default is None.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> offset of the material. Default is 0.</dd>
<dt><strong><code>surface</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The surface material code. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code> object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_lane_width"><code class="name flex">
<span>def <span class="ident">add_lane_width</span></span>(<span>self, a: float = 0, b: float = 0, c: float = 0, d: float = 0, soffset: float = 0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lane_width(
    self,
    a: float = 0,
    b: float = 0,
    c: float = 0,
    d: float = 0,
    soffset: float = 0,
) -&gt; None:
    &#34;&#34;&#34;Add an additional width element to the lane.

    Parameters
    ----------
    a : float, optional
        The `a` coefficient of the polynomial. Default is 0.
    b : float, optional
        The `b` coefficient of the polynomial. Default is 0.
    c : float, optional
        The `c` coefficient of the polynomial. Default is 0.
    d : float, optional
        The `d` coefficient of the polynomial. Default is 0.
    soffset : float, optional
        The `s` offset of the lane. Default is 0.
    &#34;&#34;&#34;
    self.widths.append(_poly3struct(a, b, c, d, soffset))</code></pre>
</details>
<div class="desc"><p>Add an additional width element to the lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>a</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>b</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>c</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>d</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> offset of the lane. Default is 0.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self, link_type: str, id: str | int) ‑> <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self, link_type: str, id: Union[str, int]) -&gt; &#34;Lane&#34;:
    &#34;&#34;&#34;Add a link to the lane.

    Parameters
    ----------
    link_type : str
        The type of the link (e.g., &#34;successor&#34; or &#34;predecessor&#34;).
    id : str or int
        The ID of the linked lane.

    Returns
    -------
    Lane
        The updated `Lane` object.
    &#34;&#34;&#34;
    self.links.add_link(_Link(link_type, str(id)))
    return self</code></pre>
</details>
<div class="desc"><p>Add a link to the lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>link_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of the link (e.g., "successor" or "predecessor").</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>The ID of the linked lane.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code> object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_roadmark"><code class="name flex">
<span>def <span class="ident">add_roadmark</span></span>(<span>self,<br>roadmark: <a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a>) ‑> <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_roadmark(self, roadmark: &#34;RoadMark&#34;) -&gt; &#34;Lane&#34;:
    &#34;&#34;&#34;Add a roadmark to the lane.

    Parameters
    ----------
    roadmark : RoadMark
        The roadmark to add.

    Returns
    -------
    Lane
        The updated `Lane` object.

    Raises
    ------
    TypeError
        If `roadmark` is not of type `RoadMark`.
    &#34;&#34;&#34;
    if not isinstance(roadmark, RoadMark):
        raise TypeError(&#34;roadmark input is not of type RoadMark&#34;)
    self.roadmark.append(roadmark)
    return self</code></pre>
</details>
<div class="desc"><p>Add a roadmark to the lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>roadmark</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></dt>
<dd>The roadmark to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>roadmark</code> is not of type <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the lane as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the lane.

    Raises
    ------
    ValueError
        If the lane ID is not set.
    &#34;&#34;&#34;
    retdict = {}
    if self.lane_id == None:
        raise ValueError(&#34;lane id is not set correctly.&#34;)
    retdict[&#34;id&#34;] = str(self.lane_id)
    retdict[&#34;type&#34;] = enum2str(self.lane_type)
    retdict[&#34;level&#34;] = &#34;false&#34;
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the lane as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the lane.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lane ID is not set.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the lane.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the lane.
    &#34;&#34;&#34;
    element = ET.Element(&#34;lane&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    # according to standard if lane is centerlane it should
    # not have a width record and omit the link record
    if self.lane_id != 0:
        element.append(self.links.get_element())
        for w in sorted(self.widths, key=lambda x: x.soffset):
            ET.SubElement(element, &#34;width&#34;, attrib=w.get_attributes())
    # use polynomial dict for laneOffset in case of center lane (only if values provided)
    # removed, should not be here..
    # elif any([self.a,self.b,self.c,self.d]):
    #     polynomialdict[&#39;s&#39;] = polynomialdict.pop(&#39;sOffset&#39;)
    #     ET.SubElement(element,&#39;laneOffset&#39;,attrib=polynomialdict)

    if self.roadmark:
        for r in sorted(self.roadmark, key=lambda x: x.soffset):
            element.append(r.get_element())

    for height in self.heights:
        ET.SubElement(element, &#34;height&#34;, attrib=height)

    for material in sorted(self.materials, key=lambda x: x[&#34;sOffset&#34;]):
        ET.SubElement(element, &#34;material&#34;, attrib=material)

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the lane.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the lane.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_linked_lane_id"><code class="name flex">
<span>def <span class="ident">get_linked_lane_id</span></span>(<span>self, link_type: str) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_linked_lane_id(self, link_type: str) -&gt; Optional[int]:
    &#34;&#34;&#34;Get the ID of the linked lane for a given link type.

    Parameters
    ----------
    link_type : str
        The type of the link (e.g., &#34;successor&#34; or &#34;predecessor&#34;).

    Returns
    -------
    int or None
        The ID of the linked lane, or None if no link exists.
    &#34;&#34;&#34;
    for link in self.links.links:
        if link.link_type == link_type:
            return int(link.element_id)
    return None</code></pre>
</details>
<div class="desc"><p>Get the ID of the linked lane for a given link type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>link_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of the link (e.g., "successor" or "predecessor").</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>None</code></dt>
<dd>The ID of the linked lane, or None if no link exists.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self, s: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self, s: float) -&gt; float:
    &#34;&#34;&#34;Calculate the width of the lane at a given `s` value.

    Parameters
    ----------
    s : float
        The `s` value at which to calculate the width.

    Returns
    -------
    float
        The width of the lane at the given `s` value.
    &#34;&#34;&#34;
    index_to_calc = 0
    for i in range(len(self.widths)):
        if s &gt;= self.widths[i].soffset:
            index_to_calc = i
        else:
            break
    return self.widths[index_to_calc].get_width(s)</code></pre>
</details>
<div class="desc"><p>Calculate the width of the lane at a given <code>s</code> value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> value at which to calculate the width.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The width of the lane at the given <code>s</code> value.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneOffset"><code class="flex name class">
<span>class <span class="ident">LaneOffset</span></span>
<span>(</span><span>s: float = 0, a: float = 0, b: float = 0, c: float = 0, d: float = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaneOffset(XodrBase):
    &#34;&#34;&#34;Define an overall lateral offset along the road as a third-degree
    polynomial.

    Parameters
    ----------
    s : float
        The `s` start coordinate of the lane offset.
    a : float
        The `a` coefficient of the polynomial.
    b : float
        The `b` coefficient of the polynomial.
    c : float
        The `c` coefficient of the polynomial.
    d : float
        The `d` coefficient of the polynomial.

    Attributes
    ----------
    s : float
        The `s` start coordinate of the lane offset.
    a : float
        The `a` coefficient of the polynomial.
    b : float
        The `b` coefficient of the polynomial.
    c : float
        The `c` coefficient of the polynomial.
    d : float
        The `d` coefficient of the polynomial.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns the attributes of the class as a dictionary.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float = 0,
        a: float = 0,
        b: float = 0,
        c: float = 0,
        d: float = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `LaneOffset` class.

        Parameters
        ----------
        s : float, optional
            The `s` start coordinate of the lane offset. Default is 0.
        a : float, optional
            The `a` coefficient of the polynomial. Default is 0.
        b : float, optional
            The `b` coefficient of the polynomial. Default is 0.
        c : float, optional
            The `c` coefficient of the polynomial. Default is 0.
        d : float, optional
            The `d` coefficient of the polynomial. Default is 0.

        Returns
        -------
        None
        &#34;&#34;&#34;
        super().__init__()
        self.s = s
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, LaneOffset) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `LaneOffset` as a dictionary.

        This method returns the attributes of the `LaneOffset` object,
        including its polynomial coefficients and the `s` start
        coordinate.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `LaneOffset`.
        &#34;&#34;&#34;

        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;a&#34;] = str(self.a)
        retdict[&#34;b&#34;] = str(self.b)
        retdict[&#34;c&#34;] = str(self.c)
        retdict[&#34;d&#34;] = str(self.d)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `LaneOffset`.

        This method generates an XML representation of the `LaneOffset`
        object, including its attributes.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `LaneOffset`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;laneOffset&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>Define an overall lateral offset along the road as a third-degree
polynomial.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> start coordinate of the lane offset.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>a</code> coefficient of the polynomial.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>b</code> coefficient of the polynomial.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>c</code> coefficient of the polynomial.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>d</code> coefficient of the polynomial.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> start coordinate of the lane offset.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>a</code> coefficient of the polynomial.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>b</code> coefficient of the polynomial.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>c</code> coefficient of the polynomial.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>d</code> coefficient of the polynomial.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns the attributes of the class as a dictionary.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>s</code> start coordinate of the lane offset. Default is 0.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>a</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>b</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>c</code> coefficient of the polynomial. Default is 0.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>d</code> coefficient of the polynomial. Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.LaneOffset.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `LaneOffset` as a dictionary.

    This method returns the attributes of the `LaneOffset` object,
    including its polynomial coefficients and the `s` start
    coordinate.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `LaneOffset`.
    &#34;&#34;&#34;

    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;a&#34;] = str(self.a)
    retdict[&#34;b&#34;] = str(self.b)
    retdict[&#34;c&#34;] = str(self.c)
    retdict[&#34;d&#34;] = str(self.d)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code> as a dictionary.</p>
<p>This method returns the attributes of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code> object,
including its polynomial coefficients and the <code>s</code> start
coordinate.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneOffset.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `LaneOffset`.

    This method generates an XML representation of the `LaneOffset`
    object, including its attributes.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `LaneOffset`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;laneOffset&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code>.</p>
<p>This method generates an XML representation of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code>
object, including its attributes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code>.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection"><code class="flex name class">
<span>class <span class="ident">LaneSection</span></span>
<span>(</span><span>s: float,<br>centerlane: <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaneSection(XodrBase):
    &#34;&#34;&#34;Create the LaneSection element of OpenDRIVE.

    This class represents a lane section, including its center lane,
    left lanes, and right lanes.

    Parameters
    ----------
    s : float
        The `s` start coordinate of the lane section.
    centerlane : Lane
        The center lane of the road.

    Attributes
    ----------
    s : float
        The `s` start coordinate of the lane section.
    centerlane : Lane
        The center lane of the road.
    leftlanes : list of Lane
        The lanes to the left of the center lane.
    rightlanes : list of Lane
        The lanes to the right of the center lane.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns the attributes of the class as a dictionary.
    add_left_lane(lane)
        Adds a new lane to the left of the center lane.
    add_right_lane(lane)
        Adds a new lane to the right of the center lane.
    &#34;&#34;&#34;

    def __init__(self, s: float, centerlane: &#34;Lane&#34;) -&gt; None:
        &#34;&#34;&#34;Initialize the `LaneSection` class.

        Parameters
        ----------
        s : float
            The `s` start coordinate of the lane section.
        centerlane : Lane
            The center lane of the road.

        Raises
        ------
        TypeError
            If `centerlane` is not of type `Lane`.
        &#34;&#34;&#34;
        super().__init__()
        self.s = s
        if not isinstance(centerlane, Lane):
            raise TypeError(&#34;centerlane input is not of type Lane&#34;)
        self.centerlane = centerlane
        self.centerlane._set_lane_id(0)
        self.leftlanes = []
        self.rightlanes = []
        self._left_id = 1
        self._right_id = -1

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, LaneSection) and super().__eq__(other):
            if (
                self.get_attributes() == other.get_attributes()
                and self.centerlane == other.centerlane
                and self.leftlanes == other.leftlanes
                and self.rightlanes == other.rightlanes
            ):
                return True
        return False

    def add_left_lane(self, lane: &#34;Lane&#34;) -&gt; &#34;LaneSection&#34;:
        &#34;&#34;&#34;Add a lane to the left of the center lane.

        Parameters
        ----------
        lane : Lane
            The lane to add.

        Returns
        -------
        LaneSection
            The updated `LaneSection` object.

        Raises
        ------
        TypeError
            If `lane` is not of type `Lane`.
        &#34;&#34;&#34;
        if not isinstance(lane, Lane):
            raise TypeError(&#34;lane input is not of type Lane&#34;)
        lane._set_lane_id(self._left_id)
        self._left_id += 1
        self.leftlanes.append(lane)
        return self

    def add_right_lane(self, lane: &#34;Lane&#34;) -&gt; &#34;LaneSection&#34;:
        &#34;&#34;&#34;Add a lane to the right of the center lane.

        Parameters
        ----------
        lane : Lane
            The lane to add.

        Returns
        -------
        LaneSection
            The updated `LaneSection` object.

        Raises
        ------
        TypeError
            If `lane` is not of type `Lane`.
        &#34;&#34;&#34;
        if not isinstance(lane, Lane):
            raise TypeError(&#34;lane input is not of type Lane&#34;)
        lane._set_lane_id(self._right_id)
        self._right_id -= 1
        self.rightlanes.append(lane)
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `LaneSection` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `LaneSection`.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `LaneSection`.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `LaneSection`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;laneSection&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        if self.leftlanes:
            left = ET.SubElement(element, &#34;left&#34;)
            for l in reversed(self.leftlanes):
                left.append(l.get_element())

        center = ET.SubElement(element, &#34;center&#34;)
        center.append(self.centerlane.get_element())

        if self.rightlanes:
            right = ET.SubElement(element, &#34;right&#34;)
            for l in self.rightlanes:
                right.append(l.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>Create the LaneSection element of OpenDRIVE.</p>
<p>This class represents a lane section, including its center lane,
left lanes, and right lanes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> start coordinate of the lane section.</dd>
<dt><strong><code>centerlane</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The center lane of the road.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> start coordinate of the lane section.</dd>
<dt><strong><code>centerlane</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The center lane of the road.</dd>
<dt><strong><code>leftlanes</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The lanes to the left of the center lane.</dd>
<dt><strong><code>rightlanes</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The lanes to the right of the center lane.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns the attributes of the class as a dictionary.
add_left_lane(lane)
Adds a new lane to the left of the center lane.
add_right_lane(lane)
Adds a new lane to the right of the center lane.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The <code>s</code> start coordinate of the lane section.</dd>
<dt><strong><code>centerlane</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The center lane of the road.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>centerlane</code> is not of type <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.LaneSection.add_left_lane"><code class="name flex">
<span>def <span class="ident">add_left_lane</span></span>(<span>self,<br>lane: <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a>) ‑> <a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_left_lane(self, lane: &#34;Lane&#34;) -&gt; &#34;LaneSection&#34;:
    &#34;&#34;&#34;Add a lane to the left of the center lane.

    Parameters
    ----------
    lane : Lane
        The lane to add.

    Returns
    -------
    LaneSection
        The updated `LaneSection` object.

    Raises
    ------
    TypeError
        If `lane` is not of type `Lane`.
    &#34;&#34;&#34;
    if not isinstance(lane, Lane):
        raise TypeError(&#34;lane input is not of type Lane&#34;)
    lane._set_lane_id(self._left_id)
    self._left_id += 1
    self.leftlanes.append(lane)
    return self</code></pre>
</details>
<div class="desc"><p>Add a lane to the left of the center lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The lane to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>lane</code> is not of type <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.add_right_lane"><code class="name flex">
<span>def <span class="ident">add_right_lane</span></span>(<span>self,<br>lane: <a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a>) ‑> <a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_right_lane(self, lane: &#34;Lane&#34;) -&gt; &#34;LaneSection&#34;:
    &#34;&#34;&#34;Add a lane to the right of the center lane.

    Parameters
    ----------
    lane : Lane
        The lane to add.

    Returns
    -------
    LaneSection
        The updated `LaneSection` object.

    Raises
    ------
    TypeError
        If `lane` is not of type `Lane`.
    &#34;&#34;&#34;
    if not isinstance(lane, Lane):
        raise TypeError(&#34;lane input is not of type Lane&#34;)
    lane._set_lane_id(self._right_id)
    self._right_id -= 1
    self.rightlanes.append(lane)
    return self</code></pre>
</details>
<div class="desc"><p>Add a lane to the right of the center lane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></dt>
<dd>The lane to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>lane</code> is not of type <code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `LaneSection` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `LaneSection`.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `LaneSection`.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `LaneSection`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;laneSection&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    if self.leftlanes:
        left = ET.SubElement(element, &#34;left&#34;)
        for l in reversed(self.leftlanes):
            left.append(l.get_element())

    center = ET.SubElement(element, &#34;center&#34;)
    center.append(self.centerlane.get_element())

    if self.rightlanes:
        right = ET.SubElement(element, &#34;right&#34;)
        for l in self.rightlanes:
            right.append(l.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes"><code class="flex name class">
<span>class <span class="ident">Lanes</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lanes(XodrBase):
    &#34;&#34;&#34;Create the Lanes element of OpenDRIVE.

    This class represents the lanes of a road, including lane sections and
    lane offsets.

    Attributes
    ----------
    lanesections : list of LaneSection
        A list of all lane sections in the road.
    laneoffsets : list of LaneOffset
        A list of lane offsets applied to the road.
    roadmarks_adjusted : bool
        Indicates whether roadmarks have been adjusted.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    add_lanesection(lanesection, lanelinks=None)
        Adds a lane section to the Lanes object.
    add_laneoffset(laneoffset)
        Adds a lane offset to the Lanes object.
    adjust_road_marks_from_start(total_road_length,
        connected_lane_section=None, contact_point=ContactPoint.end)
        Adjusts road marks from the start of the road.
    adjust_road_marks_from_end(total_road_length, connected_lane_section=None,
        contact_point=ContactPoint.end)
        Adjusts road marks from the end of the road.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the `Lanes` class.

        This constructor initializes the `Lanes` object with default
        values for lane sections, lane offsets, and roadmark adjustment
        status.

        Attributes
        ----------
        lanesections : list of LaneSection
            A list of all lane sections in the road.
        laneoffsets : list of LaneOffset
            A list of lane offsets applied to the road.
        roadmarks_adjusted : bool
            Indicates whether roadmarks have been adjusted.

        Returns
        -------
        None
        &#34;&#34;&#34;
        super().__init__()
        &#34;&#34;&#34;Initalize Lanes.&#34;&#34;&#34;
        self.lanesections = []
        self.laneoffsets = []
        self.roadmarks_adjusted = False

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Lanes) and super().__eq__(other):
            if (
                self.laneoffsets == other.laneoffsets
                and self.lanesections == other.lanesections
            ):
                return True
        return False

    def add_lanesection(
        self,
        lanesection: &#34;LaneSection&#34;,
        lanelinks: Optional[Union[&#34;LaneLinker&#34;, list[&#34;LaneLinker&#34;]]] = None,
    ) -&gt; &#34;Lanes&#34;:
        &#34;&#34;&#34;Add a lane section to the `Lanes` object.

        This method adds a `LaneSection` to the `Lanes` object and
        optionally links lanes using a `LaneLinker`.

        Parameters
        ----------
        lanesection : LaneSection
            A `LaneSection` object to add to the `Lanes` object.
        lanelinks : LaneLinker or list of LaneLinker, optional
            A `LaneLinker` or a list of `LaneLinker` objects to link &#39;
            lanes. Default is None.

        Returns
        -------
        Lanes
            The updated `Lanes` object.

        Raises
        ------
        TypeError
            If `lanesection` is not of type `LaneSection` or if
            `lanelinks` contains objects that are not of type
            `LaneLinker`.
        &#34;&#34;&#34;
        if not isinstance(lanesection, LaneSection):
            raise TypeError(&#34;input lanesection is not of type LaneSection&#34;)
        # add links to the lanes
        if lanelinks:
            # loop over all links
            if not isinstance(lanelinks, list):
                lanelinks = [lanelinks]
            if any([not isinstance(x, LaneLinker) for x in lanelinks]):
                raise TypeError(&#34;lanelinks contains a none LaneLinker type&#34;)
            for lanelink in lanelinks:
                for link in lanelink.links:
                    # check if link already added
                    if not link.used:
                        link.predecessor.add_link(
                            &#34;successor&#34;, link.successor.lane_id
                        )
                        link.successor.add_link(
                            &#34;predecessor&#34;, link.predecessor.lane_id
                        )
                        link.used = True

        self.lanesections.append(lanesection)
        return self

    def add_laneoffset(self, laneoffset: &#34;LaneOffset&#34;) -&gt; &#34;Lanes&#34;:
        &#34;&#34;&#34;Add a lane offset to the `Lanes` object.

        This method adds a `LaneOffset` to the `Lanes` object.

        Parameters
        ----------
        laneoffset : LaneOffset
            A `LaneOffset` object to add to the `Lanes` object.

        Returns
        -------
        Lanes
            The updated `Lanes` object.

        Raises
        ------
        TypeError
            If `laneoffset` is not of type `LaneOffset`.
        &#34;&#34;&#34;
        if not isinstance(laneoffset, LaneOffset):
            raise TypeError(
                &#34;add_laneoffset requires a LaneOffset as input, not &#34;
                + str(type(laneoffset))
            )
        self.laneoffsets.append(laneoffset)
        return self

    def _check_valid_mark_type(self, lane: &#34;Lane&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if the lane&#39;s roadmark can be adjusted.

        This method verifies whether the roadmark type of the given lane
        is valid for adjustment.

        Parameters
        ----------
        lane : Lane
            The lane whose roadmark should be checked.

        Returns
        -------
        bool
            True if the roadmark can be adjusted, False otherwise.
        &#34;&#34;&#34;
        return (
            lane.roadmark[0].marking_type == RoadMarkType.broken
            or lane.roadmark[0].marking_type == RoadMarkType.broken_broken
        )

    def _adjust_for_missing_line_offset(self, roadmark: &#34;RoadMark&#34;) -&gt; None:
        &#34;&#34;&#34;Add an explicit line if the offset is less than 0 ( for adjusting
        from the start) or longer than the space between lines (for adjusting
        from the end).

        Parameters
        ----------
        roadmark : RoadMark
            The roadmark to be adjusted.

        Returns
        -------
        None
        &#34;&#34;&#34;
        for line in roadmark._line:
            if line.soffset &lt; 0 or line.soffset &gt; line.length + line.soffset:
                roadmark.add_explicit_road_line(
                    ExplicitRoadLine(
                        line.width,
                        line.length + line.soffset,
                        line.toffset,
                        0,
                        line.rule,
                    )
                )
            elif line.soffset &gt; line.space:
                roadmark.add_explicit_road_line(
                    ExplicitRoadLine(
                        line.width,
                        line.soffset - line.space,
                        line.toffset,
                        0,
                        line.rule,
                    )
                )
            if line.soffset &lt; 0:
                line.shift_soffset()

    def _validity_check_for_roadmark_adjustment(self) -&gt; None:
        &#34;&#34;&#34;Perform validity checks to determine if the lanes&#39; roadmarks can be
        adjusted.

        This method checks the right, left, and center lanes to ensure
        their roadmarks meet the criteria for adjustment.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._right_lanes_adjustable = len(self.lanesections[0].rightlanes) &gt; 0
        self._left_lanes_adjustable = len(self.lanesections[0].leftlanes) &gt; 0
        self._center_lane_adjustable = True
        for ls in range(len(self.lanesections) - 1):
            if len(self.lanesections[ls].centerlane.roadmark) != 1:
                self.center_lane_adjustable = False
            if (
                self.lanesections[ls].centerlane.roadmark
                != self.lanesections[ls + 1].centerlane.roadmark
            ):
                self.center_lane_adjustable = False
            if (
                self.lanesections[ls].centerlane.roadmark[0].marking_type
                != RoadMarkType.broken
                and self.lanesections[ls].centerlane.roadmark[0].marking_type
                != RoadMarkType.broken_broken
            ):
                self.center_lane_adjustable = False

            for rl in range(len(self.lanesections[ls].rightlanes)):
                if self._right_lanes_adjustable:
                    if len(self.lanesections[ls].rightlanes[rl].roadmark) != 1:
                        self._right_lanes_adjustable = False
            for ll in range(len(self.lanesections[ls].leftlanes)):
                if self._left_lanes_adjustable:
                    if len(self.lanesections[ls].leftlanes[ll].roadmark) != 1:
                        self._left_lanes_adjustable = False

    def _get_previous_remainder(
        self,
        connected_lane_section: &#34;LaneSection&#34;,
        i_line: int,
        lane_side: str,
        contact_point: &#34;ContactPoint&#34;,
        lane_index: Optional[int],
        lane_section_index: int,
        start_or_end: str,
    ) -&gt; float:
        &#34;&#34;&#34;Get the remainder of a lane marking from a connecting lane section.

        This helper method calculates the remainder of a lane marking for
        length adjustment based on the connected lane section.

        Parameters
        ----------
        connected_lane_section : LaneSection
            The connected lane section (on another road).
        i_line : int
            The index of the line (`roadmark._line`).
        lane_side : str
            The side of the lane (&#34;left&#34;, &#34;right&#34;, or &#34;center&#34;).
        contact_point : ContactPoint
            The contact point of the `connected_lane_section`.
        lane_index : int, optional
            The lane index of the desired lane.
        lane_section_index : int
            The index of the lane section.
        start_or_end : str
            Indicates whether the adjustment is done from the start or end
            of the road.

        Returns
        -------
        float
            The remainder of the previous lane section.
        &#34;&#34;&#34;
        active_lane_sec = self.lanesections[lane_section_index]
        neighbor_lane_sec = None
        if start_or_end == &#34;end&#34;:
            on_edge = lane_section_index == len(self.lanesections) - 1
            connection = &#34;successor&#34;
            if not on_edge:
                neighbor_lane_sec = self.lanesections[lane_section_index + 1]
        else:
            on_edge = lane_section_index == 0
            connection = &#34;predecessor&#34;
            if not on_edge:
                neighbor_lane_sec = self.lanesections[lane_section_index - 1]

        linked_lane_id = 0
        found_linked_lane_id = None
        if lane_side == &#34;right&#34;:
            found_linked_lane_id = active_lane_sec.rightlanes[
                lane_index
            ].get_linked_lane_id(connection)
            if neighbor_lane_sec:
                neighboring_lane = neighbor_lane_sec.rightlanes[linked_lane_id]
        elif lane_side == &#34;left&#34;:
            found_linked_lane_id = active_lane_sec.leftlanes[
                lane_index
            ].get_linked_lane_id(connection)
            if neighbor_lane_sec:
                neighboring_lane = neighbor_lane_sec.leftlanes[linked_lane_id]
        else:  # center
            if neighbor_lane_sec:
                neighboring_lane = neighbor_lane_sec.centerlane
        if found_linked_lane_id:
            linked_lane_id = abs(found_linked_lane_id) - 1

        prev_remainder = 0
        if on_edge:
            if lane_side == &#34;right&#34;:
                if (
                    contact_point == ContactPoint.end
                    and connected_lane_section.rightlanes[linked_lane_id]
                    .roadmark[0]
                    ._line
                ):
                    prev_remainder = (
                        connected_lane_section.rightlanes[linked_lane_id]
                        .roadmark[0]
                        ._line[i_line]
                        ._remainder
                    )
                elif (
                    contact_point == ContactPoint.start
                    and connected_lane_section.leftlanes[linked_lane_id]
                    .roadmark[0]
                    ._line
                ):
                    prev_remainder = (
                        connected_lane_section.leftlanes[linked_lane_id]
                        .roadmark[0]
                        ._line[i_line]
                        .soffset
                    )

            if lane_side == &#34;left&#34;:
                if (
                    contact_point == ContactPoint.end
                    and connected_lane_section.leftlanes[linked_lane_id]
                    .roadmark[0]
                    ._line
                ):
                    prev_remainder = (
                        connected_lane_section.leftlanes[linked_lane_id]
                        .roadmark[0]
                        ._line[i_line]
                        ._remainder
                    )
                elif (
                    contact_point == ContactPoint.start
                    and connected_lane_section.rightlanes[linked_lane_id]
                    .roadmark[0]
                    ._line
                ):
                    prev_remainder = (
                        connected_lane_section.rightlanes[linked_lane_id]
                        .roadmark[0]
                        ._line[i_line]
                        .soffset
                    )

            if (
                lane_side == &#34;center&#34;
                and connected_lane_section.centerlane.roadmark[0]._line
            ):
                if contact_point == ContactPoint.end:
                    prev_remainder = (
                        connected_lane_section.centerlane.roadmark[0]
                        ._line[i_line]
                        ._remainder
                    )
                elif contact_point == ContactPoint.start:
                    prev_remainder = (
                        connected_lane_section.centerlane.roadmark[0]
                        ._line[i_line]
                        .soffset
                    )

        else:
            if start_or_end == &#34;start&#34;:
                prev_remainder = (
                    neighboring_lane.roadmark[0]._line[i_line]._remainder
                )
            else:
                prev_remainder = (
                    neighboring_lane.roadmark[0]._line[i_line].soffset
                )
        return prev_remainder

    def _get_seg_length(
        self, total_road_length: float, lane_section_index: int
    ) -&gt; float:
        &#34;&#34;&#34;Calculate the length of a lane section.

        This helper method determines the length of a specific lane
        section based on the total road length and the index of the lane
        section.

        Parameters
        ----------
        total_road_length : float
            The total length of the road.
        lane_section_index : int
            The index of the desired lane section.

        Returns
        -------
        float
            The length of the specified lane section.
        &#34;&#34;&#34;
        if len(self.lanesections) == 1:
            seg_length = total_road_length
        elif lane_section_index == 0:
            seg_length = self.lanesections[1].s
        elif lane_section_index == len(self.lanesections) - 1:
            seg_length = (
                total_road_length - self.lanesections[lane_section_index].s
            )
        else:
            seg_length = (
                self.lanesections[lane_section_index + 1].s
                - self.lanesections[lane_section_index].s
            )
        return seg_length

    def adjust_road_marks_from_start(
        self,
        total_road_length: float,
        connected_lane_section: Optional[&#34;LaneSection&#34;] = None,
        contact_point: &#34;ContactPoint&#34; = ContactPoint.end,
    ) -&gt; None:
        &#34;&#34;&#34;Adjust road marks from the start of the road.

        This method adjusts road marks based on the connected lane
        section. If `connected_lane_section` is not provided, the last
        roadmark will be placed with zero distance to the start of the
        road.

        Parameters
        ----------
        total_road_length : float
            The total length of the road.
        connected_lane_section : LaneSection, optional
            The lane section connected to the road. Default is None.
        contact_point : ContactPoint, optional
            The contact point of the `connected_lane_section`. Default is
            `ContactPoint.end`.

        Returns
        -------
        None

        Raises
        ------
        TypeError
            If `connected_lane_section` is not of type `LaneSection`.
        &#34;&#34;&#34;
        contact_point = enumchecker(contact_point, ContactPoint)
        if connected_lane_section and not isinstance(
            connected_lane_section, LaneSection
        ):
            raise TypeError(
                &#34;connected_lane_section is not of type LaneSection&#34;
            )
        if not self.roadmarks_adjusted:
            self._validity_check_for_roadmark_adjustment()
            self.roadmarks_adjusted = True

            def set_zero_offset_to_lines(lane, seg_length):
                for i_line in range(len(lane.roadmark[0]._line)):
                    lane.roadmark[0]._line[i_line].adjust_remainder(
                        seg_length, soffset=0
                    )

            for ls in range(0, len(self.lanesections)):
                seg_length = self._get_seg_length(total_road_length, ls)
                if self._right_lanes_adjustable:
                    for rl in range(len(self.lanesections[ls].rightlanes)):
                        if self._check_valid_mark_type(
                            self.lanesections[ls].rightlanes[rl]
                        ):
                            if ls == 0 and connected_lane_section is None:
                                set_zero_offset_to_lines(
                                    self.lanesections[ls].rightlanes[rl],
                                    seg_length,
                                )
                            else:
                                for i_line in range(
                                    len(
                                        self.lanesections[ls]
                                        .rightlanes[rl]
                                        .roadmark[0]
                                        ._line
                                    )
                                ):
                                    prev_remainder = (
                                        self._get_previous_remainder(
                                            connected_lane_section,
                                            i_line,
                                            &#34;right&#34;,
                                            contact_point,
                                            rl,
                                            ls,
                                            &#34;start&#34;,
                                        )
                                    )
                                    self.lanesections[ls].rightlanes[
                                        rl
                                    ].roadmark[0]._line[
                                        i_line
                                    ].adjust_remainder(
                                        seg_length,
                                        previous_remainder=prev_remainder,
                                    )
                                self._adjust_for_missing_line_offset(
                                    self.lanesections[ls]
                                    .rightlanes[rl]
                                    .roadmark[0]
                                )
                if self._left_lanes_adjustable:
                    for ll in range(len(self.lanesections[ls].leftlanes)):
                        if self._check_valid_mark_type(
                            self.lanesections[ls].leftlanes[ll]
                        ):
                            if ls == 0 and connected_lane_section is None:
                                set_zero_offset_to_lines(
                                    self.lanesections[ls].leftlanes[ll],
                                    seg_length,
                                )
                            else:
                                for i_line in range(
                                    len(
                                        self.lanesections[ls]
                                        .leftlanes[ll]
                                        .roadmark[0]
                                        ._line
                                    )
                                ):
                                    prev_remainder = (
                                        self._get_previous_remainder(
                                            connected_lane_section,
                                            i_line,
                                            &#34;left&#34;,
                                            contact_point,
                                            ll,
                                            ls,
                                            &#34;start&#34;,
                                        )
                                    )
                                    self.lanesections[ls].leftlanes[
                                        ll
                                    ].roadmark[0]._line[
                                        i_line
                                    ].adjust_remainder(
                                        seg_length,
                                        previous_remainder=prev_remainder,
                                    )
                                self._adjust_for_missing_line_offset(
                                    self.lanesections[ls]
                                    .leftlanes[ll]
                                    .roadmark[0]
                                )
                if self._center_lane_adjustable:
                    if self._check_valid_mark_type(
                        self.lanesections[ls].centerlane
                    ):
                        if ls == 0 and connected_lane_section is None:
                            set_zero_offset_to_lines(
                                self.lanesections[ls].centerlane, seg_length
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .centerlane.roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = self._get_previous_remainder(
                                    connected_lane_section,
                                    i_line,
                                    &#34;center&#34;,
                                    contact_point,
                                    None,
                                    ls,
                                    &#34;start&#34;,
                                )
                                self.lanesections[ls].centerlane.roadmark[
                                    0
                                ]._line[i_line].adjust_remainder(
                                    seg_length,
                                    previous_remainder=prev_remainder,
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls].centerlane.roadmark[0]
                            )

    def adjust_road_marks_from_end(
        self,
        total_road_length: float,
        connected_lane_section: Optional[&#34;LaneSection&#34;] = None,
        contact_point: &#34;ContactPoint&#34; = ContactPoint.end,
    ) -&gt; None:
        &#34;&#34;&#34;Adjust road marks from the end of the road.

        This method adjusts road marks based on the connected lane
        section. If `connected_lane_section` is not provided, the last
        roadmark will be placed with zero distance to the end of the road.

        Parameters
        ----------
        total_road_length : float
            The total length of the road.
        connected_lane_section : LaneSection, optional
            The lane section connected to the road. Default is None.
        contact_point : ContactPoint, optional
            The contact point of the `connected_lane_section`. Default is
            `ContactPoint.end`.

        Returns
        -------
        None

        Raises
        ------
        TypeError
            If `connected_lane_section` is not of type `LaneSection`.
        &#34;&#34;&#34;
        contact_point = enumchecker(contact_point, ContactPoint)
        if connected_lane_section and not isinstance(
            connected_lane_section, LaneSection
        ):
            raise TypeError(
                &#34;connected_lane_section is not of type LaneSection&#34;
            )
        if not self.roadmarks_adjusted:
            self._validity_check_for_roadmark_adjustment()
            self.roadmarks_adjusted = True

            def set_zero_remainder_to_lines(lane, seg_length):
                for i_line in range(len(lane.roadmark[0]._line)):
                    lane.roadmark[0]._line[i_line].adjust_soffset(
                        seg_length, remainder=0
                    )

            for ls in range(len(self.lanesections) - 1, -1, -1):
                seg_length = self._get_seg_length(total_road_length, ls)
                if self._right_lanes_adjustable:
                    for rl in range(len(self.lanesections[ls].rightlanes)):
                        if self._check_valid_mark_type(
                            self.lanesections[ls].rightlanes[rl]
                        ):
                            if (
                                ls == len(self.lanesections) - 1
                                and connected_lane_section is None
                            ):
                                set_zero_remainder_to_lines(
                                    self.lanesections[ls].rightlanes[rl],
                                    seg_length,
                                )
                            else:
                                for i_line in range(
                                    len(
                                        self.lanesections[ls]
                                        .rightlanes[rl]
                                        .roadmark[0]
                                        ._line
                                    )
                                ):
                                    prev_remainder = (
                                        self._get_previous_remainder(
                                            connected_lane_section,
                                            i_line,
                                            &#34;right&#34;,
                                            contact_point,
                                            rl,
                                            ls,
                                            &#34;end&#34;,
                                        )
                                    )
                                    self.lanesections[ls].rightlanes[
                                        rl
                                    ].roadmark[0]._line[i_line].adjust_soffset(
                                        seg_length,
                                        previous_offset=prev_remainder,
                                    )
                                self._adjust_for_missing_line_offset(
                                    self.lanesections[ls]
                                    .rightlanes[rl]
                                    .roadmark[0]
                                )
                if self._left_lanes_adjustable:
                    for ll in range(len(self.lanesections[ls].leftlanes)):
                        if self._check_valid_mark_type(
                            self.lanesections[ls].leftlanes[ll]
                        ):
                            if (
                                ls == len(self.lanesections) - 1
                                and connected_lane_section is None
                            ):
                                set_zero_remainder_to_lines(
                                    self.lanesections[ls].leftlanes[ll],
                                    seg_length,
                                )
                            else:
                                for i_line in range(
                                    len(
                                        self.lanesections[ls]
                                        .leftlanes[ll]
                                        .roadmark[0]
                                        ._line
                                    )
                                ):
                                    prev_remainder = (
                                        self._get_previous_remainder(
                                            connected_lane_section,
                                            i_line,
                                            &#34;left&#34;,
                                            contact_point,
                                            ll,
                                            ls,
                                            &#34;end&#34;,
                                        )
                                    )
                                    self.lanesections[ls].leftlanes[
                                        ll
                                    ].roadmark[0]._line[i_line].adjust_soffset(
                                        seg_length,
                                        previous_offset=prev_remainder,
                                    )
                                self._adjust_for_missing_line_offset(
                                    self.lanesections[ls]
                                    .leftlanes[ll]
                                    .roadmark[0]
                                )

                if self._center_lane_adjustable:
                    if self._check_valid_mark_type(
                        self.lanesections[ls].centerlane
                    ):
                        if (
                            ls == len(self.lanesections) - 1
                            and connected_lane_section is None
                        ):
                            set_zero_remainder_to_lines(
                                self.lanesections[ls].centerlane, seg_length
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .centerlane.roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = self._get_previous_remainder(
                                    connected_lane_section,
                                    i_line,
                                    &#34;center&#34;,
                                    contact_point,
                                    None,
                                    ls,
                                    &#34;end&#34;,
                                )
                                self.lanesections[ls].centerlane.roadmark[
                                    0
                                ]._line[i_line].adjust_soffset(
                                    seg_length, previous_offset=prev_remainder
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls].centerlane.roadmark[0]
                            )

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the ElementTree representation of the `Lanes` object.

        This method generates an XML representation of the `Lanes` object,
        including its lane sections and lane offsets.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `Lanes` object.
        &#34;&#34;&#34;
        element = ET.Element(&#34;lanes&#34;)
        self._add_additional_data_to_element(element)
        for l in self.laneoffsets:
            element.append(l.get_element())
        for l in self.lanesections:
            element.append(l.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Create the Lanes element of OpenDRIVE.</p>
<p>This class represents the lanes of a road, including lane sections and
lane offsets.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lanesections</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></dt>
<dd>A list of all lane sections in the road.</dd>
<dt><strong><code>laneoffsets</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code></dt>
<dd>A list of lane offsets applied to the road.</dd>
<dt><strong><code>roadmarks_adjusted</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether roadmarks have been adjusted.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
add_lanesection(lanesection, lanelinks=None)
Adds a lane section to the Lanes object.
add_laneoffset(laneoffset)
Adds a lane offset to the Lanes object.
adjust_road_marks_from_start(total_road_length,
connected_lane_section=None, contact_point=ContactPoint.end)
Adjusts road marks from the start of the road.
adjust_road_marks_from_end(total_road_length, connected_lane_section=None,
contact_point=ContactPoint.end)
Adjusts road marks from the end of the road.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> class.</p>
<p>This constructor initializes the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object with default
values for lane sections, lane offsets, and roadmark adjustment
status.</p>
<h2 id="attributes_1">Attributes</h2>
<dl>
<dt><strong><code>lanesections</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></dt>
<dd>A list of all lane sections in the road.</dd>
<dt><strong><code>laneoffsets</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code></dt>
<dd>A list of lane offsets applied to the road.</dd>
<dt><strong><code>roadmarks_adjusted</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether roadmarks have been adjusted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.Lanes.add_laneoffset"><code class="name flex">
<span>def <span class="ident">add_laneoffset</span></span>(<span>self,<br>laneoffset: <a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a>) ‑> <a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_laneoffset(self, laneoffset: &#34;LaneOffset&#34;) -&gt; &#34;Lanes&#34;:
    &#34;&#34;&#34;Add a lane offset to the `Lanes` object.

    This method adds a `LaneOffset` to the `Lanes` object.

    Parameters
    ----------
    laneoffset : LaneOffset
        A `LaneOffset` object to add to the `Lanes` object.

    Returns
    -------
    Lanes
        The updated `Lanes` object.

    Raises
    ------
    TypeError
        If `laneoffset` is not of type `LaneOffset`.
    &#34;&#34;&#34;
    if not isinstance(laneoffset, LaneOffset):
        raise TypeError(
            &#34;add_laneoffset requires a LaneOffset as input, not &#34;
            + str(type(laneoffset))
        )
    self.laneoffsets.append(laneoffset)
    return self</code></pre>
</details>
<div class="desc"><p>Add a lane offset to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</p>
<p>This method adds a <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code> to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>laneoffset</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code></dt>
<dd>A <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code> object to add to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>laneoffset</code> is not of type <code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.add_lanesection"><code class="name flex">
<span>def <span class="ident">add_lanesection</span></span>(<span>self,<br>lanesection: <a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a>,<br>lanelinks: ForwardRef('LaneLinker') | list['LaneLinker'] | None = None) ‑> <a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lanesection(
    self,
    lanesection: &#34;LaneSection&#34;,
    lanelinks: Optional[Union[&#34;LaneLinker&#34;, list[&#34;LaneLinker&#34;]]] = None,
) -&gt; &#34;Lanes&#34;:
    &#34;&#34;&#34;Add a lane section to the `Lanes` object.

    This method adds a `LaneSection` to the `Lanes` object and
    optionally links lanes using a `LaneLinker`.

    Parameters
    ----------
    lanesection : LaneSection
        A `LaneSection` object to add to the `Lanes` object.
    lanelinks : LaneLinker or list of LaneLinker, optional
        A `LaneLinker` or a list of `LaneLinker` objects to link &#39;
        lanes. Default is None.

    Returns
    -------
    Lanes
        The updated `Lanes` object.

    Raises
    ------
    TypeError
        If `lanesection` is not of type `LaneSection` or if
        `lanelinks` contains objects that are not of type
        `LaneLinker`.
    &#34;&#34;&#34;
    if not isinstance(lanesection, LaneSection):
        raise TypeError(&#34;input lanesection is not of type LaneSection&#34;)
    # add links to the lanes
    if lanelinks:
        # loop over all links
        if not isinstance(lanelinks, list):
            lanelinks = [lanelinks]
        if any([not isinstance(x, LaneLinker) for x in lanelinks]):
            raise TypeError(&#34;lanelinks contains a none LaneLinker type&#34;)
        for lanelink in lanelinks:
            for link in lanelink.links:
                # check if link already added
                if not link.used:
                    link.predecessor.add_link(
                        &#34;successor&#34;, link.successor.lane_id
                    )
                    link.successor.add_link(
                        &#34;predecessor&#34;, link.predecessor.lane_id
                    )
                    link.used = True

    self.lanesections.append(lanesection)
    return self</code></pre>
</details>
<div class="desc"><p>Add a lane section to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</p>
<p>This method adds a <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object and
optionally links lanes using a <code>LaneLinker</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lanesection</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></dt>
<dd>A <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> object to add to the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</dd>
<dt><strong><code>lanelinks</code></strong> :&ensp;<code>LaneLinker</code> or <code>list</code> of <code>LaneLinker</code>, optional</dt>
<dd>A <code>LaneLinker</code> or a list of <code>LaneLinker</code> objects to link '
lanes. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>lanesection</code> is not of type <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code> or if
<code>lanelinks</code> contains objects that are not of type
<code>LaneLinker</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_end"><code class="name flex">
<span>def <span class="ident">adjust_road_marks_from_end</span></span>(<span>self,<br>total_road_length: float,<br>connected_lane_section: ForwardRef('<a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a>') | None = None,<br>contact_point: ContactPoint = ContactPoint.end) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_road_marks_from_end(
    self,
    total_road_length: float,
    connected_lane_section: Optional[&#34;LaneSection&#34;] = None,
    contact_point: &#34;ContactPoint&#34; = ContactPoint.end,
) -&gt; None:
    &#34;&#34;&#34;Adjust road marks from the end of the road.

    This method adjusts road marks based on the connected lane
    section. If `connected_lane_section` is not provided, the last
    roadmark will be placed with zero distance to the end of the road.

    Parameters
    ----------
    total_road_length : float
        The total length of the road.
    connected_lane_section : LaneSection, optional
        The lane section connected to the road. Default is None.
    contact_point : ContactPoint, optional
        The contact point of the `connected_lane_section`. Default is
        `ContactPoint.end`.

    Returns
    -------
    None

    Raises
    ------
    TypeError
        If `connected_lane_section` is not of type `LaneSection`.
    &#34;&#34;&#34;
    contact_point = enumchecker(contact_point, ContactPoint)
    if connected_lane_section and not isinstance(
        connected_lane_section, LaneSection
    ):
        raise TypeError(
            &#34;connected_lane_section is not of type LaneSection&#34;
        )
    if not self.roadmarks_adjusted:
        self._validity_check_for_roadmark_adjustment()
        self.roadmarks_adjusted = True

        def set_zero_remainder_to_lines(lane, seg_length):
            for i_line in range(len(lane.roadmark[0]._line)):
                lane.roadmark[0]._line[i_line].adjust_soffset(
                    seg_length, remainder=0
                )

        for ls in range(len(self.lanesections) - 1, -1, -1):
            seg_length = self._get_seg_length(total_road_length, ls)
            if self._right_lanes_adjustable:
                for rl in range(len(self.lanesections[ls].rightlanes)):
                    if self._check_valid_mark_type(
                        self.lanesections[ls].rightlanes[rl]
                    ):
                        if (
                            ls == len(self.lanesections) - 1
                            and connected_lane_section is None
                        ):
                            set_zero_remainder_to_lines(
                                self.lanesections[ls].rightlanes[rl],
                                seg_length,
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .rightlanes[rl]
                                    .roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = (
                                    self._get_previous_remainder(
                                        connected_lane_section,
                                        i_line,
                                        &#34;right&#34;,
                                        contact_point,
                                        rl,
                                        ls,
                                        &#34;end&#34;,
                                    )
                                )
                                self.lanesections[ls].rightlanes[
                                    rl
                                ].roadmark[0]._line[i_line].adjust_soffset(
                                    seg_length,
                                    previous_offset=prev_remainder,
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls]
                                .rightlanes[rl]
                                .roadmark[0]
                            )
            if self._left_lanes_adjustable:
                for ll in range(len(self.lanesections[ls].leftlanes)):
                    if self._check_valid_mark_type(
                        self.lanesections[ls].leftlanes[ll]
                    ):
                        if (
                            ls == len(self.lanesections) - 1
                            and connected_lane_section is None
                        ):
                            set_zero_remainder_to_lines(
                                self.lanesections[ls].leftlanes[ll],
                                seg_length,
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .leftlanes[ll]
                                    .roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = (
                                    self._get_previous_remainder(
                                        connected_lane_section,
                                        i_line,
                                        &#34;left&#34;,
                                        contact_point,
                                        ll,
                                        ls,
                                        &#34;end&#34;,
                                    )
                                )
                                self.lanesections[ls].leftlanes[
                                    ll
                                ].roadmark[0]._line[i_line].adjust_soffset(
                                    seg_length,
                                    previous_offset=prev_remainder,
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls]
                                .leftlanes[ll]
                                .roadmark[0]
                            )

            if self._center_lane_adjustable:
                if self._check_valid_mark_type(
                    self.lanesections[ls].centerlane
                ):
                    if (
                        ls == len(self.lanesections) - 1
                        and connected_lane_section is None
                    ):
                        set_zero_remainder_to_lines(
                            self.lanesections[ls].centerlane, seg_length
                        )
                    else:
                        for i_line in range(
                            len(
                                self.lanesections[ls]
                                .centerlane.roadmark[0]
                                ._line
                            )
                        ):
                            prev_remainder = self._get_previous_remainder(
                                connected_lane_section,
                                i_line,
                                &#34;center&#34;,
                                contact_point,
                                None,
                                ls,
                                &#34;end&#34;,
                            )
                            self.lanesections[ls].centerlane.roadmark[
                                0
                            ]._line[i_line].adjust_soffset(
                                seg_length, previous_offset=prev_remainder
                            )
                        self._adjust_for_missing_line_offset(
                            self.lanesections[ls].centerlane.roadmark[0]
                        )</code></pre>
</details>
<div class="desc"><p>Adjust road marks from the end of the road.</p>
<p>This method adjusts road marks based on the connected lane
section. If <code>connected_lane_section</code> is not provided, the last
roadmark will be placed with zero distance to the end of the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>total_road_length</code></strong> :&ensp;<code>float</code></dt>
<dd>The total length of the road.</dd>
<dt><strong><code>connected_lane_section</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>, optional</dt>
<dd>The lane section connected to the road. Default is None.</dd>
<dt><strong><code>contact_point</code></strong> :&ensp;<code>ContactPoint</code>, optional</dt>
<dd>The contact point of the <code>connected_lane_section</code>. Default is
<code>ContactPoint.end</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>connected_lane_section</code> is not of type <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_start"><code class="name flex">
<span>def <span class="ident">adjust_road_marks_from_start</span></span>(<span>self,<br>total_road_length: float,<br>connected_lane_section: ForwardRef('<a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a>') | None = None,<br>contact_point: ContactPoint = ContactPoint.end) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_road_marks_from_start(
    self,
    total_road_length: float,
    connected_lane_section: Optional[&#34;LaneSection&#34;] = None,
    contact_point: &#34;ContactPoint&#34; = ContactPoint.end,
) -&gt; None:
    &#34;&#34;&#34;Adjust road marks from the start of the road.

    This method adjusts road marks based on the connected lane
    section. If `connected_lane_section` is not provided, the last
    roadmark will be placed with zero distance to the start of the
    road.

    Parameters
    ----------
    total_road_length : float
        The total length of the road.
    connected_lane_section : LaneSection, optional
        The lane section connected to the road. Default is None.
    contact_point : ContactPoint, optional
        The contact point of the `connected_lane_section`. Default is
        `ContactPoint.end`.

    Returns
    -------
    None

    Raises
    ------
    TypeError
        If `connected_lane_section` is not of type `LaneSection`.
    &#34;&#34;&#34;
    contact_point = enumchecker(contact_point, ContactPoint)
    if connected_lane_section and not isinstance(
        connected_lane_section, LaneSection
    ):
        raise TypeError(
            &#34;connected_lane_section is not of type LaneSection&#34;
        )
    if not self.roadmarks_adjusted:
        self._validity_check_for_roadmark_adjustment()
        self.roadmarks_adjusted = True

        def set_zero_offset_to_lines(lane, seg_length):
            for i_line in range(len(lane.roadmark[0]._line)):
                lane.roadmark[0]._line[i_line].adjust_remainder(
                    seg_length, soffset=0
                )

        for ls in range(0, len(self.lanesections)):
            seg_length = self._get_seg_length(total_road_length, ls)
            if self._right_lanes_adjustable:
                for rl in range(len(self.lanesections[ls].rightlanes)):
                    if self._check_valid_mark_type(
                        self.lanesections[ls].rightlanes[rl]
                    ):
                        if ls == 0 and connected_lane_section is None:
                            set_zero_offset_to_lines(
                                self.lanesections[ls].rightlanes[rl],
                                seg_length,
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .rightlanes[rl]
                                    .roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = (
                                    self._get_previous_remainder(
                                        connected_lane_section,
                                        i_line,
                                        &#34;right&#34;,
                                        contact_point,
                                        rl,
                                        ls,
                                        &#34;start&#34;,
                                    )
                                )
                                self.lanesections[ls].rightlanes[
                                    rl
                                ].roadmark[0]._line[
                                    i_line
                                ].adjust_remainder(
                                    seg_length,
                                    previous_remainder=prev_remainder,
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls]
                                .rightlanes[rl]
                                .roadmark[0]
                            )
            if self._left_lanes_adjustable:
                for ll in range(len(self.lanesections[ls].leftlanes)):
                    if self._check_valid_mark_type(
                        self.lanesections[ls].leftlanes[ll]
                    ):
                        if ls == 0 and connected_lane_section is None:
                            set_zero_offset_to_lines(
                                self.lanesections[ls].leftlanes[ll],
                                seg_length,
                            )
                        else:
                            for i_line in range(
                                len(
                                    self.lanesections[ls]
                                    .leftlanes[ll]
                                    .roadmark[0]
                                    ._line
                                )
                            ):
                                prev_remainder = (
                                    self._get_previous_remainder(
                                        connected_lane_section,
                                        i_line,
                                        &#34;left&#34;,
                                        contact_point,
                                        ll,
                                        ls,
                                        &#34;start&#34;,
                                    )
                                )
                                self.lanesections[ls].leftlanes[
                                    ll
                                ].roadmark[0]._line[
                                    i_line
                                ].adjust_remainder(
                                    seg_length,
                                    previous_remainder=prev_remainder,
                                )
                            self._adjust_for_missing_line_offset(
                                self.lanesections[ls]
                                .leftlanes[ll]
                                .roadmark[0]
                            )
            if self._center_lane_adjustable:
                if self._check_valid_mark_type(
                    self.lanesections[ls].centerlane
                ):
                    if ls == 0 and connected_lane_section is None:
                        set_zero_offset_to_lines(
                            self.lanesections[ls].centerlane, seg_length
                        )
                    else:
                        for i_line in range(
                            len(
                                self.lanesections[ls]
                                .centerlane.roadmark[0]
                                ._line
                            )
                        ):
                            prev_remainder = self._get_previous_remainder(
                                connected_lane_section,
                                i_line,
                                &#34;center&#34;,
                                contact_point,
                                None,
                                ls,
                                &#34;start&#34;,
                            )
                            self.lanesections[ls].centerlane.roadmark[
                                0
                            ]._line[i_line].adjust_remainder(
                                seg_length,
                                previous_remainder=prev_remainder,
                            )
                        self._adjust_for_missing_line_offset(
                            self.lanesections[ls].centerlane.roadmark[0]
                        )</code></pre>
</details>
<div class="desc"><p>Adjust road marks from the start of the road.</p>
<p>This method adjusts road marks based on the connected lane
section. If <code>connected_lane_section</code> is not provided, the last
roadmark will be placed with zero distance to the start of the
road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>total_road_length</code></strong> :&ensp;<code>float</code></dt>
<dd>The total length of the road.</dd>
<dt><strong><code>connected_lane_section</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>, optional</dt>
<dd>The lane section connected to the road. Default is None.</dd>
<dt><strong><code>contact_point</code></strong> :&ensp;<code>ContactPoint</code>, optional</dt>
<dd>The contact point of the <code>connected_lane_section</code>. Default is
<code>ContactPoint.end</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>connected_lane_section</code> is not of type <code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the ElementTree representation of the `Lanes` object.

    This method generates an XML representation of the `Lanes` object,
    including its lane sections and lane offsets.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `Lanes` object.
    &#34;&#34;&#34;
    element = ET.Element(&#34;lanes&#34;)
    self._add_additional_data_to_element(element)
    for l in self.laneoffsets:
        element.append(l.get_element())
    for l in self.lanesections:
        element.append(l.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Returns the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</p>
<p>This method generates an XML representation of the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object,
including its lane sections and lane offsets.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code> object.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine"><code class="flex name class">
<span>class <span class="ident">RoadLine</span></span>
<span>(</span><span>width: float = 0,<br>length: float = 0,<br>space: float = 0,<br>toffset: float = 0,<br>soffset: float = 0,<br>rule: <a title="scenariogeneration.xodr.enumerations.MarkRule" href="enumerations.html#scenariogeneration.xodr.enumerations.MarkRule">MarkRule</a> | None = None,<br>color: <a title="scenariogeneration.xodr.enumerations.RoadMarkColor" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkColor">RoadMarkColor</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadLine(XodrBase):
    &#34;&#34;&#34;Create a Line type to be used in roadmark.

    Parameters
    ----------
    width : float, optional
        The width of the line. Default is 0.
    length : float, optional
        The length of the line. Default is 0.
    space : float, optional
        The length of space between (broken) lines. Default is 0.
    toffset : float, optional
        The offset in the `t` direction. Default is 0.
    soffset : float, optional
        The offset in the `s` direction. Default is 0.
    rule : MarkRule, optional
        The marking rule. Default is None.
    color : RoadMarkColor, optional
        The color of the line. Default is None.

    Attributes
    ----------
    length : float
        The length of the line.
    space : float
        The length of space between (broken) lines.
    toffset : float
        The offset in the `t` direction.
    soffset : float
        The offset in the `s` direction.
    rule : MarkRule
        The marking rule.
    width : float
        The width of the line.
    color : RoadMarkColor
        The color of the line.

    Methods
    -------
    adjust_remainder(total_length, soffset=None, previous_remainder=None)
        Adjust the remainder of a broken mark for offset adjustments.
    shift_soffset()
        Shift the `soffset` by one period.
    adjust_soffset(total_length, remainder=None, previous_offset=None)
        Adjust the `soffset` of a broken mark for offset adjustments.
    get_attributes()
        Return the attributes of the `RoadLine` as a dictionary.
    get_element()
        Return the ElementTree representation of the `RoadLine`.
    &#34;&#34;&#34;

    # TODO: check this for 1.5
    def __init__(
        self,
        width: float = 0,
        length: float = 0,
        space: float = 0,
        toffset: float = 0,
        soffset: float = 0,
        rule: Optional[MarkRule] = None,
        color: Optional[RoadMarkColor] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `RoadLine` class.

        Parameters
        ----------
        width : float, optional
            The width of the line. Default is 0.
        length : float, optional
            The length of the line. Default is 0.
        space : float, optional
            The length of space between (broken) lines. Default is 0.
        toffset : float, optional
            The offset in the `t` direction. Default is 0.
        soffset : float, optional
            The offset in the `s` direction. Default is 0.
        rule : MarkRule, optional
            The marking rule. Default is None.
        color : RoadMarkColor, optional
            The color of the line. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = enumchecker(rule, MarkRule, True)
        self.soffset = soffset
        self.width = width
        self.color = enumchecker(color, RoadMarkColor, True)
        self._remainder = 0

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RoadLine) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def adjust_remainder(
        self,
        total_length: float,
        soffset: Optional[float] = None,
        previous_remainder: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Adjust the remainder of a broken mark for offset adjustments.

        Parameters
        ----------
        total_length : float
            The length of the lane section where this line is valid.
        soffset : float, optional
            The desired `soffset` at the beginning of the line. Use this
            or `previous_remainder`. Default is None.
        previous_remainder : float, optional
            The remainder of the previous line. Use this or `soffset`.
            Default is None.

        Raises
        ------
        ToManyOptionalArguments
            If both `soffset` and `previous_remainder` are provided.
        &#34;&#34;&#34;
        if soffset and previous_remainder:
            raise ToManyOptionalArguments(
                &#34;for adjusting line lengths, use only soffset or previous_remainder.&#34;
            )
        if soffset is not None:
            self.soffset = soffset
        if previous_remainder is not None:
            self.soffset = self.space - previous_remainder
        self._remainder = self._calculate_remainder_of_line(
            self.soffset, total_length
        )

    def shift_soffset(self) -&gt; None:
        &#34;&#34;&#34;Shift the `soffset` by one period.

        This method shifts the `soffset` by the sum of the space and
        length of the line.
        &#34;&#34;&#34;
        self.soffset += self.space + self.length

    def adjust_soffset(
        self,
        total_length: float,
        remainder: Optional[float] = None,
        previous_offset: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Adjust the `soffset` of a broken mark for offset adjustments.

        Parameters
        ----------
        total_length : float
            The length of the lane section where this line is valid.
        remainder : float, optional
            The desired remainder (`soffset` at the end of the line). Use
            this or `previous_offset`. Default is None.
        previous_offset : float, optional
            The `soffset` of the previous line. Use this or `remainder`.
            Default is None.

        Raises
        ------
        ToManyOptionalArguments
            If both `remainder` and `previous_offset` are provided.
        &#34;&#34;&#34;
        if remainder and previous_offset:
            raise ToManyOptionalArguments(
                &#34;for adjusting line lengths, use only soffset or previous_remainder.&#34;
            )
        if remainder is not None:
            self._remainder = remainder
        if previous_offset is not None:
            self._remainder = self.space - previous_offset
        self.soffset = self._calculate_remainder_of_line(
            self._remainder, total_length
        )

    def _calculate_remainder_of_line(
        self, soffset: float, total_length: float
    ) -&gt; float:
        &#34;&#34;&#34;Calculate the remainder of the line.

        Parameters
        ----------
        soffset : float
            The `s` offset of the line.
        total_length : float
            The total length of the lane section.

        Returns
        -------
        float
            The remainder of the line.
        &#34;&#34;&#34;
        n = (total_length - soffset + self.space) / (self.space + self.length)
        return (
            total_length
            - soffset
            - np.floor(n) * (self.space + self.length)
            + self.space
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `RoadLine` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `RoadLine`.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;space&#34;] = str(self.space)
        retdict[&#34;tOffset&#34;] = str(self.toffset)
        retdict[&#34;width&#34;] = str(self.width)
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        # if self.color:
        # retdict[&#39;color&#39;] = enum2str(self.color)
        if self.rule:
            retdict[&#34;rule&#34;] = enum2str(self.rule)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `RoadLine`.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `RoadLine`.
        &#34;&#34;&#34;
        &#34;&#34;&#34;Returns the elementTree of the RoadLine.&#34;&#34;&#34;
        element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>Create a Line type to be used in roadmark.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the line. Default is 0.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the line. Default is 0.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of space between (broken) lines. Default is 0.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code>, optional</dt>
<dd>The color of the line. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the line.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of space between (broken) lines.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>t</code> direction.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>s</code> direction.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code></dt>
<dd>The marking rule.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The width of the line.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code></dt>
<dd>The color of the line.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>adjust_remainder(total_length, soffset=None, previous_remainder=None)
Adjust the remainder of a broken mark for offset adjustments.
shift_soffset()
Shift the <code>soffset</code> by one period.
adjust_soffset(total_length, remainder=None, previous_offset=None)
Adjust the <code>soffset</code> of a broken mark for offset adjustments.
get_attributes()
Return the attributes of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code> as a dictionary.
get_element()
Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code>.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the line. Default is 0.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the line. Default is 0.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of space between (broken) lines. Default is 0.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is 0.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code>, optional</dt>
<dd>The color of the line. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.RoadLine.adjust_remainder"><code class="name flex">
<span>def <span class="ident">adjust_remainder</span></span>(<span>self,<br>total_length: float,<br>soffset: float | None = None,<br>previous_remainder: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_remainder(
    self,
    total_length: float,
    soffset: Optional[float] = None,
    previous_remainder: Optional[float] = None,
) -&gt; None:
    &#34;&#34;&#34;Adjust the remainder of a broken mark for offset adjustments.

    Parameters
    ----------
    total_length : float
        The length of the lane section where this line is valid.
    soffset : float, optional
        The desired `soffset` at the beginning of the line. Use this
        or `previous_remainder`. Default is None.
    previous_remainder : float, optional
        The remainder of the previous line. Use this or `soffset`.
        Default is None.

    Raises
    ------
    ToManyOptionalArguments
        If both `soffset` and `previous_remainder` are provided.
    &#34;&#34;&#34;
    if soffset and previous_remainder:
        raise ToManyOptionalArguments(
            &#34;for adjusting line lengths, use only soffset or previous_remainder.&#34;
        )
    if soffset is not None:
        self.soffset = soffset
    if previous_remainder is not None:
        self.soffset = self.space - previous_remainder
    self._remainder = self._calculate_remainder_of_line(
        self.soffset, total_length
    )</code></pre>
</details>
<div class="desc"><p>Adjust the remainder of a broken mark for offset adjustments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>total_length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the lane section where this line is valid.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The desired <code>soffset</code> at the beginning of the line. Use this
or <code>previous_remainder</code>. Default is None.</dd>
<dt><strong><code>previous_remainder</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The remainder of the previous line. Use this or <code>soffset</code>.
Default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ToManyOptionalArguments</code></dt>
<dd>If both <code>soffset</code> and <code>previous_remainder</code> are provided.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine.adjust_soffset"><code class="name flex">
<span>def <span class="ident">adjust_soffset</span></span>(<span>self,<br>total_length: float,<br>remainder: float | None = None,<br>previous_offset: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_soffset(
    self,
    total_length: float,
    remainder: Optional[float] = None,
    previous_offset: Optional[float] = None,
) -&gt; None:
    &#34;&#34;&#34;Adjust the `soffset` of a broken mark for offset adjustments.

    Parameters
    ----------
    total_length : float
        The length of the lane section where this line is valid.
    remainder : float, optional
        The desired remainder (`soffset` at the end of the line). Use
        this or `previous_offset`. Default is None.
    previous_offset : float, optional
        The `soffset` of the previous line. Use this or `remainder`.
        Default is None.

    Raises
    ------
    ToManyOptionalArguments
        If both `remainder` and `previous_offset` are provided.
    &#34;&#34;&#34;
    if remainder and previous_offset:
        raise ToManyOptionalArguments(
            &#34;for adjusting line lengths, use only soffset or previous_remainder.&#34;
        )
    if remainder is not None:
        self._remainder = remainder
    if previous_offset is not None:
        self._remainder = self.space - previous_offset
    self.soffset = self._calculate_remainder_of_line(
        self._remainder, total_length
    )</code></pre>
</details>
<div class="desc"><p>Adjust the <code>soffset</code> of a broken mark for offset adjustments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>total_length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the lane section where this line is valid.</dd>
<dt><strong><code>remainder</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The desired remainder (<code>soffset</code> at the end of the line). Use
this or <code>previous_offset</code>. Default is None.</dd>
<dt><strong><code>previous_offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The <code>soffset</code> of the previous line. Use this or <code>remainder</code>.
Default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ToManyOptionalArguments</code></dt>
<dd>If both <code>remainder</code> and <code>previous_offset</code> are provided.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `RoadLine` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `RoadLine`.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;length&#34;] = str(self.length)
    retdict[&#34;space&#34;] = str(self.space)
    retdict[&#34;tOffset&#34;] = str(self.toffset)
    retdict[&#34;width&#34;] = str(self.width)
    retdict[&#34;sOffset&#34;] = str(self.soffset)
    # if self.color:
    # retdict[&#39;color&#39;] = enum2str(self.color)
    if self.rule:
        retdict[&#34;rule&#34;] = enum2str(self.rule)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `RoadLine`.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `RoadLine`.
    &#34;&#34;&#34;
    &#34;&#34;&#34;Returns the elementTree of the RoadLine.&#34;&#34;&#34;
    element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine.shift_soffset"><code class="name flex">
<span>def <span class="ident">shift_soffset</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_soffset(self) -&gt; None:
    &#34;&#34;&#34;Shift the `soffset` by one period.

    This method shifts the `soffset` by the sum of the space and
    length of the line.
    &#34;&#34;&#34;
    self.soffset += self.space + self.length</code></pre>
</details>
<div class="desc"><p>Shift the <code>soffset</code> by one period.</p>
<p>This method shifts the <code>soffset</code> by the sum of the space and
length of the line.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark"><code class="flex name class">
<span>class <span class="ident">RoadMark</span></span>
<span>(</span><span>marking_type: <a title="scenariogeneration.xodr.enumerations.RoadMarkType" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkType">RoadMarkType</a>,<br>width: float | None = None,<br>length: float | None = None,<br>space: float | None = None,<br>toffset: float | None = None,<br>soffset: float = 0,<br>rule: <a title="scenariogeneration.xodr.enumerations.MarkRule" href="enumerations.html#scenariogeneration.xodr.enumerations.MarkRule">MarkRule</a> | None = None,<br>color: <a title="scenariogeneration.xodr.enumerations.RoadMarkColor" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkColor">RoadMarkColor</a> = RoadMarkColor.standard,<br>marking_weight: <a title="scenariogeneration.xodr.enumerations.RoadMarkWeight" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkWeight">RoadMarkWeight</a> = RoadMarkWeight.standard,<br>height: float | None = None,<br>laneChange: <a title="scenariogeneration.xodr.enumerations.LaneChange" href="enumerations.html#scenariogeneration.xodr.enumerations.LaneChange">LaneChange</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadMark(XodrBase):
    &#34;&#34;&#34;Create a RoadMark element of OpenDRIVE.

    Parameters
    ----------
    marking_type : RoadMarkType
        The type of marking.
    width : float, optional
        The width of the marking/line. Default is None.
    length : float, optional
        The length of the visible, marked part of the line (used for
        broken lines). Default is None.
    space : float, optional
        The length of the invisible, unmarked part of the line (used for
        broken lines). Default is None.
    toffset : float, optional
        The offset in the `t` direction. Default is None.
    soffset : float, optional
        The offset in the `s` direction. Default is 0.
    rule : MarkRule, optional
        The marking rule. Default is None.
    color : RoadMarkColor, optional
        The color of the marking. Default is `RoadMarkColor.standard`.
    marking_weight : RoadMarkWeight, optional
        The weight of the marking. Default is `RoadMarkWeight.standard`.
    height : float, optional
        The thickness of the marking. Default is None.
    laneChange : LaneChange, optional
        Indicates the direction in which lane changes are allowed.
        Default is None.

    Attributes
    ----------
    marking_type : RoadMarkType
        The type of marking.
    width : float
        The width of the marking/line.
    length : float
        The length of the visible, marked part of the line.
    space : float
        The length of the invisible, unmarked part of the line.
    toffset : float
        The offset in the `t` direction.
    soffset : float
        The offset in the `s` direction.
    rule : MarkRule
        The marking rule.
    color : RoadMarkColor
        The color of the marking.
    marking_weight : RoadMarkWeight
        The weight of the marking.
    height : float
        The thickness of the marking.
    laneChange : LaneChange
        Indicates the direction in which lane changes are allowed.

    Methods
    -------
    add_specific_road_line(line)
        Add a custom road line to the RoadMark.
    add_explicit_road_line(line)
        Add an explicit road line to the RoadMark.
    get_attributes()
        Return the attributes of the RoadMark as a dictionary.
    get_element()
        Return the ElementTree representation of the RoadMark.
    &#34;&#34;&#34;

    def __init__(
        self,
        marking_type: RoadMarkType,
        width: Optional[float] = None,
        length: Optional[float] = None,
        space: Optional[float] = None,
        toffset: Optional[float] = None,
        soffset: float = 0,
        rule: Optional[MarkRule] = None,
        color: RoadMarkColor = RoadMarkColor.standard,
        marking_weight: RoadMarkWeight = RoadMarkWeight.standard,
        height: Optional[float] = None,
        laneChange: Optional[LaneChange] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `RoadMark` class.

        Parameters
        ----------
        marking_type : RoadMarkType
            The type of marking.
        width : float, optional
            The width of the marking/line. Default is None.
        length : float, optional
            The length of the visible, marked part of the line (used for
            broken lines). Default is None.
        space : float, optional
            The length of the invisible, unmarked part of the line (used
            for broken lines). Default is None.
        toffset : float, optional
            The offset in the `t` direction. Default is None.
        soffset : float, optional
            The offset in the `s` direction. Default is 0.
        rule : MarkRule, optional
            The marking rule. Default is None.
        color : RoadMarkColor, optional
            The color of the marking. Default is `RoadMarkColor.standard`.
        marking_weight : RoadMarkWeight, optional
            The weight of the marking. Default is
            `RoadMarkWeight.standard`.
        height : float, optional
            The thickness of the marking. Default is None.
        laneChange : LaneChange, optional
            Indicates the direction in which lane changes are allowed.
            Default is None.
        &#34;&#34;&#34;
        super().__init__()
        # required arguments - must be provided by user
        self.marking_type = enumchecker(marking_type, RoadMarkType)

        # required arguments - must be provided by user or taken from defaults
        self.marking_weight = enumchecker(marking_weight, RoadMarkWeight)
        self.color = enumchecker(color, RoadMarkColor, True)
        self.soffset = soffset
        self.height = height
        self.laneChange = enumchecker(laneChange, LaneChange, True)

        # optional arguments - roadmark is valid without them being defined
        self.width = width
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule

        # TODO: there may be more line child elements per roadmark, which is currently unsupported
        self._line = []
        self._explicit_line = []
        # check if arguments were passed that require line child element
        if any([length, space, toffset, rule]):
            # set defaults in case no values were provided
            # values for broken lines
            if marking_type == RoadMarkType.broken:
                self.length = length or 3
                self.space = space or 3
            # values for solid lines
            elif marking_type == RoadMarkType.solid:
                self.length = length or 3
                self.space = space or 0
            # create empty line if arguments are missing
            else:
                self.length = length or 0
                self.space = length or 0
                print(
                    &#34;No defaults for arguments &#39;space&#39; and &#39;length&#39; for roadmark type&#34;,
                    enum2str(marking_type),
                    &#34;available and no values were passed. Creating an empty roadmark.&#34;,
                )
            # set remaining defaults
            self.width = width or 0.2
            self.toffset = toffset or 0
            self.rule = rule or MarkRule.none
            self._line.append(
                RoadLine(
                    self.width,
                    self.length,
                    self.space,
                    self.toffset,
                    0,
                    self.rule,
                    self.color,
                )
            )

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RoadMark) and super().__eq__(other):
            if (
                self._line == other._line
                and self._explicit_line == other._explicit_line
                and self.get_attributes() == other.get_attributes()
                and self.marking_type == other.marking_type
            ):
                return True
        return False

    def add_specific_road_line(self, line: &#34;RoadLine&#34;) -&gt; &#34;RoadMark&#34;:
        &#34;&#34;&#34;Add a custom road line to the RoadMark.

        Parameters
        ----------
        line : RoadLine
            The road line to add.

        Returns
        -------
        RoadMark
            The updated `RoadMark` object.

        Raises
        ------
        TypeError
            If `line` is not of type `RoadLine`.
        &#34;&#34;&#34;
        if not isinstance(line, RoadLine):
            raise TypeError(&#34;line input is not of type RoadLine&#34;)
        self._line.append(line)
        return self

    def add_explicit_road_line(self, line: &#34;ExplicitRoadLine&#34;) -&gt; &#34;RoadMark&#34;:
        &#34;&#34;&#34;Add an explicit road line to the RoadMark.

        Parameters
        ----------
        line : ExplicitRoadLine
            The explicit road line to add.

        Returns
        -------
        RoadMark
            The updated `RoadMark` object.

        Raises
        ------
        TypeError
            If `line` is not of type `ExplicitRoadLine`.
        &#34;&#34;&#34;
        if not isinstance(line, ExplicitRoadLine):
            raise TypeError(&#34;line input is not of type RoadLine&#34;)
        self._explicit_line.append(line)
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `RoadMark` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `RoadMark`.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        retdict[&#34;type&#34;] = enum2str(self.marking_type)
        retdict[&#34;weight&#34;] = enum2str(self.marking_weight)
        retdict[&#34;color&#34;] = enum2str(self.color)
        if self.height is not None:
            retdict[&#34;height&#34;] = str(self.height)
        if self.width is not None:
            retdict[&#34;width&#34;] = str(self.width)
        if self.laneChange is not None:
            retdict[&#34;laneChange&#34;] = enum2str(self.laneChange)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `RoadMark`.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the `RoadMark`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;roadMark&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        if self._line:
            attribs = {&#34;name&#34;: enum2str(self.marking_type)}
            if self.width is not None:
                attribs[&#34;width&#34;] = str(self.width)
            else:
                offsets = [x.toffset for x in self._line]

                attribs[&#34;width&#34;] = str(
                    max(offsets)
                    - min(offsets)
                    + sum(
                        [
                            x.width
                            for x in self._line
                            if x.toffset in [max(offsets), min(offsets)]
                        ]
                    )
                )
            typeelement = ET.SubElement(
                element,
                &#34;type&#34;,
                attrib=attribs,
            )
            for l in self._line:
                typeelement.append(l.get_element())
        if self._explicit_line:
            typeelement = ET.SubElement(
                element,
                &#34;explicit&#34;,
            )
            for l in self._explicit_line:
                typeelement.append(l.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Create a RoadMark element of OpenDRIVE.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>marking_type</code></strong> :&ensp;<code>RoadMarkType</code></dt>
<dd>The type of marking.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the marking/line. Default is None.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the visible, marked part of the line (used for
broken lines). Default is None.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the invisible, unmarked part of the line (used for
broken lines). Default is None.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is None.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code>, optional</dt>
<dd>The color of the marking. Default is <code>RoadMarkColor.standard</code>.</dd>
<dt><strong><code>marking_weight</code></strong> :&ensp;<code>RoadMarkWeight</code>, optional</dt>
<dd>The weight of the marking. Default is <code>RoadMarkWeight.standard</code>.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The thickness of the marking. Default is None.</dd>
<dt><strong><code>laneChange</code></strong> :&ensp;<code>LaneChange</code>, optional</dt>
<dd>Indicates the direction in which lane changes are allowed.
Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>marking_type</code></strong> :&ensp;<code>RoadMarkType</code></dt>
<dd>The type of marking.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The width of the marking/line.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the visible, marked part of the line.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the invisible, unmarked part of the line.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>t</code> direction.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code></dt>
<dd>The offset in the <code>s</code> direction.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code></dt>
<dd>The marking rule.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code></dt>
<dd>The color of the marking.</dd>
<dt><strong><code>marking_weight</code></strong> :&ensp;<code>RoadMarkWeight</code></dt>
<dd>The weight of the marking.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>The thickness of the marking.</dd>
<dt><strong><code>laneChange</code></strong> :&ensp;<code>LaneChange</code></dt>
<dd>Indicates the direction in which lane changes are allowed.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>add_specific_road_line(line)
Add a custom road line to the RoadMark.
add_explicit_road_line(line)
Add an explicit road line to the RoadMark.
get_attributes()
Return the attributes of the RoadMark as a dictionary.
get_element()
Return the ElementTree representation of the RoadMark.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code> class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>marking_type</code></strong> :&ensp;<code>RoadMarkType</code></dt>
<dd>The type of marking.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the marking/line. Default is None.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the visible, marked part of the line (used for
broken lines). Default is None.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the invisible, unmarked part of the line (used
for broken lines). Default is None.</dd>
<dt><strong><code>toffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>t</code> direction. Default is None.</dd>
<dt><strong><code>soffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The offset in the <code>s</code> direction. Default is 0.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>MarkRule</code>, optional</dt>
<dd>The marking rule. Default is None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code>, optional</dt>
<dd>The color of the marking. Default is <code>RoadMarkColor.standard</code>.</dd>
<dt><strong><code>marking_weight</code></strong> :&ensp;<code>RoadMarkWeight</code>, optional</dt>
<dd>The weight of the marking. Default is
<code>RoadMarkWeight.standard</code>.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The thickness of the marking. Default is None.</dd>
<dt><strong><code>laneChange</code></strong> :&ensp;<code>LaneChange</code>, optional</dt>
<dd>Indicates the direction in which lane changes are allowed.
Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.RoadMark.add_explicit_road_line"><code class="name flex">
<span>def <span class="ident">add_explicit_road_line</span></span>(<span>self,<br>line: <a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a>) ‑> <a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_explicit_road_line(self, line: &#34;ExplicitRoadLine&#34;) -&gt; &#34;RoadMark&#34;:
    &#34;&#34;&#34;Add an explicit road line to the RoadMark.

    Parameters
    ----------
    line : ExplicitRoadLine
        The explicit road line to add.

    Returns
    -------
    RoadMark
        The updated `RoadMark` object.

    Raises
    ------
    TypeError
        If `line` is not of type `ExplicitRoadLine`.
    &#34;&#34;&#34;
    if not isinstance(line, ExplicitRoadLine):
        raise TypeError(&#34;line input is not of type RoadLine&#34;)
    self._explicit_line.append(line)
    return self</code></pre>
</details>
<div class="desc"><p>Add an explicit road line to the RoadMark.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>line</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code></dt>
<dd>The explicit road line to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>line</code> is not of type <code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark.add_specific_road_line"><code class="name flex">
<span>def <span class="ident">add_specific_road_line</span></span>(<span>self,<br>line: <a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a>) ‑> <a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_specific_road_line(self, line: &#34;RoadLine&#34;) -&gt; &#34;RoadMark&#34;:
    &#34;&#34;&#34;Add a custom road line to the RoadMark.

    Parameters
    ----------
    line : RoadLine
        The road line to add.

    Returns
    -------
    RoadMark
        The updated `RoadMark` object.

    Raises
    ------
    TypeError
        If `line` is not of type `RoadLine`.
    &#34;&#34;&#34;
    if not isinstance(line, RoadLine):
        raise TypeError(&#34;line input is not of type RoadLine&#34;)
    self._line.append(line)
    return self</code></pre>
</details>
<div class="desc"><p>Add a custom road line to the RoadMark.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>line</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code></dt>
<dd>The road line to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></dt>
<dd>The updated <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>line</code> is not of type <code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `RoadMark` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `RoadMark`.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;sOffset&#34;] = str(self.soffset)
    retdict[&#34;type&#34;] = enum2str(self.marking_type)
    retdict[&#34;weight&#34;] = enum2str(self.marking_weight)
    retdict[&#34;color&#34;] = enum2str(self.color)
    if self.height is not None:
        retdict[&#34;height&#34;] = str(self.height)
    if self.width is not None:
        retdict[&#34;width&#34;] = str(self.width)
    if self.laneChange is not None:
        retdict[&#34;laneChange&#34;] = enum2str(self.laneChange)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `RoadMark`.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the `RoadMark`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;roadMark&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    if self._line:
        attribs = {&#34;name&#34;: enum2str(self.marking_type)}
        if self.width is not None:
            attribs[&#34;width&#34;] = str(self.width)
        else:
            offsets = [x.toffset for x in self._line]

            attribs[&#34;width&#34;] = str(
                max(offsets)
                - min(offsets)
                + sum(
                    [
                        x.width
                        for x in self._line
                        if x.toffset in [max(offsets), min(offsets)]
                    ]
                )
            )
        typeelement = ET.SubElement(
            element,
            &#34;type&#34;,
            attrib=attribs,
        )
        for l in self._line:
            typeelement.append(l.get_element())
    if self._explicit_line:
        typeelement = ET.SubElement(
            element,
            &#34;explicit&#34;,
        )
        for l in self._explicit_line:
            typeelement.append(l.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the <code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code>.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine" href="#scenariogeneration.xodr.lane.ExplicitRoadLine">ExplicitRoadLine</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine.get_attributes" href="#scenariogeneration.xodr.lane.ExplicitRoadLine.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.ExplicitRoadLine.get_element" href="#scenariogeneration.xodr.lane.ExplicitRoadLine.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_height" href="#scenariogeneration.xodr.lane.Lane.add_height">add_height</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_lane_material" href="#scenariogeneration.xodr.lane.Lane.add_lane_material">add_lane_material</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_lane_width" href="#scenariogeneration.xodr.lane.Lane.add_lane_width">add_lane_width</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_link" href="#scenariogeneration.xodr.lane.Lane.add_link">add_link</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_roadmark" href="#scenariogeneration.xodr.lane.Lane.add_roadmark">add_roadmark</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_attributes" href="#scenariogeneration.xodr.lane.Lane.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_element" href="#scenariogeneration.xodr.lane.Lane.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_linked_lane_id" href="#scenariogeneration.xodr.lane.Lane.get_linked_lane_id">get_linked_lane_id</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_width" href="#scenariogeneration.xodr.lane.Lane.get_width">get_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.LaneOffset.get_attributes" href="#scenariogeneration.xodr.lane.LaneOffset.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneOffset.get_element" href="#scenariogeneration.xodr.lane.LaneOffset.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.add_left_lane" href="#scenariogeneration.xodr.lane.LaneSection.add_left_lane">add_left_lane</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.add_right_lane" href="#scenariogeneration.xodr.lane.LaneSection.add_right_lane">add_right_lane</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.get_attributes" href="#scenariogeneration.xodr.lane.LaneSection.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.get_element" href="#scenariogeneration.xodr.lane.LaneSection.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.Lanes.add_laneoffset" href="#scenariogeneration.xodr.lane.Lanes.add_laneoffset">add_laneoffset</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.add_lanesection" href="#scenariogeneration.xodr.lane.Lanes.add_lanesection">add_lanesection</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_end" href="#scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_end">adjust_road_marks_from_end</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_start" href="#scenariogeneration.xodr.lane.Lanes.adjust_road_marks_from_start">adjust_road_marks_from_start</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.get_element" href="#scenariogeneration.xodr.lane.Lanes.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.adjust_remainder" href="#scenariogeneration.xodr.lane.RoadLine.adjust_remainder">adjust_remainder</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.adjust_soffset" href="#scenariogeneration.xodr.lane.RoadLine.adjust_soffset">adjust_soffset</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.get_attributes" href="#scenariogeneration.xodr.lane.RoadLine.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.get_element" href="#scenariogeneration.xodr.lane.RoadLine.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.shift_soffset" href="#scenariogeneration.xodr.lane.RoadLine.shift_soffset">shift_soffset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.add_explicit_road_line" href="#scenariogeneration.xodr.lane.RoadMark.add_explicit_road_line">add_explicit_road_line</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.add_specific_road_line" href="#scenariogeneration.xodr.lane.RoadMark.add_specific_road_line">add_specific_road_line</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.get_attributes" href="#scenariogeneration.xodr.lane.RoadMark.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.get_element" href="#scenariogeneration.xodr.lane.RoadMark.get_element">get_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
