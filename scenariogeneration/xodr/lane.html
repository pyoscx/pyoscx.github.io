<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>scenariogeneration.xodr.lane API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.lane</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  scenariogeneration
  https://github.com/pyoscx/scenariogeneration
 
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.
 
  Copyright (c) 2022 The scenariogeneration Authors.

&#34;&#34;&#34;

from operator import index
import xml.etree.ElementTree as ET
from ..helpers import enum2str
from .enumerations import (
    LaneType,
    LaneChange,
    RoadMarkWeight,
    RoadMarkColor,
    RoadMarkType,
    MarkRule,
)
from .links import _Links, _Link


class Lanes:
    &#34;&#34;&#34;creates the Lanes element of opendrive


    Attributes
    ----------
        lane_sections (list of LaneSection): a list of all lanesections

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        add_lanesection(lanesection)
            adds a lane section to Lanes

        add_laneoffset(laneoffset)
            adds a lane offset to Lanes
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;initalize Lanes&#34;&#34;&#34;
        self.lanesections = []
        self.laneoffsets = []

    def __eq__(self, other):
        if isinstance(other, Lanes):
            if (
                self.laneoffsets == other.laneoffsets
                and self.lanesections == other.lanesections
            ):
                return True
        return False

    def add_lanesection(self, lanesection, lanelinks=None):
        &#34;&#34;&#34;creates the Lanes element of opendrive

        Parameters
        ----------
            lanesection (LaneSection): a LaneSection to add

            lanelink (LaneLinker): (optional) a LaneLink to add

        &#34;&#34;&#34;
        # add links to the lanes
        if lanelinks:
            # loop over all links
            if not isinstance(lanelinks, list):
                lanelinks = [lanelinks]
            for lanelink in lanelinks:
                for link in lanelink.links:
                    # check if link already added
                    if not link.used:
                        link.predecessor.add_link(&#34;successor&#34;, link.successor.lane_id)
                        link.successor.add_link(&#34;predecessor&#34;, link.predecessor.lane_id)
                        link.used = True

        self.lanesections.append(lanesection)
        return self

    def add_laneoffset(self, laneoffset):
        &#34;&#34;&#34;adds a lane offset to Lanes

        Parameters
        ----------
            laneoffset (LaneOffset): a LaneOffset to add
        &#34;&#34;&#34;
        if not isinstance(laneoffset, LaneOffset):
            raise TypeError(
                &#34;add_laneoffset requires a LaneOffset as input, not &#34;
                + str(type(laneoffset))
            )
        self.laneoffsets.append(laneoffset)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of Lanes&#34;&#34;&#34;
        element = ET.Element(&#34;lanes&#34;)
        for l in self.lanesections:
            element.append(l.get_element())
        for l in self.laneoffsets:
            element.append(l.get_element())
        return element


class LaneOffset:
    &#34;&#34;&#34;the LaneOffset class defines an overall lateral offset along the road, described as a third degree polynomial

    Parameters
    ----------
        s (float): s start coordinate of the elevation

        a (float): a coefficient of the polynomial

        b (float): b coefficient of the polynomial

        c (float): c coefficient of the polynomial

        d (float): d coefficient of the polynomial

    Attributes
    ----------
        s (float): s start coordinate of the elevation

        a (float): a coefficient of the polynomial

        b (float): b coefficient of the polynomial

        c (float): c coefficient of the polynomial

        d (float): d coefficient of the polynomial

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns the attributes of the class

    &#34;&#34;&#34;

    def __init__(self, s=0, a=0, b=0, c=0, d=0):
        &#34;&#34;&#34;initalize the LaneOffset class

        Parameters
        ----------
            s (float): s start coordinate of the LaneOffset

            a (float): a coefficient of the polynomial

            b (float): b coefficient of the polynomial

            c (float): c coefficient of the polynomial

            d (float): d coefficient of the polynomial

        &#34;&#34;&#34;
        self.s = s
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    def __eq__(self, other):
        if isinstance(other, LaneOffset):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffset&#34;&#34;&#34;

        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;a&#34;] = str(self.a)
        retdict[&#34;b&#34;] = str(self.b)
        retdict[&#34;c&#34;] = str(self.c)
        retdict[&#34;d&#34;] = str(self.d)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffset&#34;&#34;&#34;
        element = ET.Element(&#34;laneOffset&#34;, attrib=self.get_attributes())

        return element


class LaneSection:
    &#34;&#34;&#34;Creates the LaneSection element of opendrive

    Parameters
    ----------
        s (float): start of lanesection

        centerlane (Lane): the centerline of the road

    Attributes
    ----------
        s (float): start of lanesection

        centerlane (Lane): the centerline of the road

        leftlanes (list of Lane): the lanes left to the center

        rightlanes (list of Lane): the lanes right to the center

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of class

        add_left_lane(Lane)
            adds a new lane to the left

        add_right_lane(Lane)
            adds a new lane to the right
    &#34;&#34;&#34;

    def __init__(self, s, centerlane):
        &#34;&#34;&#34;initalize the LaneSection

        Parameters
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road
        &#34;&#34;&#34;
        self.s = s
        self.centerlane = centerlane
        self.centerlane._set_lane_id(0)
        self.leftlanes = []
        self.rightlanes = []
        self._left_id = 1
        self._right_id = -1

    def __eq__(self, other):
        if isinstance(other, LaneSection):
            if (
                self.get_attributes() == other.get_attributes()
                and self.centerlane == other.centerlane
                and self.leftlanes == other.leftlanes
                and self.rightlanes == other.rightlanes
            ):
                return True
        return False

    def add_left_lane(self, lane):
        &#34;&#34;&#34;adds a lane to the left of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._left_id)
        self._left_id += 1
        self.leftlanes.append(lane)
        return self

    def add_right_lane(self, lane):
        &#34;&#34;&#34;adds a lane to the right of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._right_id)
        self._right_id -= 1
        self.rightlanes.append(lane)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;laneSection&#34;, attrib=self.get_attributes())

        if self.leftlanes:
            left = ET.SubElement(element, &#34;left&#34;)
            for l in reversed(self.leftlanes):
                left.append(l.get_element())

        center = ET.SubElement(element, &#34;center&#34;)
        center.append(self.centerlane.get_element())

        if self.rightlanes:
            right = ET.SubElement(element, &#34;right&#34;)
            for l in self.rightlanes:
                right.append(l.get_element())

        return element


class _poly3struct:
    def __init__(self, a=0, b=0, c=0, d=0, soffset=0):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.soffset = soffset

    def __eq__(self, other):
        if isinstance(other, _poly3struct):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_width(self, s):
        width = (
            self.a
            + self.b * (s - self.soffset)
            + self.c * (s - self.soffset) ** 2
            + self.d * (s - self.soffset) ** 3
        )
        return width

    def get_attributes(self):
        polynomialdict = {}
        polynomialdict[&#34;a&#34;] = str(self.a)
        polynomialdict[&#34;b&#34;] = str(self.b)
        polynomialdict[&#34;c&#34;] = str(self.c)
        polynomialdict[&#34;d&#34;] = str(self.d)
        polynomialdict[&#34;sOffset&#34;] = str(self.soffset)
        return polynomialdict


class Lane:
    &#34;&#34;&#34;creates a Lane of opendrive

    the inputs are on the following format:
        f(s) = a + b*s + c*s^2 + d*s^3

    Parameters
    ----------

        lane_type (LaneType): type of lane
            Default: LaneType.driving

        a (float): a coefficient
            Default: 0

        b (float): b coefficient
            Default: 0

        c (float): c coefficient
            Default: 0

        d (float): d coefficient
            Default: 0

        soffset (float): soffset of lane
            Default: 0


    Attributes
    ----------
        lane_id (int): id of the lane (automatically assigned by LaneSection)

        lane_type (LaneType): type of lane

        a (float): a coefficient

        b (float): b coefficient

        c (float): c coefficient

        d (float): d coefficient

        soffset (float): soffset of lane

        roadmark (RoadMark): roadmarks related to the lane

        links (_Links): Lane links to the lane

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of class

        add_roadmark(roadmark)
            adds a new roadmark to the lane

        add_lane_width(a, b, c, d, soffset)
            adds an additional width element to the lane
    &#34;&#34;&#34;

    def __init__(self, lane_type=LaneType.driving, a=0, b=0, c=0, d=0, soffset=0):
        &#34;&#34;&#34;initalizes the Lane

        Parameters
        ----------

            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            b (float): b polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            c (float): c polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            d (float): d polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            soffset (float): soffset of lane renamed to s in case of centerlane
                Default: 0

        &#34;&#34;&#34;
        self.lane_id = None
        self.lane_type = lane_type
        self.widths = []
        self.add_lane_width(a, b, c, d, soffset)

        self.soffset = soffset
        # TODO: enable multiple widths records per lane (only then soffset really makes sense! ASAM requires one width record to have sOffset=0)
        self.heights = (
            []
        )  # height entries to elevate the lane independent from the road elevation
        self.roadmark = []
        self.links = _Links()

    def __eq__(self, other):
        if isinstance(other, Lane):
            if (
                self.links == other.links
                and self.get_attributes() == other.get_attributes()
                and self.widths == other.widths
                and self.heights == other.heights
                and self.roadmark == other.roadmark
            ):
                return True
        return False

        # TODO: add more features to add for lane

    def add_lane_width(self, a=0, b=0, c=0, d=0, soffset=0):
        &#34;&#34;&#34;adds an additional width element to the lane

        Parameters
        ----------
            a (float): a polynomial coefficient for width
                Default: 0

            b (float): b polynomial coefficient for width
                Default: 0

            c (float): c polynomial coefficient for width
                Default: 0

            d (float): d polynomial coefficient for width
                Default: 0

            soffset (float): soffset of lane renamed to s in case of centerlane
                Default: 0

        &#34;&#34;&#34;
        self.widths.append(_poly3struct(a, b, c, d, soffset))

    def get_width(self, s):
        &#34;&#34;&#34;function that calculates the width of a lane at a point s

        Note: no check that s is on the road can be made, that has to be taken care of by the user

        Parameters
        ----------
            s (float): the point where the width is wished

        Returns
        -------
            width (float): the width at point s
        &#34;&#34;&#34;
        index_to_calc = 0
        for i in range(len(self.widths)):
            if s &gt;= self.widths[i].soffset:
                index_to_calc = i
            else:
                break
        return self.widths[index_to_calc].get_width(s)

    def add_link(self, link_type, id):
        &#34;&#34;&#34;adds a link to the lane section

        Parameters
        ----------
            link_type (str): type of link, successor or predecessor

            id (str/id): id of the linked lane
        &#34;&#34;&#34;
        self.links.add_link(_Link(link_type, str(id)))
        return self

    def _set_lane_id(self, lane_id):
        &#34;&#34;&#34;set the lane id of the lane and set lane type to &#39;none&#39; in case of centerlane&#34;&#34;&#34;
        self.lane_id = lane_id
        if self.lane_id == 0:
            self.lane_type = LaneType.none

    def add_roadmark(self, roadmark):
        &#34;&#34;&#34;add_roadmark adds a roadmark to the lane

        Parameters
        ----------
            roadmark (RoadMark): roadmark of the lane

        &#34;&#34;&#34;
        if roadmark is not None:
            self.roadmark.append(roadmark)
        return self

    def add_height(self, inner, outer=None, soffset=0):
        &#34;&#34;&#34;add_height adds a height entry to the lane to elevate it independent from the road elevation

        Parameters
        ----------
            inner (float): inner height

            outer (float): outer height (if not provided, inner height is used)
                Default: None

            s_offset (float): s offset of the height record
                Default: 0

        &#34;&#34;&#34;
        heightdict = {}
        heightdict[&#34;inner&#34;] = str(inner)
        if outer is not None:
            heightdict[&#34;outer&#34;] = str(outer)
        else:
            heightdict[&#34;outer&#34;] = str(inner)
        heightdict[&#34;sOffset&#34;] = str(soffset)

        self.heights.append(heightdict)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        if self.lane_id == None:
            raise ValueError(&#34;lane id is not set correctly.&#34;)
        retdict[&#34;id&#34;] = str(self.lane_id)
        retdict[&#34;type&#34;] = enum2str(self.lane_type)
        retdict[&#34;level&#34;] = &#34;false&#34;
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;lane&#34;, attrib=self.get_attributes())

        # according to standard if lane is centerlane it should
        # not have a width record and omit the link record
        if self.lane_id != 0:
            element.append(self.links.get_element())
            for w in sorted(self.widths, key=lambda x: x.soffset):
                ET.SubElement(element, &#34;width&#34;, attrib=w.get_attributes())
        # use polynomial dict for laneOffset in case of center lane (only if values provided)
        # removed, should not be here..
        # elif any([self.a,self.b,self.c,self.d]):
        #     polynomialdict[&#39;s&#39;] = polynomialdict.pop(&#39;sOffset&#39;)
        #     ET.SubElement(element,&#39;laneOffset&#39;,attrib=polynomialdict)

        if self.roadmark:
            for r in sorted(self.roadmark, key=lambda x: x.soffset):
                element.append(r.get_element())

        for height in self.heights:
            ET.SubElement(element, &#34;height&#34;, attrib=height)

        return element


class RoadMark:
    &#34;&#34;&#34;creates a RoadMark of opendrive

    Parameters
    ----------
        marking_type (RoadMarkType): the type of marking

        width (float): with of the line

        length (float): length of the line
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Attributes
    ----------
        marking_type (str): the type of marking

        width (float): with of the line

        length (float): length of the line
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

        add_roadmark(roadmark)
            adds a new roadmark to the lane

    &#34;&#34;&#34;

    def __init__(
        self,
        marking_type,
        width=None,
        length=None,
        space=None,
        toffset=None,
        soffset=0,
        rule=None,
        color=RoadMarkColor.standard,
        marking_weight=RoadMarkWeight.standard,
        height=0.02,
        laneChange=None,
    ):
        &#34;&#34;&#34;initializes the RoadMark

        Parameters
        ----------
            marking_type (str): the type of marking

            width (float): width of the marking / line
                Default: None
            length (float): length of the visible, marked part of the line (used for broken lines)
                Default: None
            space (float): length of the invisible, unmarked part of the line (used for broken lines)
                Default: None
            toffset (float): offset in t
                Default: None
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)
                Default: None
            color (RoadMarkColor): color of marking
                Default: &#39;standard&#39;
            marking_weight (str): the weight of marking
                Default: standard
            height (float): thickness of marking
                Default: 0.02
            laneChange (LaneChange): indicates direction in which lane change is allowed
                Default: none

        &#34;&#34;&#34;
        # required arguments - must be provided by user
        self.marking_type = marking_type

        # required arguments - must be provided by user or taken from defaults
        self.marking_weight = marking_weight
        self.color = color
        self.soffset = soffset
        self.height = height
        self.laneChange = laneChange

        # optional arguments - roadmark is valid without them being defined
        self.width = width
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule

        # TODO: there may be more line child elements per roadmark, which is currently unsupported
        self._line = []
        # check if arguments were passed that require line child element
        if any([length, space, toffset, rule]):
            # set defaults in case no values were provided
            # values for broken lines
            if marking_type == RoadMarkType.broken:
                self.length = length or 3
                self.space = space or 3
            # values for solid lines
            elif marking_type == RoadMarkType.solid:
                self.length = length or 3
                self.space = space or 0
            # create empty line if arguments are missing
            else:
                self.length = length or 0
                self.space = length or 0
                print(
                    &#34;No defaults for arguments &#39;space&#39; and &#39;length&#39; for roadmark type&#34;,
                    enum2str(marking_type),
                    &#34;available and no values were passed. Creating an empty roadmark.&#34;,
                )
            # set remaining defaults
            self.width = width or 0.2
            self.toffset = toffset or 0
            self.rule = rule or MarkRule.none
            self._line.append(
                RoadLine(
                    self.width,
                    self.length,
                    self.space,
                    self.toffset,
                    0,
                    self.rule,
                    self.color,
                )
            )

    def add_specific_road_line(self, line):
        &#34;&#34;&#34;function to add your own roadline to the RoadMark, to use for multi line type of roadmarks,

        Parameters
        ----------
            line (RoadLine): the roadline to add

        &#34;&#34;&#34;
        self._line.append(line)
        return self

    def __eq__(self, other):
        if isinstance(other, RoadMark):
            if (
                self._line == other._line
                and self.get_attributes() == other.get_attributes()
                and self.marking_type == other.marking_type
            ):
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RoadMark as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        retdict[&#34;type&#34;] = enum2str(self.marking_type)
        retdict[&#34;weight&#34;] = enum2str(self.marking_weight)
        retdict[&#34;color&#34;] = enum2str(self.color)
        retdict[&#34;height&#34;] = str(self.height)
        if self.width is not None:
            retdict[&#34;width&#34;] = str(self.width)
        if self.laneChange is not None:
            retdict[&#34;laneChange&#34;] = enum2str(self.laneChange)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RoadMark&#34;&#34;&#34;
        element = ET.Element(&#34;roadMark&#34;, attrib=self.get_attributes())
        if self._line:
            typeelement = ET.SubElement(
                element,
                &#34;type&#34;,
                attrib={&#34;name&#34;: enum2str(self.marking_type), &#34;width&#34;: str(self.width)},
            )
            for l in self._line:
                typeelement.append(l.get_element())
        return element


class RoadLine:
    &#34;&#34;&#34;creates a Line type of to be used in roadmark

    Parameters
    ----------
        width (float): with of the line
            Default: 0
        length (float): length of the line
            Default: 0
        space (float): length of space between (broken) lines
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Attributes
    ----------
        length (float): length of the line

        space (float): length of space between (broken) lines

        toffset (float): offset in t

        soffset (float): offset in s

        rule (MarkRule): mark rule

        width (float): with of the line

        color (RoadMarkColor): color of line

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;

    # TODO: check this for 1.5
    def __init__(
        self, width=0, length=0, space=0, toffset=0, soffset=0, rule=None, color=None
    ):
        &#34;&#34;&#34;initalizes the RoadLine

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)


        &#34;&#34;&#34;
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color

    def __eq__(self, other):
        if isinstance(other, RoadLine):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;space&#34;] = str(self.space)
        retdict[&#34;tOffset&#34;] = str(self.toffset)
        retdict[&#34;width&#34;] = str(self.width)
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        # if self.color:
        # retdict[&#39;color&#39;] = enum2str(self.color)
        if self.rule:
            retdict[&#34;rule&#34;] = enum2str(self.rule)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xodr.lane.Lane"><code class="flex name class">
<span>class <span class="ident">Lane</span></span>
<span>(</span><span>lane_type=LaneType.driving, a=0, b=0, c=0, d=0, soffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a Lane of opendrive</p>
<p>the inputs are on the following format:
f(s) = a + b<em>s + c</em>s^2 + d*s^3</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane_type (LaneType): type of lane
    Default: LaneType.driving

a (float): a coefficient
    Default: 0

b (float): b coefficient
    Default: 0

c (float): c coefficient
    Default: 0

d (float): d coefficient
    Default: 0

soffset (float): soffset of lane
    Default: 0
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lane_id (int): id of the lane (automatically assigned by LaneSection)

lane_type (LaneType): type of lane

a (float): a coefficient

b (float): b coefficient

c (float): c coefficient

d (float): d coefficient

soffset (float): soffset of lane

roadmark (RoadMark): roadmarks related to the lane

links (_Links): Lane links to the lane
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of class

add_roadmark(roadmark)
    adds a new roadmark to the lane

add_lane_width(a, b, c, d, soffset)
    adds an additional width element to the lane
</code></pre>
<p>initalizes the Lane</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane_type (LaneType): type of lane
    Default: LaneType.driving

a (float): a polynomial coefficient for width (left/right) or laneoffset (center)
    Default: 0

b (float): b polynomial coefficient for width (left/right) or laneoffset (center)
    Default: 0

c (float): c polynomial coefficient for width (left/right) or laneoffset (center)
    Default: 0

d (float): d polynomial coefficient for width (left/right) or laneoffset (center)
    Default: 0

soffset (float): soffset of lane renamed to s in case of centerlane
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lane:
    &#34;&#34;&#34;creates a Lane of opendrive

    the inputs are on the following format:
        f(s) = a + b*s + c*s^2 + d*s^3

    Parameters
    ----------

        lane_type (LaneType): type of lane
            Default: LaneType.driving

        a (float): a coefficient
            Default: 0

        b (float): b coefficient
            Default: 0

        c (float): c coefficient
            Default: 0

        d (float): d coefficient
            Default: 0

        soffset (float): soffset of lane
            Default: 0


    Attributes
    ----------
        lane_id (int): id of the lane (automatically assigned by LaneSection)

        lane_type (LaneType): type of lane

        a (float): a coefficient

        b (float): b coefficient

        c (float): c coefficient

        d (float): d coefficient

        soffset (float): soffset of lane

        roadmark (RoadMark): roadmarks related to the lane

        links (_Links): Lane links to the lane

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of class

        add_roadmark(roadmark)
            adds a new roadmark to the lane

        add_lane_width(a, b, c, d, soffset)
            adds an additional width element to the lane
    &#34;&#34;&#34;

    def __init__(self, lane_type=LaneType.driving, a=0, b=0, c=0, d=0, soffset=0):
        &#34;&#34;&#34;initalizes the Lane

        Parameters
        ----------

            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            b (float): b polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            c (float): c polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            d (float): d polynomial coefficient for width (left/right) or laneoffset (center)
                Default: 0

            soffset (float): soffset of lane renamed to s in case of centerlane
                Default: 0

        &#34;&#34;&#34;
        self.lane_id = None
        self.lane_type = lane_type
        self.widths = []
        self.add_lane_width(a, b, c, d, soffset)

        self.soffset = soffset
        # TODO: enable multiple widths records per lane (only then soffset really makes sense! ASAM requires one width record to have sOffset=0)
        self.heights = (
            []
        )  # height entries to elevate the lane independent from the road elevation
        self.roadmark = []
        self.links = _Links()

    def __eq__(self, other):
        if isinstance(other, Lane):
            if (
                self.links == other.links
                and self.get_attributes() == other.get_attributes()
                and self.widths == other.widths
                and self.heights == other.heights
                and self.roadmark == other.roadmark
            ):
                return True
        return False

        # TODO: add more features to add for lane

    def add_lane_width(self, a=0, b=0, c=0, d=0, soffset=0):
        &#34;&#34;&#34;adds an additional width element to the lane

        Parameters
        ----------
            a (float): a polynomial coefficient for width
                Default: 0

            b (float): b polynomial coefficient for width
                Default: 0

            c (float): c polynomial coefficient for width
                Default: 0

            d (float): d polynomial coefficient for width
                Default: 0

            soffset (float): soffset of lane renamed to s in case of centerlane
                Default: 0

        &#34;&#34;&#34;
        self.widths.append(_poly3struct(a, b, c, d, soffset))

    def get_width(self, s):
        &#34;&#34;&#34;function that calculates the width of a lane at a point s

        Note: no check that s is on the road can be made, that has to be taken care of by the user

        Parameters
        ----------
            s (float): the point where the width is wished

        Returns
        -------
            width (float): the width at point s
        &#34;&#34;&#34;
        index_to_calc = 0
        for i in range(len(self.widths)):
            if s &gt;= self.widths[i].soffset:
                index_to_calc = i
            else:
                break
        return self.widths[index_to_calc].get_width(s)

    def add_link(self, link_type, id):
        &#34;&#34;&#34;adds a link to the lane section

        Parameters
        ----------
            link_type (str): type of link, successor or predecessor

            id (str/id): id of the linked lane
        &#34;&#34;&#34;
        self.links.add_link(_Link(link_type, str(id)))
        return self

    def _set_lane_id(self, lane_id):
        &#34;&#34;&#34;set the lane id of the lane and set lane type to &#39;none&#39; in case of centerlane&#34;&#34;&#34;
        self.lane_id = lane_id
        if self.lane_id == 0:
            self.lane_type = LaneType.none

    def add_roadmark(self, roadmark):
        &#34;&#34;&#34;add_roadmark adds a roadmark to the lane

        Parameters
        ----------
            roadmark (RoadMark): roadmark of the lane

        &#34;&#34;&#34;
        if roadmark is not None:
            self.roadmark.append(roadmark)
        return self

    def add_height(self, inner, outer=None, soffset=0):
        &#34;&#34;&#34;add_height adds a height entry to the lane to elevate it independent from the road elevation

        Parameters
        ----------
            inner (float): inner height

            outer (float): outer height (if not provided, inner height is used)
                Default: None

            s_offset (float): s offset of the height record
                Default: 0

        &#34;&#34;&#34;
        heightdict = {}
        heightdict[&#34;inner&#34;] = str(inner)
        if outer is not None:
            heightdict[&#34;outer&#34;] = str(outer)
        else:
            heightdict[&#34;outer&#34;] = str(inner)
        heightdict[&#34;sOffset&#34;] = str(soffset)

        self.heights.append(heightdict)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        if self.lane_id == None:
            raise ValueError(&#34;lane id is not set correctly.&#34;)
        retdict[&#34;id&#34;] = str(self.lane_id)
        retdict[&#34;type&#34;] = enum2str(self.lane_type)
        retdict[&#34;level&#34;] = &#34;false&#34;
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;lane&#34;, attrib=self.get_attributes())

        # according to standard if lane is centerlane it should
        # not have a width record and omit the link record
        if self.lane_id != 0:
            element.append(self.links.get_element())
            for w in sorted(self.widths, key=lambda x: x.soffset):
                ET.SubElement(element, &#34;width&#34;, attrib=w.get_attributes())
        # use polynomial dict for laneOffset in case of center lane (only if values provided)
        # removed, should not be here..
        # elif any([self.a,self.b,self.c,self.d]):
        #     polynomialdict[&#39;s&#39;] = polynomialdict.pop(&#39;sOffset&#39;)
        #     ET.SubElement(element,&#39;laneOffset&#39;,attrib=polynomialdict)

        if self.roadmark:
            for r in sorted(self.roadmark, key=lambda x: x.soffset):
                element.append(r.get_element())

        for height in self.heights:
            ET.SubElement(element, &#34;height&#34;, attrib=height)

        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.Lane.add_height"><code class="name flex">
<span>def <span class="ident">add_height</span></span>(<span>self, inner, outer=None, soffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>add_height adds a height entry to the lane to elevate it independent from the road elevation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>inner (float): inner height

outer (float): outer height (if not provided, inner height is used)
    Default: None

s_offset (float): s offset of the height record
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_height(self, inner, outer=None, soffset=0):
    &#34;&#34;&#34;add_height adds a height entry to the lane to elevate it independent from the road elevation

    Parameters
    ----------
        inner (float): inner height

        outer (float): outer height (if not provided, inner height is used)
            Default: None

        s_offset (float): s offset of the height record
            Default: 0

    &#34;&#34;&#34;
    heightdict = {}
    heightdict[&#34;inner&#34;] = str(inner)
    if outer is not None:
        heightdict[&#34;outer&#34;] = str(outer)
    else:
        heightdict[&#34;outer&#34;] = str(inner)
    heightdict[&#34;sOffset&#34;] = str(soffset)

    self.heights.append(heightdict)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_lane_width"><code class="name flex">
<span>def <span class="ident">add_lane_width</span></span>(<span>self, a=0, b=0, c=0, d=0, soffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>adds an additional width element to the lane</p>
<h2 id="parameters">Parameters</h2>
<pre><code>a (float): a polynomial coefficient for width
    Default: 0

b (float): b polynomial coefficient for width
    Default: 0

c (float): c polynomial coefficient for width
    Default: 0

d (float): d polynomial coefficient for width
    Default: 0

soffset (float): soffset of lane renamed to s in case of centerlane
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lane_width(self, a=0, b=0, c=0, d=0, soffset=0):
    &#34;&#34;&#34;adds an additional width element to the lane

    Parameters
    ----------
        a (float): a polynomial coefficient for width
            Default: 0

        b (float): b polynomial coefficient for width
            Default: 0

        c (float): c polynomial coefficient for width
            Default: 0

        d (float): d polynomial coefficient for width
            Default: 0

        soffset (float): soffset of lane renamed to s in case of centerlane
            Default: 0

    &#34;&#34;&#34;
    self.widths.append(_poly3struct(a, b, c, d, soffset))</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self, link_type, id)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a link to the lane section</p>
<h2 id="parameters">Parameters</h2>
<pre><code>link_type (str): type of link, successor or predecessor

id (str/id): id of the linked lane
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self, link_type, id):
    &#34;&#34;&#34;adds a link to the lane section

    Parameters
    ----------
        link_type (str): type of link, successor or predecessor

        id (str/id): id of the linked lane
    &#34;&#34;&#34;
    self.links.add_link(_Link(link_type, str(id)))
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.add_roadmark"><code class="name flex">
<span>def <span class="ident">add_roadmark</span></span>(<span>self, roadmark)</span>
</code></dt>
<dd>
<div class="desc"><p>add_roadmark adds a roadmark to the lane</p>
<h2 id="parameters">Parameters</h2>
<pre><code>roadmark (RoadMark): roadmark of the lane
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_roadmark(self, roadmark):
    &#34;&#34;&#34;add_roadmark adds a roadmark to the lane

    Parameters
    ----------
        roadmark (RoadMark): roadmark of the lane

    &#34;&#34;&#34;
    if roadmark is not None:
        self.roadmark.append(roadmark)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
    retdict = {}
    if self.lane_id == None:
        raise ValueError(&#34;lane id is not set correctly.&#34;)
    retdict[&#34;id&#34;] = str(self.lane_id)
    retdict[&#34;type&#34;] = enum2str(self.lane_type)
    retdict[&#34;level&#34;] = &#34;false&#34;
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
    element = ET.Element(&#34;lane&#34;, attrib=self.get_attributes())

    # according to standard if lane is centerlane it should
    # not have a width record and omit the link record
    if self.lane_id != 0:
        element.append(self.links.get_element())
        for w in sorted(self.widths, key=lambda x: x.soffset):
            ET.SubElement(element, &#34;width&#34;, attrib=w.get_attributes())
    # use polynomial dict for laneOffset in case of center lane (only if values provided)
    # removed, should not be here..
    # elif any([self.a,self.b,self.c,self.d]):
    #     polynomialdict[&#39;s&#39;] = polynomialdict.pop(&#39;sOffset&#39;)
    #     ET.SubElement(element,&#39;laneOffset&#39;,attrib=polynomialdict)

    if self.roadmark:
        for r in sorted(self.roadmark, key=lambda x: x.soffset):
            element.append(r.get_element())

    for height in self.heights:
        ET.SubElement(element, &#34;height&#34;, attrib=height)

    return element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lane.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>function that calculates the width of a lane at a point s</p>
<p>Note: no check that s is on the road can be made, that has to be taken care of by the user</p>
<h2 id="parameters">Parameters</h2>
<pre><code>s (float): the point where the width is wished
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>width (float): the width at point s
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self, s):
    &#34;&#34;&#34;function that calculates the width of a lane at a point s

    Note: no check that s is on the road can be made, that has to be taken care of by the user

    Parameters
    ----------
        s (float): the point where the width is wished

    Returns
    -------
        width (float): the width at point s
    &#34;&#34;&#34;
    index_to_calc = 0
    for i in range(len(self.widths)):
        if s &gt;= self.widths[i].soffset:
            index_to_calc = i
        else:
            break
    return self.widths[index_to_calc].get_width(s)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneOffset"><code class="flex name class">
<span>class <span class="ident">LaneOffset</span></span>
<span>(</span><span>s=0, a=0, b=0, c=0, d=0)</span>
</code></dt>
<dd>
<div class="desc"><p>the LaneOffset class defines an overall lateral offset along the road, described as a third degree polynomial</p>
<h2 id="parameters">Parameters</h2>
<pre><code>s (float): s start coordinate of the elevation

a (float): a coefficient of the polynomial

b (float): b coefficient of the polynomial

c (float): c coefficient of the polynomial

d (float): d coefficient of the polynomial
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>s (float): s start coordinate of the elevation

a (float): a coefficient of the polynomial

b (float): b coefficient of the polynomial

c (float): c coefficient of the polynomial

d (float): d coefficient of the polynomial
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns the attributes of the class
</code></pre>
<p>initalize the LaneOffset class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>s (float): s start coordinate of the LaneOffset

a (float): a coefficient of the polynomial

b (float): b coefficient of the polynomial

c (float): c coefficient of the polynomial

d (float): d coefficient of the polynomial
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaneOffset:
    &#34;&#34;&#34;the LaneOffset class defines an overall lateral offset along the road, described as a third degree polynomial

    Parameters
    ----------
        s (float): s start coordinate of the elevation

        a (float): a coefficient of the polynomial

        b (float): b coefficient of the polynomial

        c (float): c coefficient of the polynomial

        d (float): d coefficient of the polynomial

    Attributes
    ----------
        s (float): s start coordinate of the elevation

        a (float): a coefficient of the polynomial

        b (float): b coefficient of the polynomial

        c (float): c coefficient of the polynomial

        d (float): d coefficient of the polynomial

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns the attributes of the class

    &#34;&#34;&#34;

    def __init__(self, s=0, a=0, b=0, c=0, d=0):
        &#34;&#34;&#34;initalize the LaneOffset class

        Parameters
        ----------
            s (float): s start coordinate of the LaneOffset

            a (float): a coefficient of the polynomial

            b (float): b coefficient of the polynomial

            c (float): c coefficient of the polynomial

            d (float): d coefficient of the polynomial

        &#34;&#34;&#34;
        self.s = s
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    def __eq__(self, other):
        if isinstance(other, LaneOffset):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffset&#34;&#34;&#34;

        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;a&#34;] = str(self.a)
        retdict[&#34;b&#34;] = str(self.b)
        retdict[&#34;c&#34;] = str(self.c)
        retdict[&#34;d&#34;] = str(self.d)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffset&#34;&#34;&#34;
        element = ET.Element(&#34;laneOffset&#34;, attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.LaneOffset.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LaneOffset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LaneOffset&#34;&#34;&#34;

    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;a&#34;] = str(self.a)
    retdict[&#34;b&#34;] = str(self.b)
    retdict[&#34;c&#34;] = str(self.c)
    retdict[&#34;d&#34;] = str(self.d)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneOffset.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LaneOffset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LaneOffset&#34;&#34;&#34;
    element = ET.Element(&#34;laneOffset&#34;, attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection"><code class="flex name class">
<span>class <span class="ident">LaneSection</span></span>
<span>(</span><span>s, centerlane)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the LaneSection element of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road

leftlanes (list of Lane): the lanes left to the center

rightlanes (list of Lane): the lanes right to the center
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of class

add_left_lane(Lane)
    adds a new lane to the left

add_right_lane(Lane)
    adds a new lane to the right
</code></pre>
<p>initalize the LaneSection</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaneSection:
    &#34;&#34;&#34;Creates the LaneSection element of opendrive

    Parameters
    ----------
        s (float): start of lanesection

        centerlane (Lane): the centerline of the road

    Attributes
    ----------
        s (float): start of lanesection

        centerlane (Lane): the centerline of the road

        leftlanes (list of Lane): the lanes left to the center

        rightlanes (list of Lane): the lanes right to the center

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of class

        add_left_lane(Lane)
            adds a new lane to the left

        add_right_lane(Lane)
            adds a new lane to the right
    &#34;&#34;&#34;

    def __init__(self, s, centerlane):
        &#34;&#34;&#34;initalize the LaneSection

        Parameters
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road
        &#34;&#34;&#34;
        self.s = s
        self.centerlane = centerlane
        self.centerlane._set_lane_id(0)
        self.leftlanes = []
        self.rightlanes = []
        self._left_id = 1
        self._right_id = -1

    def __eq__(self, other):
        if isinstance(other, LaneSection):
            if (
                self.get_attributes() == other.get_attributes()
                and self.centerlane == other.centerlane
                and self.leftlanes == other.leftlanes
                and self.rightlanes == other.rightlanes
            ):
                return True
        return False

    def add_left_lane(self, lane):
        &#34;&#34;&#34;adds a lane to the left of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._left_id)
        self._left_id += 1
        self.leftlanes.append(lane)
        return self

    def add_right_lane(self, lane):
        &#34;&#34;&#34;adds a lane to the right of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._right_id)
        self._right_id -= 1
        self.rightlanes.append(lane)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;laneSection&#34;, attrib=self.get_attributes())

        if self.leftlanes:
            left = ET.SubElement(element, &#34;left&#34;)
            for l in reversed(self.leftlanes):
                left.append(l.get_element())

        center = ET.SubElement(element, &#34;center&#34;)
        center.append(self.centerlane.get_element())

        if self.rightlanes:
            right = ET.SubElement(element, &#34;right&#34;)
            for l in self.rightlanes:
                right.append(l.get_element())

        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.LaneSection.add_left_lane"><code class="name flex">
<span>def <span class="ident">add_left_lane</span></span>(<span>self, lane)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a lane to the left of the center, add from center outwards</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (Lane): the lane to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_left_lane(self, lane):
    &#34;&#34;&#34;adds a lane to the left of the center, add from center outwards

    Parameters
    ----------
        lane (Lane): the lane to add
    &#34;&#34;&#34;
    lane._set_lane_id(self._left_id)
    self._left_id += 1
    self.leftlanes.append(lane)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.add_right_lane"><code class="name flex">
<span>def <span class="ident">add_right_lane</span></span>(<span>self, lane)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a lane to the right of the center, add from center outwards</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (Lane): the lane to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_right_lane(self, lane):
    &#34;&#34;&#34;adds a lane to the right of the center, add from center outwards

    Parameters
    ----------
        lane (Lane): the lane to add
    &#34;&#34;&#34;
    lane._set_lane_id(self._right_id)
    self._right_id -= 1
    self.rightlanes.append(lane)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.LaneSection.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
    element = ET.Element(&#34;laneSection&#34;, attrib=self.get_attributes())

    if self.leftlanes:
        left = ET.SubElement(element, &#34;left&#34;)
        for l in reversed(self.leftlanes):
            left.append(l.get_element())

    center = ET.SubElement(element, &#34;center&#34;)
    center.append(self.centerlane.get_element())

    if self.rightlanes:
        right = ET.SubElement(element, &#34;right&#34;)
        for l in self.rightlanes:
            right.append(l.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes"><code class="flex name class">
<span>class <span class="ident">Lanes</span></span>
</code></dt>
<dd>
<div class="desc"><p>creates the Lanes element of opendrive</p>
<h2 id="attributes">Attributes</h2>
<pre><code>lane_sections (list of LaneSection): a list of all lanesections
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

add_lanesection(lanesection)
    adds a lane section to Lanes

add_laneoffset(laneoffset)
    adds a lane offset to Lanes
</code></pre>
<p>initalize Lanes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lanes:
    &#34;&#34;&#34;creates the Lanes element of opendrive


    Attributes
    ----------
        lane_sections (list of LaneSection): a list of all lanesections

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        add_lanesection(lanesection)
            adds a lane section to Lanes

        add_laneoffset(laneoffset)
            adds a lane offset to Lanes
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;initalize Lanes&#34;&#34;&#34;
        self.lanesections = []
        self.laneoffsets = []

    def __eq__(self, other):
        if isinstance(other, Lanes):
            if (
                self.laneoffsets == other.laneoffsets
                and self.lanesections == other.lanesections
            ):
                return True
        return False

    def add_lanesection(self, lanesection, lanelinks=None):
        &#34;&#34;&#34;creates the Lanes element of opendrive

        Parameters
        ----------
            lanesection (LaneSection): a LaneSection to add

            lanelink (LaneLinker): (optional) a LaneLink to add

        &#34;&#34;&#34;
        # add links to the lanes
        if lanelinks:
            # loop over all links
            if not isinstance(lanelinks, list):
                lanelinks = [lanelinks]
            for lanelink in lanelinks:
                for link in lanelink.links:
                    # check if link already added
                    if not link.used:
                        link.predecessor.add_link(&#34;successor&#34;, link.successor.lane_id)
                        link.successor.add_link(&#34;predecessor&#34;, link.predecessor.lane_id)
                        link.used = True

        self.lanesections.append(lanesection)
        return self

    def add_laneoffset(self, laneoffset):
        &#34;&#34;&#34;adds a lane offset to Lanes

        Parameters
        ----------
            laneoffset (LaneOffset): a LaneOffset to add
        &#34;&#34;&#34;
        if not isinstance(laneoffset, LaneOffset):
            raise TypeError(
                &#34;add_laneoffset requires a LaneOffset as input, not &#34;
                + str(type(laneoffset))
            )
        self.laneoffsets.append(laneoffset)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of Lanes&#34;&#34;&#34;
        element = ET.Element(&#34;lanes&#34;)
        for l in self.lanesections:
            element.append(l.get_element())
        for l in self.laneoffsets:
            element.append(l.get_element())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.Lanes.add_laneoffset"><code class="name flex">
<span>def <span class="ident">add_laneoffset</span></span>(<span>self, laneoffset)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a lane offset to Lanes</p>
<h2 id="parameters">Parameters</h2>
<pre><code>laneoffset (LaneOffset): a LaneOffset to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_laneoffset(self, laneoffset):
    &#34;&#34;&#34;adds a lane offset to Lanes

    Parameters
    ----------
        laneoffset (LaneOffset): a LaneOffset to add
    &#34;&#34;&#34;
    if not isinstance(laneoffset, LaneOffset):
        raise TypeError(
            &#34;add_laneoffset requires a LaneOffset as input, not &#34;
            + str(type(laneoffset))
        )
    self.laneoffsets.append(laneoffset)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.add_lanesection"><code class="name flex">
<span>def <span class="ident">add_lanesection</span></span>(<span>self, lanesection, lanelinks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>creates the Lanes element of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lanesection (LaneSection): a LaneSection to add

lanelink (LaneLinker): (optional) a LaneLink to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lanesection(self, lanesection, lanelinks=None):
    &#34;&#34;&#34;creates the Lanes element of opendrive

    Parameters
    ----------
        lanesection (LaneSection): a LaneSection to add

        lanelink (LaneLinker): (optional) a LaneLink to add

    &#34;&#34;&#34;
    # add links to the lanes
    if lanelinks:
        # loop over all links
        if not isinstance(lanelinks, list):
            lanelinks = [lanelinks]
        for lanelink in lanelinks:
            for link in lanelink.links:
                # check if link already added
                if not link.used:
                    link.predecessor.add_link(&#34;successor&#34;, link.successor.lane_id)
                    link.successor.add_link(&#34;predecessor&#34;, link.predecessor.lane_id)
                    link.used = True

    self.lanesections.append(lanesection)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.Lanes.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of Lanes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of Lanes&#34;&#34;&#34;
    element = ET.Element(&#34;lanes&#34;)
    for l in self.lanesections:
        element.append(l.get_element())
    for l in self.laneoffsets:
        element.append(l.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine"><code class="flex name class">
<span>class <span class="ident">RoadLine</span></span>
<span>(</span><span>width=0, length=0, space=0, toffset=0, soffset=0, rule=None, color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a Line type of to be used in roadmark</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): with of the line
    Default: 0
length (float): length of the line
    Default: 0
space (float): length of space between (broken) lines
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>length (float): length of the line

space (float): length of space between (broken) lines

toffset (float): offset in t

soffset (float): offset in s

rule (MarkRule): mark rule

width (float): with of the line

color (RoadMarkColor): color of line
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre>
<p>initalizes the RoadLine</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): with of the line
    Default: 0
length (float): length of the line
    Default: 0
space (float): length of space between (broken) lines
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadLine:
    &#34;&#34;&#34;creates a Line type of to be used in roadmark

    Parameters
    ----------
        width (float): with of the line
            Default: 0
        length (float): length of the line
            Default: 0
        space (float): length of space between (broken) lines
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Attributes
    ----------
        length (float): length of the line

        space (float): length of space between (broken) lines

        toffset (float): offset in t

        soffset (float): offset in s

        rule (MarkRule): mark rule

        width (float): with of the line

        color (RoadMarkColor): color of line

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;

    # TODO: check this for 1.5
    def __init__(
        self, width=0, length=0, space=0, toffset=0, soffset=0, rule=None, color=None
    ):
        &#34;&#34;&#34;initalizes the RoadLine

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)


        &#34;&#34;&#34;
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color

    def __eq__(self, other):
        if isinstance(other, RoadLine):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;space&#34;] = str(self.space)
        retdict[&#34;tOffset&#34;] = str(self.toffset)
        retdict[&#34;width&#34;] = str(self.width)
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        # if self.color:
        # retdict[&#39;color&#39;] = enum2str(self.color)
        if self.rule:
            retdict[&#34;rule&#34;] = enum2str(self.rule)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
        element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.RoadLine.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Lane as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;length&#34;] = str(self.length)
    retdict[&#34;space&#34;] = str(self.space)
    retdict[&#34;tOffset&#34;] = str(self.toffset)
    retdict[&#34;width&#34;] = str(self.width)
    retdict[&#34;sOffset&#34;] = str(self.soffset)
    # if self.color:
    # retdict[&#39;color&#39;] = enum2str(self.color)
    if self.rule:
        retdict[&#34;rule&#34;] = enum2str(self.rule)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadLine.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the WorldPostion&#34;&#34;&#34;
    element = ET.Element(&#34;line&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark"><code class="flex name class">
<span>class <span class="ident">RoadMark</span></span>
<span>(</span><span>marking_type, width=None, length=None, space=None, toffset=None, soffset=0, rule=None, color=RoadMarkColor.standard, marking_weight=RoadMarkWeight.standard, height=0.02, laneChange=None)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a RoadMark of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>marking_type (RoadMarkType): the type of marking

width (float): with of the line

length (float): length of the line
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>marking_type (str): the type of marking

width (float): with of the line

length (float): length of the line
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of FileHeader

add_roadmark(roadmark)
    adds a new roadmark to the lane
</code></pre>
<p>initializes the RoadMark</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>marking_type (str): the type of marking

width (float): width of the marking / line
    Default: None
length (float): length of the visible, marked part of the line (used for broken lines)
    Default: None
space (float): length of the invisible, unmarked part of the line (used for broken lines)
    Default: None
toffset (float): offset in t
    Default: None
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)
    Default: None
color (RoadMarkColor): color of marking
    Default: 'standard'
marking_weight (str): the weight of marking
    Default: standard
height (float): thickness of marking
    Default: 0.02
laneChange (LaneChange): indicates direction in which lane change is allowed
    Default: none
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadMark:
    &#34;&#34;&#34;creates a RoadMark of opendrive

    Parameters
    ----------
        marking_type (RoadMarkType): the type of marking

        width (float): with of the line

        length (float): length of the line
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Attributes
    ----------
        marking_type (str): the type of marking

        width (float): with of the line

        length (float): length of the line
            Default: 0
        toffset (float): offset in t
            Default: 0
        soffset (float): offset in s
            Default: 0
        rule (MarkRule): mark rule (optional)

        color (RoadMarkColor): color of line (optional)

    Methods
    -------
        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

        add_roadmark(roadmark)
            adds a new roadmark to the lane

    &#34;&#34;&#34;

    def __init__(
        self,
        marking_type,
        width=None,
        length=None,
        space=None,
        toffset=None,
        soffset=0,
        rule=None,
        color=RoadMarkColor.standard,
        marking_weight=RoadMarkWeight.standard,
        height=0.02,
        laneChange=None,
    ):
        &#34;&#34;&#34;initializes the RoadMark

        Parameters
        ----------
            marking_type (str): the type of marking

            width (float): width of the marking / line
                Default: None
            length (float): length of the visible, marked part of the line (used for broken lines)
                Default: None
            space (float): length of the invisible, unmarked part of the line (used for broken lines)
                Default: None
            toffset (float): offset in t
                Default: None
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)
                Default: None
            color (RoadMarkColor): color of marking
                Default: &#39;standard&#39;
            marking_weight (str): the weight of marking
                Default: standard
            height (float): thickness of marking
                Default: 0.02
            laneChange (LaneChange): indicates direction in which lane change is allowed
                Default: none

        &#34;&#34;&#34;
        # required arguments - must be provided by user
        self.marking_type = marking_type

        # required arguments - must be provided by user or taken from defaults
        self.marking_weight = marking_weight
        self.color = color
        self.soffset = soffset
        self.height = height
        self.laneChange = laneChange

        # optional arguments - roadmark is valid without them being defined
        self.width = width
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule

        # TODO: there may be more line child elements per roadmark, which is currently unsupported
        self._line = []
        # check if arguments were passed that require line child element
        if any([length, space, toffset, rule]):
            # set defaults in case no values were provided
            # values for broken lines
            if marking_type == RoadMarkType.broken:
                self.length = length or 3
                self.space = space or 3
            # values for solid lines
            elif marking_type == RoadMarkType.solid:
                self.length = length or 3
                self.space = space or 0
            # create empty line if arguments are missing
            else:
                self.length = length or 0
                self.space = length or 0
                print(
                    &#34;No defaults for arguments &#39;space&#39; and &#39;length&#39; for roadmark type&#34;,
                    enum2str(marking_type),
                    &#34;available and no values were passed. Creating an empty roadmark.&#34;,
                )
            # set remaining defaults
            self.width = width or 0.2
            self.toffset = toffset or 0
            self.rule = rule or MarkRule.none
            self._line.append(
                RoadLine(
                    self.width,
                    self.length,
                    self.space,
                    self.toffset,
                    0,
                    self.rule,
                    self.color,
                )
            )

    def add_specific_road_line(self, line):
        &#34;&#34;&#34;function to add your own roadline to the RoadMark, to use for multi line type of roadmarks,

        Parameters
        ----------
            line (RoadLine): the roadline to add

        &#34;&#34;&#34;
        self._line.append(line)
        return self

    def __eq__(self, other):
        if isinstance(other, RoadMark):
            if (
                self._line == other._line
                and self.get_attributes() == other.get_attributes()
                and self.marking_type == other.marking_type
            ):
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RoadMark as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;sOffset&#34;] = str(self.soffset)
        retdict[&#34;type&#34;] = enum2str(self.marking_type)
        retdict[&#34;weight&#34;] = enum2str(self.marking_weight)
        retdict[&#34;color&#34;] = enum2str(self.color)
        retdict[&#34;height&#34;] = str(self.height)
        if self.width is not None:
            retdict[&#34;width&#34;] = str(self.width)
        if self.laneChange is not None:
            retdict[&#34;laneChange&#34;] = enum2str(self.laneChange)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RoadMark&#34;&#34;&#34;
        element = ET.Element(&#34;roadMark&#34;, attrib=self.get_attributes())
        if self._line:
            typeelement = ET.SubElement(
                element,
                &#34;type&#34;,
                attrib={&#34;name&#34;: enum2str(self.marking_type), &#34;width&#34;: str(self.width)},
            )
            for l in self._line:
                typeelement.append(l.get_element())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.lane.RoadMark.add_specific_road_line"><code class="name flex">
<span>def <span class="ident">add_specific_road_line</span></span>(<span>self, line)</span>
</code></dt>
<dd>
<div class="desc"><p>function to add your own roadline to the RoadMark, to use for multi line type of roadmarks,</p>
<h2 id="parameters">Parameters</h2>
<pre><code>line (RoadLine): the roadline to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_specific_road_line(self, line):
    &#34;&#34;&#34;function to add your own roadline to the RoadMark, to use for multi line type of roadmarks,

    Parameters
    ----------
        line (RoadLine): the roadline to add

    &#34;&#34;&#34;
    self._line.append(line)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RoadMark as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RoadMark as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;sOffset&#34;] = str(self.soffset)
    retdict[&#34;type&#34;] = enum2str(self.marking_type)
    retdict[&#34;weight&#34;] = enum2str(self.marking_weight)
    retdict[&#34;color&#34;] = enum2str(self.color)
    retdict[&#34;height&#34;] = str(self.height)
    if self.width is not None:
        retdict[&#34;width&#34;] = str(self.width)
    if self.laneChange is not None:
        retdict[&#34;laneChange&#34;] = enum2str(self.laneChange)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.lane.RoadMark.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RoadMark</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RoadMark&#34;&#34;&#34;
    element = ET.Element(&#34;roadMark&#34;, attrib=self.get_attributes())
    if self._line:
        typeelement = ET.SubElement(
            element,
            &#34;type&#34;,
            attrib={&#34;name&#34;: enum2str(self.marking_type), &#34;width&#34;: str(self.width)},
        )
        for l in self._line:
            typeelement.append(l.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.Lane" href="#scenariogeneration.xodr.lane.Lane">Lane</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_height" href="#scenariogeneration.xodr.lane.Lane.add_height">add_height</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_lane_width" href="#scenariogeneration.xodr.lane.Lane.add_lane_width">add_lane_width</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_link" href="#scenariogeneration.xodr.lane.Lane.add_link">add_link</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.add_roadmark" href="#scenariogeneration.xodr.lane.Lane.add_roadmark">add_roadmark</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_attributes" href="#scenariogeneration.xodr.lane.Lane.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_element" href="#scenariogeneration.xodr.lane.Lane.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lane.get_width" href="#scenariogeneration.xodr.lane.Lane.get_width">get_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.LaneOffset" href="#scenariogeneration.xodr.lane.LaneOffset">LaneOffset</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.LaneOffset.get_attributes" href="#scenariogeneration.xodr.lane.LaneOffset.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneOffset.get_element" href="#scenariogeneration.xodr.lane.LaneOffset.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.LaneSection" href="#scenariogeneration.xodr.lane.LaneSection">LaneSection</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.add_left_lane" href="#scenariogeneration.xodr.lane.LaneSection.add_left_lane">add_left_lane</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.add_right_lane" href="#scenariogeneration.xodr.lane.LaneSection.add_right_lane">add_right_lane</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.get_attributes" href="#scenariogeneration.xodr.lane.LaneSection.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.LaneSection.get_element" href="#scenariogeneration.xodr.lane.LaneSection.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.Lanes" href="#scenariogeneration.xodr.lane.Lanes">Lanes</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.Lanes.add_laneoffset" href="#scenariogeneration.xodr.lane.Lanes.add_laneoffset">add_laneoffset</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.add_lanesection" href="#scenariogeneration.xodr.lane.Lanes.add_lanesection">add_lanesection</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.Lanes.get_element" href="#scenariogeneration.xodr.lane.Lanes.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.RoadLine" href="#scenariogeneration.xodr.lane.RoadLine">RoadLine</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.get_attributes" href="#scenariogeneration.xodr.lane.RoadLine.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadLine.get_element" href="#scenariogeneration.xodr.lane.RoadLine.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.lane.RoadMark" href="#scenariogeneration.xodr.lane.RoadMark">RoadMark</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.add_specific_road_line" href="#scenariogeneration.xodr.lane.RoadMark.add_specific_road_line">add_specific_road_line</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.get_attributes" href="#scenariogeneration.xodr.lane.RoadMark.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.lane.RoadMark.get_element" href="#scenariogeneration.xodr.lane.RoadMark.get_element">get_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>