<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xodr.geometry API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.geometry</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenariogeneration.xodr.geometry.wrap_pi"><code class="name flex">
<span>def <span class="ident">wrap_pi</span></span>(<span>angle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_pi(angle):
    return angle % (2 * np.pi)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xodr.geometry.AdjustablePlanview"><code class="flex name class">
<span>class <span class="ident">AdjustablePlanview</span></span>
<span>(</span><span>left_lane_defs: List | None = None,<br>right_lane_defs: List | None = None,<br>center_road_mark: str | None = None,<br>lane_width: float | None = None,<br>lane_width_end: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdjustablePlanview:
    &#34;&#34;&#34;AdjustablePlanview can be used to fit a geometry between two fixed
    roads.

    Parameters
    ----------
    left_lane_defs : optional
        Definitions for the left lanes.
    right_lane_defs : optional
        Definitions for the right lanes.
    center_road_mark : optional
        Definition for the center road marking.
    lane_width : optional
        Width of the lanes at the start.
    lane_width_end : optional
        Width of the lanes at the end.

    Attributes
    ----------
    fixed : bool
        Indicates whether the planview is fixed.
    adjusted : bool
        Indicates whether the planview has been adjusted.
    left_lane_defs : optional
        Definitions for the left lanes.
    right_lane_defs : optional
        Definitions for the right lanes.
    center_road_mark : optional
        Definition for the center road marking.
    lane_width : optional
        Width of the lanes at the start.
    lane_width_end : optional
        Width of the lanes at the end.
    &#34;&#34;&#34;

    def __init__(
        self,
        left_lane_defs: Optional[List] = None,
        right_lane_defs: Optional[List] = None,
        center_road_mark: Optional[str] = None,
        lane_width: Optional[float] = None,
        lane_width_end: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `AdjustablePlanview` instance.

        Parameters
        ----------
        left_lane_defs : list, optional
            Definitions for the left lanes. Default is None.
        right_lane_defs : list, optional
            Definitions for the right lanes. Default is None.
        center_road_mark : str, optional
            Definition for the center road marking. Default is None.
        lane_width : float, optional
            Width of the lanes at the start. Default is None.
        lane_width_end : float, optional
            Width of the lanes at the end. Default is None.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.fixed = False
        self.adjusted = False
        self.left_lane_defs = left_lane_defs
        self.right_lane_defs = right_lane_defs
        self.center_road_mark = center_road_mark
        self.lane_width = lane_width
        self.lane_width_end = lane_width_end</code></pre>
</details>
<div class="desc"><p>AdjustablePlanview can be used to fit a geometry between two fixed
roads.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_lane_defs</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definitions for the left lanes.</dd>
<dt><strong><code>right_lane_defs</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definitions for the right lanes.</dd>
<dt><strong><code>center_road_mark</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definition for the center road marking.</dd>
<dt><strong><code>lane_width</code></strong> :&ensp;<code>optional</code></dt>
<dd>Width of the lanes at the start.</dd>
<dt><strong><code>lane_width_end</code></strong> :&ensp;<code>optional</code></dt>
<dd>Width of the lanes at the end.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>fixed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the planview is fixed.</dd>
<dt><strong><code>adjusted</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the planview has been adjusted.</dd>
<dt><strong><code>left_lane_defs</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definitions for the left lanes.</dd>
<dt><strong><code>right_lane_defs</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definitions for the right lanes.</dd>
<dt><strong><code>center_road_mark</code></strong> :&ensp;<code>optional</code></dt>
<dd>Definition for the center road marking.</dd>
<dt><strong><code>lane_width</code></strong> :&ensp;<code>optional</code></dt>
<dd>Width of the lanes at the start.</dd>
<dt><strong><code>lane_width_end</code></strong> :&ensp;<code>optional</code></dt>
<dd>Width of the lanes at the end.</dd>
</dl>
<p>Initialize the <code><a title="scenariogeneration.xodr.geometry.AdjustablePlanview" href="#scenariogeneration.xodr.geometry.AdjustablePlanview">AdjustablePlanview</a></code> instance.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>left_lane_defs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Definitions for the left lanes. Default is None.</dd>
<dt><strong><code>right_lane_defs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Definitions for the right lanes. Default is None.</dd>
<dt><strong><code>center_road_mark</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Definition for the center road marking. Default is None.</dd>
<dt><strong><code>lane_width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the lanes at the start. Default is None.</dd>
<dt><strong><code>lane_width_end</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the lanes at the end. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Arc"><code class="flex name class">
<span>class <span class="ident">Arc</span></span>
<span>(</span><span>curvature: float, length: float | None = None, angle: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arc(_BaseGeometry):
    &#34;&#34;&#34;The `Arc` class creates an arc type of geometry.

    Parameters
    ----------
    curvature : float
        The curvature of the arc.
    length : float, optional
        The length of the arc. Either `length` or `angle` must be provided.
    angle : float, optional
        The angle of the arc. Either `angle` or `length` must be provided.

    Attributes
    ----------
    curvature : float
        The curvature of the arc.
    length : float
        The length of the arc.
    angle : float
        The angle of the arc.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    get_end_data(x, y, h)
        Returns the end point of the geometry.
    get_start_data(end_x, end_y, end_h)
        Returns the start point of the geometry.
    &#34;&#34;&#34;

    def __init__(
        self,
        curvature: float,
        length: Optional[float] = None,
        angle: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `Arc` instance.

        Parameters
        ----------
        curvature : float
            The curvature of the arc.
        length : float, optional
            The length of the arc. Either `length` or `angle` must be provided.
        angle : float, optional
            The angle of the arc. Either `angle` or `length` must be provided.

        Raises
        ------
        NotEnoughInputArguments
            If neither `length` nor `angle` is provided.
        ToManyOptionalArguments
            If both `length` and `angle` are provided.
        ValueError
            If `curvature` is 0, as it would create a straight line.
        &#34;&#34;&#34;
        super().__init__()
        if length == None and angle == None:
            raise NotEnoughInputArguments(
                &#34;neither length nor angle defined, for arc&#34;
            )

        if length != None and angle != None:
            raise ToManyOptionalArguments(
                &#34;both length and angle set, only one is requiered&#34;
            )

        self.length = length
        self.angle = angle
        if curvature == 0:
            raise ValueError(
                &#34;You are creating a straight line, please use Line instead&#34;
            )
        self.curvature = curvature

        if self.length:
            self.angle = self.length * self.curvature

        if self.angle:
            _, _, _, self.length = self.get_end_data(0, 0, 0)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Arc) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_end_data(
        self, x: float, y: float, h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Return the end point of the geometry.

        Parameters
        ----------
        x : float
            The x start coordinate of the geometry.
        y : float
            The y start coordinate of the geometry.
        h : float
            The start heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_end : float
                The x end coordinate of the geometry.
            - y_end : float
                The y end coordinate of the geometry.
            - h_end : float
                The end heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;
        radius = 1 / np.abs(self.curvature)
        if self.curvature &lt; 0:
            phi_0 = h + np.pi / 2
            x_0 = x - np.cos(phi_0) * radius
            y_0 = y - np.sin(phi_0) * radius

        else:
            phi_0 = h - np.pi / 2
            x_0 = x - np.cos(phi_0) * radius
            y_0 = y - np.sin(phi_0) * radius

        if self.length:
            self.angle = self.length * self.curvature

        new_ang = self.angle + phi_0
        if self.angle:
            self.length = np.abs(radius * self.angle)

        new_ang = self.angle + phi_0
        new_h = h + self.angle
        new_x = np.cos(new_ang) * radius + x_0
        new_y = np.sin(new_ang) * radius + y_0

        return new_x, new_y, new_h, self.length

    def get_start_data(
        self, end_x: float, end_y: float, end_h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns information about the end point of the geometry.

        Parameters
        ----------
        end_x : float
            The end x coordinate of the geometry
        end_y : float
            The end y coordinate of the geometry

        end_h : float
            The end h coordinate of the geometry

        Returns
        ---------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_start : float
                The x start coordinate of the geometry.
            - y_start : float
                The y start coordinate of the geometry.
            - h_start : float
                The start heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;
        x = end_x
        y = end_y
        h = end_h
        inv_curv = -self.curvature
        radius = 1 / np.abs(inv_curv)
        if inv_curv &lt; 0:
            phi_0 = h + np.pi / 2
            x_0 = x - np.cos(phi_0) * radius
            y_0 = y - np.sin(phi_0) * radius

        else:
            phi_0 = h - np.pi / 2
            x_0 = x - np.cos(phi_0) * radius
            y_0 = y - np.sin(phi_0) * radius

        if self.length:
            self.angle = self.length * inv_curv

        new_ang = self.angle + phi_0
        if self.angle:
            self.length = np.abs(radius * self.angle)

        new_h = h + self.angle
        new_x = np.cos(new_ang) * radius + x_0
        new_y = np.sin(new_ang) * radius + y_0
        return new_x, new_y, new_h, self.length

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `Arc` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `Arc`:
            - &#34;curvature&#34; : str
                The curvature of the arc.
        &#34;&#34;&#34;
        return {&#34;curvature&#34;: str(self.curvature)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `Arc`.

        This method generates an XML element for the `Arc`, including
        its attributes and any additional data.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the `Arc`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;arc&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>The <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code> class creates an arc type of geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>The curvature of the arc.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the arc. Either <code>length</code> or <code>angle</code> must be provided.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The angle of the arc. Either <code>angle</code> or <code>length</code> must be provided.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>The curvature of the arc.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the arc.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle of the arc.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns a dictionary of all attributes of the class.
get_end_data(x, y, h)
Returns the end point of the geometry.
get_start_data(end_x, end_y, end_h)
Returns the start point of the geometry.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code> instance.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>The curvature of the arc.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the arc. Either <code>length</code> or <code>angle</code> must be provided.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The angle of the arc. Either <code>angle</code> or <code>length</code> must be provided.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughInputArguments</code></dt>
<dd>If neither <code>length</code> nor <code>angle</code> is provided.</dd>
<dt><code>ToManyOptionalArguments</code></dt>
<dd>If both <code>length</code> and <code>angle</code> are provided.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>curvature</code> is 0, as it would create a straight line.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.geometry._BaseGeometry</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.geometry.Arc.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `Arc` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `Arc`:
        - &#34;curvature&#34; : str
            The curvature of the arc.
    &#34;&#34;&#34;
    return {&#34;curvature&#34;: str(self.curvature)}</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code>:
- "curvature" : str
The curvature of the arc.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Arc.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `Arc`.

    This method generates an XML element for the `Arc`, including
    its attributes and any additional data.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the `Arc`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;arc&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code>.</p>
<p>This method generates an XML element for the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code>, including
its attributes and any additional data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Arc.get_end_data"><code class="name flex">
<span>def <span class="ident">get_end_data</span></span>(<span>self, x: float, y: float, h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_data(
    self, x: float, y: float, h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Return the end point of the geometry.

    Parameters
    ----------
    x : float
        The x start coordinate of the geometry.
    y : float
        The y start coordinate of the geometry.
    h : float
        The start heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_end : float
            The x end coordinate of the geometry.
        - y_end : float
            The y end coordinate of the geometry.
        - h_end : float
            The end heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;
    radius = 1 / np.abs(self.curvature)
    if self.curvature &lt; 0:
        phi_0 = h + np.pi / 2
        x_0 = x - np.cos(phi_0) * radius
        y_0 = y - np.sin(phi_0) * radius

    else:
        phi_0 = h - np.pi / 2
        x_0 = x - np.cos(phi_0) * radius
        y_0 = y - np.sin(phi_0) * radius

    if self.length:
        self.angle = self.length * self.curvature

    new_ang = self.angle + phi_0
    if self.angle:
        self.length = np.abs(radius * self.angle)

    new_ang = self.angle + phi_0
    new_h = h + self.angle
    new_x = np.cos(new_ang) * radius + x_0
    new_y = np.sin(new_ang) * radius + y_0

    return new_x, new_y, new_h, self.length</code></pre>
</details>
<div class="desc"><p>Return the end point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x start coordinate of the geometry.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y start coordinate of the geometry.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The start heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_end : float
The x end coordinate of the geometry.
- y_end : float
The y end coordinate of the geometry.
- h_end : float
The end heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Arc.get_start_data"><code class="name flex">
<span>def <span class="ident">get_start_data</span></span>(<span>self, end_x: float, end_y: float, end_h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_data(
    self, end_x: float, end_y: float, end_h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns information about the end point of the geometry.

    Parameters
    ----------
    end_x : float
        The end x coordinate of the geometry
    end_y : float
        The end y coordinate of the geometry

    end_h : float
        The end h coordinate of the geometry

    Returns
    ---------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_start : float
            The x start coordinate of the geometry.
        - y_start : float
            The y start coordinate of the geometry.
        - h_start : float
            The start heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;
    x = end_x
    y = end_y
    h = end_h
    inv_curv = -self.curvature
    radius = 1 / np.abs(inv_curv)
    if inv_curv &lt; 0:
        phi_0 = h + np.pi / 2
        x_0 = x - np.cos(phi_0) * radius
        y_0 = y - np.sin(phi_0) * radius

    else:
        phi_0 = h - np.pi / 2
        x_0 = x - np.cos(phi_0) * radius
        y_0 = y - np.sin(phi_0) * radius

    if self.length:
        self.angle = self.length * inv_curv

    new_ang = self.angle + phi_0
    if self.angle:
        self.length = np.abs(radius * self.angle)

    new_h = h + self.angle
    new_x = np.cos(new_ang) * radius + x_0
    new_y = np.sin(new_ang) * radius + y_0
    return new_x, new_y, new_h, self.length</code></pre>
</details>
<div class="desc"><p>Returns information about the end point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>end_x</code></strong> :&ensp;<code>float</code></dt>
<dd>The end x coordinate of the geometry</dd>
<dt><strong><code>end_y</code></strong> :&ensp;<code>float</code></dt>
<dd>The end y coordinate of the geometry</dd>
<dt><strong><code>end_h</code></strong> :&ensp;<code>float</code></dt>
<dd>The end h coordinate of the geometry</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_start : float
The x start coordinate of the geometry.
- y_start : float
The y start coordinate of the geometry.
- h_start : float
The start heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.geometry.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>length: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line(_BaseGeometry):
    &#34;&#34;&#34;The `Line` class creates a line type of geometry.

    Parameters
    ----------
    length : float
        The length of the line.

    Attributes
    ----------
    length : float
        The length of the line.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    get_end_data(x, y, h)
        Returns the end point of the geometry.
    get_start_data(end_x, end_y, end_h)
        Returns the start point of the geometry.
    &#34;&#34;&#34;

    def __init__(self, length: float) -&gt; None:
        &#34;&#34;&#34;Initialize the `Line` instance.

        Parameters
        ----------
        length : float
            The length of the line.

        Returns
        -------
        None
        &#34;&#34;&#34;
        super().__init__()
        self.length = length

    def __eq__(self, other: object) -&gt; bool:
        return super().__eq__(other)

    def get_end_data(
        self, x: float, y: float, h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Return the end point of the geometry.

        Parameters
        ----------
        x : float
            The x start coordinate of the geometry.
        y : float
            The y start coordinate of the geometry.
        h : float
            The start heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_end : float
                The x end coordinate of the geometry.
            - y_end : float
                The y end coordinate of the geometry.
            - h_end : float
                The end heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;

        new_x = self.length * np.cos(h) + x
        new_y = self.length * np.sin(h) + y
        new_h = h

        return new_x, new_y, new_h, self.length

    def get_start_data(
        self, end_x: float, end_y: float, end_h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Return the start point of the geometry.

        Parameters
        ----------
        end_x : float
            The x end coordinate of the geometry.
        end_y : float
            The y end coordinate of the geometry.
        end_h : float
            The end heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_start : float
                The start x coordinate of the geometry.
            - y_start : float
                The start y coordinate of the geometry.
            - h_start : float
                The start heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;
        start_x = self.length * np.cos(end_h) + end_x
        start_y = self.length * np.sin(end_h) + end_y
        start_h = end_h

        return start_x, start_y, start_h, self.length

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `Line`.

        This method generates an XML element for the `Line`, including
        any additional data.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the `Line`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;line&#34;)
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>The <code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code> class creates a line type of geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the line.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the line.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
get_end_data(x, y, h)
Returns the end point of the geometry.
get_start_data(end_x, end_y, end_h)
Returns the start point of the geometry.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code> instance.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the line.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.geometry._BaseGeometry</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.geometry.Line.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `Line`.

    This method generates an XML element for the `Line`, including
    any additional data.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the `Line`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;line&#34;)
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code>.</p>
<p>This method generates an XML element for the <code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code>, including
any additional data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Line.get_end_data"><code class="name flex">
<span>def <span class="ident">get_end_data</span></span>(<span>self, x: float, y: float, h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_data(
    self, x: float, y: float, h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Return the end point of the geometry.

    Parameters
    ----------
    x : float
        The x start coordinate of the geometry.
    y : float
        The y start coordinate of the geometry.
    h : float
        The start heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_end : float
            The x end coordinate of the geometry.
        - y_end : float
            The y end coordinate of the geometry.
        - h_end : float
            The end heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;

    new_x = self.length * np.cos(h) + x
    new_y = self.length * np.sin(h) + y
    new_h = h

    return new_x, new_y, new_h, self.length</code></pre>
</details>
<div class="desc"><p>Return the end point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x start coordinate of the geometry.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y start coordinate of the geometry.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The start heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_end : float
The x end coordinate of the geometry.
- y_end : float
The y end coordinate of the geometry.
- h_end : float
The end heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Line.get_start_data"><code class="name flex">
<span>def <span class="ident">get_start_data</span></span>(<span>self, end_x: float, end_y: float, end_h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_data(
    self, end_x: float, end_y: float, end_h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Return the start point of the geometry.

    Parameters
    ----------
    end_x : float
        The x end coordinate of the geometry.
    end_y : float
        The y end coordinate of the geometry.
    end_h : float
        The end heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_start : float
            The start x coordinate of the geometry.
        - y_start : float
            The start y coordinate of the geometry.
        - h_start : float
            The start heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;
    start_x = self.length * np.cos(end_h) + end_x
    start_y = self.length * np.sin(end_h) + end_y
    start_h = end_h

    return start_x, start_y, start_h, self.length</code></pre>
</details>
<div class="desc"><p>Return the start point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>end_x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x end coordinate of the geometry.</dd>
<dt><strong><code>end_y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y end coordinate of the geometry.</dd>
<dt><strong><code>end_h</code></strong> :&ensp;<code>float</code></dt>
<dd>The end heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_start : float
The start x coordinate of the geometry.
- y_start : float
The start y coordinate of the geometry.
- h_start : float
The start heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.geometry.ParamPoly3"><code class="flex name class">
<span>class <span class="ident">ParamPoly3</span></span>
<span>(</span><span>au: float,<br>bu: float,<br>cu: float,<br>du: float,<br>av: float,<br>bv: float,<br>cv: float,<br>dv: float,<br>prange: str = 'normalized',<br>length: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamPoly3(_BaseGeometry):
    &#34;&#34;&#34;The `ParamPoly3` class creates a parametric polynomial type of geometry
    in the coordinate system U (along the road) and V (normal to the road).

    The polynomials are of the form:
        uv(p) = a + b*p + c*p^2 + d*p^3

    Parameters
    ----------
    au : float
        Coefficient `a` of the `u` polynomial.
    bu : float
        Coefficient `b` of the `u` polynomial.
    cu : float
        Coefficient `c` of the `u` polynomial.
    du : float
        Coefficient `d` of the `u` polynomial.
    av : float
        Coefficient `a` of the `v` polynomial.
    bv : float
        Coefficient `b` of the `v` polynomial.
    cv : float
        Coefficient `c` of the `v` polynomial.
    dv : float
        Coefficient `d` of the `v` polynomial.
    prange : str, optional
        Either `&#34;normalized&#34;` or `&#34;arcLength&#34;`. Default is `&#34;normalized&#34;`.
    length : float, optional
        Total length of the arc, used if `prange == &#34;arcLength&#34;`.

    Attributes
    ----------
    au : float
        Coefficient `a` of the `u` polynomial.
    bu : float
        Coefficient `b` of the `u` polynomial.
    cu : float
        Coefficient `c` of the `u` polynomial.
    du : float
        Coefficient `d` of the `u` polynomial.
    av : float
        Coefficient `a` of the `v` polynomial.
    bv : float
        Coefficient `b` of the `v` polynomial.
    cv : float
        Coefficient `c` of the `v` polynomial.
    dv : float
        Coefficient `d` of the `v` polynomial.
    prange : str
        Either `&#34;normalized&#34;` or `&#34;arcLength&#34;`. Default is `&#34;normalized&#34;`.
    length : float
        Total length of the arc, used if `prange == &#34;arcLength&#34;`.

    Methods
    -------
    get_element(elementname)
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    get_end_coordinate(length, x, y, h)
        Returns the end point of the geometry.
    &#34;&#34;&#34;

    def __init__(
        self,
        au: float,
        bu: float,
        cu: float,
        du: float,
        av: float,
        bv: float,
        cv: float,
        dv: float,
        prange: str = &#34;normalized&#34;,
        length: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `ParamPoly3` instance.

        Parameters
        ----------
        au : float
            Coefficient `a` of the `u` polynomial.
        bu : float
            Coefficient `b` of the `u` polynomial.
        cu : float
            Coefficient `c` of the `u` polynomial.
        du : float
            Coefficient `d` of the `u` polynomial.
        av : float
            Coefficient `a` of the `v` polynomial.
        bv : float
            Coefficient `b` of the `v` polynomial.
        cv : float
            Coefficient `c` of the `v` polynomial.
        dv : float
            Coefficient `d` of the `v` polynomial.
        prange : str, optional
            Either `&#34;normalized&#34;` or `&#34;arcLength&#34;`. Default is `&#34;normalized&#34;`.
        length : float, optional
            Total length of the arc, used if `prange == &#34;arcLength&#34;`.

        Raises
        ------
        ValueError
            If `prange == &#34;arcLength&#34;` and `length` is not provided.
        &#34;&#34;&#34;
        super().__init__()
        self.au = au
        self.bu = bu
        self.cu = cu
        self.du = du
        self.av = av
        self.bv = bv
        self.cv = cv
        self.dv = dv
        self.prange = prange
        if prange == &#34;arcLength&#34; and length == None:
            raise ValueError(
                &#34;No length was provided for ParamPoly3 with arcLength option&#34;
            )
        if length:
            self.length = length
        else:
            _, _, _, self.length = self.get_end_data(0, 0, 0)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ParamPoly3) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def _integrand(self, p: float) -&gt; float:
        &#34;&#34;&#34;Integral function to calculate the length of the polynomial.

        Note
        ----
        This method is not tested or verified.

        Parameters
        ----------
        p : float
            The parameter value for the polynomial.

        Returns
        -------
        float
            The value of the integral function at `p`.
        &#34;&#34;&#34;
        return np.sqrt(
            (abs(3 * self.du * p**2 + 2 * self.cu * p + self.bu)) ** 2
            + (abs(3 * self.dv * p**2 + 2 * self.cv * p + self.bv)) ** 2
        )

    def get_start_data(
        self, x: float, y: float, h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns the start point of the geometry.

        Parameters
        ----------
        x : float
            The x end coordinate of the geometry
        y : float
            The y end coordinate of the geometry
        h : float
            The x end heading of the geometry

        Returns
        ---------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_start : float
                The start x coordinate of the geometry.
            - y_start : float
                The start y coordinate of the geometry.
            - h_start : float
                The start heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;
        if self.prange == &#34;normalized&#34;:
            p = 1
            I = quad(self._integrand, 0, 1)
            self.length = I[0]
        else:
            p = self.length
        newu = self.au + self.bu * p + self.cu * p**2 + self.du * p**3
        newv = self.av + self.bv * p + self.cv * p**2 + self.dv * p**3

        new_x = x - (newu * np.cos(h) - np.sin(h) * newv)
        new_y = y - (newu * np.sin(h) + np.cos(h) * newv)
        new_h = h - np.arctan2(
            self.bv + 2 * self.cv * p + 3 * self.dv * p**2,
            self.bu + 2 * self.cu * p + 3 * self.du * p**2,
        )

        return new_x, new_y, new_h, self.length

    def get_end_data(
        self, x: float, y: float, h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns the end point of the geometry.

        Parameters
        ----------
        x : float
            The x start coordinate of the geometry.
        y : float
            The y start coordinate of the geometry.
        h : float
            The start heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_end : float
                The x end coordinate of the geometry.
            - y_end : float
                The y end coordinate of the geometry.
            - h_end : float
                The end heading of the geometry.
            - length : float
                The length of the geometry.
        &#34;&#34;&#34;
        if self.prange == &#34;normalized&#34;:
            p = 1
            I = quad(self._integrand, 0, 1)
            self.length = I[0]
        else:
            p = self.length
        newu = self.au + self.bu * p + self.cu * p**2 + self.du * p**3
        newv = self.av + self.bv * p + self.cv * p**2 + self.dv * p**3

        new_x = x + newu * np.cos(h) - np.sin(h) * newv
        new_y = y + newu * np.sin(h) + np.cos(h) * newv
        new_h = h + np.arctan2(
            self.bv + 2 * self.cv * p + 3 * self.dv * p**2,
            self.bu + 2 * self.cu * p + 3 * self.du * p**2,
        )

        return new_x, new_y, new_h, self.length

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `ParamPoly3` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `ParamPoly3`:
            - &#34;aU&#34; : str
                Coefficient `a` of the `u` polynomial.
            - &#34;bU&#34; : str
                Coefficient `b` of the `u` polynomial.
            - &#34;cU&#34; : str
                Coefficient `c` of the `u` polynomial.
            - &#34;dU&#34; : str
                Coefficient `d` of the `u` polynomial.
            - &#34;aV&#34; : str
                Coefficient `a` of the `v` polynomial.
            - &#34;bV&#34; : str
                Coefficient `b` of the `v` polynomial.
            - &#34;cV&#34; : str
                Coefficient `c` of the `v` polynomial.
            - &#34;dV&#34; : str
                Coefficient `d` of the `v` polynomial.
            - &#34;pRange&#34; : str
                The range type of the polynomial
                (`&#34;normalized&#34;` or `&#34;arcLength&#34;`).
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;aU&#34;] = str(self.au)
        retdict[&#34;bU&#34;] = str(self.bu)
        retdict[&#34;cU&#34;] = str(self.cu)
        retdict[&#34;dU&#34;] = str(self.du)
        retdict[&#34;aV&#34;] = str(self.av)
        retdict[&#34;bV&#34;] = str(self.bv)
        retdict[&#34;cV&#34;] = str(self.cv)
        retdict[&#34;dV&#34;] = str(self.dv)
        retdict[&#34;pRange&#34;] = self.prange
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `ParamPoly3`.

        This method generates an XML element for the `ParamPoly3`,
        including its attributes and any additional data.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the `ParamPoly3`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;paramPoly3&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>The <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code> class creates a parametric polynomial type of geometry
in the coordinate system U (along the road) and V (normal to the road).</p>
<p>The polynomials are of the form:
uv(p) = a + b<em>p + c</em>p^2 + d*p^3</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>au</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>bu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>cu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>du</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>av</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>bv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>cv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>dv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>prange</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Either <code>"normalized"</code> or <code>"arcLength"</code>. Default is <code>"normalized"</code>.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total length of the arc, used if <code>prange == "arcLength"</code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>au</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>bu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>cu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>du</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>av</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>bv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>cv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>dv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>prange</code></strong> :&ensp;<code>str</code></dt>
<dd>Either <code>"normalized"</code> or <code>"arcLength"</code>. Default is <code>"normalized"</code>.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Total length of the arc, used if <code>prange == "arcLength"</code>.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element(elementname)
Returns the full ElementTree representation of the class.
get_attributes()
Returns a dictionary of all attributes of the class.
get_end_coordinate(length, x, y, h)
Returns the end point of the geometry.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code> instance.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>au</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>bu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>cu</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>du</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>u</code> polynomial.</dd>
<dt><strong><code>av</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>a</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>bv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>b</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>cv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>c</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>dv</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient <code>d</code> of the <code>v</code> polynomial.</dd>
<dt><strong><code>prange</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Either <code>"normalized"</code> or <code>"arcLength"</code>. Default is <code>"normalized"</code>.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total length of the arc, used if <code>prange == "arcLength"</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>prange == "arcLength"</code> and <code>length</code> is not provided.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.geometry._BaseGeometry</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.geometry.ParamPoly3.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `ParamPoly3` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `ParamPoly3`:
        - &#34;aU&#34; : str
            Coefficient `a` of the `u` polynomial.
        - &#34;bU&#34; : str
            Coefficient `b` of the `u` polynomial.
        - &#34;cU&#34; : str
            Coefficient `c` of the `u` polynomial.
        - &#34;dU&#34; : str
            Coefficient `d` of the `u` polynomial.
        - &#34;aV&#34; : str
            Coefficient `a` of the `v` polynomial.
        - &#34;bV&#34; : str
            Coefficient `b` of the `v` polynomial.
        - &#34;cV&#34; : str
            Coefficient `c` of the `v` polynomial.
        - &#34;dV&#34; : str
            Coefficient `d` of the `v` polynomial.
        - &#34;pRange&#34; : str
            The range type of the polynomial
            (`&#34;normalized&#34;` or `&#34;arcLength&#34;`).
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;aU&#34;] = str(self.au)
    retdict[&#34;bU&#34;] = str(self.bu)
    retdict[&#34;cU&#34;] = str(self.cu)
    retdict[&#34;dU&#34;] = str(self.du)
    retdict[&#34;aV&#34;] = str(self.av)
    retdict[&#34;bV&#34;] = str(self.bv)
    retdict[&#34;cV&#34;] = str(self.cv)
    retdict[&#34;dV&#34;] = str(self.dv)
    retdict[&#34;pRange&#34;] = self.prange
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code>:
- "aU" : str
Coefficient <code>a</code> of the <code>u</code> polynomial.
- "bU" : str
Coefficient <code>b</code> of the <code>u</code> polynomial.
- "cU" : str
Coefficient <code>c</code> of the <code>u</code> polynomial.
- "dU" : str
Coefficient <code>d</code> of the <code>u</code> polynomial.
- "aV" : str
Coefficient <code>a</code> of the <code>v</code> polynomial.
- "bV" : str
Coefficient <code>b</code> of the <code>v</code> polynomial.
- "cV" : str
Coefficient <code>c</code> of the <code>v</code> polynomial.
- "dV" : str
Coefficient <code>d</code> of the <code>v</code> polynomial.
- "pRange" : str
The range type of the polynomial
(<code>"normalized"</code> or <code>"arcLength"</code>).</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.ParamPoly3.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `ParamPoly3`.

    This method generates an XML element for the `ParamPoly3`,
    including its attributes and any additional data.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the `ParamPoly3`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;paramPoly3&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code>.</p>
<p>This method generates an XML element for the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code>,
including its attributes and any additional data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.ParamPoly3.get_end_data"><code class="name flex">
<span>def <span class="ident">get_end_data</span></span>(<span>self, x: float, y: float, h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_data(
    self, x: float, y: float, h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns the end point of the geometry.

    Parameters
    ----------
    x : float
        The x start coordinate of the geometry.
    y : float
        The y start coordinate of the geometry.
    h : float
        The start heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_end : float
            The x end coordinate of the geometry.
        - y_end : float
            The y end coordinate of the geometry.
        - h_end : float
            The end heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;
    if self.prange == &#34;normalized&#34;:
        p = 1
        I = quad(self._integrand, 0, 1)
        self.length = I[0]
    else:
        p = self.length
    newu = self.au + self.bu * p + self.cu * p**2 + self.du * p**3
    newv = self.av + self.bv * p + self.cv * p**2 + self.dv * p**3

    new_x = x + newu * np.cos(h) - np.sin(h) * newv
    new_y = y + newu * np.sin(h) + np.cos(h) * newv
    new_h = h + np.arctan2(
        self.bv + 2 * self.cv * p + 3 * self.dv * p**2,
        self.bu + 2 * self.cu * p + 3 * self.du * p**2,
    )

    return new_x, new_y, new_h, self.length</code></pre>
</details>
<div class="desc"><p>Returns the end point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x start coordinate of the geometry.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y start coordinate of the geometry.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The start heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_end : float
The x end coordinate of the geometry.
- y_end : float
The y end coordinate of the geometry.
- h_end : float
The end heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.ParamPoly3.get_start_data"><code class="name flex">
<span>def <span class="ident">get_start_data</span></span>(<span>self, x: float, y: float, h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_data(
    self, x: float, y: float, h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns the start point of the geometry.

    Parameters
    ----------
    x : float
        The x end coordinate of the geometry
    y : float
        The y end coordinate of the geometry
    h : float
        The x end heading of the geometry

    Returns
    ---------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_start : float
            The start x coordinate of the geometry.
        - y_start : float
            The start y coordinate of the geometry.
        - h_start : float
            The start heading of the geometry.
        - length : float
            The length of the geometry.
    &#34;&#34;&#34;
    if self.prange == &#34;normalized&#34;:
        p = 1
        I = quad(self._integrand, 0, 1)
        self.length = I[0]
    else:
        p = self.length
    newu = self.au + self.bu * p + self.cu * p**2 + self.du * p**3
    newv = self.av + self.bv * p + self.cv * p**2 + self.dv * p**3

    new_x = x - (newu * np.cos(h) - np.sin(h) * newv)
    new_y = y - (newu * np.sin(h) + np.cos(h) * newv)
    new_h = h - np.arctan2(
        self.bv + 2 * self.cv * p + 3 * self.dv * p**2,
        self.bu + 2 * self.cu * p + 3 * self.du * p**2,
    )

    return new_x, new_y, new_h, self.length</code></pre>
</details>
<div class="desc"><p>Returns the start point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x end coordinate of the geometry</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y end coordinate of the geometry</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The x end heading of the geometry</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_start : float
The start x coordinate of the geometry.
- y_start : float
The start y coordinate of the geometry.
- h_start : float
The start heading of the geometry.
- length : float
The length of the geometry.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView"><code class="flex name class">
<span>class <span class="ident">PlanView</span></span>
<span>(</span><span>x_start: float | None = None,<br>y_start: float | None = None,<br>h_start: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlanView(XodrBase):
    &#34;&#34;&#34;The PlanView is the geometrical description of a road.

    Parameters
    ----------
    x_start : float, optional
        Start x coordinate of the first geometry. Default is None.
    y_start : float, optional
        Start y coordinate of the first geometry. Default is None.
    h_start : float, optional
        Starting heading of the first geometry. Default is None.

    Attributes
    ----------
    present_x : float
        The start x coordinate of the next geometry added.
    present_y : float
        The y coordinate of the next geometry added.
    present_h : float
        The heading coordinate of the next geometry added.
    present_s : float
        The along-road measure of the next geometry added.

    Methods
    -------
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_total_length()
        Returns the full length of the PlanView.
    add_geometry(geom, length)
        Adds a new geometry entry to the PlanView.
    set_start_point(x_start, y_start, h_start)
        Sets the start point and heading of the PlanView.
    adjust_geometries()
        Adjusts all geometries in the PlanView based on the start point.
    &#34;&#34;&#34;

    def __init__(
        self,
        x_start: Optional[float] = None,
        y_start: Optional[float] = None,
        h_start: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the PlanView.

        Parameters
        ----------
        x_start : float, optional
            Start x coordinate of the first geometry. Default is None.
        y_start : float, optional
            Start y coordinate of the first geometry. Default is None.
        h_start : float, optional
            Starting heading of the first geometry. Default is None.

        Raises
        ------
        NotEnoughInputArguments
            If only some of the start values are provided but not all.
        &#34;&#34;&#34;
        super().__init__()
        self.present_x: float = 0
        self.present_y: float = 0
        self.present_h: float = 0
        self.present_s: float = 0
        self.fixed: bool = False

        if all([x_start != None, y_start != None, h_start != None]):
            self.set_start_point(x_start, y_start, h_start)
        elif any([x_start != None, y_start != None, h_start != None]):
            raise NotEnoughInputArguments(
                &#34;If a start position is wanted for the PlanView, all inputs must be used.&#34;
            )

        self.x_start = None
        self.y_start = None
        self.h_start = None

        self.x_end = None
        self.y_end = None
        self.h_end = None

        self._raw_geometries = []
        self._adjusted_geometries = []
        self._overridden_headings = []

        self.adjusted = False
        # variable to track what mode of adding geometries are used

        self._addition_mode = None

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, PlanView) and super().__eq__(other):
            if self.adjusted and other.adjusted:
                if self._adjusted_geometries == other._adjusted_geometries:
                    return True
            elif not self.adjusted and not other.adjusted:
                Warning(
                    &#34;Comparing non adjusted geometries, default value will always be False&#34;
                )
                return False

        return False

    def add_geometry(
        self, geom: _BaseGeometry, heading: Optional[float] = None
    ) -&gt; &#34;PlanView&#34;:
        &#34;&#34;&#34;Add a geometry to the PlanView and stitch together all geometries in
        the order they are added.

        This method should be used together with the
        `adjust_roads_and_lanes` method in the OpenDrive class.

        Note
        ----
        Do not mix this method with `add_fixed_geometry`.

        Parameters
        ----------
        geom : _BaseGeometry
            The geometry to add. Must be an instance of `_BaseGeometry`.
        heading : float, optional
            Override the previous heading (not recommended). If used, it
            must be applied consistently for all geometries. Default is None.

        Returns
        -------
        PlanView
            The updated PlanView instance.

        Raises
        ------
        MixOfGeometryAddition
            If a fixed geometry has already been added.
        TypeError
            If `geom` is not an instance of `_BaseGeometry`.
        &#34;&#34;&#34;
        if self._addition_mode == &#34;add_fixed_geometry&#34;:
            raise MixOfGeometryAddition(
                &#34;A fixed geometry has already been added, please use either add_geometry or add_fixed_geometry&#34;
            )

        if heading is not None:
            self._overridden_headings.append(heading)
        if not isinstance(geom, _BaseGeometry):
            raise TypeError(&#34;geom_type is not of type _BaseGeometry.&#34;)
        self._raw_geometries.append(geom)
        self._addition_mode = &#34;add_geometry&#34;
        return self

    def add_fixed_geometry(
        self,
        geom: Union[&#34;Line&#34;, &#34;Spiral&#34;, &#34;ParamPoly3&#34;, &#34;Arc&#34;],
        x_start: float,
        y_start: float,
        h_start: float,
        s: Optional[float] = None,
    ) -&gt; &#34;PlanView&#34;:
        &#34;&#34;&#34;Add a fixed geometry to the PlanView at a specific point.

        If `s` is provided, the values will be coded, and it is up to the
        user to ensure correctness. If `s` is not provided, the geometries
        are expected to be added in order, and `s` will be calculated.

        Note
        ----
        Do not mix this method with `add_geometry`.

        Parameters
        ----------
        geom : Line, Spiral, ParamPoly3, or Arc
            The geometry to add.
        x_start : float
            Start x position of the geometry.
        y_start : float
            Start y position of the geometry.
        h_start : float
            Start heading of the geometry.
        s : float, optional
            Start s value of the geometry. Default is None.

        Returns
        -------
        PlanView
            The updated PlanView instance.

        Raises
        ------
        MixOfGeometryAddition
            If a geometry has already been added using `add_geometry`.
        &#34;&#34;&#34;

        if self._addition_mode == &#34;add_geometry&#34;:
            raise MixOfGeometryAddition(
                &#34;A geometry has already been added with add_geometry, please use either add_geometry, or add_fixed_geometry not both&#34;
            )

        if s != None:
            pres_s = s
        else:
            pres_s = self.present_s

        if not self.fixed:
            self.x_start = x_start
            self.y_start = y_start
            self.h_start = h_start
            self.fixed = True

        newgeom = _Geometry(pres_s, x_start, y_start, h_start, geom)
        self._adjusted_geometries.append(newgeom)
        self.x_end, self.y_end, self.h_end, length = newgeom.get_end_data()
        self.present_s += length
        self.adjusted = True
        self._addition_mode = &#34;add_fixed_geometry&#34;
        return self

    def set_start_point(
        self, x_start: float = 0, y_start: float = 0, h_start: float = 0
    ) -&gt; None:
        &#34;&#34;&#34;Set the start point of the PlanView.

        Parameters
        ----------
        x_start : float, optional
            Start x coordinate of the first geometry. Default is 0.
        y_start : float, optional
            Start y coordinate of the first geometry. Default is 0.
        h_start : float, optional
            Starting heading of the first geometry. Default is 0.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.present_x = x_start
        self.present_y = y_start
        self.present_h = h_start
        self.fixed = True

    def get_start_point(
        self,
    ) -&gt; tuple[Optional[float], Optional[float], Optional[float]]:
        &#34;&#34;&#34;Return the start point of the PlanView.

        Returns
        -------
        tuple of (float or None, float or None, float or None)
            A tuple containing:
            - x_start : float or None
                The start x coordinate of the PlanView.
            - y_start : float or None
                The start y coordinate of the PlanView.
            - h_start : float or None
                The starting heading of the PlanView.
        &#34;&#34;&#34;

        return self.x_start, self.y_start, self.h_start
        # return self._adjusted_geometries[-1].get_end_point

    def get_end_point(
        self,
    ) -&gt; tuple[Optional[float], Optional[float], Optional[float]]:
        &#34;&#34;&#34;Return the end point of the PlanView.

        Returns
        -------
        tuple of (float or None, float or None, float or None)
            A tuple containing:
            - x_end : float or None
                The end x coordinate of the PlanView.
            - y_end : float or None
                The end y coordinate of the PlanView.
            - h_end : float or None
                The ending heading of the PlanView.
        &#34;&#34;&#34;

        return self.x_end, self.y_end, self.h_end

    def adjust_geometries(self, from_end: bool = False) -&gt; None:
        &#34;&#34;&#34;Adjust all geometries to have the correct start point and heading.

        Parameters
        ----------
        from_end : bool, optional
            Indicates whether `(self.present_x, self.present_y,
            self.present_h)` are interpreted as the starting point
            (`False`) or the ending point (`True`) of the geometry.
            Default is `False`.

        Returns
        -------
        None
        &#34;&#34;&#34;
        if from_end == False:
            self.x_start = self.present_x
            self.y_start = self.present_y
            self.h_start = self.present_h

            for i in range(len(self._raw_geometries)):
                if len(self._overridden_headings) &gt; 0:
                    self.present_h = self._overridden_headings[i]

                newgeom = _Geometry(
                    self.present_s,
                    self.present_x,
                    self.present_y,
                    self.present_h,
                    self._raw_geometries[i],
                )
                (
                    self.present_x,
                    self.present_y,
                    self.present_h,
                    length,
                ) = newgeom.get_end_data()
                self.present_s += length

                self._adjusted_geometries.append(newgeom)
            self.x_end = self.present_x
            self.y_end = self.present_y
            self.h_end = wrap_pi(self.present_h)

        else:
            self.x_end = self.present_x
            self.y_end = self.present_y
            self.h_end = self.present_h + np.pi

            lengths = []
            for i in range(len(self._raw_geometries) - 1, -1, -1):
                newgeom = _Geometry(
                    self.present_s,
                    self.present_x,
                    self.present_y,
                    self.present_h,
                    self._raw_geometries[i],
                )
                (
                    self.present_x,
                    self.present_y,
                    self.present_h,
                    partial_length,
                ) = newgeom.get_start_data()
                lengths.append(partial_length)
                self._adjusted_geometries.append(newgeom)

            self.x_start = self.present_x
            self.y_start = self.present_y
            self.h_start = wrap_pi(self.present_h + np.pi)

            length = sum(lengths)
            self.present_s = 0

            for i in range(len(self._adjusted_geometries) - 1, -1, -1):
                self._adjusted_geometries[i].set_s(self.present_s)
                self.present_s += lengths[i]
            self._adjusted_geometries.reverse()
        self.h_start = wrap_pi(self.h_start)
        self.h_end = wrap_pi(self.h_end)
        self.adjusted = True

    def get_total_length(self) -&gt; float:
        &#34;&#34;&#34;Return the total length of the PlanView.

        If the geometries have been adjusted, the total length is
        calculated based on the adjusted geometries. Otherwise, it is
        calculated based on the raw geometries.

        Returns
        -------
        float
            The total length of the PlanView.
        &#34;&#34;&#34;
        if self.adjusted:
            return self.present_s
        else:
            return sum([x.length for x in self._raw_geometries])

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the PlanView.

        This method generates an XML element for the PlanView, including
        all adjusted geometries.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the PlanView.
        &#34;&#34;&#34;

        element = ET.Element(&#34;planView&#34;)
        self._add_additional_data_to_element(element)
        for geom in self._adjusted_geometries:
            element.append(geom.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The PlanView is the geometrical description of a road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start x coordinate of the first geometry. Default is None.</dd>
<dt><strong><code>y_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start y coordinate of the first geometry. Default is None.</dd>
<dt><strong><code>h_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting heading of the first geometry. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>present_x</code></strong> :&ensp;<code>float</code></dt>
<dd>The start x coordinate of the next geometry added.</dd>
<dt><strong><code>present_y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y coordinate of the next geometry added.</dd>
<dt><strong><code>present_h</code></strong> :&ensp;<code>float</code></dt>
<dd>The heading coordinate of the next geometry added.</dd>
<dt><strong><code>present_s</code></strong> :&ensp;<code>float</code></dt>
<dd>The along-road measure of the next geometry added.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element(elementname)
Returns the full ElementTree of the class.
get_total_length()
Returns the full length of the PlanView.
add_geometry(geom, length)
Adds a new geometry entry to the PlanView.
set_start_point(x_start, y_start, h_start)
Sets the start point and heading of the PlanView.
adjust_geometries()
Adjusts all geometries in the PlanView based on the start point.</p>
<p>Initialize the PlanView.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>x_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start x coordinate of the first geometry. Default is None.</dd>
<dt><strong><code>y_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start y coordinate of the first geometry. Default is None.</dd>
<dt><strong><code>h_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting heading of the first geometry. Default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughInputArguments</code></dt>
<dd>If only some of the start values are provided but not all.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.geometry.PlanView.add_fixed_geometry"><code class="name flex">
<span>def <span class="ident">add_fixed_geometry</span></span>(<span>self,<br>geom: ForwardRef('<a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a>') | ForwardRef('<a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a>') | ForwardRef('<a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a>') | ForwardRef('<a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a>'),<br>x_start: float,<br>y_start: float,<br>h_start: float,<br>s: float | None = None) ‑> <a title="scenariogeneration.xodr.geometry.PlanView" href="#scenariogeneration.xodr.geometry.PlanView">PlanView</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fixed_geometry(
    self,
    geom: Union[&#34;Line&#34;, &#34;Spiral&#34;, &#34;ParamPoly3&#34;, &#34;Arc&#34;],
    x_start: float,
    y_start: float,
    h_start: float,
    s: Optional[float] = None,
) -&gt; &#34;PlanView&#34;:
    &#34;&#34;&#34;Add a fixed geometry to the PlanView at a specific point.

    If `s` is provided, the values will be coded, and it is up to the
    user to ensure correctness. If `s` is not provided, the geometries
    are expected to be added in order, and `s` will be calculated.

    Note
    ----
    Do not mix this method with `add_geometry`.

    Parameters
    ----------
    geom : Line, Spiral, ParamPoly3, or Arc
        The geometry to add.
    x_start : float
        Start x position of the geometry.
    y_start : float
        Start y position of the geometry.
    h_start : float
        Start heading of the geometry.
    s : float, optional
        Start s value of the geometry. Default is None.

    Returns
    -------
    PlanView
        The updated PlanView instance.

    Raises
    ------
    MixOfGeometryAddition
        If a geometry has already been added using `add_geometry`.
    &#34;&#34;&#34;

    if self._addition_mode == &#34;add_geometry&#34;:
        raise MixOfGeometryAddition(
            &#34;A geometry has already been added with add_geometry, please use either add_geometry, or add_fixed_geometry not both&#34;
        )

    if s != None:
        pres_s = s
    else:
        pres_s = self.present_s

    if not self.fixed:
        self.x_start = x_start
        self.y_start = y_start
        self.h_start = h_start
        self.fixed = True

    newgeom = _Geometry(pres_s, x_start, y_start, h_start, geom)
    self._adjusted_geometries.append(newgeom)
    self.x_end, self.y_end, self.h_end, length = newgeom.get_end_data()
    self.present_s += length
    self.adjusted = True
    self._addition_mode = &#34;add_fixed_geometry&#34;
    return self</code></pre>
</details>
<div class="desc"><p>Add a fixed geometry to the PlanView at a specific point.</p>
<p>If <code>s</code> is provided, the values will be coded, and it is up to the
user to ensure correctness. If <code>s</code> is not provided, the geometries
are expected to be added in order, and <code>s</code> will be calculated.</p>
<h2 id="note">Note</h2>
<p>Do not mix this method with <code>add_geometry</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geom</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a>, <a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a>, <a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a>,</code> or <code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code></dt>
<dd>The geometry to add.</dd>
<dt><strong><code>x_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start x position of the geometry.</dd>
<dt><strong><code>y_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start y position of the geometry.</dd>
<dt><strong><code>h_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start heading of the geometry.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start s value of the geometry. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.geometry.PlanView" href="#scenariogeneration.xodr.geometry.PlanView">PlanView</a></code></dt>
<dd>The updated PlanView instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MixOfGeometryAddition</code></dt>
<dd>If a geometry has already been added using <code>add_geometry</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.add_geometry"><code class="name flex">
<span>def <span class="ident">add_geometry</span></span>(<span>self,<br>geom: scenariogeneration.xodr.geometry._BaseGeometry,<br>heading: float | None = None) ‑> <a title="scenariogeneration.xodr.geometry.PlanView" href="#scenariogeneration.xodr.geometry.PlanView">PlanView</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geometry(
    self, geom: _BaseGeometry, heading: Optional[float] = None
) -&gt; &#34;PlanView&#34;:
    &#34;&#34;&#34;Add a geometry to the PlanView and stitch together all geometries in
    the order they are added.

    This method should be used together with the
    `adjust_roads_and_lanes` method in the OpenDrive class.

    Note
    ----
    Do not mix this method with `add_fixed_geometry`.

    Parameters
    ----------
    geom : _BaseGeometry
        The geometry to add. Must be an instance of `_BaseGeometry`.
    heading : float, optional
        Override the previous heading (not recommended). If used, it
        must be applied consistently for all geometries. Default is None.

    Returns
    -------
    PlanView
        The updated PlanView instance.

    Raises
    ------
    MixOfGeometryAddition
        If a fixed geometry has already been added.
    TypeError
        If `geom` is not an instance of `_BaseGeometry`.
    &#34;&#34;&#34;
    if self._addition_mode == &#34;add_fixed_geometry&#34;:
        raise MixOfGeometryAddition(
            &#34;A fixed geometry has already been added, please use either add_geometry or add_fixed_geometry&#34;
        )

    if heading is not None:
        self._overridden_headings.append(heading)
    if not isinstance(geom, _BaseGeometry):
        raise TypeError(&#34;geom_type is not of type _BaseGeometry.&#34;)
    self._raw_geometries.append(geom)
    self._addition_mode = &#34;add_geometry&#34;
    return self</code></pre>
</details>
<div class="desc"><p>Add a geometry to the PlanView and stitch together all geometries in
the order they are added.</p>
<p>This method should be used together with the
<code>adjust_roads_and_lanes</code> method in the OpenDrive class.</p>
<h2 id="note">Note</h2>
<p>Do not mix this method with <code>add_fixed_geometry</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geom</code></strong> :&ensp;<code>_BaseGeometry</code></dt>
<dd>The geometry to add. Must be an instance of <code>_BaseGeometry</code>.</dd>
<dt><strong><code>heading</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Override the previous heading (not recommended). If used, it
must be applied consistently for all geometries. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.geometry.PlanView" href="#scenariogeneration.xodr.geometry.PlanView">PlanView</a></code></dt>
<dd>The updated PlanView instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MixOfGeometryAddition</code></dt>
<dd>If a fixed geometry has already been added.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>geom</code> is not an instance of <code>_BaseGeometry</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.adjust_geometries"><code class="name flex">
<span>def <span class="ident">adjust_geometries</span></span>(<span>self, from_end: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_geometries(self, from_end: bool = False) -&gt; None:
    &#34;&#34;&#34;Adjust all geometries to have the correct start point and heading.

    Parameters
    ----------
    from_end : bool, optional
        Indicates whether `(self.present_x, self.present_y,
        self.present_h)` are interpreted as the starting point
        (`False`) or the ending point (`True`) of the geometry.
        Default is `False`.

    Returns
    -------
    None
    &#34;&#34;&#34;
    if from_end == False:
        self.x_start = self.present_x
        self.y_start = self.present_y
        self.h_start = self.present_h

        for i in range(len(self._raw_geometries)):
            if len(self._overridden_headings) &gt; 0:
                self.present_h = self._overridden_headings[i]

            newgeom = _Geometry(
                self.present_s,
                self.present_x,
                self.present_y,
                self.present_h,
                self._raw_geometries[i],
            )
            (
                self.present_x,
                self.present_y,
                self.present_h,
                length,
            ) = newgeom.get_end_data()
            self.present_s += length

            self._adjusted_geometries.append(newgeom)
        self.x_end = self.present_x
        self.y_end = self.present_y
        self.h_end = wrap_pi(self.present_h)

    else:
        self.x_end = self.present_x
        self.y_end = self.present_y
        self.h_end = self.present_h + np.pi

        lengths = []
        for i in range(len(self._raw_geometries) - 1, -1, -1):
            newgeom = _Geometry(
                self.present_s,
                self.present_x,
                self.present_y,
                self.present_h,
                self._raw_geometries[i],
            )
            (
                self.present_x,
                self.present_y,
                self.present_h,
                partial_length,
            ) = newgeom.get_start_data()
            lengths.append(partial_length)
            self._adjusted_geometries.append(newgeom)

        self.x_start = self.present_x
        self.y_start = self.present_y
        self.h_start = wrap_pi(self.present_h + np.pi)

        length = sum(lengths)
        self.present_s = 0

        for i in range(len(self._adjusted_geometries) - 1, -1, -1):
            self._adjusted_geometries[i].set_s(self.present_s)
            self.present_s += lengths[i]
        self._adjusted_geometries.reverse()
    self.h_start = wrap_pi(self.h_start)
    self.h_end = wrap_pi(self.h_end)
    self.adjusted = True</code></pre>
</details>
<div class="desc"><p>Adjust all geometries to have the correct start point and heading.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>from_end</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether <code>(self.present_x, self.present_y,
self.present_h)</code> are interpreted as the starting point
(<code>False</code>) or the ending point (<code>True</code>) of the geometry.
Default is <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the PlanView.

    This method generates an XML element for the PlanView, including
    all adjusted geometries.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the PlanView.
    &#34;&#34;&#34;

    element = ET.Element(&#34;planView&#34;)
    self._add_additional_data_to_element(element)
    for geom in self._adjusted_geometries:
        element.append(geom.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the PlanView.</p>
<p>This method generates an XML element for the PlanView, including
all adjusted geometries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the PlanView.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.get_end_point"><code class="name flex">
<span>def <span class="ident">get_end_point</span></span>(<span>self) ‑> tuple[float | None, float | None, float | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_point(
    self,
) -&gt; tuple[Optional[float], Optional[float], Optional[float]]:
    &#34;&#34;&#34;Return the end point of the PlanView.

    Returns
    -------
    tuple of (float or None, float or None, float or None)
        A tuple containing:
        - x_end : float or None
            The end x coordinate of the PlanView.
        - y_end : float or None
            The end y coordinate of the PlanView.
        - h_end : float or None
            The ending heading of the PlanView.
    &#34;&#34;&#34;

    return self.x_end, self.y_end, self.h_end</code></pre>
</details>
<div class="desc"><p>Return the end point of the PlanView.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float</code> or <code>None, float</code> or <code>None, float</code> or <code>None)</code></dt>
<dd>A tuple containing:
- x_end : float or None
The end x coordinate of the PlanView.
- y_end : float or None
The end y coordinate of the PlanView.
- h_end : float or None
The ending heading of the PlanView.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.get_start_point"><code class="name flex">
<span>def <span class="ident">get_start_point</span></span>(<span>self) ‑> tuple[float | None, float | None, float | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_point(
    self,
) -&gt; tuple[Optional[float], Optional[float], Optional[float]]:
    &#34;&#34;&#34;Return the start point of the PlanView.

    Returns
    -------
    tuple of (float or None, float or None, float or None)
        A tuple containing:
        - x_start : float or None
            The start x coordinate of the PlanView.
        - y_start : float or None
            The start y coordinate of the PlanView.
        - h_start : float or None
            The starting heading of the PlanView.
    &#34;&#34;&#34;

    return self.x_start, self.y_start, self.h_start
    # return self._adjusted_geometries[-1].get_end_point</code></pre>
</details>
<div class="desc"><p>Return the start point of the PlanView.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float</code> or <code>None, float</code> or <code>None, float</code> or <code>None)</code></dt>
<dd>A tuple containing:
- x_start : float or None
The start x coordinate of the PlanView.
- y_start : float or None
The start y coordinate of the PlanView.
- h_start : float or None
The starting heading of the PlanView.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.get_total_length"><code class="name flex">
<span>def <span class="ident">get_total_length</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_total_length(self) -&gt; float:
    &#34;&#34;&#34;Return the total length of the PlanView.

    If the geometries have been adjusted, the total length is
    calculated based on the adjusted geometries. Otherwise, it is
    calculated based on the raw geometries.

    Returns
    -------
    float
        The total length of the PlanView.
    &#34;&#34;&#34;
    if self.adjusted:
        return self.present_s
    else:
        return sum([x.length for x in self._raw_geometries])</code></pre>
</details>
<div class="desc"><p>Return the total length of the PlanView.</p>
<p>If the geometries have been adjusted, the total length is
calculated based on the adjusted geometries. Otherwise, it is
calculated based on the raw geometries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The total length of the PlanView.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.PlanView.set_start_point"><code class="name flex">
<span>def <span class="ident">set_start_point</span></span>(<span>self, x_start: float = 0, y_start: float = 0, h_start: float = 0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_start_point(
    self, x_start: float = 0, y_start: float = 0, h_start: float = 0
) -&gt; None:
    &#34;&#34;&#34;Set the start point of the PlanView.

    Parameters
    ----------
    x_start : float, optional
        Start x coordinate of the first geometry. Default is 0.
    y_start : float, optional
        Start y coordinate of the first geometry. Default is 0.
    h_start : float, optional
        Starting heading of the first geometry. Default is 0.

    Returns
    -------
    None
    &#34;&#34;&#34;

    self.present_x = x_start
    self.present_y = y_start
    self.present_h = h_start
    self.fixed = True</code></pre>
</details>
<div class="desc"><p>Set the start point of the PlanView.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start x coordinate of the first geometry. Default is 0.</dd>
<dt><strong><code>y_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start y coordinate of the first geometry. Default is 0.</dd>
<dt><strong><code>h_start</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting heading of the first geometry. Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.geometry.Spiral"><code class="flex name class">
<span>class <span class="ident">Spiral</span></span>
<span>(</span><span>curvstart: float,<br>curvend: float,<br>length: float | None = None,<br>angle: float | None = None,<br>cdot: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spiral(_BaseGeometry):
    &#34;&#34;&#34;The `Spiral` (Clothoid) class creates a spiral type of geometry.

    Parameters
    ----------
    curvstart : float
        Starting curvature of the spiral.
    curvend : float
        Final curvature of the spiral.
    length : float, optional
        Length of the spiral. Either `length`, `angle`, or `cdot` must
        be provided.
    angle : float, optional
        Angle of the spiral. Either `length`, `angle`, or `cdot` must
        be provided.
    cdot : float, optional
        Curvature change of the spiral. Either `length`, `angle`, or
        `cdot` must be provided.

    Attributes
    ----------
    curvstart : float
        Starting curvature of the spiral.
    curvend : float
        Final curvature of the spiral.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    get_end_data(x, y, h)
        Returns the end point of the geometry.
    get_start_data(end_x, end_y, end_h)
        Returns the start point of the geometry.
    &#34;&#34;&#34;

    def __init__(
        self,
        curvstart: float,
        curvend: float,
        length: Optional[float] = None,
        angle: Optional[float] = None,
        cdot: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the `Spiral` instance.

        Parameters
        ----------
        curvstart : float
            Starting curvature of the spiral.
        curvend : float
            Final curvature of the spiral.
        length : float, optional
            Length of the spiral. Either `length`, `angle`, or `cdot` must
            be provided.
        angle : float, optional
            Angle of the spiral. Either `length`, `angle`, or `cdot` must
            be provided.
        cdot : float, optional
            Curvature change of the spiral. Either `length`, `angle`, or
            `cdot` must be provided.

        Raises
        ------
        NotEnoughInputArguments
            If none of `length`, `angle`, or `cdot` is provided.
        ToManyOptionalArguments
            If more than one of `length`, `angle`, or `cdot` is provided.
        &#34;&#34;&#34;
        super().__init__()
        self.curvstart = curvstart
        self.curvend = curvend
        if length == None and angle == None and cdot == None:
            raise NotEnoughInputArguments(&#34;Spiral is underdefined&#34;)
        if sum([x != None for x in [length, angle, cdot]]) &gt; 1:
            raise ToManyOptionalArguments(
                &#34;Spiral is overdefined, please use only one of the optional inputs&#34;
            )
        if angle:
            self.length = (
                2 * abs(angle) / np.maximum(abs(curvend), abs(curvstart))
            )

        elif cdot:
            self.length = (self.curvend - self.curvstart) / cdot
        else:
            self.length = length

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Spiral) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_end_data(
        self, x: float, y: float, h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns the end point of the geometry.

        Parameters
        ----------
        x : float
            The x start coordinate of the geometry.
        y : float
            The y start coordinate of the geometry.
        h : float
            The start heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_end : float
                The x end coordinate of the geometry.
            - y_end : float
                The y end coordinate of the geometry.
            - h_end : float
                The end heading of the geometry.
            - length : float
                The length of the spiral.
        &#34;&#34;&#34;

        cloth = pcloth.Clothoid.StandardParams(
            x,
            y,
            h,
            self.curvstart,
            (self.curvend - self.curvstart) / self.length,
            self.length,
        )

        return cloth.XEnd, cloth.YEnd, cloth.ThetaEnd, cloth.length

    def get_start_data(
        self, end_x: float, end_y: float, end_h: float
    ) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns the start point of the geometry.

        Parameters
        ----------
        end_x : float
            The x end coordinate of the geometry.
        end_y : float
            The y end coordinate of the geometry.
        end_h : float
            The end heading of the geometry.

        Returns
        -------
        tuple of (float, float, float, float)
            A tuple containing:
            - x_start : float
                The start x coordinate of the geometry.
            - y_start : float
                The start y coordinate of the geometry.
            - h_start : float
                The start heading of the inverse geometry.
            - length : float
                The length of the spiral.
        &#34;&#34;&#34;
        cloth = pcloth.Clothoid.StandardParams(
            end_x,
            end_y,
            end_h,
            -self.curvend,
            -(self.curvstart - self.curvend) / self.length,
            self.length,
        )

        return cloth.XEnd, cloth.YEnd, cloth.ThetaEnd, cloth.length

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the `Spiral` as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the `Spiral`:
            - &#34;curvStart&#34; : str
                Starting curvature of the spiral.
            - &#34;curvEnd&#34; : str
                Final curvature of the spiral.
        &#34;&#34;&#34;
        return {&#34;curvStart&#34;: str(self.curvstart), &#34;curvEnd&#34;: str(self.curvend)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the `Spiral`.

        This method generates an XML element for the `Spiral`, including
        its attributes and any additional data.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the `Spiral`.
        &#34;&#34;&#34;
        element = ET.Element(&#34;spiral&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>The <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code> (Clothoid) class creates a spiral type of geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>curvstart</code></strong> :&ensp;<code>float</code></dt>
<dd>Starting curvature of the spiral.</dd>
<dt><strong><code>curvend</code></strong> :&ensp;<code>float</code></dt>
<dd>Final curvature of the spiral.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the spiral. Either <code>length</code>, <code>angle</code>, or <code>cdot</code> must
be provided.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Angle of the spiral. Either <code>length</code>, <code>angle</code>, or <code>cdot</code> must
be provided.</dd>
<dt><strong><code>cdot</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Curvature change of the spiral. Either <code>length</code>, <code>angle</code>, or
<code>cdot</code> must be provided.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>curvstart</code></strong> :&ensp;<code>float</code></dt>
<dd>Starting curvature of the spiral.</dd>
<dt><strong><code>curvend</code></strong> :&ensp;<code>float</code></dt>
<dd>Final curvature of the spiral.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns a dictionary of all attributes of the class.
get_end_data(x, y, h)
Returns the end point of the geometry.
get_start_data(end_x, end_y, end_h)
Returns the start point of the geometry.</p>
<p>Initialize the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code> instance.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>curvstart</code></strong> :&ensp;<code>float</code></dt>
<dd>Starting curvature of the spiral.</dd>
<dt><strong><code>curvend</code></strong> :&ensp;<code>float</code></dt>
<dd>Final curvature of the spiral.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the spiral. Either <code>length</code>, <code>angle</code>, or <code>cdot</code> must
be provided.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Angle of the spiral. Either <code>length</code>, <code>angle</code>, or <code>cdot</code> must
be provided.</dd>
<dt><strong><code>cdot</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Curvature change of the spiral. Either <code>length</code>, <code>angle</code>, or
<code>cdot</code> must be provided.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughInputArguments</code></dt>
<dd>If none of <code>length</code>, <code>angle</code>, or <code>cdot</code> is provided.</dd>
<dt><code>ToManyOptionalArguments</code></dt>
<dd>If more than one of <code>length</code>, <code>angle</code>, or <code>cdot</code> is provided.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.geometry._BaseGeometry</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.geometry.Spiral.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the `Spiral` as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the `Spiral`:
        - &#34;curvStart&#34; : str
            Starting curvature of the spiral.
        - &#34;curvEnd&#34; : str
            Final curvature of the spiral.
    &#34;&#34;&#34;
    return {&#34;curvStart&#34;: str(self.curvstart), &#34;curvEnd&#34;: str(self.curvend)}</code></pre>
</details>
<div class="desc"><p>Return the attributes of the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code> as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code>:
- "curvStart" : str
Starting curvature of the spiral.
- "curvEnd" : str
Final curvature of the spiral.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Spiral.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the `Spiral`.

    This method generates an XML element for the `Spiral`, including
    its attributes and any additional data.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the `Spiral`.
    &#34;&#34;&#34;
    element = ET.Element(&#34;spiral&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code>.</p>
<p>This method generates an XML element for the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code>, including
its attributes and any additional data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the <code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Spiral.get_end_data"><code class="name flex">
<span>def <span class="ident">get_end_data</span></span>(<span>self, x: float, y: float, h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_data(
    self, x: float, y: float, h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns the end point of the geometry.

    Parameters
    ----------
    x : float
        The x start coordinate of the geometry.
    y : float
        The y start coordinate of the geometry.
    h : float
        The start heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_end : float
            The x end coordinate of the geometry.
        - y_end : float
            The y end coordinate of the geometry.
        - h_end : float
            The end heading of the geometry.
        - length : float
            The length of the spiral.
    &#34;&#34;&#34;

    cloth = pcloth.Clothoid.StandardParams(
        x,
        y,
        h,
        self.curvstart,
        (self.curvend - self.curvstart) / self.length,
        self.length,
    )

    return cloth.XEnd, cloth.YEnd, cloth.ThetaEnd, cloth.length</code></pre>
</details>
<div class="desc"><p>Returns the end point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x start coordinate of the geometry.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y start coordinate of the geometry.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The start heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_end : float
The x end coordinate of the geometry.
- y_end : float
The y end coordinate of the geometry.
- h_end : float
The end heading of the geometry.
- length : float
The length of the spiral.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.geometry.Spiral.get_start_data"><code class="name flex">
<span>def <span class="ident">get_start_data</span></span>(<span>self, end_x: float, end_y: float, end_h: float) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_data(
    self, end_x: float, end_y: float, end_h: float
) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns the start point of the geometry.

    Parameters
    ----------
    end_x : float
        The x end coordinate of the geometry.
    end_y : float
        The y end coordinate of the geometry.
    end_h : float
        The end heading of the geometry.

    Returns
    -------
    tuple of (float, float, float, float)
        A tuple containing:
        - x_start : float
            The start x coordinate of the geometry.
        - y_start : float
            The start y coordinate of the geometry.
        - h_start : float
            The start heading of the inverse geometry.
        - length : float
            The length of the spiral.
    &#34;&#34;&#34;
    cloth = pcloth.Clothoid.StandardParams(
        end_x,
        end_y,
        end_h,
        -self.curvend,
        -(self.curvstart - self.curvend) / self.length,
        self.length,
    )

    return cloth.XEnd, cloth.YEnd, cloth.ThetaEnd, cloth.length</code></pre>
</details>
<div class="desc"><p>Returns the start point of the geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>end_x</code></strong> :&ensp;<code>float</code></dt>
<dd>The x end coordinate of the geometry.</dd>
<dt><strong><code>end_y</code></strong> :&ensp;<code>float</code></dt>
<dd>The y end coordinate of the geometry.</dd>
<dt><strong><code>end_h</code></strong> :&ensp;<code>float</code></dt>
<dd>The end heading of the geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(float, float, float, float)</code></dt>
<dd>A tuple containing:
- x_start : float
The start x coordinate of the geometry.
- y_start : float
The start y coordinate of the geometry.
- h_start : float
The start heading of the inverse geometry.
- length : float
The length of the spiral.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scenariogeneration.xodr.geometry.wrap_pi" href="#scenariogeneration.xodr.geometry.wrap_pi">wrap_pi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.AdjustablePlanview" href="#scenariogeneration.xodr.geometry.AdjustablePlanview">AdjustablePlanview</a></code></h4>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.Arc" href="#scenariogeneration.xodr.geometry.Arc">Arc</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.geometry.Arc.get_attributes" href="#scenariogeneration.xodr.geometry.Arc.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Arc.get_element" href="#scenariogeneration.xodr.geometry.Arc.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Arc.get_end_data" href="#scenariogeneration.xodr.geometry.Arc.get_end_data">get_end_data</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Arc.get_start_data" href="#scenariogeneration.xodr.geometry.Arc.get_start_data">get_start_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.Line" href="#scenariogeneration.xodr.geometry.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.geometry.Line.get_element" href="#scenariogeneration.xodr.geometry.Line.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Line.get_end_data" href="#scenariogeneration.xodr.geometry.Line.get_end_data">get_end_data</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Line.get_start_data" href="#scenariogeneration.xodr.geometry.Line.get_start_data">get_start_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.ParamPoly3" href="#scenariogeneration.xodr.geometry.ParamPoly3">ParamPoly3</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.geometry.ParamPoly3.get_attributes" href="#scenariogeneration.xodr.geometry.ParamPoly3.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.ParamPoly3.get_element" href="#scenariogeneration.xodr.geometry.ParamPoly3.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.ParamPoly3.get_end_data" href="#scenariogeneration.xodr.geometry.ParamPoly3.get_end_data">get_end_data</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.ParamPoly3.get_start_data" href="#scenariogeneration.xodr.geometry.ParamPoly3.get_start_data">get_start_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.PlanView" href="#scenariogeneration.xodr.geometry.PlanView">PlanView</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.add_fixed_geometry" href="#scenariogeneration.xodr.geometry.PlanView.add_fixed_geometry">add_fixed_geometry</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.add_geometry" href="#scenariogeneration.xodr.geometry.PlanView.add_geometry">add_geometry</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.adjust_geometries" href="#scenariogeneration.xodr.geometry.PlanView.adjust_geometries">adjust_geometries</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.get_element" href="#scenariogeneration.xodr.geometry.PlanView.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.get_end_point" href="#scenariogeneration.xodr.geometry.PlanView.get_end_point">get_end_point</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.get_start_point" href="#scenariogeneration.xodr.geometry.PlanView.get_start_point">get_start_point</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.get_total_length" href="#scenariogeneration.xodr.geometry.PlanView.get_total_length">get_total_length</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.PlanView.set_start_point" href="#scenariogeneration.xodr.geometry.PlanView.set_start_point">set_start_point</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.geometry.Spiral" href="#scenariogeneration.xodr.geometry.Spiral">Spiral</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.geometry.Spiral.get_attributes" href="#scenariogeneration.xodr.geometry.Spiral.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Spiral.get_element" href="#scenariogeneration.xodr.geometry.Spiral.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Spiral.get_end_data" href="#scenariogeneration.xodr.geometry.Spiral.get_end_data">get_end_data</a></code></li>
<li><code><a title="scenariogeneration.xodr.geometry.Spiral.get_start_data" href="#scenariogeneration.xodr.geometry.Spiral.get_start_data">get_start_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
