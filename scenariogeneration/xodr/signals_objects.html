<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xodr.signals_objects API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.signals_objects</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.CornerLocal"><code class="flex name class">
<span>class <span class="ident">CornerLocal</span></span>
<span>(</span><span>u: float, v: float, z: float, height: float, id: int | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CornerLocal(XodrBase):
    &#34;&#34;&#34;CornerLocal is one way to describe an outline for objects.

    Attributes
    ----------
    u : float
        Local u-coordinate.
    v : float
        Local v-coordinate.
    z : float
        Local z-coordinate.
    height : float
        Height of the object at this corner.
    id : int, optional
        ID of the point.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the CornerLocal.
    get_attributes()
        Returns a dictionary of all attributes of the CornerLocal.
    &#34;&#34;&#34;

    def __init__(
        self,
        u: float,
        v: float,
        z: float,
        height: float,
        id: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the CornerLocal.

        Parameters
        ----------
        u : float
            Local u-coordinate.
        v : float
            Local v-coordinate.
        z : float
            Local z-coordinate.
        height : float
            Height of the object at this corner.
        id : int, optional
            ID of the point. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.u = u
        self.v = v
        self.z = z
        self.height = height
        self.id = id

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, CornerLocal) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the CornerLocal as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the CornerLocal.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;u&#34;] = str(self.u)
        retdict[&#34;v&#34;] = str(self.v)
        retdict[&#34;z&#34;] = str(self.z)
        retdict[&#34;height&#34;] = str(self.height)
        if self.id is not None:
            retdict[&#34;id&#34;] = str(self.id)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the CornerLocal.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the CornerLocal.
        &#34;&#34;&#34;
        element = ET.Element(&#34;cornerLocal&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>CornerLocal is one way to describe an outline for objects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>Local u-coordinate.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>Local v-coordinate.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Local z-coordinate.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Height of the object at this corner.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the point.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the CornerLocal.
get_attributes()
Returns a dictionary of all attributes of the CornerLocal.</p>
<p>Initialize the CornerLocal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>Local u-coordinate.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>Local v-coordinate.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Local z-coordinate.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Height of the object at this corner.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the point. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.CornerLocal.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the CornerLocal as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the CornerLocal.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;u&#34;] = str(self.u)
    retdict[&#34;v&#34;] = str(self.v)
    retdict[&#34;z&#34;] = str(self.z)
    retdict[&#34;height&#34;] = str(self.height)
    if self.id is not None:
        retdict[&#34;id&#34;] = str(self.id)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the CornerLocal as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the CornerLocal.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.CornerLocal.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the CornerLocal.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the CornerLocal.
    &#34;&#34;&#34;
    element = ET.Element(&#34;cornerLocal&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the CornerLocal.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the CornerLocal.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.CornerRoad"><code class="flex name class">
<span>class <span class="ident">CornerRoad</span></span>
<span>(</span><span>s: float, t: float, dz: float, height: float, id: int | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CornerRoad(XodrBase):
    &#34;&#34;&#34;CornerRoad is one way to describe an outline for objects.

    Attributes
    ----------
    s : float
        s-coordinate of the corner.
    t : float
        t-coordinate of the corner.
    dz : float
        z-coordinate relative to the road.
    height : float
        Height of the object at this corner.
    id : int, optional
        ID of the point.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the CornerRoad.
    get_attributes()
        Returns a dictionary of all attributes of the CornerRoad.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        t: float,
        dz: float,
        height: float,
        id: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the CornerRoad.

        Parameters
        ----------
        s : float
            s-coordinate of the corner.
        t : float
            t-coordinate of the corner.
        dz : float
            z-coordinate relative to the road.
        height : float
            Height of the object at this corner.
        id : int, optional
            ID of the point. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.s = s
        self.t = t
        self.dz = dz
        self.height = height
        self.id = id

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, CornerRoad) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the CornerRoad as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the CornerRoad.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;t&#34;] = str(self.t)
        retdict[&#34;dz&#34;] = str(self.dz)
        retdict[&#34;height&#34;] = str(self.height)
        if self.id is not None:
            retdict[&#34;id&#34;] = str(self.id)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the CornerRoad.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the CornerRoad.
        &#34;&#34;&#34;
        element = ET.Element(&#34;cornerRoad&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>CornerRoad is one way to describe an outline for objects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the corner.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the corner.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate relative to the road.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Height of the object at this corner.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the point.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the CornerRoad.
get_attributes()
Returns a dictionary of all attributes of the CornerRoad.</p>
<p>Initialize the CornerRoad.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the corner.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the corner.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate relative to the road.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Height of the object at this corner.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the point. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.CornerRoad.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the CornerRoad as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the CornerRoad.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;t&#34;] = str(self.t)
    retdict[&#34;dz&#34;] = str(self.dz)
    retdict[&#34;height&#34;] = str(self.height)
    if self.id is not None:
        retdict[&#34;id&#34;] = str(self.id)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the CornerRoad as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the CornerRoad.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.CornerRoad.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the CornerRoad.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the CornerRoad.
    &#34;&#34;&#34;
    element = ET.Element(&#34;cornerRoad&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the CornerRoad.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the CornerRoad.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Dependency"><code class="flex name class">
<span>class <span class="ident">Dependency</span></span>
<span>(</span><span>id: str, type: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dependency(XodrBase):
    &#34;&#34;&#34;Dependency defines the dependency element in OpenDRIVE. It is placed
    within the signal element.

    Attributes
    ----------
    id : str
        ID of the controlled signal.
    type : str
        Type of dependency.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the Dependency.
    get_attributes()
        Returns a dictionary of all attributes of the Dependency.
    &#34;&#34;&#34;

    def __init__(self, id: str, type: str) -&gt; None:
        &#34;&#34;&#34;Initialize the Dependency.

        Parameters
        ----------
        id : str
            ID of the controlled signal.
        type : str
            Type of dependency.
        &#34;&#34;&#34;
        super().__init__()
        self.id = id
        self.type = type

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Dependency) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the Dependency as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Dependency.
        &#34;&#34;&#34;
        retdict = {&#34;id&#34;: str(self.id), &#34;type&#34;: str(self.type)}
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Dependency.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Dependency.
        &#34;&#34;&#34;
        element = ET.Element(&#34;dependency&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>Dependency defines the dependency element in OpenDRIVE. It is placed
within the signal element.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the controlled signal.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of dependency.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the Dependency.
get_attributes()
Returns a dictionary of all attributes of the Dependency.</p>
<p>Initialize the Dependency.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the controlled signal.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of dependency.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Dependency.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the Dependency as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Dependency.
    &#34;&#34;&#34;
    retdict = {&#34;id&#34;: str(self.id), &#34;type&#34;: str(self.type)}
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Dependency as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Dependency.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Dependency.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Dependency.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Dependency.
    &#34;&#34;&#34;
    element = ET.Element(&#34;dependency&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Dependency.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Dependency.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Marking"><code class="flex name class">
<span>class <span class="ident">Marking</span></span>
<span>(</span><span>color: <a title="scenariogeneration.xodr.enumerations.RoadMarkColor" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkColor">RoadMarkColor</a>,<br>lineLength: float,<br>side: <a title="scenariogeneration.xodr.enumerations.SideType" href="enumerations.html#scenariogeneration.xodr.enumerations.SideType">SideType</a>,<br>spaceLength: float,<br>startOffset: float,<br>stopOffset: float,<br>weight: <a title="scenariogeneration.xodr.enumerations.RoadMarkWeight" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkWeight">RoadMarkWeight</a> | None = None,<br>width: float | None = None,<br>zOffset: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Marking(XodrBase):
    &#34;&#34;&#34;Marking describes the road marks of any objects like crosswalks,
    stopping-lines, and parking spaces. Marking is defined either in accordance
    to the bounding box of the element or by referencing outline points of the
    object.

    Attributes
    ----------
    color : RoadMarkColor
        Color of the marking.
    lineLength : float
        Length of the visible part.
    side : SideType
        Side of the bounding box described in &lt;object&gt; element in the local
        coordinate system u/v
    spaceLength : float
        ength of the gap between the visible parts.
    startOffset : float
        Lateral offset in u-direction from start of bounding box side where
        the first marking starts
    stopOffset : float
        Lateral offset in u-direction from end of bounding box side where the
        marking ends
    weight : RoadMarkWeight, optional
        Optical &#34;weight&#34; of the marking
    width : float, optional
        Width of the marking
    zOffset : float, optional
        Height of road mark above the road, i.e. thickness of the road mark

    Methods
    -------
    add_cornerReference(corner)
        Adds a cornerReference to the Marking.
    get_element()
        Returns the full ElementTree representation of the Marking.
    get_attributes()
        Returns a dictionary of all attributes of the Marking.
    &#34;&#34;&#34;

    def __init__(
        self,
        color: RoadMarkColor,
        lineLength: float,
        side: SideType,
        spaceLength: float,
        startOffset: float,
        stopOffset: float,
        weight: Optional[RoadMarkWeight] = None,
        width: Optional[float] = None,
        zOffset: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Marking.&#34;&#34;&#34;
        super().__init__()
        self.color = enumchecker(color, RoadMarkColor)
        self.lineLength = lineLength
        self.side = enumchecker(side, SideType)
        self.spaceLength = spaceLength
        self.startOffset = startOffset
        self.stopOffset = stopOffset
        self.weight = enumchecker(weight, RoadMarkWeight, True)
        self.width = width
        self.zOffset = zOffset
        self.cornerReferences = []

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Marking) and super().__eq__(other):
            if (
                self.get_attributes() == other.get_attributes()
                and self.cornerReferences == other.cornerReferences
            ):
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the Marking as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Marking.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;color&#34;] = enum2str(self.color)
        retdict[&#34;lineLength&#34;] = str(self.lineLength)
        retdict[&#34;side&#34;] = enum2str(self.side)
        retdict[&#34;spaceLength&#34;] = str(self.spaceLength)
        retdict[&#34;startOffset&#34;] = str(self.startOffset)
        retdict[&#34;stopOffset&#34;] = str(self.stopOffset)
        if self.weight is not None:
            retdict[&#34;weight&#34;] = enum2str(self.weight)
        if self.width is not None:
            retdict[&#34;width&#34;] = str(self.width)
        if self.zOffset is not None:
            retdict[&#34;zOffset&#34;] = str(self.zOffset)
        return retdict

    def add_cornerReference(self, cornerReference: int) -&gt; None:
        &#34;&#34;&#34;Add a cornerReference to the Marking.

        Parameters
        ----------
        cornerReference : int
            The cornerReference to add.
        &#34;&#34;&#34;
        self.cornerReferences.append(cornerReference)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Marking.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Marking.
        &#34;&#34;&#34;
        element = ET.Element(&#34;marking&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        for cornerReference in self.cornerReferences:
            ET.SubElement(
                element, &#34;cornerReference&#34;, attrib={&#34;id&#34;: str(cornerReference)}
            )

        return element</code></pre>
</details>
<div class="desc"><p>Marking describes the road marks of any objects like crosswalks,
stopping-lines, and parking spaces. Marking is defined either in accordance
to the bounding box of the element or by referencing outline points of the
object.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>RoadMarkColor</code></dt>
<dd>Color of the marking.</dd>
<dt><strong><code>lineLength</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the visible part.</dd>
<dt><strong><code>side</code></strong> :&ensp;<code>SideType</code></dt>
<dd>Side of the bounding box described in <object> element in the local
coordinate system u/v</dd>
<dt><strong><code>spaceLength</code></strong> :&ensp;<code>float</code></dt>
<dd>ength of the gap between the visible parts.</dd>
<dt><strong><code>startOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset in u-direction from start of bounding box side where
the first marking starts</dd>
<dt><strong><code>stopOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset in u-direction from end of bounding box side where the
marking ends</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>RoadMarkWeight</code>, optional</dt>
<dd>Optical "weight" of the marking</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the marking</dd>
<dt><strong><code>zOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height of road mark above the road, i.e. thickness of the road mark</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>add_cornerReference(corner)
Adds a cornerReference to the Marking.
get_element()
Returns the full ElementTree representation of the Marking.
get_attributes()
Returns a dictionary of all attributes of the Marking.</p>
<p>Initialize the Marking.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Marking.add_cornerReference"><code class="name flex">
<span>def <span class="ident">add_cornerReference</span></span>(<span>self, cornerReference: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cornerReference(self, cornerReference: int) -&gt; None:
    &#34;&#34;&#34;Add a cornerReference to the Marking.

    Parameters
    ----------
    cornerReference : int
        The cornerReference to add.
    &#34;&#34;&#34;
    self.cornerReferences.append(cornerReference)</code></pre>
</details>
<div class="desc"><p>Add a cornerReference to the Marking.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cornerReference</code></strong> :&ensp;<code>int</code></dt>
<dd>The cornerReference to add.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Marking.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the Marking as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Marking.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;color&#34;] = enum2str(self.color)
    retdict[&#34;lineLength&#34;] = str(self.lineLength)
    retdict[&#34;side&#34;] = enum2str(self.side)
    retdict[&#34;spaceLength&#34;] = str(self.spaceLength)
    retdict[&#34;startOffset&#34;] = str(self.startOffset)
    retdict[&#34;stopOffset&#34;] = str(self.stopOffset)
    if self.weight is not None:
        retdict[&#34;weight&#34;] = enum2str(self.weight)
    if self.width is not None:
        retdict[&#34;width&#34;] = str(self.width)
    if self.zOffset is not None:
        retdict[&#34;zOffset&#34;] = str(self.zOffset)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Marking as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Marking.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Marking.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Marking.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Marking.
    &#34;&#34;&#34;
    element = ET.Element(&#34;marking&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    for cornerReference in self.cornerReferences:
        ET.SubElement(
            element, &#34;cornerReference&#34;, attrib={&#34;id&#34;: str(cornerReference)}
        )

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Marking.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Marking.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object"><code class="flex name class">
<span>class <span class="ident">Object</span></span>
<span>(</span><span>s: float,<br>t: float,<br>Type: <a title="scenariogeneration.xodr.enumerations.ObjectType" href="enumerations.html#scenariogeneration.xodr.enumerations.ObjectType">ObjectType</a> | str = ObjectType.none,<br>subtype: str | None = None,<br>id: str | None = None,<br>name: str | None = None,<br>dynamic: <a title="scenariogeneration.xodr.enumerations.Dynamic" href="enumerations.html#scenariogeneration.xodr.enumerations.Dynamic">Dynamic</a> = Dynamic.no,<br>zOffset: float = 0,<br>orientation: <a title="scenariogeneration.xodr.enumerations.Orientation" href="enumerations.html#scenariogeneration.xodr.enumerations.Orientation">Orientation</a> = Orientation.none,<br>hdg: float = 0,<br>pitch: float = 0,<br>roll: float = 0,<br>width: float | None = None,<br>length: float | None = None,<br>height: float | None = None,<br>radius: float | None = None,<br>validLength: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Object(_SignalObjectBase):
    &#34;&#34;&#34;Creates an Object in OpenDRIVE.

    Attributes
    ----------
    s : float
        s-coordinate of the Object (inherited from base class).
    t : float
        t-coordinate of the Object (inherited from base class).
    type : ObjectType or str
        Type of the Object (typically enum ObjectType, inherited from base class).
    subtype : str
        Subtype for further specification of the Object (inherited from base class).
    id : str, optional
        ID of the Object (inherited from base class).
    name : str, optional
        Name for identification of the Object (inherited from base class).
    dynamic : Dynamic
        Specifies if the Object is static or dynamic (inherited from base class).
    zOffset : float
        Vertical offset of the Object with respect to the centerline (inherited from base class).
    orientation : Orientation
        Orientation of the Object with respect to the road (inherited from base class).
    hdg : float
        Heading angle (rad) of the Object relative to the road direction.
    pitch : float
        Pitch angle (rad) of the Object relative to the inertial system (inherited from base class).
    roll : float
        Roll angle (rad) of the Object after applying pitch (inherited from base class).
    width : float, optional
        Width of the Object (inherited from base class).
    length : float, optional
        Length of the Object (shall not be used with radius).
    height : float, optional
        Height of the Object (inherited from base class).
    radius : float, optional
        Radius of the Object (shall not be used with width/length).
    validLength : float, optional
        Validity of the Object along the s-coordinate.
    _repeats : list[dict]
        List of dictionaries containing attributes for repeating Objects.
    validity : Validity, optional
        Explicit validity information for the Object.
    outlines : list[Outline]
        List of outlines for the Object.
    markings : list[Marking]
        List of markings for the Object.
    parking_space : ParkingSpace, optional
        Parking space information for the Object.
    materials : list[Material]
        List of materials for the Object.

    Methods
    -------
    repeat(...)
        Adds a dictionary to `_repeats` to create a subelement for repeating the Object.
    add_outline(outline)
        Adds an outline to the Object.
    add_parking_space(parking_space)
        Adds a parking space to the Object.
    get_element()
        Returns the full ElementTree representation of the Object.
    get_attributes()
        Returns a dictionary of all attributes of the Object.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        t: float,
        Type: Union[ObjectType, str] = ObjectType.none,
        subtype: Optional[str] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        dynamic: Dynamic = Dynamic.no,
        zOffset: float = 0,
        orientation: Orientation = Orientation.none,
        hdg: float = 0,
        pitch: float = 0,
        roll: float = 0,
        width: Optional[float] = None,
        length: Optional[float] = None,
        height: Optional[float] = None,
        radius: Optional[float] = None,
        validLength: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Object.

        Parameters
        ----------
        s : float
            s-coordinate of the Object.
        t : float
            t-coordinate of the Object.
        Type : ObjectType or str, optional
            Type of the Object. Default is ObjectType.none.
        subtype : str, optional
            Subtype for further specification of the Object. Default is None.
        id : str, optional
            ID of the Object. Default is None.
        name : str, optional
            Name for identification of the Object. Default is None.
        dynamic : Dynamic, optional
            Specifies if the Object is static or dynamic. Default is Dynamic.no.
        zOffset : float, optional
            Vertical offset of the Object with respect to the centerline. Default is 0.
        orientation : Orientation, optional
            Orientation of the Object with respect to the road. Default is Orientation.none.
        hdg : float, optional
            Heading angle (rad) of the Object relative to the road direction. Default is 0.
        pitch : float, optional
            Pitch angle (rad) of the Object relative to the inertial system. Default is 0.
        roll : float, optional
            Roll angle (rad) of the Object after applying pitch. Default is 0.
        width : float, optional
            Width of the Object. Default is None.
        length : float, optional
            Length of the Object. Default is None.
        height : float, optional
            Height of the Object. Default is None.
        radius : float, optional
            Radius of the Object. Default is None.
        validLength : float, optional
            Validity of the Object along the s-coordinate. Default is None.
        &#34;&#34;&#34;
        # get attributes that are common with signals
        super().__init__(
            s,
            t,
            id,
            Type,
            subtype,
            dynamic,
            name,
            zOffset,
            orientation,
            pitch,
            roll,
            width,
            height,
            length,
        )

        # attributes that differ from signals
        self.validLength = validLength
        self.length = length
        self.hdg = hdg
        self.radius = radius

        # list for repeat entries
        self._repeats = []
        self.outlines = []
        self.markings = []
        self.materials = []
        self.validity = None
        self.parking_space = None

        # check if width/length combination or radius was provided and ensure working defaults
        if radius is not None and (width is not None or length is not None):
            print(
                &#34;Object with id&#34;,
                self.id,
                &#34;was provided with radius, width and/or length. Provide either radius or width and length. Using radius as fallback.&#34;,
            )
            self.width = None
            self.length = None
        elif width is not None and length is None:
            print(
                &#34;Object with id&#34;,
                self.id,
                &#34;was provided with width, but length is missing. Using 0 as fallback.&#34;,
            )
            self.length = 0
        elif length is not None and width is None:
            print(
                &#34;Object with id&#34;,
                self.id,
                &#34;was provided with length, but width is missing. Using 0 as fallback.&#34;,
            )
            self.width = 0
        else:
            pass

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Object) and super().__eq__(other):
            if (
                self.get_attributes() == other.get_attributes()
                and self._repeats == other._repeats
                and self.outlines == other.outlines
                and self.markings == other.markings
                and self.validity == other.validity
                and self.parking_space == other.parking_space
                and self.materials == other.materials
            ):
                return True
        return False

    def repeat(
        self,
        repeatLength: float,
        repeatDistance: float,
        sStart: Optional[float] = None,
        tStart: Optional[float] = None,
        tEnd: Optional[float] = None,
        heightStart: Optional[float] = None,
        heightEnd: Optional[float] = None,
        zOffsetStart: Optional[float] = None,
        zOffsetEnd: Optional[float] = None,
        widthStart: Optional[float] = None,
        widthEnd: Optional[float] = None,
        lengthStart: Optional[float] = None,
        lengthEnd: Optional[float] = None,
        radiusStart: Optional[float] = None,
        radiusEnd: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add a repeat entry to the Object.

        Parameters
        ----------
        repeatLength : float
            Length of the repeat.
        repeatDistance : float
            Distance between repeats.
        sStart : float, optional
            Starting s-coordinate. Default is None.
        tStart : float, optional
            Starting t-coordinate. Default is None.
        tEnd : float, optional
            Ending t-coordinate. Default is None.
        heightStart : float, optional
            Starting height. Default is None.
        heightEnd : float, optional
            Ending height. Default is None.
        zOffsetStart : float, optional
            Starting z-offset. Default is None.
        zOffsetEnd : float, optional
            Ending z-offset. Default is None.
        widthStart : float, optional
            Starting width. Default is None.
        widthEnd : float, optional
            Ending width. Default is None.
        lengthStart : float, optional
            Starting length. Default is None.
        lengthEnd : float, optional
            Ending length. Default is None.
        radiusStart : float, optional
            Starting radius. Default is None.
        radiusEnd : float, optional
            Ending radius. Default is None.
        &#34;&#34;&#34;
        self._repeats.append({})

        self._repeats[-1][&#34;length&#34;] = str(repeatLength)
        self._repeats[-1][&#34;distance&#34;] = str(repeatDistance)

        def infoFallback(id, attributeName):
            pass
            # print (&#34;Info: Using data of parent object with id&#34;,id,&#34;as attribute&#34;,attributeName,&#34;was not specified for repeat entry.&#34;)

        # ensuring that all attributes that are required according to OpenDRIVE 1.6 are filled - for convenience the ones of the parent object are used
        # if not provided specifically
        if sStart == None:
            self._repeats[-1][&#34;s&#34;] = str(self.s)
            infoFallback(self.id, &#34;s&#34;)
        else:
            self._repeats[-1][&#34;s&#34;] = str(sStart)
        if tStart == None:
            self._repeats[-1][&#34;tStart&#34;] = str(self.t)
            infoFallback(self.id, &#34;tStart&#34;)
        else:
            self._repeats[-1][&#34;tStart&#34;] = str(tStart)
        if tEnd == None:
            self._repeats[-1][&#34;tEnd&#34;] = str(self.t)
            infoFallback(self.id, &#34;tEnd&#34;)
        else:
            self._repeats[-1][&#34;tEnd&#34;] = str(tEnd)
        if heightStart == None and self.height != None:
            self._repeats[-1][&#34;heightStart&#34;] = str(self.height)
            infoFallback(self.id, &#34;heightStart&#34;)
        else:
            self._repeats[-1][&#34;heightStart&#34;] = str(heightStart)
        if heightEnd == None and self.height != None:
            self._repeats[-1][&#34;heightEnd&#34;] = str(self.height)
            infoFallback(self.id, &#34;heightEnd&#34;)
        else:
            self._repeats[-1][&#34;heightEnd&#34;] = str(heightEnd)
        if zOffsetStart == None:
            self._repeats[-1][&#34;zOffsetStart&#34;] = str(self.zOffset)
            infoFallback(self.id, &#34;zOffsetStart&#34;)
        else:
            self._repeats[-1][&#34;zOffsetStart&#34;] = str(zOffsetStart)
        if zOffsetEnd == None:
            self._repeats[-1][&#34;zOffsetEnd&#34;] = str(self.zOffset)
            infoFallback(self.id, &#34;zOffsetEnd&#34;)
        else:
            self._repeats[-1][&#34;zOffsetEnd&#34;] = str(zOffsetEnd)

        # attributes below are optional according to OpenDRIVE 1.6 - no further checks as these values overrule the ones of parent object
        # and fallbacks might be implemented differently by different simulators
        if widthStart is not None:
            self._repeats[-1][&#34;widthStart&#34;] = str(widthStart)
        if widthEnd is not None:
            self._repeats[-1][&#34;widthEnd&#34;] = str(widthEnd)
        if lengthStart is not None:
            self._repeats[-1][&#34;lengthStart&#34;] = str(lengthStart)
        if lengthEnd is not None:
            self._repeats[-1][&#34;lengthEnd&#34;] = str(lengthEnd)
        if radiusStart is not None:
            self._repeats[-1][&#34;radiusStart&#34;] = str(radiusStart)
        if radiusEnd is not None:
            self._repeats[-1][&#34;radiusEnd&#34;] = str(radiusEnd)

    def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;Object&#34;:
        &#34;&#34;&#34;Add a validity range to the Object.

        Parameters
        ----------
        fromLane : int
            The starting lane for the validity range.
        toLane : int
            The ending lane for the validity range.

        Returns
        -------
        Object
            The updated Object instance.

        Raises
        ------
        ValueError
            If a validity range is already set for the Object.
        &#34;&#34;&#34;
        if self.validity:
            raise ValueError(&#34;only one validity is allowed&#34;)
        self.validity = Validity(fromLane, toLane)
        return self

    def add_outline(self, outline: &#34;Outline&#34;) -&gt; None:
        &#34;&#34;&#34;Add an outline to the Object.

        Parameters
        ----------
        outline : Outline
            The outline to be added.
        &#34;&#34;&#34;
        self.outlines.append(outline)

    def add_parking_space(self, parking_space: &#34;ParkingSpace&#34;) -&gt; None:
        &#34;&#34;&#34;Add a parking space to the Object.

        Parameters
        ----------
        parking_space : ParkingSpace
            The parking space to be added.
        &#34;&#34;&#34;
        self.parking_space = parking_space

    def add_marking(self, marking: &#34;Marking&#34;) -&gt; None:
        &#34;&#34;&#34;Add a marking to the Object.

        Parameters
        ----------
        marking : Marking
            The marking to be added.
        &#34;&#34;&#34;
        self.markings.append(marking)

    def add_material(
        self,
        friction: Optional[float] = None,
        roadMarkColor: Optional[RoadMarkColor] = None,
        roughness: Optional[float] = None,
        surface: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add a material description entry to the object.

        Parameters
        ----------
        friction : float, optional
            The friction coefficient of the material. Default is None.
        roadMarkColor : RoadMarkColor, optional
            Color of the painted road mark. Default is None.
        roughness : float, optional
            The roughness of the material. Default is None.
        surface : str, optional
            The surface material code. Default is None.

        Returns
        -------
        None
        &#34;&#34;&#34;
        materialdict = {}
        if friction is not None:
            materialdict[&#34;friction&#34;] = str(friction)
        if roadMarkColor is not None:
            checked_color = enumchecker(roadMarkColor, RoadMarkColor)
            materialdict[&#34;roadMarkColor&#34;] = enum2str(checked_color)
        if roughness is not None:
            materialdict[&#34;roughness&#34;] = str(roughness)
        if surface is not None:
            materialdict[&#34;surface&#34;] = surface
        self.materials.append(materialdict)

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the Object as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Object.
        &#34;&#34;&#34;
        retdict = super().get_common_attributes()
        if self.validLength is not None:
            retdict[&#34;validLength&#34;] = str(self.validLength)
        retdict[&#34;hdg&#34;] = str(self.hdg)

        if self.radius is not None:
            retdict[&#34;radius&#34;] = str(self.radius)
        elif self.length is not None and self.width is not None:
            retdict[&#34;length&#34;] = str(self.length)
            retdict[&#34;width&#34;] = str(self.width)

        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Object.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Object.
        &#34;&#34;&#34;
        valid_corner_ids = set()
        for outline in self.outlines:
            for corner in outline.corners:
                if hasattr(corner, &#34;id&#34;) and corner.id is not None:
                    valid_corner_ids.add(corner.id)

        # Check all markings for cornerReferences
        for marking in self.markings:
            for ref_id in getattr(marking, &#34;cornerReferences&#34;, []):
                if ref_id not in valid_corner_ids:
                    raise ValueError(
                        (
                            f&#34;Marking references corner id {ref_id} &#34;
                            &#34;which does not exist in outlines.&#34;
                        )
                    )

        element = ET.Element(&#34;object&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        for _repeat in self._repeats:
            ET.SubElement(element, &#34;repeat&#34;, attrib=_repeat)
        if self.validity:
            element.append(self.validity.get_element())
        if self.parking_space:
            element.append(self.parking_space.get_element())
        if self.outlines:
            outlines_element = ET.SubElement(element, &#34;outlines&#34;)
            for outline in self.outlines:
                outlines_element.append(outline.get_element())
        if self.markings:
            markings_element = ET.SubElement(element, &#34;markings&#34;)
            for marking in self.markings:
                markings_element.append(marking.get_element())
        if self.materials:
            for material in self.materials:
                ET.SubElement(element, &#34;material&#34;, attrib=material)
        return element</code></pre>
</details>
<div class="desc"><p>Creates an Object in OpenDRIVE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the Object (inherited from base class).</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the Object (inherited from base class).</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>ObjectType</code> or <code>str</code></dt>
<dd>Type of the Object (typically enum ObjectType, inherited from base class).</dd>
<dt><strong><code>subtype</code></strong> :&ensp;<code>str</code></dt>
<dd>Subtype for further specification of the Object (inherited from base class).</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the Object (inherited from base class).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for identification of the Object (inherited from base class).</dd>
<dt><strong><code>dynamic</code></strong> :&ensp;<code>Dynamic</code></dt>
<dd>Specifies if the Object is static or dynamic (inherited from base class).</dd>
<dt><strong><code>zOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Vertical offset of the Object with respect to the centerline (inherited from base class).</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the Object with respect to the road (inherited from base class).</dd>
<dt><strong><code>hdg</code></strong> :&ensp;<code>float</code></dt>
<dd>Heading angle (rad) of the Object relative to the road direction.</dd>
<dt><strong><code>pitch</code></strong> :&ensp;<code>float</code></dt>
<dd>Pitch angle (rad) of the Object relative to the inertial system (inherited from base class).</dd>
<dt><strong><code>roll</code></strong> :&ensp;<code>float</code></dt>
<dd>Roll angle (rad) of the Object after applying pitch (inherited from base class).</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the Object (inherited from base class).</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the Object (shall not be used with radius).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height of the Object (inherited from base class).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius of the Object (shall not be used with width/length).</dd>
<dt><strong><code>validLength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Validity of the Object along the s-coordinate.</dd>
<dt><strong><code>_repeats</code></strong> :&ensp;<code>list[dict]</code></dt>
<dd>List of dictionaries containing attributes for repeating Objects.</dd>
<dt><strong><code>validity</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.Validity" href="#scenariogeneration.xodr.signals_objects.Validity">Validity</a></code>, optional</dt>
<dd>Explicit validity information for the Object.</dd>
<dt><strong><code>outlines</code></strong> :&ensp;<code>list[<a title="scenariogeneration.xodr.signals_objects.Outline" href="#scenariogeneration.xodr.signals_objects.Outline">Outline</a>]</code></dt>
<dd>List of outlines for the Object.</dd>
<dt><strong><code>markings</code></strong> :&ensp;<code>list[<a title="scenariogeneration.xodr.signals_objects.Marking" href="#scenariogeneration.xodr.signals_objects.Marking">Marking</a>]</code></dt>
<dd>List of markings for the Object.</dd>
<dt><strong><code>parking_space</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.ParkingSpace" href="#scenariogeneration.xodr.signals_objects.ParkingSpace">ParkingSpace</a></code>, optional</dt>
<dd>Parking space information for the Object.</dd>
<dt><strong><code>materials</code></strong> :&ensp;<code>list[Material]</code></dt>
<dd>List of materials for the Object.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>repeat(&hellip;)
Adds a dictionary to <code>_repeats</code> to create a subelement for repeating the Object.
add_outline(outline)
Adds an outline to the Object.
add_parking_space(parking_space)
Adds a parking space to the Object.
get_element()
Returns the full ElementTree representation of the Object.
get_attributes()
Returns a dictionary of all attributes of the Object.</p>
<p>Initialize the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the Object.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the Object.</dd>
<dt><strong><code>Type</code></strong> :&ensp;<code>ObjectType</code> or <code>str</code>, optional</dt>
<dd>Type of the Object. Default is ObjectType.none.</dd>
<dt><strong><code>subtype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subtype for further specification of the Object. Default is None.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the Object. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for identification of the Object. Default is None.</dd>
<dt><strong><code>dynamic</code></strong> :&ensp;<code>Dynamic</code>, optional</dt>
<dd>Specifies if the Object is static or dynamic. Default is Dynamic.no.</dd>
<dt><strong><code>zOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Vertical offset of the Object with respect to the centerline. Default is 0.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the Object with respect to the road. Default is Orientation.none.</dd>
<dt><strong><code>hdg</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Heading angle (rad) of the Object relative to the road direction. Default is 0.</dd>
<dt><strong><code>pitch</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Pitch angle (rad) of the Object relative to the inertial system. Default is 0.</dd>
<dt><strong><code>roll</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Roll angle (rad) of the Object after applying pitch. Default is 0.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the Object. Default is None.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the Object. Default is None.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height of the Object. Default is None.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius of the Object. Default is None.</dd>
<dt><strong><code>validLength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Validity of the Object along the s-coordinate. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.signals_objects._SignalObjectBase</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Object.add_marking"><code class="name flex">
<span>def <span class="ident">add_marking</span></span>(<span>self,<br>marking: <a title="scenariogeneration.xodr.signals_objects.Marking" href="#scenariogeneration.xodr.signals_objects.Marking">Marking</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_marking(self, marking: &#34;Marking&#34;) -&gt; None:
    &#34;&#34;&#34;Add a marking to the Object.

    Parameters
    ----------
    marking : Marking
        The marking to be added.
    &#34;&#34;&#34;
    self.markings.append(marking)</code></pre>
</details>
<div class="desc"><p>Add a marking to the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>marking</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.Marking" href="#scenariogeneration.xodr.signals_objects.Marking">Marking</a></code></dt>
<dd>The marking to be added.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self,<br>friction: float | None = None,<br>roadMarkColor: <a title="scenariogeneration.xodr.enumerations.RoadMarkColor" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadMarkColor">RoadMarkColor</a> | None = None,<br>roughness: float | None = None,<br>surface: str | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_material(
    self,
    friction: Optional[float] = None,
    roadMarkColor: Optional[RoadMarkColor] = None,
    roughness: Optional[float] = None,
    surface: Optional[str] = None,
) -&gt; None:
    &#34;&#34;&#34;Add a material description entry to the object.

    Parameters
    ----------
    friction : float, optional
        The friction coefficient of the material. Default is None.
    roadMarkColor : RoadMarkColor, optional
        Color of the painted road mark. Default is None.
    roughness : float, optional
        The roughness of the material. Default is None.
    surface : str, optional
        The surface material code. Default is None.

    Returns
    -------
    None
    &#34;&#34;&#34;
    materialdict = {}
    if friction is not None:
        materialdict[&#34;friction&#34;] = str(friction)
    if roadMarkColor is not None:
        checked_color = enumchecker(roadMarkColor, RoadMarkColor)
        materialdict[&#34;roadMarkColor&#34;] = enum2str(checked_color)
    if roughness is not None:
        materialdict[&#34;roughness&#34;] = str(roughness)
    if surface is not None:
        materialdict[&#34;surface&#34;] = surface
    self.materials.append(materialdict)</code></pre>
</details>
<div class="desc"><p>Add a material description entry to the object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>friction</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The friction coefficient of the material. Default is None.</dd>
<dt><strong><code>roadMarkColor</code></strong> :&ensp;<code>RoadMarkColor</code>, optional</dt>
<dd>Color of the painted road mark. Default is None.</dd>
<dt><strong><code>roughness</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The roughness of the material. Default is None.</dd>
<dt><strong><code>surface</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The surface material code. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.add_outline"><code class="name flex">
<span>def <span class="ident">add_outline</span></span>(<span>self,<br>outline: <a title="scenariogeneration.xodr.signals_objects.Outline" href="#scenariogeneration.xodr.signals_objects.Outline">Outline</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_outline(self, outline: &#34;Outline&#34;) -&gt; None:
    &#34;&#34;&#34;Add an outline to the Object.

    Parameters
    ----------
    outline : Outline
        The outline to be added.
    &#34;&#34;&#34;
    self.outlines.append(outline)</code></pre>
</details>
<div class="desc"><p>Add an outline to the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>outline</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.Outline" href="#scenariogeneration.xodr.signals_objects.Outline">Outline</a></code></dt>
<dd>The outline to be added.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.add_parking_space"><code class="name flex">
<span>def <span class="ident">add_parking_space</span></span>(<span>self,<br>parking_space: <a title="scenariogeneration.xodr.signals_objects.ParkingSpace" href="#scenariogeneration.xodr.signals_objects.ParkingSpace">ParkingSpace</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parking_space(self, parking_space: &#34;ParkingSpace&#34;) -&gt; None:
    &#34;&#34;&#34;Add a parking space to the Object.

    Parameters
    ----------
    parking_space : ParkingSpace
        The parking space to be added.
    &#34;&#34;&#34;
    self.parking_space = parking_space</code></pre>
</details>
<div class="desc"><p>Add a parking space to the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parking_space</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.ParkingSpace" href="#scenariogeneration.xodr.signals_objects.ParkingSpace">ParkingSpace</a></code></dt>
<dd>The parking space to be added.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.add_validity"><code class="name flex">
<span>def <span class="ident">add_validity</span></span>(<span>self, fromLane: int, toLane: int) ‑> <a title="scenariogeneration.xodr.signals_objects.Object" href="#scenariogeneration.xodr.signals_objects.Object">Object</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;Object&#34;:
    &#34;&#34;&#34;Add a validity range to the Object.

    Parameters
    ----------
    fromLane : int
        The starting lane for the validity range.
    toLane : int
        The ending lane for the validity range.

    Returns
    -------
    Object
        The updated Object instance.

    Raises
    ------
    ValueError
        If a validity range is already set for the Object.
    &#34;&#34;&#34;
    if self.validity:
        raise ValueError(&#34;only one validity is allowed&#34;)
    self.validity = Validity(fromLane, toLane)
    return self</code></pre>
</details>
<div class="desc"><p>Add a validity range to the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The starting lane for the validity range.</dd>
<dt><strong><code>toLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The ending lane for the validity range.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.signals_objects.Object" href="#scenariogeneration.xodr.signals_objects.Object">Object</a></code></dt>
<dd>The updated Object instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a validity range is already set for the Object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the Object as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Object.
    &#34;&#34;&#34;
    retdict = super().get_common_attributes()
    if self.validLength is not None:
        retdict[&#34;validLength&#34;] = str(self.validLength)
    retdict[&#34;hdg&#34;] = str(self.hdg)

    if self.radius is not None:
        retdict[&#34;radius&#34;] = str(self.radius)
    elif self.length is not None and self.width is not None:
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;width&#34;] = str(self.width)

    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Object as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Object.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Object.
    &#34;&#34;&#34;
    valid_corner_ids = set()
    for outline in self.outlines:
        for corner in outline.corners:
            if hasattr(corner, &#34;id&#34;) and corner.id is not None:
                valid_corner_ids.add(corner.id)

    # Check all markings for cornerReferences
    for marking in self.markings:
        for ref_id in getattr(marking, &#34;cornerReferences&#34;, []):
            if ref_id not in valid_corner_ids:
                raise ValueError(
                    (
                        f&#34;Marking references corner id {ref_id} &#34;
                        &#34;which does not exist in outlines.&#34;
                    )
                )

    element = ET.Element(&#34;object&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    for _repeat in self._repeats:
        ET.SubElement(element, &#34;repeat&#34;, attrib=_repeat)
    if self.validity:
        element.append(self.validity.get_element())
    if self.parking_space:
        element.append(self.parking_space.get_element())
    if self.outlines:
        outlines_element = ET.SubElement(element, &#34;outlines&#34;)
        for outline in self.outlines:
            outlines_element.append(outline.get_element())
    if self.markings:
        markings_element = ET.SubElement(element, &#34;markings&#34;)
        for marking in self.markings:
            markings_element.append(marking.get_element())
    if self.materials:
        for material in self.materials:
            ET.SubElement(element, &#34;material&#34;, attrib=material)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Object.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self,<br>repeatLength: float,<br>repeatDistance: float,<br>sStart: float | None = None,<br>tStart: float | None = None,<br>tEnd: float | None = None,<br>heightStart: float | None = None,<br>heightEnd: float | None = None,<br>zOffsetStart: float | None = None,<br>zOffsetEnd: float | None = None,<br>widthStart: float | None = None,<br>widthEnd: float | None = None,<br>lengthStart: float | None = None,<br>lengthEnd: float | None = None,<br>radiusStart: float | None = None,<br>radiusEnd: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(
    self,
    repeatLength: float,
    repeatDistance: float,
    sStart: Optional[float] = None,
    tStart: Optional[float] = None,
    tEnd: Optional[float] = None,
    heightStart: Optional[float] = None,
    heightEnd: Optional[float] = None,
    zOffsetStart: Optional[float] = None,
    zOffsetEnd: Optional[float] = None,
    widthStart: Optional[float] = None,
    widthEnd: Optional[float] = None,
    lengthStart: Optional[float] = None,
    lengthEnd: Optional[float] = None,
    radiusStart: Optional[float] = None,
    radiusEnd: Optional[float] = None,
) -&gt; None:
    &#34;&#34;&#34;Add a repeat entry to the Object.

    Parameters
    ----------
    repeatLength : float
        Length of the repeat.
    repeatDistance : float
        Distance between repeats.
    sStart : float, optional
        Starting s-coordinate. Default is None.
    tStart : float, optional
        Starting t-coordinate. Default is None.
    tEnd : float, optional
        Ending t-coordinate. Default is None.
    heightStart : float, optional
        Starting height. Default is None.
    heightEnd : float, optional
        Ending height. Default is None.
    zOffsetStart : float, optional
        Starting z-offset. Default is None.
    zOffsetEnd : float, optional
        Ending z-offset. Default is None.
    widthStart : float, optional
        Starting width. Default is None.
    widthEnd : float, optional
        Ending width. Default is None.
    lengthStart : float, optional
        Starting length. Default is None.
    lengthEnd : float, optional
        Ending length. Default is None.
    radiusStart : float, optional
        Starting radius. Default is None.
    radiusEnd : float, optional
        Ending radius. Default is None.
    &#34;&#34;&#34;
    self._repeats.append({})

    self._repeats[-1][&#34;length&#34;] = str(repeatLength)
    self._repeats[-1][&#34;distance&#34;] = str(repeatDistance)

    def infoFallback(id, attributeName):
        pass
        # print (&#34;Info: Using data of parent object with id&#34;,id,&#34;as attribute&#34;,attributeName,&#34;was not specified for repeat entry.&#34;)

    # ensuring that all attributes that are required according to OpenDRIVE 1.6 are filled - for convenience the ones of the parent object are used
    # if not provided specifically
    if sStart == None:
        self._repeats[-1][&#34;s&#34;] = str(self.s)
        infoFallback(self.id, &#34;s&#34;)
    else:
        self._repeats[-1][&#34;s&#34;] = str(sStart)
    if tStart == None:
        self._repeats[-1][&#34;tStart&#34;] = str(self.t)
        infoFallback(self.id, &#34;tStart&#34;)
    else:
        self._repeats[-1][&#34;tStart&#34;] = str(tStart)
    if tEnd == None:
        self._repeats[-1][&#34;tEnd&#34;] = str(self.t)
        infoFallback(self.id, &#34;tEnd&#34;)
    else:
        self._repeats[-1][&#34;tEnd&#34;] = str(tEnd)
    if heightStart == None and self.height != None:
        self._repeats[-1][&#34;heightStart&#34;] = str(self.height)
        infoFallback(self.id, &#34;heightStart&#34;)
    else:
        self._repeats[-1][&#34;heightStart&#34;] = str(heightStart)
    if heightEnd == None and self.height != None:
        self._repeats[-1][&#34;heightEnd&#34;] = str(self.height)
        infoFallback(self.id, &#34;heightEnd&#34;)
    else:
        self._repeats[-1][&#34;heightEnd&#34;] = str(heightEnd)
    if zOffsetStart == None:
        self._repeats[-1][&#34;zOffsetStart&#34;] = str(self.zOffset)
        infoFallback(self.id, &#34;zOffsetStart&#34;)
    else:
        self._repeats[-1][&#34;zOffsetStart&#34;] = str(zOffsetStart)
    if zOffsetEnd == None:
        self._repeats[-1][&#34;zOffsetEnd&#34;] = str(self.zOffset)
        infoFallback(self.id, &#34;zOffsetEnd&#34;)
    else:
        self._repeats[-1][&#34;zOffsetEnd&#34;] = str(zOffsetEnd)

    # attributes below are optional according to OpenDRIVE 1.6 - no further checks as these values overrule the ones of parent object
    # and fallbacks might be implemented differently by different simulators
    if widthStart is not None:
        self._repeats[-1][&#34;widthStart&#34;] = str(widthStart)
    if widthEnd is not None:
        self._repeats[-1][&#34;widthEnd&#34;] = str(widthEnd)
    if lengthStart is not None:
        self._repeats[-1][&#34;lengthStart&#34;] = str(lengthStart)
    if lengthEnd is not None:
        self._repeats[-1][&#34;lengthEnd&#34;] = str(lengthEnd)
    if radiusStart is not None:
        self._repeats[-1][&#34;radiusStart&#34;] = str(radiusStart)
    if radiusEnd is not None:
        self._repeats[-1][&#34;radiusEnd&#34;] = str(radiusEnd)</code></pre>
</details>
<div class="desc"><p>Add a repeat entry to the Object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>repeatLength</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the repeat.</dd>
<dt><strong><code>repeatDistance</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between repeats.</dd>
<dt><strong><code>sStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting s-coordinate. Default is None.</dd>
<dt><strong><code>tStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting t-coordinate. Default is None.</dd>
<dt><strong><code>tEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending t-coordinate. Default is None.</dd>
<dt><strong><code>heightStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting height. Default is None.</dd>
<dt><strong><code>heightEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending height. Default is None.</dd>
<dt><strong><code>zOffsetStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting z-offset. Default is None.</dd>
<dt><strong><code>zOffsetEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending z-offset. Default is None.</dd>
<dt><strong><code>widthStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting width. Default is None.</dd>
<dt><strong><code>widthEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending width. Default is None.</dd>
<dt><strong><code>lengthStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting length. Default is None.</dd>
<dt><strong><code>lengthEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending length. Default is None.</dd>
<dt><strong><code>radiusStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting radius. Default is None.</dd>
<dt><strong><code>radiusEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ending radius. Default is None.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Outline"><code class="flex name class">
<span>class <span class="ident">Outline</span></span>
<span>(</span><span>closed: bool | None = None,<br>fill_type: <a title="scenariogeneration.xodr.enumerations.FillType" href="enumerations.html#scenariogeneration.xodr.enumerations.FillType">FillType</a> | None = None,<br>lane_type: <a title="scenariogeneration.xodr.enumerations.LaneType" href="enumerations.html#scenariogeneration.xodr.enumerations.LaneType">LaneType</a> | None = None,<br>outer: bool | None = None,<br>id: int | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Outline(XodrBase):
    &#34;&#34;&#34;Outline is used to wrap corners for an object in OpenDRIVE.

    Attributes
    ----------
    closed : bool, optional
        Indicates if the outline is closed.
    fill_type : FillType, optional
        Filling type of the object.
    lane_type : LaneType, optional
        Type of the outline.
    outer : bool, optional
        Defines if the outline is the outer outline.
    id : int, optional
        ID of the outline.
    corners : list[Union[CornerRoad, CornerLocal]]
        List of corners in the outline.

    Methods
    -------
    add_corner(corner)
        Adds a corner to the outline.
    get_element()
        Returns the full ElementTree representation of the Outline.
    get_attributes()
        Returns a dictionary of all attributes of the Outline.
    &#34;&#34;&#34;

    def __init__(
        self,
        closed: Optional[bool] = None,
        fill_type: Optional[FillType] = None,
        lane_type: Optional[LaneType] = None,
        outer: Optional[bool] = None,
        id: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Outline.

        Parameters
        ----------
        closed : bool, optional
            Indicates if the outline is closed. Default is None.
        fill_type : FillType, optional
            Filling type of the object. Default is None.
        lane_type : LaneType, optional
            Type of the outline. Default is None.
        outer : bool, optional
            Defines if the outline is the outer outline. Default is None.
        id : int, optional
            ID of the outline. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.closed = closed
        self.fill_type = enumchecker(fill_type, FillType, True)
        self.lane_type = enumchecker(lane_type, LaneType, True)
        self.outer = outer
        self.id = id
        self.corners = []
        self._corner_type = None

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Outline) and super().__eq__(other):
            if (
                self.get_attributes() == other.get_attributes()
                and self.corners == other.corners
            ):
                return True
        return False

    def add_corner(self, corner: Union[CornerRoad, CornerLocal]) -&gt; None:
        &#34;&#34;&#34;Add a corner to the outline.

        Note: Only the same type of corners can be added.

        Parameters
        ----------
        corner : CornerRoad or CornerLocal
            The corner to add.

        Raises
        ------
        TypeError
            If the corner is not a valid type.
        GeneralIssueInputArguments
            If a mix of corner types is attempted.
        &#34;&#34;&#34;
        if not (
            isinstance(corner, CornerLocal) or isinstance(corner, CornerRoad)
        ):
            raise TypeError(&#34;Not a valid corner.&#34;)
        if len(self.corners) == 0:
            if isinstance(corner, CornerLocal):
                self._corner_type = &#34;local&#34;
            else:
                self._corner_type = &#34;road&#34;
        if (
            isinstance(corner, CornerLocal) and self._corner_type == &#34;local&#34;
        ) or (isinstance(corner, CornerRoad) and self._corner_type == &#34;road&#34;):
            self.corners.append(corner)
        else:
            raise GeneralIssueInputArguments(
                &#34;Mix of cornertypes not allowed. &#34;
            )

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the Outline as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Outline.
        &#34;&#34;&#34;
        retdict = {}
        if self.closed is not None:
            retdict[&#34;closed&#34;] = get_bool_string(self.closed)
        if self.outer is not None:
            retdict[&#34;outer&#34;] = get_bool_string(self.outer)
        if self.fill_type is not None:
            retdict[&#34;fillType&#34;] = enum2str(self.fill_type)
        if self.lane_type is not None:
            retdict[&#34;laneType&#34;] = enum2str(self.lane_type)
        if self.id is not None:
            retdict[&#34;id&#34;] = str(self.id)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Outline.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Outline.
        &#34;&#34;&#34;
        element = ET.Element(&#34;outline&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        for corner in self.corners:
            element.append(corner.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>Outline is used to wrap corners for an object in OpenDRIVE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if the outline is closed.</dd>
<dt><strong><code>fill_type</code></strong> :&ensp;<code>FillType</code>, optional</dt>
<dd>Filling type of the object.</dd>
<dt><strong><code>lane_type</code></strong> :&ensp;<code>LaneType</code>, optional</dt>
<dd>Type of the outline.</dd>
<dt><strong><code>outer</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defines if the outline is the outer outline.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the outline.</dd>
<dt><strong><code>corners</code></strong> :&ensp;<code>list[Union[<a title="scenariogeneration.xodr.signals_objects.CornerRoad" href="#scenariogeneration.xodr.signals_objects.CornerRoad">CornerRoad</a>, <a title="scenariogeneration.xodr.signals_objects.CornerLocal" href="#scenariogeneration.xodr.signals_objects.CornerLocal">CornerLocal</a>]]</code></dt>
<dd>List of corners in the outline.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>add_corner(corner)
Adds a corner to the outline.
get_element()
Returns the full ElementTree representation of the Outline.
get_attributes()
Returns a dictionary of all attributes of the Outline.</p>
<p>Initialize the Outline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if the outline is closed. Default is None.</dd>
<dt><strong><code>fill_type</code></strong> :&ensp;<code>FillType</code>, optional</dt>
<dd>Filling type of the object. Default is None.</dd>
<dt><strong><code>lane_type</code></strong> :&ensp;<code>LaneType</code>, optional</dt>
<dd>Type of the outline. Default is None.</dd>
<dt><strong><code>outer</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defines if the outline is the outer outline. Default is None.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ID of the outline. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Outline.add_corner"><code class="name flex">
<span>def <span class="ident">add_corner</span></span>(<span>self,<br>corner: <a title="scenariogeneration.xodr.signals_objects.CornerRoad" href="#scenariogeneration.xodr.signals_objects.CornerRoad">CornerRoad</a> | <a title="scenariogeneration.xodr.signals_objects.CornerLocal" href="#scenariogeneration.xodr.signals_objects.CornerLocal">CornerLocal</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_corner(self, corner: Union[CornerRoad, CornerLocal]) -&gt; None:
    &#34;&#34;&#34;Add a corner to the outline.

    Note: Only the same type of corners can be added.

    Parameters
    ----------
    corner : CornerRoad or CornerLocal
        The corner to add.

    Raises
    ------
    TypeError
        If the corner is not a valid type.
    GeneralIssueInputArguments
        If a mix of corner types is attempted.
    &#34;&#34;&#34;
    if not (
        isinstance(corner, CornerLocal) or isinstance(corner, CornerRoad)
    ):
        raise TypeError(&#34;Not a valid corner.&#34;)
    if len(self.corners) == 0:
        if isinstance(corner, CornerLocal):
            self._corner_type = &#34;local&#34;
        else:
            self._corner_type = &#34;road&#34;
    if (
        isinstance(corner, CornerLocal) and self._corner_type == &#34;local&#34;
    ) or (isinstance(corner, CornerRoad) and self._corner_type == &#34;road&#34;):
        self.corners.append(corner)
    else:
        raise GeneralIssueInputArguments(
            &#34;Mix of cornertypes not allowed. &#34;
        )</code></pre>
</details>
<div class="desc"><p>Add a corner to the outline.</p>
<p>Note: Only the same type of corners can be added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>corner</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.CornerRoad" href="#scenariogeneration.xodr.signals_objects.CornerRoad">CornerRoad</a></code> or <code><a title="scenariogeneration.xodr.signals_objects.CornerLocal" href="#scenariogeneration.xodr.signals_objects.CornerLocal">CornerLocal</a></code></dt>
<dd>The corner to add.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the corner is not a valid type.</dd>
<dt><code>GeneralIssueInputArguments</code></dt>
<dd>If a mix of corner types is attempted.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Outline.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the Outline as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Outline.
    &#34;&#34;&#34;
    retdict = {}
    if self.closed is not None:
        retdict[&#34;closed&#34;] = get_bool_string(self.closed)
    if self.outer is not None:
        retdict[&#34;outer&#34;] = get_bool_string(self.outer)
    if self.fill_type is not None:
        retdict[&#34;fillType&#34;] = enum2str(self.fill_type)
    if self.lane_type is not None:
        retdict[&#34;laneType&#34;] = enum2str(self.lane_type)
    if self.id is not None:
        retdict[&#34;id&#34;] = str(self.id)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Outline as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Outline.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Outline.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Outline.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Outline.
    &#34;&#34;&#34;
    element = ET.Element(&#34;outline&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    for corner in self.corners:
        element.append(corner.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Outline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Outline.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.ParkingSpace"><code class="flex name class">
<span>class <span class="ident">ParkingSpace</span></span>
<span>(</span><span>access: <a title="scenariogeneration.xodr.enumerations.Access" href="enumerations.html#scenariogeneration.xodr.enumerations.Access">Access</a> | None = None,<br>restrictions: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParkingSpace(XodrBase):
    &#34;&#34;&#34;ParkingSpace is used to define access and restrictions for objects
    in OpenDRIVE.

    Attributes
    ----------
    access : Access, optional
        Type of access of the parking space.
    restrictions : str, optional
        Restrictions of the parking space.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the ParkingSpace.
    get_attributes()
        Returns a dictionary of all attributes of the ParkingSpace.
    &#34;&#34;&#34;

    def __init__(
        self,
        access: Optional[Access] = None,
        restrictions: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the ParkingSpace.

        Parameters
        ----------
        access : Access, optional
            Type of access of the parking space. Default is None.
        restrictions : str, optional
            Restrictions of the parking space. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.access = enumchecker(access, Access)
        self.restrictions = restrictions

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Outline) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the ParkingSpace as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the ParkingSpace.
        &#34;&#34;&#34;
        retdict = {}
        if self.access is not None:
            retdict[&#34;access&#34;] = enum2str(self.access)
        if self.restrictions is not None:
            retdict[&#34;restrictions&#34;] = self.restrictions

        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the ParkingSpace.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the ParkingSpace.
        &#34;&#34;&#34;
        element = ET.Element(&#34;parkingSpace&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)

        return element</code></pre>
</details>
<div class="desc"><p>ParkingSpace is used to define access and restrictions for objects
in OpenDRIVE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>access</code></strong> :&ensp;<code>Access</code>, optional</dt>
<dd>Type of access of the parking space.</dd>
<dt><strong><code>restrictions</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Restrictions of the parking space.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the ParkingSpace.
get_attributes()
Returns a dictionary of all attributes of the ParkingSpace.</p>
<p>Initialize the ParkingSpace.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>access</code></strong> :&ensp;<code>Access</code>, optional</dt>
<dd>Type of access of the parking space. Default is None.</dd>
<dt><strong><code>restrictions</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Restrictions of the parking space. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.ParkingSpace.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the ParkingSpace as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the ParkingSpace.
    &#34;&#34;&#34;
    retdict = {}
    if self.access is not None:
        retdict[&#34;access&#34;] = enum2str(self.access)
    if self.restrictions is not None:
        retdict[&#34;restrictions&#34;] = self.restrictions

    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the ParkingSpace as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the ParkingSpace.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.ParkingSpace.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the ParkingSpace.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the ParkingSpace.
    &#34;&#34;&#34;
    element = ET.Element(&#34;parkingSpace&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the ParkingSpace.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the ParkingSpace.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>s: float,<br>t: float,<br>country: str,<br>Type: <a title="scenariogeneration.xodr.enumerations.ObjectType" href="enumerations.html#scenariogeneration.xodr.enumerations.ObjectType">ObjectType</a> | str,<br>subtype: str = '-1',<br>countryRevision: str | None = None,<br>id: str | None = None,<br>name: str | None = None,<br>dynamic: <a title="scenariogeneration.xodr.enumerations.Dynamic" href="enumerations.html#scenariogeneration.xodr.enumerations.Dynamic">Dynamic</a> = Dynamic.no,<br>value: float | None = None,<br>unit: str | None = None,<br>zOffset: float = 1.5,<br>orientation: <a title="scenariogeneration.xodr.enumerations.Orientation" href="enumerations.html#scenariogeneration.xodr.enumerations.Orientation">Orientation</a> = Orientation.positive,<br>hOffset: float = 0,<br>pitch: float = 0,<br>roll: float = 0,<br>height: float | None = None,<br>width: float | None = None,<br>length: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal(_SignalObjectBase):
    &#34;&#34;&#34;Signal defines the signal element in OpenDRIVE.

    Attributes
    ----------
    s : float
        s-coordinate of the Signal (inherited from base class).
    t : float
        t-coordinate of the Signal (inherited from base class).
    country : str
        Country code according to ISO 3166-1 (alpha-2 for OpenDRIVE 1.6,
        alpha-3 for OpenDRIVE 1.4).
    countryRevision : str, optional
        Year of the applied traffic rules, ensuring unique sign
        interpretation with country, type, and subtype.
    Type : SignalType or str
        Type of the Signal (inherited from base class).
    subtype : str
        Subtype for further specification of the Signal (inherited from
        base class).
    id : str, optional
        ID of the Signal (inherited from base class).
    name : str, optional
        Name for identification of the Signal (inherited from base class).
    dynamic : Dynamic
        Specifies if the Signal is static or dynamic (inherited from base
        class).
    value : float, optional
        Value for further specification of the Signal.
    unit : str, optional
        Unit of the value, required if `value` is provided.
    zOffset : float
        Vertical offset of the Signal with respect to the centerline
        (inherited from base class).
    orientation : Orientation
        Orientation of the Signal with respect to the road (inherited from
        base class).
    hOffset : float
        Heading offset of the Signal relative to its orientation.
    pitch : float
        Pitch angle (rad) of the Signal relative to the inertial system
        (inherited from base class).
    roll : float
        Roll angle (rad) of the Signal after applying pitch (inherited
        from base class).
    width : float, optional
        Width of the Signal (inherited from base class).
    height : float, optional
        Height of the Signal (inherited from base class).
    length : float, optional
        Length of the Signal (inherited from base class).
    validity : Validity, optional
        Explicit validity information for the Signal.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the Signal.
    get_attributes()
        Returns a dictionary of all attributes of the Signal.
    add_validity(fromLane, toLane)
        Adds a new validity range for the Signal.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        t: float,
        country: str,
        Type: Union[ObjectType, str],
        subtype: str = &#34;-1&#34;,
        countryRevision: Optional[str] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        dynamic: Dynamic = Dynamic.no,
        value: Optional[float] = None,
        unit: Optional[str] = None,
        zOffset: float = 1.5,
        orientation: Orientation = Orientation.positive,
        hOffset: float = 0,
        pitch: float = 0,
        roll: float = 0,
        height: Optional[float] = None,
        width: Optional[float] = None,
        length: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Signal.

        Parameters
        ----------
        s : float
            s-coordinate of the Signal.
        t : float
            t-coordinate of the Signal.
        country : str
            Country code according to ISO 3166-1 (alpha-2 for OpenDRIVE 1.6,
            alpha-3 for OpenDRIVE 1.4).
        Type : SignalType or str
            Type of the Signal.
        subtype : str, optional
            Subtype for further specification of the Signal. Default is &#34;-1&#34;.
        countryRevision : str, optional
            Year of the applied traffic rules. Default is None.
        id : str, optional
            ID of the Signal. Default is None.
        name : str, optional
            Name for identification of the Signal. Default is None.
        dynamic : Dynamic, optional
            Specifies if the Signal is static or dynamic. Default is
            Dynamic.no.
        value : float, optional
            Value for further specification of the Signal. Default is None.
        unit : str, optional
            Unit of the value, required if `value` is provided. Default is
            None.
        zOffset : float, optional
            Vertical offset of the Signal with respect to the centerline.
            Default is 1.5.
        orientation : Orientation, optional
            Orientation of the Signal with respect to the road. Default is
            Orientation.positive.
        hOffset : float, optional
            Heading offset of the Signal relative to its orientation.
            Default is 0.
        pitch : float, optional
            Pitch angle (rad) of the Signal relative to the inertial system.
            Default is 0.
        roll : float, optional
            Roll angle (rad) of the Signal after applying pitch. Default is
            0.
        height : float, optional
            Height of the Signal. Default is None.
        width : float, optional
            Width of the Signal. Default is None.
        length : float, optional
            Length of the Signal. Default is None.
        &#34;&#34;&#34;

        # get attributes that are common with signals
        super().__init__(
            s,
            t,
            id,
            Type,
            subtype,
            dynamic,
            name,
            zOffset,
            orientation,
            pitch,
            roll,
            width,
            height,
            length,
        )
        self.s = s
        self.t = t
        self.dynamic = dynamic
        self.orientation = orientation
        self.zOffset = zOffset
        self.country = country
        self.countryRevision = countryRevision
        self.type = Type
        self.subtype = subtype
        self.value = value
        self.unit = unit
        self.hOffset = hOffset
        self.validity = None

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Signal) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the Signal as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Signal.
        &#34;&#34;&#34;
        retdict = super().get_common_attributes()
        retdict[&#34;country&#34;] = str(self.country).upper()
        retdict[&#34;type&#34;] = str(self.type)
        retdict[&#34;subtype&#34;] = str(self.subtype)
        if self.countryRevision is not None:
            retdict[&#34;countryRevision&#34;] = str(self.countryRevision)
        if self.hOffset is not None:
            retdict[&#34;hOffset&#34;] = str(self.hOffset)
        if self.value is not None:
            retdict[&#34;value&#34;] = str(self.value)
            if self.unit is None:
                raise NotEnoughInputArguments(
                    &#34;If value is set for a signal, unit has to be added aswell&#34;
                )
            retdict[&#34;unit&#34;] = str(self.unit)
        return retdict

    def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;Signal&#34;:
        &#34;&#34;&#34;Add a validity range to the Signal.

        Parameters
        ----------
        fromLane : int
            The starting lane for the validity range.
        toLane : int
            The ending lane for the validity range.

        Returns
        -------
        Signal
            The updated Signal object.

        Raises
        ------
        ValueError
            If a validity range is already set for the Signal.
        &#34;&#34;&#34;
        if self.validity:
            raise ValueError(&#34;only one validity is allowed&#34;)
        self.validity = Validity(fromLane, toLane)
        return self

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Signal.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Signal.
        &#34;&#34;&#34;
        element = ET.Element(&#34;signal&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        if self.validity:
            element.append(self.validity.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Signal defines the signal element in OpenDRIVE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the Signal (inherited from base class).</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the Signal (inherited from base class).</dd>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code></dt>
<dd>Country code according to ISO 3166-1 (alpha-2 for OpenDRIVE 1.6,
alpha-3 for OpenDRIVE 1.4).</dd>
<dt><strong><code>countryRevision</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Year of the applied traffic rules, ensuring unique sign
interpretation with country, type, and subtype.</dd>
<dt><strong><code>Type</code></strong> :&ensp;<code>SignalType</code> or <code>str</code></dt>
<dd>Type of the Signal (inherited from base class).</dd>
<dt><strong><code>subtype</code></strong> :&ensp;<code>str</code></dt>
<dd>Subtype for further specification of the Signal (inherited from
base class).</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the Signal (inherited from base class).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for identification of the Signal (inherited from base class).</dd>
<dt><strong><code>dynamic</code></strong> :&ensp;<code>Dynamic</code></dt>
<dd>Specifies if the Signal is static or dynamic (inherited from base
class).</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for further specification of the Signal.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unit of the value, required if <code>value</code> is provided.</dd>
<dt><strong><code>zOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Vertical offset of the Signal with respect to the centerline
(inherited from base class).</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the Signal with respect to the road (inherited from
base class).</dd>
<dt><strong><code>hOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Heading offset of the Signal relative to its orientation.</dd>
<dt><strong><code>pitch</code></strong> :&ensp;<code>float</code></dt>
<dd>Pitch angle (rad) of the Signal relative to the inertial system
(inherited from base class).</dd>
<dt><strong><code>roll</code></strong> :&ensp;<code>float</code></dt>
<dd>Roll angle (rad) of the Signal after applying pitch (inherited
from base class).</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the Signal (inherited from base class).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height of the Signal (inherited from base class).</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the Signal (inherited from base class).</dd>
<dt><strong><code>validity</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.Validity" href="#scenariogeneration.xodr.signals_objects.Validity">Validity</a></code>, optional</dt>
<dd>Explicit validity information for the Signal.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the Signal.
get_attributes()
Returns a dictionary of all attributes of the Signal.
add_validity(fromLane, toLane)
Adds a new validity range for the Signal.</p>
<p>Initialize the Signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the Signal.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the Signal.</dd>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code></dt>
<dd>Country code according to ISO 3166-1 (alpha-2 for OpenDRIVE 1.6,
alpha-3 for OpenDRIVE 1.4).</dd>
<dt><strong><code>Type</code></strong> :&ensp;<code>SignalType</code> or <code>str</code></dt>
<dd>Type of the Signal.</dd>
<dt><strong><code>subtype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subtype for further specification of the Signal. Default is "-1".</dd>
<dt><strong><code>countryRevision</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Year of the applied traffic rules. Default is None.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the Signal. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for identification of the Signal. Default is None.</dd>
<dt><strong><code>dynamic</code></strong> :&ensp;<code>Dynamic</code>, optional</dt>
<dd>Specifies if the Signal is static or dynamic. Default is
Dynamic.no.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for further specification of the Signal. Default is None.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unit of the value, required if <code>value</code> is provided. Default is
None.</dd>
<dt><strong><code>zOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Vertical offset of the Signal with respect to the centerline.
Default is 1.5.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the Signal with respect to the road. Default is
Orientation.positive.</dd>
<dt><strong><code>hOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Heading offset of the Signal relative to its orientation.
Default is 0.</dd>
<dt><strong><code>pitch</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Pitch angle (rad) of the Signal relative to the inertial system.
Default is 0.</dd>
<dt><strong><code>roll</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Roll angle (rad) of the Signal after applying pitch. Default is
0.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height of the Signal. Default is None.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the Signal. Default is None.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the Signal. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xodr.signals_objects._SignalObjectBase</li>
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Signal.add_validity"><code class="name flex">
<span>def <span class="ident">add_validity</span></span>(<span>self, fromLane: int, toLane: int) ‑> <a title="scenariogeneration.xodr.signals_objects.Signal" href="#scenariogeneration.xodr.signals_objects.Signal">Signal</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;Signal&#34;:
    &#34;&#34;&#34;Add a validity range to the Signal.

    Parameters
    ----------
    fromLane : int
        The starting lane for the validity range.
    toLane : int
        The ending lane for the validity range.

    Returns
    -------
    Signal
        The updated Signal object.

    Raises
    ------
    ValueError
        If a validity range is already set for the Signal.
    &#34;&#34;&#34;
    if self.validity:
        raise ValueError(&#34;only one validity is allowed&#34;)
    self.validity = Validity(fromLane, toLane)
    return self</code></pre>
</details>
<div class="desc"><p>Add a validity range to the Signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The starting lane for the validity range.</dd>
<dt><strong><code>toLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The ending lane for the validity range.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.signals_objects.Signal" href="#scenariogeneration.xodr.signals_objects.Signal">Signal</a></code></dt>
<dd>The updated Signal object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a validity range is already set for the Signal.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Signal.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the Signal as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Signal.
    &#34;&#34;&#34;
    retdict = super().get_common_attributes()
    retdict[&#34;country&#34;] = str(self.country).upper()
    retdict[&#34;type&#34;] = str(self.type)
    retdict[&#34;subtype&#34;] = str(self.subtype)
    if self.countryRevision is not None:
        retdict[&#34;countryRevision&#34;] = str(self.countryRevision)
    if self.hOffset is not None:
        retdict[&#34;hOffset&#34;] = str(self.hOffset)
    if self.value is not None:
        retdict[&#34;value&#34;] = str(self.value)
        if self.unit is None:
            raise NotEnoughInputArguments(
                &#34;If value is set for a signal, unit has to be added aswell&#34;
            )
        retdict[&#34;unit&#34;] = str(self.unit)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Signal as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Signal.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Signal.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Signal.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Signal.
    &#34;&#34;&#34;
    element = ET.Element(&#34;signal&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    if self.validity:
        element.append(self.validity.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Signal.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Signal.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.SignalReference"><code class="flex name class">
<span>class <span class="ident">SignalReference</span></span>
<span>(</span><span>s: float,<br>t: float,<br>id: str | None = None,<br>orientation: <a title="scenariogeneration.xodr.enumerations.Orientation" href="enumerations.html#scenariogeneration.xodr.enumerations.Orientation">Orientation</a> = Orientation.positive)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalReference(XodrBase):
    &#34;&#34;&#34;SignalReference defines the signal reference element in OpenDRIVE.

    Attributes
    ----------
    s : float
        s-coordinate of the SignalReference.
    t : float
        t-coordinate of the SignalReference.
    id : str, optional
        ID of the SignalReference.
    orientation : Orientation
        Orientation of the SignalReference with respect to the road.
    validity : Validity, optional
        Explicit validity information for the SignalReference.
    _usedIDs : dict[str, list[str]]
        Dictionary with a list of used IDs. Keys are class names of
        SignalReference. Shared to auto-generate unique IDs.
    _IDCounter : dict[str, int]
        Dictionary with counters for auto-generation of IDs. Keys are
        class names of SignalReference. Shared to auto-generate unique IDs.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the SignalReference.
    get_attributes()
        Returns a dictionary of all attributes of the SignalReference.
    add_validity(fromLane, toLane)
        Adds a new validity range for the SignalReference.
    _update_id()
        Ensures that an ID is assigned if none was provided and that
        provided IDs are unique.
    &#34;&#34;&#34;

    _usedIDs = {}
    _IDCounter = {}

    def __init__(
        self,
        s: float,
        t: float,
        id: Optional[str] = None,
        orientation: Orientation = Orientation.positive,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the SignalReference.

        Parameters
        ----------
        s : float
            s-coordinate of the SignalReference.
        t : float
            t-coordinate of the SignalReference.
        id : str, optional
            ID of the SignalReference. Default is None.
        orientation : Orientation, optional
            Orientation of the SignalReference with respect to the road.
            Default is Orientation.positive.
        &#34;&#34;&#34;

        # get attributes that are common with signals
        super().__init__()
        self.s = s
        self.t = t
        self.orientation = enumchecker(orientation, Orientation)
        self.validity = None
        self.id = id

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, SignalReference) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def _update_id(self) -&gt; None:
        &#34;&#34;&#34;Ensure that an ID is assigned if none was provided and that
        provided IDs are unique.&#34;&#34;&#34;
        # ensure unique IDs
        try:
            if str(self.id) in self._usedIDs[self.__class__.__name__]:
                print(
                    &#34;Warning: id&#34;,
                    self.id,
                    &#34;has already been used for another&#34;,
                    self.__class__.__name__,
                    &#34;...auto-generating unique id.&#34;,
                )

        except KeyError:
            self._usedIDs[self.__class__.__name__] = []
            self._IDCounter[self.__class__.__name__] = 0

        if self.id == None or (
            str(self.id) in self._usedIDs[self.__class__.__name__]
        ):
            while (
                str(self._IDCounter[self.__class__.__name__])
                in self._usedIDs[self.__class__.__name__]
            ):
                self._IDCounter[self.__class__.__name__] += 1
            self.id = str(self._IDCounter[self.__class__.__name__])

        self._usedIDs[self.__class__.__name__].append(str(self.id))

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of the SignalReference as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the SignalReference.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;id&#34;] = str(self.id)
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;t&#34;] = str(self.t)
        if self.orientation == Orientation.positive:
            retdict[&#34;orientation&#34;] = &#34;+&#34;
        elif self.orientation == Orientation.negative:
            retdict[&#34;orientation&#34;] = &#34;-&#34;
        else:
            retdict[&#34;orientation&#34;] = enum2str(self.orientation)

        return retdict

    def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;SignalReference&#34;:
        &#34;&#34;&#34;Add a validity range to the SignalReference.

        Parameters
        ----------
        fromLane : int
            The starting lane for the validity range.
        toLane : int
            The ending lane for the validity range.

        Returns
        -------
        SignalReference
            The updated SignalReference object.

        Raises
        ------
        ValueError
            If a validity range is already set for the SignalReference.
        &#34;&#34;&#34;
        if self.validity:
            raise ValueError(&#34;only one validity is allowed&#34;)
        self.validity = Validity(fromLane, toLane)
        return self

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the SignalReference.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the SignalReference.
        &#34;&#34;&#34;
        element = ET.Element(&#34;signalReference&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        if self.validity:
            element.append(self.validity.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>SignalReference defines the signal reference element in OpenDRIVE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the SignalReference.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the SignalReference.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the SignalReference.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the SignalReference with respect to the road.</dd>
<dt><strong><code>validity</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.signals_objects.Validity" href="#scenariogeneration.xodr.signals_objects.Validity">Validity</a></code>, optional</dt>
<dd>Explicit validity information for the SignalReference.</dd>
<dt><strong><code>_usedIDs</code></strong> :&ensp;<code>dict[str, list[str]]</code></dt>
<dd>Dictionary with a list of used IDs. Keys are class names of
SignalReference. Shared to auto-generate unique IDs.</dd>
<dt><strong><code>_IDCounter</code></strong> :&ensp;<code>dict[str, int]</code></dt>
<dd>Dictionary with counters for auto-generation of IDs. Keys are
class names of SignalReference. Shared to auto-generate unique IDs.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the SignalReference.
get_attributes()
Returns a dictionary of all attributes of the SignalReference.
add_validity(fromLane, toLane)
Adds a new validity range for the SignalReference.
_update_id()
Ensures that an ID is assigned if none was provided and that
provided IDs are unique.</p>
<p>Initialize the SignalReference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the SignalReference.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>t-coordinate of the SignalReference.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the SignalReference. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the SignalReference with respect to the road.
Default is Orientation.positive.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.SignalReference.add_validity"><code class="name flex">
<span>def <span class="ident">add_validity</span></span>(<span>self, fromLane: int, toLane: int) ‑> <a title="scenariogeneration.xodr.signals_objects.SignalReference" href="#scenariogeneration.xodr.signals_objects.SignalReference">SignalReference</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_validity(self, fromLane: int, toLane: int) -&gt; &#34;SignalReference&#34;:
    &#34;&#34;&#34;Add a validity range to the SignalReference.

    Parameters
    ----------
    fromLane : int
        The starting lane for the validity range.
    toLane : int
        The ending lane for the validity range.

    Returns
    -------
    SignalReference
        The updated SignalReference object.

    Raises
    ------
    ValueError
        If a validity range is already set for the SignalReference.
    &#34;&#34;&#34;
    if self.validity:
        raise ValueError(&#34;only one validity is allowed&#34;)
    self.validity = Validity(fromLane, toLane)
    return self</code></pre>
</details>
<div class="desc"><p>Add a validity range to the SignalReference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The starting lane for the validity range.</dd>
<dt><strong><code>toLane</code></strong> :&ensp;<code>int</code></dt>
<dd>The ending lane for the validity range.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.signals_objects.SignalReference" href="#scenariogeneration.xodr.signals_objects.SignalReference">SignalReference</a></code></dt>
<dd>The updated SignalReference object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a validity range is already set for the SignalReference.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.SignalReference.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of the SignalReference as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the SignalReference.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;id&#34;] = str(self.id)
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;t&#34;] = str(self.t)
    if self.orientation == Orientation.positive:
        retdict[&#34;orientation&#34;] = &#34;+&#34;
    elif self.orientation == Orientation.negative:
        retdict[&#34;orientation&#34;] = &#34;-&#34;
    else:
        retdict[&#34;orientation&#34;] = enum2str(self.orientation)

    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the SignalReference as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the SignalReference.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.SignalReference.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the SignalReference.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the SignalReference.
    &#34;&#34;&#34;
    element = ET.Element(&#34;signalReference&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    if self.validity:
        element.append(self.validity.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the SignalReference.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the SignalReference.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Tunnel"><code class="flex name class">
<span>class <span class="ident">Tunnel</span></span>
<span>(</span><span>s: float,<br>length: float,<br>id: str,<br>name: str,<br>tunnel_type: <a title="scenariogeneration.xodr.enumerations.TunnelType" href="enumerations.html#scenariogeneration.xodr.enumerations.TunnelType">TunnelType</a> = TunnelType.standard,<br>daylight: float = 0.5,<br>lighting: float = 0.5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tunnel(XodrBase):
    &#34;&#34;&#34;A tunnel road object (t_road_objects_tunnel).

    Attributes
    ----------
    s : float
        s-coordinate of the tunnel.
    length : float
        Length of the tunnel.
    id : str
        ID of the tunnel.
    name : str
        Name of the tunnel.
    tunnel_type : TunnelType
        Type of the tunnel.
    daylight : float
        Value between 0.0 and 1.0 (application-specific).
    lighting : float
        Value between 0.0 and 1.0 (application-specific).

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the Tunnel.
    get_attributes()
        Returns a dictionary of all XML attributes of the Tunnel.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        length: float,
        id: str,
        name: str,
        tunnel_type: TunnelType = TunnelType.standard,
        daylight: float = 0.5,
        lighting: float = 0.5,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a Tunnel.

        Parameters
        ----------
        s : float
            s-coordinate of the tunnel.
        length : float
            Length of the tunnel.
        id : str
            ID of the tunnel.
        name : str
            Name of the tunnel.
        tunnel_type : TunnelType, optional
            Type of the tunnel. Default is TunnelType.standard.
        daylight : float, optional
            Value between 0.0 and 1.0 (application-specific). Default is 0.5.
        lighting : float, optional
            Value between 0.0 and 1.0 (application-specific). Default is 0.5.
        &#34;&#34;&#34;
        super().__init__()
        self.s = s
        self.length = length
        self.id = id
        self.name = name
        self.tunnel_type = enumchecker(tunnel_type, TunnelType)
        self.daylight = daylight
        self.lighting = lighting

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Tunnel) and super().__eq__(other):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return a dictionary of all XML attributes of the Tunnel.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Tunnel.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;length&#34;] = str(self.length)
        retdict[&#34;id&#34;] = str(self.id)
        retdict[&#34;name&#34;] = str(self.name)
        retdict[&#34;type&#34;] = enum2str(self.tunnel_type)
        retdict[&#34;daylight&#34;] = str(self.daylight)
        retdict[&#34;lighting&#34;] = str(self.lighting)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Tunnel.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Tunnel.
        &#34;&#34;&#34;
        element = ET.Element(&#34;tunnel&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>A tunnel road object (t_road_objects_tunnel).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the tunnel.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the tunnel.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the tunnel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the tunnel.</dd>
<dt><strong><code>tunnel_type</code></strong> :&ensp;<code>TunnelType</code></dt>
<dd>Type of the tunnel.</dd>
<dt><strong><code>daylight</code></strong> :&ensp;<code>float</code></dt>
<dd>Value between 0.0 and 1.0 (application-specific).</dd>
<dt><strong><code>lighting</code></strong> :&ensp;<code>float</code></dt>
<dd>Value between 0.0 and 1.0 (application-specific).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the Tunnel.
get_attributes()
Returns a dictionary of all XML attributes of the Tunnel.</p>
<p>Initialize a Tunnel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>s-coordinate of the tunnel.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the tunnel.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the tunnel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the tunnel.</dd>
<dt><strong><code>tunnel_type</code></strong> :&ensp;<code>TunnelType</code>, optional</dt>
<dd>Type of the tunnel. Default is TunnelType.standard.</dd>
<dt><strong><code>daylight</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value between 0.0 and 1.0 (application-specific). Default is 0.5.</dd>
<dt><strong><code>lighting</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value between 0.0 and 1.0 (application-specific). Default is 0.5.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Tunnel.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return a dictionary of all XML attributes of the Tunnel.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Tunnel.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;length&#34;] = str(self.length)
    retdict[&#34;id&#34;] = str(self.id)
    retdict[&#34;name&#34;] = str(self.name)
    retdict[&#34;type&#34;] = enum2str(self.tunnel_type)
    retdict[&#34;daylight&#34;] = str(self.daylight)
    retdict[&#34;lighting&#34;] = str(self.lighting)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return a dictionary of all XML attributes of the Tunnel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Tunnel.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Tunnel.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Tunnel.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Tunnel.
    &#34;&#34;&#34;
    element = ET.Element(&#34;tunnel&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Tunnel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Tunnel.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Validity"><code class="flex name class">
<span>class <span class="ident">Validity</span></span>
<span>(</span><span>fromLane: int, toLane: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Validity(XodrBase):
    &#34;&#34;&#34;Validity is the explicit validity information for a signal.

    Attributes
    ----------
    fromLane : int
        Minimum ID of the lanes for which the object is valid.
    toLane : int
        Maximum ID of the lanes for which the object is valid.

    Methods
    -------
    get_element()
        Returns the full ElementTree representation of the Validity.
    get_attributes()
        Returns a dictionary of all attributes of the Validity.
    &#34;&#34;&#34;

    def __init__(self, fromLane: int, toLane: int) -&gt; None:
        &#34;&#34;&#34;Initialize the Validity.

        Parameters
        ----------
        fromLane : int
            Minimum ID of the lanes for which the object is valid.
        toLane : int
            Maximum ID of the lanes for which the object is valid.
        &#34;&#34;&#34;
        super().__init__()
        self.fromLane = fromLane
        self.toLane = toLane

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Validity) and super().__eq__(other):
            if self.fromLane == other.fromLane and self.toLane == other.toLane:
                return True
        return False

    def get_attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Return the attributes of Validity as a dictionary.

        Returns
        -------
        dict[str, str]
            A dictionary containing the attributes of the Validity.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;fromLane&#34;] = str(self.fromLane)
        retdict[&#34;toLane&#34;] = str(self.toLane)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the Validity.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the Validity.
        &#34;&#34;&#34;
        element = ET.Element(&#34;validity&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>Validity is the explicit validity information for a signal.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>fromLane</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum ID of the lanes for which the object is valid.</dd>
<dt><strong><code>toLane</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum ID of the lanes for which the object is valid.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree representation of the Validity.
get_attributes()
Returns a dictionary of all attributes of the Validity.</p>
<p>Initialize the Validity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromLane</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum ID of the lanes for which the object is valid.</dd>
<dt><strong><code>toLane</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum ID of the lanes for which the object is valid.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.signals_objects.Validity.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Return the attributes of Validity as a dictionary.

    Returns
    -------
    dict[str, str]
        A dictionary containing the attributes of the Validity.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;fromLane&#34;] = str(self.fromLane)
    retdict[&#34;toLane&#34;] = str(self.toLane)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of Validity as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A dictionary containing the attributes of the Validity.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.signals_objects.Validity.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the Validity.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the Validity.
    &#34;&#34;&#34;
    element = ET.Element(&#34;validity&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the Validity.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the Validity.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.CornerLocal" href="#scenariogeneration.xodr.signals_objects.CornerLocal">CornerLocal</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.CornerLocal.get_attributes" href="#scenariogeneration.xodr.signals_objects.CornerLocal.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.CornerLocal.get_element" href="#scenariogeneration.xodr.signals_objects.CornerLocal.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.CornerRoad" href="#scenariogeneration.xodr.signals_objects.CornerRoad">CornerRoad</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.CornerRoad.get_attributes" href="#scenariogeneration.xodr.signals_objects.CornerRoad.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.CornerRoad.get_element" href="#scenariogeneration.xodr.signals_objects.CornerRoad.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Dependency" href="#scenariogeneration.xodr.signals_objects.Dependency">Dependency</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Dependency.get_attributes" href="#scenariogeneration.xodr.signals_objects.Dependency.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Dependency.get_element" href="#scenariogeneration.xodr.signals_objects.Dependency.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Marking" href="#scenariogeneration.xodr.signals_objects.Marking">Marking</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Marking.add_cornerReference" href="#scenariogeneration.xodr.signals_objects.Marking.add_cornerReference">add_cornerReference</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Marking.get_attributes" href="#scenariogeneration.xodr.signals_objects.Marking.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Marking.get_element" href="#scenariogeneration.xodr.signals_objects.Marking.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Object" href="#scenariogeneration.xodr.signals_objects.Object">Object</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.add_marking" href="#scenariogeneration.xodr.signals_objects.Object.add_marking">add_marking</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.add_material" href="#scenariogeneration.xodr.signals_objects.Object.add_material">add_material</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.add_outline" href="#scenariogeneration.xodr.signals_objects.Object.add_outline">add_outline</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.add_parking_space" href="#scenariogeneration.xodr.signals_objects.Object.add_parking_space">add_parking_space</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.add_validity" href="#scenariogeneration.xodr.signals_objects.Object.add_validity">add_validity</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.get_attributes" href="#scenariogeneration.xodr.signals_objects.Object.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.get_element" href="#scenariogeneration.xodr.signals_objects.Object.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Object.repeat" href="#scenariogeneration.xodr.signals_objects.Object.repeat">repeat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Outline" href="#scenariogeneration.xodr.signals_objects.Outline">Outline</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Outline.add_corner" href="#scenariogeneration.xodr.signals_objects.Outline.add_corner">add_corner</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Outline.get_attributes" href="#scenariogeneration.xodr.signals_objects.Outline.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Outline.get_element" href="#scenariogeneration.xodr.signals_objects.Outline.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.ParkingSpace" href="#scenariogeneration.xodr.signals_objects.ParkingSpace">ParkingSpace</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.ParkingSpace.get_attributes" href="#scenariogeneration.xodr.signals_objects.ParkingSpace.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.ParkingSpace.get_element" href="#scenariogeneration.xodr.signals_objects.ParkingSpace.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Signal" href="#scenariogeneration.xodr.signals_objects.Signal">Signal</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Signal.add_validity" href="#scenariogeneration.xodr.signals_objects.Signal.add_validity">add_validity</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Signal.get_attributes" href="#scenariogeneration.xodr.signals_objects.Signal.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Signal.get_element" href="#scenariogeneration.xodr.signals_objects.Signal.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.SignalReference" href="#scenariogeneration.xodr.signals_objects.SignalReference">SignalReference</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.SignalReference.add_validity" href="#scenariogeneration.xodr.signals_objects.SignalReference.add_validity">add_validity</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.SignalReference.get_attributes" href="#scenariogeneration.xodr.signals_objects.SignalReference.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.SignalReference.get_element" href="#scenariogeneration.xodr.signals_objects.SignalReference.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Tunnel" href="#scenariogeneration.xodr.signals_objects.Tunnel">Tunnel</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Tunnel.get_attributes" href="#scenariogeneration.xodr.signals_objects.Tunnel.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Tunnel.get_element" href="#scenariogeneration.xodr.signals_objects.Tunnel.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.signals_objects.Validity" href="#scenariogeneration.xodr.signals_objects.Validity">Validity</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.signals_objects.Validity.get_attributes" href="#scenariogeneration.xodr.signals_objects.Validity.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.signals_objects.Validity.get_element" href="#scenariogeneration.xodr.signals_objects.Validity.get_element">get_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
