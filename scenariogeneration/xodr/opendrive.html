<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xodr.opendrive API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.opendrive</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive"><code class="flex name class">
<span>class <span class="ident">OpenDrive</span></span>
<span>(</span><span>name: str,<br>revMajor: str = '1',<br>revMinor: str = '5',<br>geo_reference: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenDrive(XodrBase):
    &#34;&#34;&#34;OpenDrive is the main class of pyodrx to generate an OpenDrive road.

    Parameters
    ----------
    name : str
        Name of the road.
    revMajor : str, optional
        Major revision of OpenDRIVE written to the header. Default is &#39;1&#39;.
    revMinor : str, optional
        Minor revision of OpenDRIVE written to the header. Default is &#39;5&#39;.
    geo_reference : str, optional
        Geographic reference information for the database. Default is None.

    Attributes
    ----------
    name : str
        Name of the road.
    revMajor : str
        Major revision of OpenDRIVE written to the header.
    revMinor : str
        Minor revision of OpenDRIVE written to the header.
    geo_reference : str
        Geographic reference information for the database.
    roads : dict[str, Road]
        All roads in the OpenDrive.
    junctions : list[Junction]
        All junctions in the OpenDrive.

    Methods
    -------
    get_element()
        Returns the full ElementTree of the OpenDrive.
    add_road(road)
        Adds a road to the OpenDrive.
    add_junction(junction)
        Adds a junction to the OpenDrive.
    add_junction_creator(junction_creator)
        Adds necessary info from a junction creator to the OpenDrive.
    adjust_roads_and_lanes()
        Adjusts starting positions of all geometries of all roads and links
        lanes in neighboring roads.
    adjust_roadmarks()
        Adjusts roadmarks along roads and lane sections.
    adjust_startpoints()
        Adjusts starting positions of all geometries of all roads.
    write_xml(filename, prettyprint, encoding)
        Writes the OpenDrive to an XML file.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        revMajor: str = &#34;1&#34;,
        revMinor: str = &#34;5&#34;,
        geo_reference: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the OpenDrive.

        Parameters
        ----------
        name : str
            Name of the road.
        revMajor : str, optional
            Major revision of OpenDRIVE. Default is &#39;1&#39;.
        revMinor : str, optional
            Minor revision of OpenDRIVE. Default is &#39;5&#39;.
        geo_reference : str, optional
            Geographic reference information for the database. Default is None.
        &#34;&#34;&#34;
        super().__init__()
        self.name = name
        self.revMajor = revMajor
        self.revMinor = revMinor
        self._header = _Header(
            self.name, self.revMajor, self.revMinor, geo_reference
        )
        self.roads = {}
        self.junctions = []
        # self.road_ids = []

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, OpenDrive) and super().__eq__(other):
            if (
                self.roads == other.roads
                and self.junctions == other.junctions
                and self._header == other._header
            ):
                return True
        return False

    def add_road(self, road: Road) -&gt; &#34;OpenDrive&#34;:
        &#34;&#34;&#34;Add a new road to the OpenDrive.

        Parameters
        ----------
        road : Road
            The road to add.

        Returns
        -------
        OpenDrive
            The updated OpenDrive object.

        Raises
        ------
        TypeError
            If the input is not of type `Road`.
        ValueError
            If the road has a predecessor but no roads have been added yet.
        IdAlreadyExists
            If a road with the same ID already exists.
        &#34;&#34;&#34;
        if not isinstance(road, Road):
            raise TypeError(&#34;input road is not of type Road&#34;)
        if (len(self.roads) == 0) and road.predecessor:
            ValueError(
                &#34;No road was added and the added road has a predecessor, please add the predecessor first&#34;
            )
        if str(road.id) in self.roads:
            raise IdAlreadyExists(
                &#34;Road id &#34; + str(road.id) + &#34; has already been added. &#34;
            )
        self.roads[str(road.id)] = road
        return self

    def add_junction_creator(
        self,
        junction_creator: Union[
            &#34;CommonJunctionCreator&#34;, &#34;DirectJunctionCreator&#34;
        ],
    ) -&gt; &#34;OpenDrive&#34;:
        &#34;&#34;&#34;Add a junction creator to the OpenDrive.

        This method takes a `CommonJunctionCreator` or `DirectJunctionCreator`
        as input and adds all necessary information (roads and junctions) to
        the OpenDrive.

        Parameters
        ----------
        junction_creator : CommonJunctionCreator or DirectJunctionCreator
            The junction creator to add.

        Returns
        -------
        OpenDrive
            The updated OpenDrive object.
        &#34;&#34;&#34;
        if junction_creator.junction.junction_type == JunctionType.default:
            for road in junction_creator.get_connecting_roads():
                self.add_road(road)

        self.add_junction(junction_creator.junction)
        return self

    def adjust_roads_and_lanes(self) -&gt; None:
        &#34;&#34;&#34;Adjust the starting position of all geometries of all roads and
        link all lanes in neighboring roads.

        This method adjusts the starting positions of all road geometries
        and attempts to link lanes between neighboring roads.

        Returns
        -------
        None

        Raises
        ------
        RoadsAndLanesNotAdjusted
            If roads and lanes are not adjusted properly.
        &#34;&#34;&#34;
        # adjust roads and their geometries
        self.adjust_startpoints()

        results = list(combinations(self.roads, 2))

        for r in range(len(results)):
            # print(&#39;Analyzing roads&#39;, results[r][0], &#39;and&#39;, results[r][1] )
            create_lane_links(
                self.roads[results[r][0]], self.roads[results[r][1]]
            )

    def adjust_roadmarks(self) -&gt; None:
        &#34;&#34;&#34;Adjust broken roadmarks (if the same definition) along roads and
        lane sections.

        This method attempts to fix roadmarks across roads and lane
        sections by ensuring continuity and consistency.

        Returns
        -------
        None

        Raises
        ------
        RoadsAndLanesNotAdjusted
            If roads and lanes are not adjusted properly before calling
            this method.
        &#34;&#34;&#34;
        adjusted_road = self.roads[list(self.roads.keys())[0]]
        if not adjusted_road.is_adjusted(&#34;planview&#34;):
            raise RoadsAndLanesNotAdjusted(
                &#34;Cannot adjust roadmarks if geometries are not adjusted properly first. Consider calling &#39;adjust_roads_and_lanes()&#39; first.&#34;
            )
        adjusted_road.lanes.adjust_road_marks_from_start(
            adjusted_road.planview.get_total_length()
        )

        count_total_adjusted_roads = 1

        while count_total_adjusted_roads &lt; len(self.roads):
            for r in self.roads.keys():
                if not self.roads[r].is_adjusted(&#34;planview&#34;):
                    raise RoadsAndLanesNotAdjusted(
                        &#34;Cannot adjust roadmarks if geometries are not adjusted properly first. Consider calling &#39;adjust_roads_and_lanes()&#39; first.&#34;
                    )
                if self.roads[r].lanes.roadmarks_adjusted:
                    if self.roads[r].successor:
                        if (
                            self.roads[r].successor.element_type
                            == ElementType.road
                        ):
                            if (
                                self.roads[r].successor.contact_point
                                == ContactPoint.start
                            ):
                                self.roads[
                                    str(self.roads[r].successor.element_id)
                                ].lanes.adjust_road_marks_from_start(
                                    self.roads[
                                        str(self.roads[r].successor.element_id)
                                    ].planview.get_total_length(),
                                    self.roads[r].lanes.lanesections[-1],
                                    ContactPoint.end,
                                )
                                count_total_adjusted_roads += 1
                            else:
                                self.roads[
                                    str(self.roads[r].successor.element_id)
                                ].lanes.adjust_road_marks_from_end(
                                    self.roads[
                                        str(self.roads[r].successor.element_id)
                                    ].planview.get_total_length(),
                                    self.roads[r].lanes.lanesections[-1],
                                    ContactPoint.end,
                                )
                                count_total_adjusted_roads += 1
                        else:
                            for j in self.junctions:
                                if j.id == self.roads[r].successor.element_id:
                                    junction = j
                                    break

                            for conn in junction.connections:
                                if str(conn.incoming_road) == r:
                                    if (
                                        conn.contact_point
                                        == ContactPoint.start
                                    ):
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].lanes.adjust_road_marks_from_start(
                                            self.roads[
                                                str(conn.connecting_road)
                                            ].planview.get_total_length(),
                                            self.roads[r].lanes.lanesections[
                                                0
                                            ],
                                            ContactPoint.end,
                                        )
                                    else:
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].lanes.adjust_road_marks_from_end(
                                            self.roads[
                                                str(conn.connecting_road)
                                            ].planview.get_total_length(),
                                            self.roads[r].lanes.lanesections[
                                                0
                                            ],
                                            ContactPoint.end,
                                        )

                                    count_total_adjusted_roads += 1

                    if self.roads[r].predecessor:
                        if (
                            self.roads[r].predecessor.element_type
                            == ElementType.road
                        ):
                            if (
                                self.roads[r].predecessor.contact_point
                                == ContactPoint.start
                            ):
                                self.roads[
                                    str(self.roads[r].predecessor.element_id)
                                ].lanes.adjust_road_marks_from_start(
                                    self.roads[
                                        str(
                                            self.roads[
                                                r
                                            ].predecessor.element_id
                                        )
                                    ].planview.get_total_length(),
                                    self.roads[r].lanes.lanesections[0],
                                    ContactPoint.start,
                                )
                                count_total_adjusted_roads += 1
                            else:
                                self.roads[
                                    str(self.roads[r].predecessor.element_id)
                                ].lanes.adjust_road_marks_from_end(
                                    self.roads[
                                        str(
                                            self.roads[
                                                r
                                            ].predecessor.element_id
                                        )
                                    ].planview.get_total_length(),
                                    self.roads[r].lanes.lanesections[0],
                                    ContactPoint.start,
                                )
                                count_total_adjusted_roads += 1
                        else:
                            for conn in self.junctions[0].connections:
                                if str(conn.incoming_road) == r:
                                    if (
                                        conn.contact_point
                                        == ContactPoint.start
                                    ):
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].lanes.adjust_road_marks_from_start(
                                            self.roads[
                                                str(conn.connecting_road)
                                            ].planview.get_total_length(),
                                            self.roads[r].lanes.lanesections[
                                                -1
                                            ],
                                            ContactPoint.start,
                                        )
                                    else:
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].lanes.adjust_road_marks_from_end(
                                            self.roads[
                                                str(conn.connecting_road)
                                            ].planview.get_total_length(),
                                            self.roads[r].lanes.lanesections[
                                                -1
                                            ],
                                            ContactPoint.start,
                                        )
                                    count_total_adjusted_roads += 1

    def _adjust_road_wrt_neighbour(
        self,
        road_id: int,
        neighbour_id: int,
        contact_point: ContactPoint,
        neighbour_type: str,
    ) -&gt; None:
        &#34;&#34;&#34;Adjust geometries of a road using a neighboring road as a
        reference.

        This method adjusts the geometries of the road with `road_id` by
        taking the neighboring road with `neighbour_id` as a reference.
        The neighboring road can be a successor or predecessor. The type
        of `contact_point` is necessary because this function is also
        called on roads connecting to a junction road, where the road
        itself does not know the contact point of the junction road it
        connects to.

        Parameters
        ----------
        road_id : int
            ID of the road to adjust.
        neighbour_id : int
            ID of the neighboring road used as a reference. The neighboring
            road is assumed to be already adjusted.
        contact_point : ContactPoint
            The contact point with respect to the road being adjusted.
        neighbour_type : str
            Type of linking to the neighboring road. Can be &#39;successor&#39; or
            &#39;predecessor&#39;.

        Returns
        -------
        None

        Raises
        ------
        ValueError
            If the `contact_point` is unknown.
        &#34;&#34;&#34;
        main_road = self.roads[str(road_id)]

        if contact_point == ContactPoint.start:
            x, y, h = self.roads[str(neighbour_id)].planview.get_start_point()
            h = (
                h + np.pi
            )  # we are attached to the predecessor&#39;s start, so road[k] will start in its opposite direction
        elif contact_point == ContactPoint.end:
            x, y, h = self.roads[str(neighbour_id)].planview.get_end_point()

            # since we are at the end, the relevant s-coordinate for determining widths for lane offset is the length of the last lane section
        else:
            raise ValueError(&#34;Unknown ContactPoint&#34;)

        if neighbour_type == &#34;predecessor&#34;:
            num_lane_offsets = 0
            if main_road.pred_direct_junction:
                num_lane_offsets = main_road.pred_direct_junction[neighbour_id]
            elif str(neighbour_id) in main_road.lane_offset_pred:
                num_lane_offsets = main_road.lane_offset_pred[
                    str(neighbour_id)
                ]
            offset_width = self._calculate_lane_offset_width(
                road_id, neighbour_id, num_lane_offsets, contact_point
            )
            x = -offset_width * np.sin(h) + x
            y = offset_width * np.cos(h) + y

            main_road.planview.set_start_point(x, y, h)
            main_road.planview.adjust_geometries()

        elif neighbour_type == &#34;successor&#34;:
            num_lane_offsets = 0
            if main_road.succ_direct_junction:
                num_lane_offsets = main_road.succ_direct_junction[neighbour_id]
            elif str(neighbour_id) in main_road.lane_offset_suc:
                num_lane_offsets = main_road.lane_offset_suc[str(neighbour_id)]
            offset_width = self._calculate_lane_offset_width(
                road_id, neighbour_id, num_lane_offsets, contact_point
            )
            x = offset_width * np.sin(h) + x
            y = -offset_width * np.cos(h) + y

            main_road.planview.set_start_point(x, y, h)
            main_road.planview.adjust_geometries(True)

    def _calculate_lane_offset_width(
        self,
        road_id: int,
        neighbour_id: int,
        num_lane_offsets: int,
        contact_point: ContactPoint,
    ) -&gt; float:
        &#34;&#34;&#34;Calculate the width for shifting the road if a lane offset is
        present.

        Parameters
        ----------
        road_id : int
            ID of the road being adjusted.
        neighbour_id : int
            ID of the neighboring road used as a reference. The neighboring
            road is assumed to be already adjusted.
        num_lane_offsets : int
            Number of lane offsets to consider for the calculation.
        contact_point : ContactPoint
            The contact point with respect to the road being adjusted.

        Returns
        -------
        float
            The calculated offset width for shifting the road.

        Raises
        ------
        ValueError
            If the `contact_point` is invalid.
        &#34;&#34;&#34;
        relevant_lanesection, relevant_s = get_lane_sec_and_s_for_lane_calc(
            self.roads[str(neighbour_id)], contact_point
        )
        # remains 0 if no lane offset exists
        offset_width = 0
        # if a lane offset exists, loop through relevant lanes (left/right) at the relevant s-coordinate to determine width of offset
        if num_lane_offsets &lt; 0:
            for lane in (
                self.roads[str(neighbour_id)]
                .lanes.lanesections[relevant_lanesection]
                .rightlanes[0 : -1 * num_lane_offsets]
            ):
                offset_width = offset_width - (
                    lane.widths[relevant_lanesection].a
                    + lane.widths[relevant_lanesection].b * relevant_s
                    + lane.widths[relevant_lanesection].c * relevant_s**2
                    + lane.widths[relevant_lanesection].d * relevant_s**3
                )
        if num_lane_offsets &gt; 0:
            for lane in (
                self.roads[str(neighbour_id)]
                .lanes.lanesections[relevant_lanesection]
                .leftlanes[0:num_lane_offsets]
            ):
                offset_width = offset_width + (
                    lane.widths[relevant_lanesection].a
                    + lane.widths[relevant_lanesection].b * relevant_s
                    + lane.widths[relevant_lanesection].c * relevant_s**2
                    + lane.widths[relevant_lanesection].d * relevant_s**3
                )

        return offset_width

    def _connection_sanity_check(
        self, road_id: str, connection_type: str
    ) -&gt; None:
        &#34;&#34;&#34;Check if a connection and its input make sense.

        This method verifies that all predecessor and successor connections
        and their contact points are correctly defined.

        Parameters
        ----------
        road_id : str
            ID of the road of interest.
        connection_type : str
            Specifies whether to check the predecessor or successor. Valid
            values are &#39;predecessor&#39; or &#39;successor&#39;.

        Returns
        -------
        None

        Raises
        ------
        GeneralIssueInputArguments
            If the `connection_type` is unknown.
        MixingDrivingDirection
            If there is a mismatch in connections between the road and its
            neighbor.
        &#34;&#34;&#34;
        road_id = str(road_id)
        if connection_type == &#34;predecessor&#34;:
            contact_point = self.roads[road_id].predecessor.contact_point
            neighbor_id = str(self.roads[road_id].predecessor.element_id)
        elif connection_type == &#34;successor&#34;:
            contact_point = self.roads[road_id].successor.contact_point
            neighbor_id = str(self.roads[road_id].successor.element_id)
        else:
            raise GeneralIssueInputArguments(
                &#34;connection_type: &#34; + connection_type + &#34; is unknown.&#34;
            )
        if self.roads[road_id].road_type == -1:
            if not (
                (
                    contact_point == ContactPoint.start
                    and self.roads[neighbor_id].predecessor is not None
                    and self.roads[neighbor_id].predecessor.element_id
                    == int(road_id)
                )
                or (
                    contact_point == ContactPoint.end
                    and self.roads[neighbor_id].successor is not None
                    and self.roads[neighbor_id].successor.element_id
                    == int(road_id)
                )
            ):
                raise MixingDrivingDirection(
                    &#34;road &#34;
                    + road_id
                    + &#34; and road &#34;
                    + neighbor_id
                    + &#34; have a mismatch in connections, please check predecessors/sucessors and contact points.&#34;
                )
        else:
            if not (
                (
                    contact_point == ContactPoint.start
                    and self.roads[neighbor_id].predecessor is not None
                    and self.roads[neighbor_id].predecessor.element_id
                    == self.roads[road_id].road_type
                )
                or contact_point == ContactPoint.end
                and self.roads[neighbor_id].successor is not None
                and self.roads[neighbor_id].successor.element_id
                == self.roads[road_id].road_type
            ):
                raise MixingDrivingDirection(
                    &#34;road &#34;
                    + road_id
                    + &#34; and road &#34;
                    + neighbor_id
                    + &#34; have a mismatch in connections, please check predecessors/sucessors and contact points.&#34;
                )

    def _create_adjustable_planview(
        self,
        road_id: str,
        predecessor_id: str,
        predecessor_contact_point: ContactPoint,
        successor_id: str,
        successor_contact_point: ContactPoint,
    ) -&gt; None:
        &#34;&#34;&#34;Create the geometry of an AdjustablePlanview type of planview.

        This method creates the geometry for a road with an
        AdjustablePlanview. Both the predecessor and the successor of the
        road must be fixed/adjusted for this to work.

        Parameters
        ----------
        road_id : str
            ID of the road with an AdjustablePlanview.
        predecessor_id : str
            ID of the predecessor road.
        predecessor_contact_point : ContactPoint
            The contact point of the predecessor.
        successor_id : str
            ID of the successor road.
        successor_contact_point : ContactPoint
            The contact point of the successor.

        Returns
        -------
        None
        &#34;&#34;&#34;

        def recalculate_xy(
            lane_offset: int,
            road: Road,
            lanesection: int,
            x: float,
            y: float,
            h: float,
            common_direct_signs: int = 1,
        ) -&gt; tuple[float, float]:
            &#34;&#34;&#34;Recalculate x and y if an offset (in junctions) is present.

            Parameters
            ----------
            lane_offset : int
                Lane offset of the road.
            road : Road
                The connected road.
            lanesection : int
                The lane section index.
            x : float
                The reference line x-coordinate of the connected road.
            y : float
                The reference line y-coordinate of the connected road.
            h : float
                The heading of the connected road.
            common_direct_signs : int, optional
                Direction sign multiplier. Default is 1.

            Returns
            -------
            tuple[float, float]
                The recalculated x and y coordinates.
            &#34;&#34;&#34;
            dist = 0
            start_offset = 0
            if lanesection == -1:
                dist = road.planview.get_total_length()
            if np.sign(lane_offset) == -1:
                angle_addition = -common_direct_signs * np.pi / 2
                for lane_iter in range((np.sign(lane_offset) * lane_offset)):
                    start_offset += (
                        road.lanes.lanesections[lanesection]
                        .rightlanes[lane_iter]
                        .get_width(dist)
                    )
            else:
                angle_addition = common_direct_signs * np.pi / 2
                for lane_iter in range((np.sign(lane_offset) * lane_offset)):
                    start_offset += (
                        road.lanes.lanesections[lanesection]
                        .leftlanes[lane_iter]
                        .get_width(dist)
                    )
            new_x = x + start_offset * np.cos(h + angle_addition)
            new_y = y + start_offset * np.sin(h + angle_addition)
            return new_x, new_y

        if predecessor_contact_point == ContactPoint.start:
            start_x, start_y, start_h = self.roads[
                predecessor_id
            ].planview.get_start_point()
            start_lane_section = 0
            start_h = start_h - np.pi
            flip_start = True

        elif predecessor_contact_point == ContactPoint.end:
            start_x, start_y, start_h = self.roads[
                predecessor_id
            ].planview.get_end_point()
            start_lane_section = -1
            flip_start = False

        if (
            self.roads[road_id].pred_direct_junction
            and int(predecessor_id) in self.roads[road_id].pred_direct_junction
        ):
            start_x, start_y = recalculate_xy(
                self.roads[road_id].pred_direct_junction[int(predecessor_id)],
                self.roads[predecessor_id],
                start_lane_section,
                start_x,
                start_y,
                start_h,
            )

        if (
            self.roads[road_id].lane_offset_pred
            and predecessor_id in self.roads[road_id].lane_offset_pred
            and self.roads[road_id].lane_offset_pred[predecessor_id] != 0
        ):
            start_x, start_y = recalculate_xy(
                self.roads[road_id].lane_offset_pred[predecessor_id],
                self.roads[predecessor_id],
                start_lane_section,
                start_x,
                start_y,
                start_h,
                -1,
            )

        if successor_contact_point == ContactPoint.start:
            end_x, end_y, end_h = self.roads[
                successor_id
            ].planview.get_start_point()
            end_lane_section = 0
            flip_end = False

        elif successor_contact_point == ContactPoint.end:
            end_x, end_y, end_h = self.roads[
                successor_id
            ].planview.get_end_point()
            end_lane_section = -1
            end_h = end_h - np.pi
            flip_end = True

        if (
            self.roads[road_id].succ_direct_junction
            and int(successor_id) in self.roads[road_id].succ_direct_junction
        ):
            end_x, end_y = recalculate_xy(
                self.roads[road_id].succ_direct_junction[int(successor_id)],
                self.roads[successor_id],
                end_lane_section,
                end_x,
                end_y,
                end_h,
            )

        clothoids = pcloth.SolveG2(
            start_x,
            start_y,
            start_h,
            1 / 1000000000,
            end_x,
            end_y,
            end_h,
            1 / 1000000000,
        )
        pv = PlanView(start_x, start_y, start_h)

        [
            pv.add_geometry(Spiral(x.KappaStart, x.KappaEnd, length=x.length))
            for x in clothoids
        ]
        pv.adjust_geometries()

        s_start = 0
        s_end = 0
        if start_lane_section == -1:
            s_start = self.roads[predecessor_id].planview.get_total_length()
        if end_lane_section == -1:
            s_end = self.roads[successor_id].planview.get_total_length()

        if (
            self.roads[road_id].planview.right_lane_defs is None
            and self.roads[road_id].planview.left_lane_defs is None
        ):
            if flip_start:
                right_lanes_start = [
                    ll.get_width(s_start)
                    for ll in self.roads[predecessor_id]
                    .lanes.lanesections[start_lane_section]
                    .leftlanes
                ]
                left_lanes_start = [
                    rl.get_width(s_start)
                    for rl in self.roads[predecessor_id]
                    .lanes.lanesections[start_lane_section]
                    .rightlanes
                ]
            else:
                left_lanes_start = [
                    ll.get_width(s_start)
                    for ll in self.roads[predecessor_id]
                    .lanes.lanesections[start_lane_section]
                    .leftlanes
                ]
                right_lanes_start = [
                    rl.get_width(s_start)
                    for rl in self.roads[predecessor_id]
                    .lanes.lanesections[start_lane_section]
                    .rightlanes
                ]

            if flip_end:
                right_lanes_end = [
                    ll.get_width(s_end)
                    for ll in self.roads[successor_id]
                    .lanes.lanesections[end_lane_section]
                    .leftlanes
                ]
                left_lanes_end = [
                    rl.get_width(s_end)
                    for rl in self.roads[successor_id]
                    .lanes.lanesections[end_lane_section]
                    .rightlanes
                ]
            else:
                left_lanes_end = [
                    ll.get_width(s_end)
                    for ll in self.roads[successor_id]
                    .lanes.lanesections[end_lane_section]
                    .leftlanes
                ]
                right_lanes_end = [
                    rl.get_width(s_end)
                    for rl in self.roads[successor_id]
                    .lanes.lanesections[end_lane_section]
                    .rightlanes
                ]
            if self.roads[road_id].planview.center_road_mark is None:
                center_road_mark = (
                    self.roads[predecessor_id]
                    .lanes.lanesections[start_lane_section]
                    .centerlane.roadmark[0]
                )
            else:
                center_road_mark = self.roads[
                    road_id
                ].planview.center_road_mark

            lanes = create_lanes_merge_split(
                [
                    LaneDef(
                        0,
                        pv.get_total_length(),
                        len(right_lanes_start),
                        len(right_lanes_end),
                        None,
                        right_lanes_start,
                        right_lanes_end,
                    )
                ],
                [
                    LaneDef(
                        0,
                        pv.get_total_length(),
                        len(left_lanes_start),
                        len(left_lanes_end),
                        None,
                        left_lanes_start,
                        left_lanes_end,
                    )
                ],
                pv.get_total_length(),
                center_road_mark,
                None,
                lane_width_end=None,
            )

        else:
            lanes = create_lanes_merge_split(
                self.roads[road_id].planview.right_lane_defs,
                self.roads[road_id].planview.left_lane_defs,
                pv.get_total_length(),
                self.roads[road_id].planview.center_road_mark,
                self.roads[road_id].planview.lane_width,
                lane_width_end=self.roads[road_id].planview.lane_width_end,
            )
        self.roads[road_id].planview = pv
        self.roads[road_id].lanes = lanes

    def adjust_startpoints(self) -&gt; None:
        &#34;&#34;&#34;Adjust the starting position of all geometries of all roads.

        This method adjusts logically connected roads by moving them so
        they connect geometrically. If no roads are fixed, the first road
        is selected as the pivot road.

        Returns
        -------
        None

        Raises
        ------
        UndefinedRoadNetwork
            If roads are missing successors or predecessors to connect
            properly, or if no start position is defined for disconnected
            roads.
        &#34;&#34;&#34;

        # Adjust logically connected roads, i.e. move them so they connect geometrically.
        # Method:
        #    Fix a pre defined roads (if start position in planview is used), other wise fix the first road at 0
        #    Next, in the set of remaining unconnected roads, find and adjust any roads connecting to a already fixed road
        # Loop until all roads have been adjusted,

        # adjust the roads that have a fixed start of the planview
        count_total_adjusted_roads = 0
        fixed_road = False
        for k in self.roads:
            if self.roads[k].planview.fixed and not self.roads[k].is_adjusted(
                &#34;planview&#34;
            ):
                self.roads[k].planview.adjust_geometries()
                # print(&#39;Fixing Road: &#39; + k)
                count_total_adjusted_roads += 1
                fixed_road = True
            elif self.roads[k].is_adjusted(&#34;planview&#34;):
                fixed_road = True
                count_total_adjusted_roads += 1

        # If no roads are fixed, select the first road is selected as the pivot-road
        if len(self.roads) &gt; 0:
            if fixed_road is False:
                for key in self.roads.keys():
                    # make sure it is not a connecting road, patching algorithm can&#39;t handle that
                    if self.roads[key].road_type == -1 and not isinstance(
                        self.roads[key].planview, AdjustablePlanview
                    ):
                        self.roads[key].planview.adjust_geometries()
                        break
                count_total_adjusted_roads += 1

        while count_total_adjusted_roads &lt; len(self.roads):
            count_adjusted_roads = 0

            for k in self.roads:  # Check all
                if self.roads[k].planview.adjusted is False:
                    # check if road is a adjustable planview
                    if isinstance(self.roads[k].planview, AdjustablePlanview):
                        predecessor = None
                        successor = None

                        if (
                            self.roads[k].predecessor is None
                            or self.roads[k].successor is None
                        ):
                            raise UndefinedRoadNetwork(
                                &#34;An AdjustablePlanview needs both a predecessor and a successor.&#34;
                            )

                        if (
                            self.roads[k].successor.element_type
                            == ElementType.junction
                        ):
                            if self.roads[k].succ_direct_junction:
                                for key, value in self.roads[
                                    k
                                ].succ_direct_junction.items():
                                    if self.roads[str(key)].planview.adjusted:
                                        successor = str(key)
                                        if (
                                            self.roads[str(key)].successor
                                            and self.roads[
                                                str(key)
                                            ].successor.element_type
                                            == ElementType.junction
                                            and self.roads[
                                                str(key)
                                            ].successor.element_id
                                            == self.roads[
                                                k
                                            ].successor.element_id
                                        ):
                                            suc_contact_point = (
                                                ContactPoint.end
                                            )
                                        else:
                                            suc_contact_point = (
                                                ContactPoint.start
                                            )
                                        break
                            else:
                                raise UndefinedRoadNetwork(
                                    &#34;cannot handle a successor connection to a junction with an AdjustablePlanView&#34;
                                )
                        else:
                            if self.roads[
                                str(self.roads[k].successor.element_id)
                            ].planview.adjusted:
                                successor = str(
                                    self.roads[k].successor.element_id
                                )
                                suc_contact_point = self.roads[
                                    k
                                ].successor.contact_point

                        if (
                            self.roads[k].predecessor.element_type
                            == ElementType.junction
                        ):
                            if self.roads[k].pred_direct_junction:
                                for key, value in self.roads[
                                    k
                                ].pred_direct_junction.items():
                                    if self.roads[str(key)].planview.adjusted:
                                        predecessor = str(key)
                                        if (
                                            self.roads[str(key)].successor
                                            and self.roads[
                                                str(key)
                                            ].successor.element_type
                                            == ElementType.junction
                                            and self.roads[
                                                str(key)
                                            ].successor.element_id
                                            == self.roads[
                                                k
                                            ].predecessor.element_id
                                        ):
                                            pred_contact_point = (
                                                ContactPoint.end
                                            )
                                        else:
                                            pred_contact_point = (
                                                ContactPoint.start
                                            )
                                        break
                            else:
                                for r_id, r in self.roads.items():
                                    if (
                                        r.road_type
                                        == self.roads[k].predecessor.element_id
                                        and r.planview.adjusted
                                    ):
                                        if r.predecessor.element_id == int(k):
                                            pred_contact_point = (
                                                ContactPoint.start
                                            )
                                            predecessor = r_id
                                            break
                                        elif r.successor.element_id == int(k):
                                            pred_contact_point = (
                                                ContactPoint.end
                                            )
                                            predecessor = r_id
                                            break

                        else:
                            if self.roads[
                                str(self.roads[k].predecessor.element_id)
                            ].planview.adjusted:
                                predecessor = str(
                                    self.roads[k].predecessor.element_id
                                )
                                pred_contact_point = self.roads[
                                    k
                                ].predecessor.contact_point
                        if successor and predecessor:
                            self._create_adjustable_planview(
                                k,
                                predecessor,
                                pred_contact_point,
                                successor,
                                suc_contact_point,
                            )
                            count_adjusted_roads += 1

                    # check if it has a normal (road) predecessor
                    elif (
                        self.roads[k].predecessor is not None
                        and self.roads[k].predecessor.element_type
                        is not ElementType.junction
                        and self.roads[
                            str(self.roads[k].predecessor.element_id)
                        ].is_adjusted(&#34;planview&#34;)
                        is True
                    ):
                        self._connection_sanity_check(k, &#34;predecessor&#34;)
                        self._adjust_road_wrt_neighbour(
                            k,
                            self.roads[k].predecessor.element_id,
                            self.roads[k].predecessor.contact_point,
                            &#34;predecessor&#34;,
                        )
                        count_adjusted_roads += 1

                        if (
                            self.roads[k].road_type != -1
                            and self.roads[k].successor is not None
                            and self.roads[
                                str(self.roads[k].successor.element_id)
                            ].is_adjusted(&#34;planview&#34;)
                            is False
                            and not isinstance(
                                self.roads[
                                    str(self.roads[k].successor.element_id)
                                ].planview,
                                AdjustablePlanview,
                            )
                        ):
                            succ_id = self.roads[k].successor.element_id
                            if (
                                self.roads[k].successor.contact_point
                                == ContactPoint.start
                            ):
                                self._adjust_road_wrt_neighbour(
                                    succ_id, k, ContactPoint.end, &#34;predecessor&#34;
                                )
                            else:
                                self._adjust_road_wrt_neighbour(
                                    succ_id, k, ContactPoint.end, &#34;successor&#34;
                                )
                            count_adjusted_roads += 1

                    # check if geometry has a normal (road) successor
                    elif (
                        self.roads[k].successor is not None
                        and self.roads[k].successor.element_type
                        is not ElementType.junction
                        and self.roads[
                            str(self.roads[k].successor.element_id)
                        ].is_adjusted(&#34;planview&#34;)
                        is True
                    ):
                        self._connection_sanity_check(k, &#34;successor&#34;)
                        self._adjust_road_wrt_neighbour(
                            k,
                            self.roads[k].successor.element_id,
                            self.roads[k].successor.contact_point,
                            &#34;successor&#34;,
                        )
                        count_adjusted_roads += 1

                        if (
                            self.roads[k].road_type != -1
                            and self.roads[k].predecessor is not None
                            and self.roads[
                                str(self.roads[k].predecessor.element_id)
                            ].is_adjusted(&#34;planview&#34;)
                            is False
                            and not isinstance(
                                self.roads[
                                    str(self.roads[k].successor.element_id)
                                ].planview,
                                AdjustablePlanview,
                            )
                        ):
                            pred_id = self.roads[k].predecessor.element_id
                            if (
                                self.roads[k].predecessor.contact_point
                                == ContactPoint.start
                            ):
                                self._adjust_road_wrt_neighbour(
                                    pred_id,
                                    k,
                                    ContactPoint.start,
                                    &#34;predecessor&#34;,
                                )
                            else:
                                self._adjust_road_wrt_neighbour(
                                    pred_id, k, ContactPoint.start, &#34;successor&#34;
                                )
                            count_adjusted_roads += 1
                    # do special check for direct junctions
                    elif (
                        self.roads[k].succ_direct_junction
                        or self.roads[k].pred_direct_junction
                    ):
                        if (
                            self.roads[k].successor is not None
                            and self.roads[k].successor.element_type
                            is ElementType.junction
                        ):
                            for dr in self.roads[k].succ_direct_junction:
                                if (
                                    self.roads[str(dr)].is_adjusted(&#34;planview&#34;)
                                    is True
                                ):
                                    if (
                                        int(k)
                                        in self.roads[
                                            str(dr)
                                        ].succ_direct_junction
                                    ):
                                        cp = ContactPoint.end
                                    elif (
                                        int(k)
                                        in self.roads[
                                            str(dr)
                                        ].pred_direct_junction
                                    ):
                                        cp = ContactPoint.start
                                    else:
                                        raise UndefinedRoadNetwork(
                                            &#34;direct junction is not properly defined&#34;
                                        )
                                    self._adjust_road_wrt_neighbour(
                                        k, dr, cp, &#34;successor&#34;
                                    )

                                    count_adjusted_roads += 1
                        if (
                            self.roads[k].predecessor is not None
                            and self.roads[k].predecessor.element_type
                            is ElementType.junction
                        ):
                            for dr in self.roads[k].pred_direct_junction:
                                if (
                                    self.roads[str(dr)].is_adjusted(&#34;planview&#34;)
                                    is True
                                ):
                                    if (
                                        int(k)
                                        in self.roads[
                                            str(dr)
                                        ].succ_direct_junction
                                    ):
                                        cp = ContactPoint.end
                                    elif (
                                        int(k)
                                        in self.roads[
                                            str(dr)
                                        ].pred_direct_junction
                                    ):
                                        cp = ContactPoint.start
                                    else:
                                        raise UndefinedRoadNetwork(
                                            &#34;direct junction is not properly defined&#34;
                                        )
                                    self._adjust_road_wrt_neighbour(
                                        k, dr, cp, &#34;predecessor&#34;
                                    )
                                    count_adjusted_roads += 1
            count_total_adjusted_roads += count_adjusted_roads

            if (
                count_total_adjusted_roads != len(self.roads)
                and count_adjusted_roads == 0
            ):
                # No more connecting roads found, move to next pivot-road
                raise UndefinedRoadNetwork(
                    &#34;Roads are either missing successor, or predecessor to connect to the roads, \n if the roads are disconnected, please add a start position for one of the planviews.&#34;
                )

    def adjust_elevations(self) -&gt; None:
        &#34;&#34;&#34;Adjust the elevation and superelevation profiles of all roads.

        This method calculates and adjusts the elevation and superelevation
        profiles for all roads in the OpenDrive. It ensures that connected
        roads have consistent elevation profiles.

        Returns
        -------
        None

        Raises
        ------
        UndefinedRoadNetwork
            If the elevation profiles cannot be adjusted due to missing
            connections or undefined profiles.
        &#34;&#34;&#34;
        elevation_calculators = []
        for k in self.roads:
            ec = ElevationCalculator(self.roads[k])
            if (
                self.roads[k].predecessor is not None
                and self.roads[k].predecessor.element_type == ElementType.road
            ):
                ec.add_predecessor(
                    self.roads[str(self.roads[k].predecessor.element_id)]
                )
            elif (
                self.roads[k].predecessor is not None
                and self.roads[k].predecessor.element_type
                == ElementType.junction
            ):
                if self.roads[k].pred_direct_junction:
                    for key in self.roads[k].pred_direct_junction:
                        ec.add_predecessor(self.roads[str(key)])

                else:
                    for key in self.roads:
                        if self.roads[key].road_type == self.roads[
                            k
                        ].predecessor.element_id and self.roads[k].id in [
                            self.roads[key].successor.element_id,
                            self.roads[key].predecessor.element_id,
                        ]:
                            ec.add_predecessor(self.roads[str(key)])

            if (
                self.roads[k].successor is not None
                and self.roads[k].successor.element_type == ElementType.road
            ):
                ec.add_successor(
                    self.roads[str(self.roads[k].successor.element_id)]
                )
            elif (
                self.roads[k].successor is not None
                and self.roads[k].successor.element_type
                == ElementType.junction
            ):
                if self.roads[k].succ_direct_junction:
                    for key in self.roads[k].succ_direct_junction:
                        ec.add_successor(self.roads[str(key)])

                else:
                    for key in self.roads:
                        if self.roads[key].road_type == self.roads[
                            k
                        ].successor.element_id and self.roads[k].id in [
                            self.roads[key].successor.element_id,
                            self.roads[key].predecessor.element_id,
                        ]:
                            ec.add_successor(self.roads[str(key)])

            elevation_calculators.append(ec)
        for elevation_type in [&#34;superelevation&#34;, &#34;elevation&#34;]:
            count_total_adjusted_roads = sum(
                [x.is_adjusted(elevation_type) for _, x in self.roads.items()]
            )
            if (
                any([x._extra_elevation_needed for x in elevation_calculators])
                and count_total_adjusted_roads == 0
            ):
                elevation_calculators[0].set_zero_elevation()
                count_total_adjusted_roads = 1
            if count_total_adjusted_roads == 0:
                continue
            while count_total_adjusted_roads &lt; len(self.roads):
                for ec in elevation_calculators:
                    ec.create_profile(elevation_type)

                new_count = sum(
                    [
                        x.is_adjusted(elevation_type)
                        for _, x in self.roads.items()
                    ]
                )
                if new_count == count_total_adjusted_roads:
                    Warning(&#34;cannot adjust &#34; + elevation_type + &#34; more.&#34;)
                    break
                count_total_adjusted_roads = new_count

    def add_junction(self, junction: Junction) -&gt; &#34;OpenDrive&#34;:
        &#34;&#34;&#34;Add a junction to the OpenDrive.

        Parameters
        ----------
        junction : Junction
            The junction to add.

        Returns
        -------
        OpenDrive
            The updated OpenDrive object.

        Raises
        ------
        TypeError
            If the input is not of type `Junction`.
        IdAlreadyExists
            If a junction with the same ID already exists.
        &#34;&#34;&#34;
        if not isinstance(junction, Junction):
            raise TypeError(&#34;junction input is not of type Junction&#34;)
        if any([junction.id == x.id for x in self.junctions]):
            raise IdAlreadyExists(
                &#34;Junction with id &#34;
                + str(junction.id)
                + &#34; has already been added. &#34;
            )
        self.junctions.append(junction)
        return self

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the OpenDrive.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the OpenDrive.
        &#34;&#34;&#34;
        element = ET.Element(&#34;OpenDRIVE&#34;)
        self._add_additional_data_to_element(element)
        element.append(self._header.get_element())
        for r in self.roads:
            element.append(self.roads[r].get_element())

        for j in self.junctions:
            element.append(j.get_element())

        return element

    def write_xml(
        self,
        filename: Optional[str] = None,
        prettyprint: bool = True,
        encoding: str = &#34;utf-8&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;Write the OpenDRIVE XML file.

        Parameters
        ----------
        filename : str, optional
            Path and filename of the desired XML file. Default is the name
            of the OpenDrive with a `.xodr` extension.
        prettyprint : bool, optional
            Whether to pretty-print the XML. Default is True.
        encoding : str, optional
            Specifies the output encoding. Default is &#39;utf-8&#39;.

        Returns
        -------
        None
        &#34;&#34;&#34;
        if filename == None:
            filename = self.name + &#34;.xodr&#34;
        printToFile(self.get_element(), filename, prettyprint, encoding)</code></pre>
</details>
<div class="desc"><p>OpenDrive is the main class of pyodrx to generate an OpenDrive road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the road.</dd>
<dt><strong><code>revMajor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Major revision of OpenDRIVE written to the header. Default is '1'.</dd>
<dt><strong><code>revMinor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Minor revision of OpenDRIVE written to the header. Default is '5'.</dd>
<dt><strong><code>geo_reference</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Geographic reference information for the database. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the road.</dd>
<dt><strong><code>revMajor</code></strong> :&ensp;<code>str</code></dt>
<dd>Major revision of OpenDRIVE written to the header.</dd>
<dt><strong><code>revMinor</code></strong> :&ensp;<code>str</code></dt>
<dd>Minor revision of OpenDRIVE written to the header.</dd>
<dt><strong><code>geo_reference</code></strong> :&ensp;<code>str</code></dt>
<dd>Geographic reference information for the database.</dd>
<dt><strong><code>roads</code></strong> :&ensp;<code>dict[str, <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a>]</code></dt>
<dd>All roads in the OpenDrive.</dd>
<dt><strong><code>junctions</code></strong> :&ensp;<code>list[Junction]</code></dt>
<dd>All junctions in the OpenDrive.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree of the OpenDrive.
add_road(road)
Adds a road to the OpenDrive.
add_junction(junction)
Adds a junction to the OpenDrive.
add_junction_creator(junction_creator)
Adds necessary info from a junction creator to the OpenDrive.
adjust_roads_and_lanes()
Adjusts starting positions of all geometries of all roads and links
lanes in neighboring roads.
adjust_roadmarks()
Adjusts roadmarks along roads and lane sections.
adjust_startpoints()
Adjusts starting positions of all geometries of all roads.
write_xml(filename, prettyprint, encoding)
Writes the OpenDrive to an XML file.</p>
<p>Initialize the OpenDrive.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the road.</dd>
<dt><strong><code>revMajor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Major revision of OpenDRIVE. Default is '1'.</dd>
<dt><strong><code>revMinor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Minor revision of OpenDRIVE. Default is '5'.</dd>
<dt><strong><code>geo_reference</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Geographic reference information for the database. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.add_junction"><code class="name flex">
<span>def <span class="ident">add_junction</span></span>(<span>self,<br>junction: <a title="scenariogeneration.xodr.links.Junction" href="links.html#scenariogeneration.xodr.links.Junction">Junction</a>) ‑> <a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_junction(self, junction: Junction) -&gt; &#34;OpenDrive&#34;:
    &#34;&#34;&#34;Add a junction to the OpenDrive.

    Parameters
    ----------
    junction : Junction
        The junction to add.

    Returns
    -------
    OpenDrive
        The updated OpenDrive object.

    Raises
    ------
    TypeError
        If the input is not of type `Junction`.
    IdAlreadyExists
        If a junction with the same ID already exists.
    &#34;&#34;&#34;
    if not isinstance(junction, Junction):
        raise TypeError(&#34;junction input is not of type Junction&#34;)
    if any([junction.id == x.id for x in self.junctions]):
        raise IdAlreadyExists(
            &#34;Junction with id &#34;
            + str(junction.id)
            + &#34; has already been added. &#34;
        )
    self.junctions.append(junction)
    return self</code></pre>
</details>
<div class="desc"><p>Add a junction to the OpenDrive.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>junction</code></strong> :&ensp;<code>Junction</code></dt>
<dd>The junction to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></code></dt>
<dd>The updated OpenDrive object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the input is not of type <code>Junction</code>.</dd>
<dt><code>IdAlreadyExists</code></dt>
<dd>If a junction with the same ID already exists.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.add_junction_creator"><code class="name flex">
<span>def <span class="ident">add_junction_creator</span></span>(<span>self,<br>junction_creator: ForwardRef('CommonJunctionCreator') | ForwardRef('DirectJunctionCreator')) ‑> <a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_junction_creator(
    self,
    junction_creator: Union[
        &#34;CommonJunctionCreator&#34;, &#34;DirectJunctionCreator&#34;
    ],
) -&gt; &#34;OpenDrive&#34;:
    &#34;&#34;&#34;Add a junction creator to the OpenDrive.

    This method takes a `CommonJunctionCreator` or `DirectJunctionCreator`
    as input and adds all necessary information (roads and junctions) to
    the OpenDrive.

    Parameters
    ----------
    junction_creator : CommonJunctionCreator or DirectJunctionCreator
        The junction creator to add.

    Returns
    -------
    OpenDrive
        The updated OpenDrive object.
    &#34;&#34;&#34;
    if junction_creator.junction.junction_type == JunctionType.default:
        for road in junction_creator.get_connecting_roads():
            self.add_road(road)

    self.add_junction(junction_creator.junction)
    return self</code></pre>
</details>
<div class="desc"><p>Add a junction creator to the OpenDrive.</p>
<p>This method takes a <code>CommonJunctionCreator</code> or <code>DirectJunctionCreator</code>
as input and adds all necessary information (roads and junctions) to
the OpenDrive.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>junction_creator</code></strong> :&ensp;<code>CommonJunctionCreator</code> or <code>DirectJunctionCreator</code></dt>
<dd>The junction creator to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></code></dt>
<dd>The updated OpenDrive object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.add_road"><code class="name flex">
<span>def <span class="ident">add_road</span></span>(<span>self,<br>road: <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a>) ‑> <a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_road(self, road: Road) -&gt; &#34;OpenDrive&#34;:
    &#34;&#34;&#34;Add a new road to the OpenDrive.

    Parameters
    ----------
    road : Road
        The road to add.

    Returns
    -------
    OpenDrive
        The updated OpenDrive object.

    Raises
    ------
    TypeError
        If the input is not of type `Road`.
    ValueError
        If the road has a predecessor but no roads have been added yet.
    IdAlreadyExists
        If a road with the same ID already exists.
    &#34;&#34;&#34;
    if not isinstance(road, Road):
        raise TypeError(&#34;input road is not of type Road&#34;)
    if (len(self.roads) == 0) and road.predecessor:
        ValueError(
            &#34;No road was added and the added road has a predecessor, please add the predecessor first&#34;
        )
    if str(road.id) in self.roads:
        raise IdAlreadyExists(
            &#34;Road id &#34; + str(road.id) + &#34; has already been added. &#34;
        )
    self.roads[str(road.id)] = road
    return self</code></pre>
</details>
<div class="desc"><p>Add a new road to the OpenDrive.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>road</code></strong> :&ensp;<code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The road to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></code></dt>
<dd>The updated OpenDrive object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the input is not of type <code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code>.</dd>
<dt><code>ValueError</code></dt>
<dd>If the road has a predecessor but no roads have been added yet.</dd>
<dt><code>IdAlreadyExists</code></dt>
<dd>If a road with the same ID already exists.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.adjust_elevations"><code class="name flex">
<span>def <span class="ident">adjust_elevations</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_elevations(self) -&gt; None:
    &#34;&#34;&#34;Adjust the elevation and superelevation profiles of all roads.

    This method calculates and adjusts the elevation and superelevation
    profiles for all roads in the OpenDrive. It ensures that connected
    roads have consistent elevation profiles.

    Returns
    -------
    None

    Raises
    ------
    UndefinedRoadNetwork
        If the elevation profiles cannot be adjusted due to missing
        connections or undefined profiles.
    &#34;&#34;&#34;
    elevation_calculators = []
    for k in self.roads:
        ec = ElevationCalculator(self.roads[k])
        if (
            self.roads[k].predecessor is not None
            and self.roads[k].predecessor.element_type == ElementType.road
        ):
            ec.add_predecessor(
                self.roads[str(self.roads[k].predecessor.element_id)]
            )
        elif (
            self.roads[k].predecessor is not None
            and self.roads[k].predecessor.element_type
            == ElementType.junction
        ):
            if self.roads[k].pred_direct_junction:
                for key in self.roads[k].pred_direct_junction:
                    ec.add_predecessor(self.roads[str(key)])

            else:
                for key in self.roads:
                    if self.roads[key].road_type == self.roads[
                        k
                    ].predecessor.element_id and self.roads[k].id in [
                        self.roads[key].successor.element_id,
                        self.roads[key].predecessor.element_id,
                    ]:
                        ec.add_predecessor(self.roads[str(key)])

        if (
            self.roads[k].successor is not None
            and self.roads[k].successor.element_type == ElementType.road
        ):
            ec.add_successor(
                self.roads[str(self.roads[k].successor.element_id)]
            )
        elif (
            self.roads[k].successor is not None
            and self.roads[k].successor.element_type
            == ElementType.junction
        ):
            if self.roads[k].succ_direct_junction:
                for key in self.roads[k].succ_direct_junction:
                    ec.add_successor(self.roads[str(key)])

            else:
                for key in self.roads:
                    if self.roads[key].road_type == self.roads[
                        k
                    ].successor.element_id and self.roads[k].id in [
                        self.roads[key].successor.element_id,
                        self.roads[key].predecessor.element_id,
                    ]:
                        ec.add_successor(self.roads[str(key)])

        elevation_calculators.append(ec)
    for elevation_type in [&#34;superelevation&#34;, &#34;elevation&#34;]:
        count_total_adjusted_roads = sum(
            [x.is_adjusted(elevation_type) for _, x in self.roads.items()]
        )
        if (
            any([x._extra_elevation_needed for x in elevation_calculators])
            and count_total_adjusted_roads == 0
        ):
            elevation_calculators[0].set_zero_elevation()
            count_total_adjusted_roads = 1
        if count_total_adjusted_roads == 0:
            continue
        while count_total_adjusted_roads &lt; len(self.roads):
            for ec in elevation_calculators:
                ec.create_profile(elevation_type)

            new_count = sum(
                [
                    x.is_adjusted(elevation_type)
                    for _, x in self.roads.items()
                ]
            )
            if new_count == count_total_adjusted_roads:
                Warning(&#34;cannot adjust &#34; + elevation_type + &#34; more.&#34;)
                break
            count_total_adjusted_roads = new_count</code></pre>
</details>
<div class="desc"><p>Adjust the elevation and superelevation profiles of all roads.</p>
<p>This method calculates and adjusts the elevation and superelevation
profiles for all roads in the OpenDrive. It ensures that connected
roads have consistent elevation profiles.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>UndefinedRoadNetwork</code></dt>
<dd>If the elevation profiles cannot be adjusted due to missing
connections or undefined profiles.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.adjust_roadmarks"><code class="name flex">
<span>def <span class="ident">adjust_roadmarks</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_roadmarks(self) -&gt; None:
    &#34;&#34;&#34;Adjust broken roadmarks (if the same definition) along roads and
    lane sections.

    This method attempts to fix roadmarks across roads and lane
    sections by ensuring continuity and consistency.

    Returns
    -------
    None

    Raises
    ------
    RoadsAndLanesNotAdjusted
        If roads and lanes are not adjusted properly before calling
        this method.
    &#34;&#34;&#34;
    adjusted_road = self.roads[list(self.roads.keys())[0]]
    if not adjusted_road.is_adjusted(&#34;planview&#34;):
        raise RoadsAndLanesNotAdjusted(
            &#34;Cannot adjust roadmarks if geometries are not adjusted properly first. Consider calling &#39;adjust_roads_and_lanes()&#39; first.&#34;
        )
    adjusted_road.lanes.adjust_road_marks_from_start(
        adjusted_road.planview.get_total_length()
    )

    count_total_adjusted_roads = 1

    while count_total_adjusted_roads &lt; len(self.roads):
        for r in self.roads.keys():
            if not self.roads[r].is_adjusted(&#34;planview&#34;):
                raise RoadsAndLanesNotAdjusted(
                    &#34;Cannot adjust roadmarks if geometries are not adjusted properly first. Consider calling &#39;adjust_roads_and_lanes()&#39; first.&#34;
                )
            if self.roads[r].lanes.roadmarks_adjusted:
                if self.roads[r].successor:
                    if (
                        self.roads[r].successor.element_type
                        == ElementType.road
                    ):
                        if (
                            self.roads[r].successor.contact_point
                            == ContactPoint.start
                        ):
                            self.roads[
                                str(self.roads[r].successor.element_id)
                            ].lanes.adjust_road_marks_from_start(
                                self.roads[
                                    str(self.roads[r].successor.element_id)
                                ].planview.get_total_length(),
                                self.roads[r].lanes.lanesections[-1],
                                ContactPoint.end,
                            )
                            count_total_adjusted_roads += 1
                        else:
                            self.roads[
                                str(self.roads[r].successor.element_id)
                            ].lanes.adjust_road_marks_from_end(
                                self.roads[
                                    str(self.roads[r].successor.element_id)
                                ].planview.get_total_length(),
                                self.roads[r].lanes.lanesections[-1],
                                ContactPoint.end,
                            )
                            count_total_adjusted_roads += 1
                    else:
                        for j in self.junctions:
                            if j.id == self.roads[r].successor.element_id:
                                junction = j
                                break

                        for conn in junction.connections:
                            if str(conn.incoming_road) == r:
                                if (
                                    conn.contact_point
                                    == ContactPoint.start
                                ):
                                    self.roads[
                                        str(conn.connecting_road)
                                    ].lanes.adjust_road_marks_from_start(
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].planview.get_total_length(),
                                        self.roads[r].lanes.lanesections[
                                            0
                                        ],
                                        ContactPoint.end,
                                    )
                                else:
                                    self.roads[
                                        str(conn.connecting_road)
                                    ].lanes.adjust_road_marks_from_end(
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].planview.get_total_length(),
                                        self.roads[r].lanes.lanesections[
                                            0
                                        ],
                                        ContactPoint.end,
                                    )

                                count_total_adjusted_roads += 1

                if self.roads[r].predecessor:
                    if (
                        self.roads[r].predecessor.element_type
                        == ElementType.road
                    ):
                        if (
                            self.roads[r].predecessor.contact_point
                            == ContactPoint.start
                        ):
                            self.roads[
                                str(self.roads[r].predecessor.element_id)
                            ].lanes.adjust_road_marks_from_start(
                                self.roads[
                                    str(
                                        self.roads[
                                            r
                                        ].predecessor.element_id
                                    )
                                ].planview.get_total_length(),
                                self.roads[r].lanes.lanesections[0],
                                ContactPoint.start,
                            )
                            count_total_adjusted_roads += 1
                        else:
                            self.roads[
                                str(self.roads[r].predecessor.element_id)
                            ].lanes.adjust_road_marks_from_end(
                                self.roads[
                                    str(
                                        self.roads[
                                            r
                                        ].predecessor.element_id
                                    )
                                ].planview.get_total_length(),
                                self.roads[r].lanes.lanesections[0],
                                ContactPoint.start,
                            )
                            count_total_adjusted_roads += 1
                    else:
                        for conn in self.junctions[0].connections:
                            if str(conn.incoming_road) == r:
                                if (
                                    conn.contact_point
                                    == ContactPoint.start
                                ):
                                    self.roads[
                                        str(conn.connecting_road)
                                    ].lanes.adjust_road_marks_from_start(
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].planview.get_total_length(),
                                        self.roads[r].lanes.lanesections[
                                            -1
                                        ],
                                        ContactPoint.start,
                                    )
                                else:
                                    self.roads[
                                        str(conn.connecting_road)
                                    ].lanes.adjust_road_marks_from_end(
                                        self.roads[
                                            str(conn.connecting_road)
                                        ].planview.get_total_length(),
                                        self.roads[r].lanes.lanesections[
                                            -1
                                        ],
                                        ContactPoint.start,
                                    )
                                count_total_adjusted_roads += 1</code></pre>
</details>
<div class="desc"><p>Adjust broken roadmarks (if the same definition) along roads and
lane sections.</p>
<p>This method attempts to fix roadmarks across roads and lane
sections by ensuring continuity and consistency.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RoadsAndLanesNotAdjusted</code></dt>
<dd>If roads and lanes are not adjusted properly before calling
this method.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.adjust_roads_and_lanes"><code class="name flex">
<span>def <span class="ident">adjust_roads_and_lanes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_roads_and_lanes(self) -&gt; None:
    &#34;&#34;&#34;Adjust the starting position of all geometries of all roads and
    link all lanes in neighboring roads.

    This method adjusts the starting positions of all road geometries
    and attempts to link lanes between neighboring roads.

    Returns
    -------
    None

    Raises
    ------
    RoadsAndLanesNotAdjusted
        If roads and lanes are not adjusted properly.
    &#34;&#34;&#34;
    # adjust roads and their geometries
    self.adjust_startpoints()

    results = list(combinations(self.roads, 2))

    for r in range(len(results)):
        # print(&#39;Analyzing roads&#39;, results[r][0], &#39;and&#39;, results[r][1] )
        create_lane_links(
            self.roads[results[r][0]], self.roads[results[r][1]]
        )</code></pre>
</details>
<div class="desc"><p>Adjust the starting position of all geometries of all roads and
link all lanes in neighboring roads.</p>
<p>This method adjusts the starting positions of all road geometries
and attempts to link lanes between neighboring roads.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RoadsAndLanesNotAdjusted</code></dt>
<dd>If roads and lanes are not adjusted properly.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.adjust_startpoints"><code class="name flex">
<span>def <span class="ident">adjust_startpoints</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_startpoints(self) -&gt; None:
    &#34;&#34;&#34;Adjust the starting position of all geometries of all roads.

    This method adjusts logically connected roads by moving them so
    they connect geometrically. If no roads are fixed, the first road
    is selected as the pivot road.

    Returns
    -------
    None

    Raises
    ------
    UndefinedRoadNetwork
        If roads are missing successors or predecessors to connect
        properly, or if no start position is defined for disconnected
        roads.
    &#34;&#34;&#34;

    # Adjust logically connected roads, i.e. move them so they connect geometrically.
    # Method:
    #    Fix a pre defined roads (if start position in planview is used), other wise fix the first road at 0
    #    Next, in the set of remaining unconnected roads, find and adjust any roads connecting to a already fixed road
    # Loop until all roads have been adjusted,

    # adjust the roads that have a fixed start of the planview
    count_total_adjusted_roads = 0
    fixed_road = False
    for k in self.roads:
        if self.roads[k].planview.fixed and not self.roads[k].is_adjusted(
            &#34;planview&#34;
        ):
            self.roads[k].planview.adjust_geometries()
            # print(&#39;Fixing Road: &#39; + k)
            count_total_adjusted_roads += 1
            fixed_road = True
        elif self.roads[k].is_adjusted(&#34;planview&#34;):
            fixed_road = True
            count_total_adjusted_roads += 1

    # If no roads are fixed, select the first road is selected as the pivot-road
    if len(self.roads) &gt; 0:
        if fixed_road is False:
            for key in self.roads.keys():
                # make sure it is not a connecting road, patching algorithm can&#39;t handle that
                if self.roads[key].road_type == -1 and not isinstance(
                    self.roads[key].planview, AdjustablePlanview
                ):
                    self.roads[key].planview.adjust_geometries()
                    break
            count_total_adjusted_roads += 1

    while count_total_adjusted_roads &lt; len(self.roads):
        count_adjusted_roads = 0

        for k in self.roads:  # Check all
            if self.roads[k].planview.adjusted is False:
                # check if road is a adjustable planview
                if isinstance(self.roads[k].planview, AdjustablePlanview):
                    predecessor = None
                    successor = None

                    if (
                        self.roads[k].predecessor is None
                        or self.roads[k].successor is None
                    ):
                        raise UndefinedRoadNetwork(
                            &#34;An AdjustablePlanview needs both a predecessor and a successor.&#34;
                        )

                    if (
                        self.roads[k].successor.element_type
                        == ElementType.junction
                    ):
                        if self.roads[k].succ_direct_junction:
                            for key, value in self.roads[
                                k
                            ].succ_direct_junction.items():
                                if self.roads[str(key)].planview.adjusted:
                                    successor = str(key)
                                    if (
                                        self.roads[str(key)].successor
                                        and self.roads[
                                            str(key)
                                        ].successor.element_type
                                        == ElementType.junction
                                        and self.roads[
                                            str(key)
                                        ].successor.element_id
                                        == self.roads[
                                            k
                                        ].successor.element_id
                                    ):
                                        suc_contact_point = (
                                            ContactPoint.end
                                        )
                                    else:
                                        suc_contact_point = (
                                            ContactPoint.start
                                        )
                                    break
                        else:
                            raise UndefinedRoadNetwork(
                                &#34;cannot handle a successor connection to a junction with an AdjustablePlanView&#34;
                            )
                    else:
                        if self.roads[
                            str(self.roads[k].successor.element_id)
                        ].planview.adjusted:
                            successor = str(
                                self.roads[k].successor.element_id
                            )
                            suc_contact_point = self.roads[
                                k
                            ].successor.contact_point

                    if (
                        self.roads[k].predecessor.element_type
                        == ElementType.junction
                    ):
                        if self.roads[k].pred_direct_junction:
                            for key, value in self.roads[
                                k
                            ].pred_direct_junction.items():
                                if self.roads[str(key)].planview.adjusted:
                                    predecessor = str(key)
                                    if (
                                        self.roads[str(key)].successor
                                        and self.roads[
                                            str(key)
                                        ].successor.element_type
                                        == ElementType.junction
                                        and self.roads[
                                            str(key)
                                        ].successor.element_id
                                        == self.roads[
                                            k
                                        ].predecessor.element_id
                                    ):
                                        pred_contact_point = (
                                            ContactPoint.end
                                        )
                                    else:
                                        pred_contact_point = (
                                            ContactPoint.start
                                        )
                                    break
                        else:
                            for r_id, r in self.roads.items():
                                if (
                                    r.road_type
                                    == self.roads[k].predecessor.element_id
                                    and r.planview.adjusted
                                ):
                                    if r.predecessor.element_id == int(k):
                                        pred_contact_point = (
                                            ContactPoint.start
                                        )
                                        predecessor = r_id
                                        break
                                    elif r.successor.element_id == int(k):
                                        pred_contact_point = (
                                            ContactPoint.end
                                        )
                                        predecessor = r_id
                                        break

                    else:
                        if self.roads[
                            str(self.roads[k].predecessor.element_id)
                        ].planview.adjusted:
                            predecessor = str(
                                self.roads[k].predecessor.element_id
                            )
                            pred_contact_point = self.roads[
                                k
                            ].predecessor.contact_point
                    if successor and predecessor:
                        self._create_adjustable_planview(
                            k,
                            predecessor,
                            pred_contact_point,
                            successor,
                            suc_contact_point,
                        )
                        count_adjusted_roads += 1

                # check if it has a normal (road) predecessor
                elif (
                    self.roads[k].predecessor is not None
                    and self.roads[k].predecessor.element_type
                    is not ElementType.junction
                    and self.roads[
                        str(self.roads[k].predecessor.element_id)
                    ].is_adjusted(&#34;planview&#34;)
                    is True
                ):
                    self._connection_sanity_check(k, &#34;predecessor&#34;)
                    self._adjust_road_wrt_neighbour(
                        k,
                        self.roads[k].predecessor.element_id,
                        self.roads[k].predecessor.contact_point,
                        &#34;predecessor&#34;,
                    )
                    count_adjusted_roads += 1

                    if (
                        self.roads[k].road_type != -1
                        and self.roads[k].successor is not None
                        and self.roads[
                            str(self.roads[k].successor.element_id)
                        ].is_adjusted(&#34;planview&#34;)
                        is False
                        and not isinstance(
                            self.roads[
                                str(self.roads[k].successor.element_id)
                            ].planview,
                            AdjustablePlanview,
                        )
                    ):
                        succ_id = self.roads[k].successor.element_id
                        if (
                            self.roads[k].successor.contact_point
                            == ContactPoint.start
                        ):
                            self._adjust_road_wrt_neighbour(
                                succ_id, k, ContactPoint.end, &#34;predecessor&#34;
                            )
                        else:
                            self._adjust_road_wrt_neighbour(
                                succ_id, k, ContactPoint.end, &#34;successor&#34;
                            )
                        count_adjusted_roads += 1

                # check if geometry has a normal (road) successor
                elif (
                    self.roads[k].successor is not None
                    and self.roads[k].successor.element_type
                    is not ElementType.junction
                    and self.roads[
                        str(self.roads[k].successor.element_id)
                    ].is_adjusted(&#34;planview&#34;)
                    is True
                ):
                    self._connection_sanity_check(k, &#34;successor&#34;)
                    self._adjust_road_wrt_neighbour(
                        k,
                        self.roads[k].successor.element_id,
                        self.roads[k].successor.contact_point,
                        &#34;successor&#34;,
                    )
                    count_adjusted_roads += 1

                    if (
                        self.roads[k].road_type != -1
                        and self.roads[k].predecessor is not None
                        and self.roads[
                            str(self.roads[k].predecessor.element_id)
                        ].is_adjusted(&#34;planview&#34;)
                        is False
                        and not isinstance(
                            self.roads[
                                str(self.roads[k].successor.element_id)
                            ].planview,
                            AdjustablePlanview,
                        )
                    ):
                        pred_id = self.roads[k].predecessor.element_id
                        if (
                            self.roads[k].predecessor.contact_point
                            == ContactPoint.start
                        ):
                            self._adjust_road_wrt_neighbour(
                                pred_id,
                                k,
                                ContactPoint.start,
                                &#34;predecessor&#34;,
                            )
                        else:
                            self._adjust_road_wrt_neighbour(
                                pred_id, k, ContactPoint.start, &#34;successor&#34;
                            )
                        count_adjusted_roads += 1
                # do special check for direct junctions
                elif (
                    self.roads[k].succ_direct_junction
                    or self.roads[k].pred_direct_junction
                ):
                    if (
                        self.roads[k].successor is not None
                        and self.roads[k].successor.element_type
                        is ElementType.junction
                    ):
                        for dr in self.roads[k].succ_direct_junction:
                            if (
                                self.roads[str(dr)].is_adjusted(&#34;planview&#34;)
                                is True
                            ):
                                if (
                                    int(k)
                                    in self.roads[
                                        str(dr)
                                    ].succ_direct_junction
                                ):
                                    cp = ContactPoint.end
                                elif (
                                    int(k)
                                    in self.roads[
                                        str(dr)
                                    ].pred_direct_junction
                                ):
                                    cp = ContactPoint.start
                                else:
                                    raise UndefinedRoadNetwork(
                                        &#34;direct junction is not properly defined&#34;
                                    )
                                self._adjust_road_wrt_neighbour(
                                    k, dr, cp, &#34;successor&#34;
                                )

                                count_adjusted_roads += 1
                    if (
                        self.roads[k].predecessor is not None
                        and self.roads[k].predecessor.element_type
                        is ElementType.junction
                    ):
                        for dr in self.roads[k].pred_direct_junction:
                            if (
                                self.roads[str(dr)].is_adjusted(&#34;planview&#34;)
                                is True
                            ):
                                if (
                                    int(k)
                                    in self.roads[
                                        str(dr)
                                    ].succ_direct_junction
                                ):
                                    cp = ContactPoint.end
                                elif (
                                    int(k)
                                    in self.roads[
                                        str(dr)
                                    ].pred_direct_junction
                                ):
                                    cp = ContactPoint.start
                                else:
                                    raise UndefinedRoadNetwork(
                                        &#34;direct junction is not properly defined&#34;
                                    )
                                self._adjust_road_wrt_neighbour(
                                    k, dr, cp, &#34;predecessor&#34;
                                )
                                count_adjusted_roads += 1
        count_total_adjusted_roads += count_adjusted_roads

        if (
            count_total_adjusted_roads != len(self.roads)
            and count_adjusted_roads == 0
        ):
            # No more connecting roads found, move to next pivot-road
            raise UndefinedRoadNetwork(
                &#34;Roads are either missing successor, or predecessor to connect to the roads, \n if the roads are disconnected, please add a start position for one of the planviews.&#34;
            )</code></pre>
</details>
<div class="desc"><p>Adjust the starting position of all geometries of all roads.</p>
<p>This method adjusts logically connected roads by moving them so
they connect geometrically. If no roads are fixed, the first road
is selected as the pivot road.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>UndefinedRoadNetwork</code></dt>
<dd>If roads are missing successors or predecessors to connect
properly, or if no start position is defined for disconnected
roads.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the OpenDrive.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the OpenDrive.
    &#34;&#34;&#34;
    element = ET.Element(&#34;OpenDRIVE&#34;)
    self._add_additional_data_to_element(element)
    element.append(self._header.get_element())
    for r in self.roads:
        element.append(self.roads[r].get_element())

    for j in self.junctions:
        element.append(j.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the OpenDrive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the OpenDrive.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.OpenDrive.write_xml"><code class="name flex">
<span>def <span class="ident">write_xml</span></span>(<span>self,<br>filename: str | None = None,<br>prettyprint: bool = True,<br>encoding: str = 'utf-8') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_xml(
    self,
    filename: Optional[str] = None,
    prettyprint: bool = True,
    encoding: str = &#34;utf-8&#34;,
) -&gt; None:
    &#34;&#34;&#34;Write the OpenDRIVE XML file.

    Parameters
    ----------
    filename : str, optional
        Path and filename of the desired XML file. Default is the name
        of the OpenDrive with a `.xodr` extension.
    prettyprint : bool, optional
        Whether to pretty-print the XML. Default is True.
    encoding : str, optional
        Specifies the output encoding. Default is &#39;utf-8&#39;.

    Returns
    -------
    None
    &#34;&#34;&#34;
    if filename == None:
        filename = self.name + &#34;.xodr&#34;
    printToFile(self.get_element(), filename, prettyprint, encoding)</code></pre>
</details>
<div class="desc"><p>Write the OpenDRIVE XML file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path and filename of the desired XML file. Default is the name
of the OpenDrive with a <code>.xodr</code> extension.</dd>
<dt><strong><code>prettyprint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to pretty-print the XML. Default is True.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the output encoding. Default is 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road"><code class="flex name class">
<span>class <span class="ident">Road</span></span>
<span>(</span><span>road_id: int,<br>planview: <a title="scenariogeneration.xodr.geometry.PlanView" href="geometry.html#scenariogeneration.xodr.geometry.PlanView">PlanView</a>,<br>lanes: <a title="scenariogeneration.xodr.lane.Lanes" href="lane.html#scenariogeneration.xodr.lane.Lanes">Lanes</a>,<br>road_type: int = -1,<br>name: str | None = None,<br>rule: <a title="scenariogeneration.xodr.enumerations.TrafficRule" href="enumerations.html#scenariogeneration.xodr.enumerations.TrafficRule">TrafficRule</a> = TrafficRule.RHT)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Road(XodrBase):
    &#34;&#34;&#34;Road defines the road element of OpenDRIVE.

    Parameters
    ----------
    road_id : int
        Identifier of the road.
    planview : PlanView
        The planview of the road.
    lanes : Lanes
        The lanes of the road.
    road_type : int, optional
        Type of road (junction). Default is -1.
    name : str, optional
        Name of the road. Default is None.
    rule : TrafficRule, optional
        Traffic rule. Default is `TrafficRule.RHT`.

    Attributes
    ----------
    id : int
        Identifier of the road.
    planview : PlanView
        The planview of the road.
    lanes : Lanes
        The lanes of the road.
    road_type : int
        Type of road (junction).
    name : str
        Name of the road.
    rule : TrafficRule
        Traffic rule.
    links : _Links
        Links associated with the road.
    objects : list[Object]
        List of objects on the road.
    signals : list[Signal]
        List of signals on the road.
    types : list[_Type]
        List of road types.
    elevationprofile : ElevationProfile
        Elevation profile of the road.
    lateralprofile : LateralProfile
        Lateral profile of the road.
    successor : _Link or None
        Successor link of the road.
    predecessor : _Link or None
        Predecessor link of the road.

    Methods
    -------
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    add_successor(element_type, element_id, contact_point, lane_offset)
        Adds a successor for the road.
    add_predecessor(element_type, element_id, contact_point, lane_offset)
        Adds a predecessor for the road.
    add_neighbor(element_type, element_id, direction)
        Adds a neighbor for the road.
    add_object(road_object)
        Adds an object to the road.
    add_elevation(s, a, b, c, d)
        Adds an elevation profile to the road.
    add_superelevation(s, a, b, c, d)
        Adds a superelevation to the road.
    add_shape(s, t, a, b, c, d)
        Adds a lateral shape to the road.
    add_tunnel(tunnel)
        Adds a tunnel or list of tunnels to a road.
    add_object_roadside(road_object_prototype, repeatDistance, ...)
        Adds a repeated object to the road.
    add_signal(signal)
        Adds a signal to the road.
    add_type(road_type, s, country, speed, speed_unit)
        Adds a type to the road (not to mix with junction or not as the
        init)
    get_end_point()
        Returns the x, y, and heading at the end of the road.
    &#34;&#34;&#34;

    def __init__(
        self,
        road_id: int,
        planview: PlanView,
        lanes: Lanes,
        road_type: int = -1,
        name: Optional[str] = None,
        rule: TrafficRule = TrafficRule.RHT,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Road.

        Parameters
        ----------
        road_id : int
            Identifier of the road.
        planview : PlanView
            The planview of the road.
        lanes : Lanes
            The lanes of the road.
        road_type : int, optional
            Type of road (junction). Default is -1.
        name : str, optional
            Name of the road. Default is None.
        rule : TrafficRule, optional
            Traffic rule. Default is `TrafficRule.RHT`.

        Raises
        ------
        TypeError
            If `planview` is not of type `PlanView` or `AdjustablePlanview`.
            If `lanes` is not of type `Lanes`.
        &#34;&#34;&#34;
        super().__init__()
        self.id = road_id
        if not (
            isinstance(planview, PlanView)
            or isinstance(planview, AdjustablePlanview)
        ):
            raise TypeError(
                &#34;planview input is not of type PlanView or AdjustablePlanview&#34;
            )
        self.planview = planview
        if not isinstance(lanes, Lanes):
            raise TypeError(
                &#34;planview input is not of type PlanView or AdjustablePlanview&#34;
            )
        self.lanes = lanes
        self.road_type = road_type
        self.name = name
        self.rule = enumchecker(rule, TrafficRule)
        self.links = _Links()
        self._neighbor_added = 0
        self.successor = None
        self.predecessor = None
        self.lane_offset_suc = {}
        self.lane_offset_pred = {}
        self.succ_direct_junction = {}
        self.pred_direct_junction = {}

        self.objects = []
        self.signals = []
        self.types = []
        self.elevationprofile = ElevationProfile()
        self.lateralprofile = LateralProfile()
        self._elevation_adjusted = False
        self._superelevation_adjusted = False
        self._shape_adjusted = False

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, Road) and super().__eq__(other):
            if (
                self.get_attributes() == other.get_attributes()
                and self.objects == other.objects
                and self.signals == other.signals
                and self.types == other.types
                and self.links == other.links
                and self.planview == other.planview
                and self.lanes == other.lanes
                and self.elevationprofile == other.elevationprofile
                and self.lateralprofile == other.lateralprofile
                and self.predecessor == other.predecessor
                and self.successor == other.successor
                and self.lane_offset_suc == other.lane_offset_suc
                and self.lane_offset_pred == other.lane_offset_pred
                and self.pred_direct_junction == other.pred_direct_junction
                and self.succ_direct_junction == other.succ_direct_junction
            ):
                return True
        return False

    def is_adjusted(self, domain: str = &#34;planview&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if the road has been properly defined in the specified
        domain.

        Parameters
        ----------
        domain : str, optional
            The domain to check. Valid values are &#34;planview&#34;, &#34;elevation&#34;,
            &#34;superelevation&#34;, or &#34;shape&#34;. Default is &#34;planview&#34;.

        Returns
        -------
        bool
            True if the road is properly defined in the specified domain,
            False otherwise.

        Raises
        ------
        ValueError
            If the domain is not one of the valid values.
        &#34;&#34;&#34;
        if domain == &#34;planview&#34;:
            return self.planview.adjusted
        elif domain == &#34;elevation&#34;:
            return self._elevation_adjusted
        elif domain == &#34;superelevation&#34;:
            return self._superelevation_adjusted
        elif domain == &#34;shape&#34;:
            return self._shape_adjusted
        else:
            raise ValueError(
                &#34;domain can only be: geometry, elevation, superelevation, or shape , not &#34;
                + domain
            )

    def add_successor(
        self,
        element_type: ElementType,
        element_id: Union[int, str],
        contact_point: Optional[ContactPoint] = None,
        lane_offset: int = 0,
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a successor link to the road.

        Parameters
        ----------
        element_type : ElementType
            The type of the linked road element.
        element_id : int or str
            The identifier of the linked road element.
        contact_point : ContactPoint, optional
            The contact point of the link. Default is None.
        lane_offset : int, optional
            The lane offset for the successor. Default is 0.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        ValueError
            If a successor already exists for the road.
        &#34;&#34;&#34;

        if self.successor:
            raise ValueError(&#34;only one successor is allowed&#34;)
        self.successor = _Link(
            &#34;successor&#34;,
            element_id,
            enumchecker(element_type, ElementType),
            contact_point,
        )
        self.links.add_link(self.successor)
        self.lane_offset_suc[str(element_id)] = lane_offset
        return self

    def add_predecessor(
        self,
        element_type: ElementType,
        element_id: Union[int, str],
        contact_point: Optional[ContactPoint] = None,
        lane_offset: int = 0,
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a predecessor link to the road.

        Parameters
        ----------
        element_type : ElementType
            The type of the linked road element.
        element_id : int or str
            The identifier of the linked road element.
        contact_point : ContactPoint, optional
            The contact point of the link. Default is None.
        lane_offset : int, optional
            The lane offset for the predecessor. Default is 0.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        ValueError
            If a predecessor already exists for the road.
        &#34;&#34;&#34;
        if self.predecessor:
            raise ValueError(&#34;only one predecessor is allowed&#34;)
        self.predecessor = _Link(
            &#34;predecessor&#34;,
            element_id,
            enumchecker(element_type, ElementType),
            contact_point,
        )
        self.links.add_link(self.predecessor)
        self.lane_offset_pred[str(element_id)] = lane_offset
        return self

    def add_neighbor(
        self,
        element_type: ElementType,
        element_id: Union[int, str],
        direction: &#34;Direction&#34;,
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a neighbor to the road.

        Parameters
        ----------
        element_type : ElementType
            The type of the linked road element.
        element_id : int or str
            The identifier of the linked road element.
        direction : Direction
            The direction of the link.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        ValueError
            If more than two neighbors are added to the road.
        &#34;&#34;&#34;
        if self._neighbor_added &gt; 1:
            raise ValueError(&#34;only two neighbors are allowed&#34;)
        suc = _Link(&#34;neighbor&#34;, element_id, element_type, direction=direction)

        self.links.add_link(suc)
        self._neighbor_added += 1
        return self

    def add_elevation(
        self, s: float, a: float, b: float, c: float, d: float
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add an elevation profile to the road (3-degree polynomial).

        Parameters
        ----------
        s : float
            The s-coordinate where the elevation starts.
        a : float
            The a coefficient of the polynomial.
        b : float
            The b coefficient of the polynomial.
        c : float
            The c coefficient of the polynomial.
        d : float
            The d coefficient of the polynomial.

        Returns
        -------
        Road
            The updated Road object.
        &#34;&#34;&#34;
        self.elevationprofile.add_elevation(
            _Poly3Profile(s, a, b, c, d, elevation_type=&#34;elevation&#34;)
        )
        self._elevation_adjusted = True
        return self

    def add_superelevation(
        self, s: float, a: float, b: float, c: float, d: float
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a superelevation profile to the road (3-degree polynomial).

        Parameters
        ----------
        s : float
            The s-coordinate where the superelevation starts.
        a : float
            The a coefficient of the polynomial.
        b : float
            The b coefficient of the polynomial.
        c : float
            The c coefficient of the polynomial.
        d : float
            The d coefficient of the polynomial.

        Returns
        -------
        Road
            The updated Road object.
        &#34;&#34;&#34;
        self.lateralprofile.add_superelevation(
            _Poly3Profile(s, a, b, c, d, elevation_type=&#34;superelevation&#34;)
        )
        self._superelevation_adjusted = True
        return self

    def add_shape(
        self, s: float, t: float, a: float, b: float, c: float, d: float
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a lateral shape profile to the road (3-degree polynomial).

        Parameters
        ----------
        s : float
            The s-coordinate where the shape starts.
        t : float
            The t-coordinate of the lateral profile.
        a : float
            The a coefficient of the polynomial.
        b : float
            The b coefficient of the polynomial.
        c : float
            The c coefficient of the polynomial.
        d : float
            The d coefficient of the polynomial.

        Returns
        -------
        Road
            The updated Road object.
        &#34;&#34;&#34;
        self.lateralprofile.add_shape(
            _Poly3Profile(s, a, b, c, d, t, elevation_type=&#34;shape&#34;)
        )
        self._shape_adjusted = True
        return self

    def add_object(self, road_object: Union[Object, list[Object]]) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add an object or a list of objects to the road and ensure unique
        IDs.

        Parameters
        ----------
        road_object : Object or list[Object]
            The object(s) to be added to the road.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        TypeError
            If `road_object` or any element in the list is not of type `Object`.
        &#34;&#34;&#34;
        if isinstance(road_object, list):
            for single_object in road_object:
                if not isinstance(single_object, Object):
                    raise TypeError(
                        &#34;road_object contains elements that are not of type Object&#34;
                    )
                single_object._update_id()

            self.objects = self.objects + road_object
        else:
            if not isinstance(road_object, Object):
                raise TypeError(&#34;road_object is not of type Object&#34;)
            road_object._update_id()
            self.objects.append(road_object)
        return self

    def add_tunnel(self, tunnel: Union[Tunnel, list[Tunnel]]) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a tunnel or a list of tunnels to the road.

        Parameters
        ----------
        tunnel : Tunnel or list[Tunnel]
            The tunnel(s) to be added to the road.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        TypeError
            If `tunnel` or any element in the list is not of type `Tunnel`.
        &#34;&#34;&#34;
        if isinstance(tunnel, list):
            if any([not isinstance(x, Tunnel) for x in tunnel]):
                raise TypeError(
                    &#34;tunnel contains elements that are not of type Tunnel&#34;
                )
            self.objects.extend(tunnel)
        else:
            if not isinstance(tunnel, Tunnel):
                raise TypeError(&#34;tunnel is not of type Tunnel&#34;)
            self.objects.append(tunnel)
        return self

    def add_object_roadside(
        self,
        road_object_prototype: Object,
        repeatDistance: float,
        sOffset: float = 0,
        tOffset: float = 0,
        side: RoadSide = RoadSide.both,
        widthStart: Optional[float] = None,
        widthEnd: Optional[float] = None,
        lengthStart: Optional[float] = None,
        lengthEnd: Optional[float] = None,
        radiusStart: Optional[float] = None,
        radiusEnd: Optional[float] = None,
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a repeating object to the roadside.

        This method is a convenience function to add a repeating object
        on the side of the road. It can only be used after
        `adjust_roads_and_lanes()` has been performed.

        Parameters
        ----------
        road_object_prototype : Object
            The object that will be used as a basis for generation.
        repeatDistance : float
            The distance between repeated objects. Use 0 for continuous.
        sOffset : float, optional
            The start s-coordinate of repeating objects. Default is 0.
        tOffset : float, optional
            The t-offset additional to lane width. The sign will be added
            automatically (positive if further from the roadside).
            Default is 0.
        side : RoadSide, optional
            Add objects on both, left, or right side. Default is both.
        widthStart : float, optional
            Width of the object at the start-coordinate. Default is None.
        widthEnd : float, optional
            Width of the object at the end-coordinate. If not equal to
            `widthStart`, automatic linear width adaptation is applied
            over the distance. Default is None.
        lengthStart : float, optional
            Length of the object at the start-coordinate. Default is None.
        lengthEnd : float, optional
            Length of the object at the end-coordinate. If not equal to
            `lengthStart`, automatic linear length adaptation is applied
            over the distance. Default is None.
        radiusStart : float, optional
            Radius of the object at the start-coordinate. Default is None.
        radiusEnd : float, optional
            Radius of the object at the end-coordinate. If not equal to
            `radiusStart`, automatic linear radius adaptation is applied
            over the distance. Default is None.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        RoadsAndLanesNotAdjusted
            If roads and lanes are not adjusted before calling this method.
        TypeError
            If `road_object_prototype` is not of type `Object`.
        &#34;&#34;&#34;
        if not self.is_adjusted(&#34;planview&#34;):
            raise RoadsAndLanesNotAdjusted(
                &#34;Could not add roadside object because roads and lanes need to be adjusted first. Consider calling &#39;adjust_roads_and_lanes()&#39;.&#34;
            )
        if not isinstance(road_object_prototype, Object):
            raise TypeError(&#34;road_object_prototype is not of type Object&#34;)
        side = enumchecker(side, RoadSide)

        total_widths = {RoadSide.right: [], RoadSide.left: []}
        road_objects = {RoadSide.right: None, RoadSide.left: None}
        repeat_lengths = {RoadSide.right: [], RoadSide.left: []}
        repeat_s = {RoadSide.right: [], RoadSide.left: []}
        repeat_t = {RoadSide.right: [], RoadSide.left: []}
        lanesections_s = []
        lanesections_length = []
        # TODO: handle width parameters apart from a
        for idx, lanesection in enumerate(self.lanes.lanesections):
            # retrieve lengths and widths of lane sections
            if idx == len(self.lanes.lanesections) - 1:
                # last lanesection
                lanesections_length.append(
                    self.planview.get_total_length() - lanesection.s
                )

            else:
                lanesections_length.append(
                    self.lanes.lanesections[idx + 1].s - lanesection.s
                )
            lanesections_s.append(lanesection.s)
            if side != RoadSide.right:
                # adding object for left side
                road_objects[RoadSide.left] = cpy.deepcopy(
                    road_object_prototype
                )
                total_widths[RoadSide.left].append(0)
                for lane in lanesection.leftlanes:
                    total_widths[RoadSide.left][-1] = (
                        total_widths[RoadSide.left][-1] + lane.widths[0].a
                    )
            if side != RoadSide.left:
                # adding object for right side
                road_objects[RoadSide.right] = cpy.deepcopy(
                    road_object_prototype
                )
                total_widths[RoadSide.right].append(0)
                for lane in lanesection.rightlanes:
                    total_widths[RoadSide.right][-1] = (
                        total_widths[RoadSide.right][-1] + lane.widths[0].a
                    )
            # both sides are added if RoadSide.both

        for road_side in [RoadSide.left, RoadSide.right]:
            if road_objects[road_side] is None:
                # no road_object is added to this roadside
                continue

            # initialize road objects with meaningful values
            hdg_factor = 1
            if road_side == RoadSide.right:
                hdg_factor = -1
            road_objects[road_side].t = (
                total_widths[road_side][0] + tOffset
            ) * hdg_factor
            road_objects[road_side].hdg = np.pi * (1 + hdg_factor) / 2
            road_objects[road_side].s = sOffset

            accumulated_length = 0
            for idx, length in enumerate(lanesections_length):
                accumulated_length += length
                if idx == 0:
                    repeat_lengths[road_side].append(
                        accumulated_length - sOffset
                    )
                    repeat_s[road_side].append(sOffset)
                    repeat_t[road_side].append(
                        (total_widths[road_side][idx] + tOffset) * hdg_factor
                    )
                else:
                    if (
                        total_widths[road_side][idx]
                        != total_widths[road_side][idx - 1]
                    ):
                        # add another repeat record only if width is changing
                        repeat_lengths[road_side].append(length)
                        repeat_s[road_side].append(lanesections_s[idx])
                        repeat_t[road_side].append(
                            (total_widths[road_side][idx] + tOffset)
                            * hdg_factor
                        )
                    else:
                        # otherwise add the length to existing repeat entry
                        repeat_lengths[road_side][-1] += length

            for idx, repeat_length in enumerate(repeat_lengths[road_side]):
                if repeat_length &lt; 0:
                    raise ValueError(
                        f&#34;Calculated negative value for s-coordinate of roadside object with name &#34;
                        f&#34;&#39;{road_objects[road_side].name}&#39;. Ensure using sOffset &lt; length of road.&#34;
                    )
                road_objects[road_side].repeat(
                    repeat_length,
                    repeatDistance,
                    sStart=repeat_s[road_side][idx],
                    tStart=repeat_t[road_side][idx],
                    tEnd=repeat_t[road_side][idx],
                    widthStart=widthStart,
                    widthEnd=widthEnd,
                    lengthStart=lengthStart,
                    lengthEnd=lengthEnd,
                    radiusStart=radiusStart,
                    radiusEnd=radiusEnd,
                )
            self.add_object(road_objects[road_side])
        return self

    def add_signal(self, signal: Union[Signal, list[Signal]]) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a signal or a list of signals to the road.

        Parameters
        ----------
        signal : Signal or list[Signal]
            The signal(s) to be added to the road.

        Returns
        -------
        Road
            The updated Road object.

        Raises
        ------
        TypeError
            If `signal` or any element in the list is not of type `Signal` or
            `SignalReference`.
        &#34;&#34;&#34;
        if isinstance(signal, list):
            if any(
                [
                    not any(
                        isinstance(x, Signal) or isinstance(x, SignalReference)
                    )
                    for x in signal
                ]
            ):
                raise TypeError(
                    &#34;signal contains elements that are not of type Signal&#34;
                )
            for single_signal in signal:
                single_signal._update_id()
            self.signals = self.signals + signal
        else:
            if not (
                isinstance(signal, Signal)
                or isinstance(signal, SignalReference)
            ):
                raise TypeError(&#34;signal is not of type Signal&#34;)
            signal._update_id()
            self.signals.append(signal)
        return self

    def add_type(
        self,
        road_type: RoadType,
        s: float = 0,
        country: Optional[str] = None,
        speed: Optional[Union[float, str]] = None,
        speed_unit: str = &#34;m/s&#34;,
    ) -&gt; &#34;Road&#34;:
        &#34;&#34;&#34;Add a type to the road (not to mix with junction or
        initialization).

        Parameters
        ----------
        road_type : RoadType
            The type of road.
        s : float, optional
            The distance where the type starts. Default is 0.
        country : str, optional
            Country code (should follow ISO 3166-1, alpha-2). Default is None.
        speed : float or str, optional
            The maximum speed allowed. Default is None.
        speed_unit : str, optional
            Unit of the speed. Can be &#39;m/s&#39;, &#39;mph&#39;, or &#39;km/h&#39;. Default is &#39;m/s&#39;.

        Returns
        -------
        Road
            The updated Road object.
        &#34;&#34;&#34;
        self.types.append(_Type(road_type, s, country, speed, speed_unit))
        return self

    def get_end_point(self) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;Get the x, y, and heading of the end of the road.

        Returns
        -------
        tuple[float, float, float]
            A tuple containing:
            - x : float
                The end x-coordinate.
            - y : float
                The end y-coordinate.
            - h : float
                The end heading.
        &#34;&#34;&#34;
        return (
            self.planview.present_x,
            self.planview.present_y,
            self.planview.present_h,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the road as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the road.
        &#34;&#34;&#34;
        retdict = {}
        if self.name:
            retdict[&#34;name&#34;] = self.name
        if self.rule:
            retdict[&#34;rule&#34;] = enum2str(self.rule)
        retdict[&#34;id&#34;] = str(self.id)
        retdict[&#34;junction&#34;] = str(self.road_type)
        retdict[&#34;length&#34;] = str(self.planview.get_total_length())
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the road.

        Returns
        -------
        ET.Element
            The XML ElementTree representation of the road.
        &#34;&#34;&#34;
        element = ET.Element(&#34;road&#34;, attrib=self.get_attributes())
        self._add_additional_data_to_element(element)
        element.append(self.links.get_element())
        if self.types:
            for r in self.types:
                element.append(r.get_element())
        element.append(self.planview.get_element())
        element.append(self.elevationprofile.get_element())
        element.append(self.lateralprofile.get_element())
        element.append(self.lanes.get_element())
        if len(self.objects) &gt; 0:
            objectselement = ET.SubElement(element, &#34;objects&#34;)
            for road_object in self.objects:
                objectselement.append(road_object.get_element())
        if len(self.signals) &gt; 0:
            signalselement = ET.SubElement(element, &#34;signals&#34;)
            for signal in self.signals:
                signalselement.append(signal.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Road defines the road element of OpenDRIVE.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>road_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Identifier of the road.</dd>
<dt><strong><code>planview</code></strong> :&ensp;<code>PlanView</code></dt>
<dd>The planview of the road.</dd>
<dt><strong><code>lanes</code></strong> :&ensp;<code>Lanes</code></dt>
<dd>The lanes of the road.</dd>
<dt><strong><code>road_type</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Type of road (junction). Default is -1.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the road. Default is None.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>TrafficRule</code>, optional</dt>
<dd>Traffic rule. Default is <code>TrafficRule.RHT</code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Identifier of the road.</dd>
<dt><strong><code>planview</code></strong> :&ensp;<code>PlanView</code></dt>
<dd>The planview of the road.</dd>
<dt><strong><code>lanes</code></strong> :&ensp;<code>Lanes</code></dt>
<dd>The lanes of the road.</dd>
<dt><strong><code>road_type</code></strong> :&ensp;<code>int</code></dt>
<dd>Type of road (junction).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the road.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>TrafficRule</code></dt>
<dd>Traffic rule.</dd>
<dt><strong><code>links</code></strong> :&ensp;<code>_Links</code></dt>
<dd>Links associated with the road.</dd>
<dt><strong><code>objects</code></strong> :&ensp;<code>list[Object]</code></dt>
<dd>List of objects on the road.</dd>
<dt><strong><code>signals</code></strong> :&ensp;<code>list[Signal]</code></dt>
<dd>List of signals on the road.</dd>
<dt><strong><code>types</code></strong> :&ensp;<code>list[_Type]</code></dt>
<dd>List of road types.</dd>
<dt><strong><code>elevationprofile</code></strong> :&ensp;<code>ElevationProfile</code></dt>
<dd>Elevation profile of the road.</dd>
<dt><strong><code>lateralprofile</code></strong> :&ensp;<code>LateralProfile</code></dt>
<dd>Lateral profile of the road.</dd>
<dt><strong><code>successor</code></strong> :&ensp;<code>_Link</code> or <code>None</code></dt>
<dd>Successor link of the road.</dd>
<dt><strong><code>predecessor</code></strong> :&ensp;<code>_Link</code> or <code>None</code></dt>
<dd>Predecessor link of the road.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.
add_successor(element_type, element_id, contact_point, lane_offset)
Adds a successor for the road.
add_predecessor(element_type, element_id, contact_point, lane_offset)
Adds a predecessor for the road.
add_neighbor(element_type, element_id, direction)
Adds a neighbor for the road.
add_object(road_object)
Adds an object to the road.
add_elevation(s, a, b, c, d)
Adds an elevation profile to the road.
add_superelevation(s, a, b, c, d)
Adds a superelevation to the road.
add_shape(s, t, a, b, c, d)
Adds a lateral shape to the road.
add_tunnel(tunnel)
Adds a tunnel or list of tunnels to a road.
add_object_roadside(road_object_prototype, repeatDistance, &hellip;)
Adds a repeated object to the road.
add_signal(signal)
Adds a signal to the road.
add_type(road_type, s, country, speed, speed_unit)
Adds a type to the road (not to mix with junction or not as the
init)
get_end_point()
Returns the x, y, and heading at the end of the road.</p>
<p>Initialize the Road.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>road_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Identifier of the road.</dd>
<dt><strong><code>planview</code></strong> :&ensp;<code>PlanView</code></dt>
<dd>The planview of the road.</dd>
<dt><strong><code>lanes</code></strong> :&ensp;<code>Lanes</code></dt>
<dd>The lanes of the road.</dd>
<dt><strong><code>road_type</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Type of road (junction). Default is -1.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the road. Default is None.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>TrafficRule</code>, optional</dt>
<dd>Traffic rule. Default is <code>TrafficRule.RHT</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>planview</code> is not of type <code>PlanView</code> or <code>AdjustablePlanview</code>.
If <code>lanes</code> is not of type <code>Lanes</code>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xodr.opendrive.Road.add_elevation"><code class="name flex">
<span>def <span class="ident">add_elevation</span></span>(<span>self, s: float, a: float, b: float, c: float, d: float) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elevation(
    self, s: float, a: float, b: float, c: float, d: float
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add an elevation profile to the road (3-degree polynomial).

    Parameters
    ----------
    s : float
        The s-coordinate where the elevation starts.
    a : float
        The a coefficient of the polynomial.
    b : float
        The b coefficient of the polynomial.
    c : float
        The c coefficient of the polynomial.
    d : float
        The d coefficient of the polynomial.

    Returns
    -------
    Road
        The updated Road object.
    &#34;&#34;&#34;
    self.elevationprofile.add_elevation(
        _Poly3Profile(s, a, b, c, d, elevation_type=&#34;elevation&#34;)
    )
    self._elevation_adjusted = True
    return self</code></pre>
</details>
<div class="desc"><p>Add an elevation profile to the road (3-degree polynomial).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The s-coordinate where the elevation starts.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>The a coefficient of the polynomial.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The b coefficient of the polynomial.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>The c coefficient of the polynomial.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>The d coefficient of the polynomial.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_neighbor"><code class="name flex">
<span>def <span class="ident">add_neighbor</span></span>(<span>self,<br>element_type: <a title="scenariogeneration.xodr.enumerations.ElementType" href="enumerations.html#scenariogeneration.xodr.enumerations.ElementType">ElementType</a>,<br>element_id: str | int,<br>direction: Direction) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_neighbor(
    self,
    element_type: ElementType,
    element_id: Union[int, str],
    direction: &#34;Direction&#34;,
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a neighbor to the road.

    Parameters
    ----------
    element_type : ElementType
        The type of the linked road element.
    element_id : int or str
        The identifier of the linked road element.
    direction : Direction
        The direction of the link.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    ValueError
        If more than two neighbors are added to the road.
    &#34;&#34;&#34;
    if self._neighbor_added &gt; 1:
        raise ValueError(&#34;only two neighbors are allowed&#34;)
    suc = _Link(&#34;neighbor&#34;, element_id, element_type, direction=direction)

    self.links.add_link(suc)
    self._neighbor_added += 1
    return self</code></pre>
</details>
<div class="desc"><p>Add a neighbor to the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element_type</code></strong> :&ensp;<code>ElementType</code></dt>
<dd>The type of the linked road element.</dd>
<dt><strong><code>element_id</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>The identifier of the linked road element.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code></dt>
<dd>The direction of the link.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If more than two neighbors are added to the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_object"><code class="name flex">
<span>def <span class="ident">add_object</span></span>(<span>self,<br>road_object: <a title="scenariogeneration.xodr.signals_objects.Object" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Object">Object</a> | list[<a title="scenariogeneration.xodr.signals_objects.Object" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Object">Object</a>]) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_object(self, road_object: Union[Object, list[Object]]) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add an object or a list of objects to the road and ensure unique
    IDs.

    Parameters
    ----------
    road_object : Object or list[Object]
        The object(s) to be added to the road.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    TypeError
        If `road_object` or any element in the list is not of type `Object`.
    &#34;&#34;&#34;
    if isinstance(road_object, list):
        for single_object in road_object:
            if not isinstance(single_object, Object):
                raise TypeError(
                    &#34;road_object contains elements that are not of type Object&#34;
                )
            single_object._update_id()

        self.objects = self.objects + road_object
    else:
        if not isinstance(road_object, Object):
            raise TypeError(&#34;road_object is not of type Object&#34;)
        road_object._update_id()
        self.objects.append(road_object)
    return self</code></pre>
</details>
<div class="desc"><p>Add an object or a list of objects to the road and ensure unique
IDs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>road_object</code></strong> :&ensp;<code>Object</code> or <code>list[Object]</code></dt>
<dd>The object(s) to be added to the road.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>road_object</code> or any element in the list is not of type <code>Object</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_object_roadside"><code class="name flex">
<span>def <span class="ident">add_object_roadside</span></span>(<span>self,<br>road_object_prototype: <a title="scenariogeneration.xodr.signals_objects.Object" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Object">Object</a>,<br>repeatDistance: float,<br>sOffset: float = 0,<br>tOffset: float = 0,<br>side: <a title="scenariogeneration.xodr.enumerations.RoadSide" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadSide">RoadSide</a> = RoadSide.both,<br>widthStart: float | None = None,<br>widthEnd: float | None = None,<br>lengthStart: float | None = None,<br>lengthEnd: float | None = None,<br>radiusStart: float | None = None,<br>radiusEnd: float | None = None) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_object_roadside(
    self,
    road_object_prototype: Object,
    repeatDistance: float,
    sOffset: float = 0,
    tOffset: float = 0,
    side: RoadSide = RoadSide.both,
    widthStart: Optional[float] = None,
    widthEnd: Optional[float] = None,
    lengthStart: Optional[float] = None,
    lengthEnd: Optional[float] = None,
    radiusStart: Optional[float] = None,
    radiusEnd: Optional[float] = None,
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a repeating object to the roadside.

    This method is a convenience function to add a repeating object
    on the side of the road. It can only be used after
    `adjust_roads_and_lanes()` has been performed.

    Parameters
    ----------
    road_object_prototype : Object
        The object that will be used as a basis for generation.
    repeatDistance : float
        The distance between repeated objects. Use 0 for continuous.
    sOffset : float, optional
        The start s-coordinate of repeating objects. Default is 0.
    tOffset : float, optional
        The t-offset additional to lane width. The sign will be added
        automatically (positive if further from the roadside).
        Default is 0.
    side : RoadSide, optional
        Add objects on both, left, or right side. Default is both.
    widthStart : float, optional
        Width of the object at the start-coordinate. Default is None.
    widthEnd : float, optional
        Width of the object at the end-coordinate. If not equal to
        `widthStart`, automatic linear width adaptation is applied
        over the distance. Default is None.
    lengthStart : float, optional
        Length of the object at the start-coordinate. Default is None.
    lengthEnd : float, optional
        Length of the object at the end-coordinate. If not equal to
        `lengthStart`, automatic linear length adaptation is applied
        over the distance. Default is None.
    radiusStart : float, optional
        Radius of the object at the start-coordinate. Default is None.
    radiusEnd : float, optional
        Radius of the object at the end-coordinate. If not equal to
        `radiusStart`, automatic linear radius adaptation is applied
        over the distance. Default is None.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    RoadsAndLanesNotAdjusted
        If roads and lanes are not adjusted before calling this method.
    TypeError
        If `road_object_prototype` is not of type `Object`.
    &#34;&#34;&#34;
    if not self.is_adjusted(&#34;planview&#34;):
        raise RoadsAndLanesNotAdjusted(
            &#34;Could not add roadside object because roads and lanes need to be adjusted first. Consider calling &#39;adjust_roads_and_lanes()&#39;.&#34;
        )
    if not isinstance(road_object_prototype, Object):
        raise TypeError(&#34;road_object_prototype is not of type Object&#34;)
    side = enumchecker(side, RoadSide)

    total_widths = {RoadSide.right: [], RoadSide.left: []}
    road_objects = {RoadSide.right: None, RoadSide.left: None}
    repeat_lengths = {RoadSide.right: [], RoadSide.left: []}
    repeat_s = {RoadSide.right: [], RoadSide.left: []}
    repeat_t = {RoadSide.right: [], RoadSide.left: []}
    lanesections_s = []
    lanesections_length = []
    # TODO: handle width parameters apart from a
    for idx, lanesection in enumerate(self.lanes.lanesections):
        # retrieve lengths and widths of lane sections
        if idx == len(self.lanes.lanesections) - 1:
            # last lanesection
            lanesections_length.append(
                self.planview.get_total_length() - lanesection.s
            )

        else:
            lanesections_length.append(
                self.lanes.lanesections[idx + 1].s - lanesection.s
            )
        lanesections_s.append(lanesection.s)
        if side != RoadSide.right:
            # adding object for left side
            road_objects[RoadSide.left] = cpy.deepcopy(
                road_object_prototype
            )
            total_widths[RoadSide.left].append(0)
            for lane in lanesection.leftlanes:
                total_widths[RoadSide.left][-1] = (
                    total_widths[RoadSide.left][-1] + lane.widths[0].a
                )
        if side != RoadSide.left:
            # adding object for right side
            road_objects[RoadSide.right] = cpy.deepcopy(
                road_object_prototype
            )
            total_widths[RoadSide.right].append(0)
            for lane in lanesection.rightlanes:
                total_widths[RoadSide.right][-1] = (
                    total_widths[RoadSide.right][-1] + lane.widths[0].a
                )
        # both sides are added if RoadSide.both

    for road_side in [RoadSide.left, RoadSide.right]:
        if road_objects[road_side] is None:
            # no road_object is added to this roadside
            continue

        # initialize road objects with meaningful values
        hdg_factor = 1
        if road_side == RoadSide.right:
            hdg_factor = -1
        road_objects[road_side].t = (
            total_widths[road_side][0] + tOffset
        ) * hdg_factor
        road_objects[road_side].hdg = np.pi * (1 + hdg_factor) / 2
        road_objects[road_side].s = sOffset

        accumulated_length = 0
        for idx, length in enumerate(lanesections_length):
            accumulated_length += length
            if idx == 0:
                repeat_lengths[road_side].append(
                    accumulated_length - sOffset
                )
                repeat_s[road_side].append(sOffset)
                repeat_t[road_side].append(
                    (total_widths[road_side][idx] + tOffset) * hdg_factor
                )
            else:
                if (
                    total_widths[road_side][idx]
                    != total_widths[road_side][idx - 1]
                ):
                    # add another repeat record only if width is changing
                    repeat_lengths[road_side].append(length)
                    repeat_s[road_side].append(lanesections_s[idx])
                    repeat_t[road_side].append(
                        (total_widths[road_side][idx] + tOffset)
                        * hdg_factor
                    )
                else:
                    # otherwise add the length to existing repeat entry
                    repeat_lengths[road_side][-1] += length

        for idx, repeat_length in enumerate(repeat_lengths[road_side]):
            if repeat_length &lt; 0:
                raise ValueError(
                    f&#34;Calculated negative value for s-coordinate of roadside object with name &#34;
                    f&#34;&#39;{road_objects[road_side].name}&#39;. Ensure using sOffset &lt; length of road.&#34;
                )
            road_objects[road_side].repeat(
                repeat_length,
                repeatDistance,
                sStart=repeat_s[road_side][idx],
                tStart=repeat_t[road_side][idx],
                tEnd=repeat_t[road_side][idx],
                widthStart=widthStart,
                widthEnd=widthEnd,
                lengthStart=lengthStart,
                lengthEnd=lengthEnd,
                radiusStart=radiusStart,
                radiusEnd=radiusEnd,
            )
        self.add_object(road_objects[road_side])
    return self</code></pre>
</details>
<div class="desc"><p>Add a repeating object to the roadside.</p>
<p>This method is a convenience function to add a repeating object
on the side of the road. It can only be used after
<code>adjust_roads_and_lanes()</code> has been performed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>road_object_prototype</code></strong> :&ensp;<code>Object</code></dt>
<dd>The object that will be used as a basis for generation.</dd>
<dt><strong><code>repeatDistance</code></strong> :&ensp;<code>float</code></dt>
<dd>The distance between repeated objects. Use 0 for continuous.</dd>
<dt><strong><code>sOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The start s-coordinate of repeating objects. Default is 0.</dd>
<dt><strong><code>tOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The t-offset additional to lane width. The sign will be added
automatically (positive if further from the roadside).
Default is 0.</dd>
<dt><strong><code>side</code></strong> :&ensp;<code>RoadSide</code>, optional</dt>
<dd>Add objects on both, left, or right side. Default is both.</dd>
<dt><strong><code>widthStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the object at the start-coordinate. Default is None.</dd>
<dt><strong><code>widthEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Width of the object at the end-coordinate. If not equal to
<code>widthStart</code>, automatic linear width adaptation is applied
over the distance. Default is None.</dd>
<dt><strong><code>lengthStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the object at the start-coordinate. Default is None.</dd>
<dt><strong><code>lengthEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the object at the end-coordinate. If not equal to
<code>lengthStart</code>, automatic linear length adaptation is applied
over the distance. Default is None.</dd>
<dt><strong><code>radiusStart</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius of the object at the start-coordinate. Default is None.</dd>
<dt><strong><code>radiusEnd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius of the object at the end-coordinate. If not equal to
<code>radiusStart</code>, automatic linear radius adaptation is applied
over the distance. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RoadsAndLanesNotAdjusted</code></dt>
<dd>If roads and lanes are not adjusted before calling this method.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>road_object_prototype</code> is not of type <code>Object</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_predecessor"><code class="name flex">
<span>def <span class="ident">add_predecessor</span></span>(<span>self,<br>element_type: <a title="scenariogeneration.xodr.enumerations.ElementType" href="enumerations.html#scenariogeneration.xodr.enumerations.ElementType">ElementType</a>,<br>element_id: str | int,<br>contact_point: <a title="scenariogeneration.xodr.enumerations.ContactPoint" href="enumerations.html#scenariogeneration.xodr.enumerations.ContactPoint">ContactPoint</a> | None = None,<br>lane_offset: int = 0) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_predecessor(
    self,
    element_type: ElementType,
    element_id: Union[int, str],
    contact_point: Optional[ContactPoint] = None,
    lane_offset: int = 0,
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a predecessor link to the road.

    Parameters
    ----------
    element_type : ElementType
        The type of the linked road element.
    element_id : int or str
        The identifier of the linked road element.
    contact_point : ContactPoint, optional
        The contact point of the link. Default is None.
    lane_offset : int, optional
        The lane offset for the predecessor. Default is 0.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    ValueError
        If a predecessor already exists for the road.
    &#34;&#34;&#34;
    if self.predecessor:
        raise ValueError(&#34;only one predecessor is allowed&#34;)
    self.predecessor = _Link(
        &#34;predecessor&#34;,
        element_id,
        enumchecker(element_type, ElementType),
        contact_point,
    )
    self.links.add_link(self.predecessor)
    self.lane_offset_pred[str(element_id)] = lane_offset
    return self</code></pre>
</details>
<div class="desc"><p>Add a predecessor link to the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element_type</code></strong> :&ensp;<code>ElementType</code></dt>
<dd>The type of the linked road element.</dd>
<dt><strong><code>element_id</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>The identifier of the linked road element.</dd>
<dt><strong><code>contact_point</code></strong> :&ensp;<code>ContactPoint</code>, optional</dt>
<dd>The contact point of the link. Default is None.</dd>
<dt><strong><code>lane_offset</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The lane offset for the predecessor. Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a predecessor already exists for the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_shape"><code class="name flex">
<span>def <span class="ident">add_shape</span></span>(<span>self, s: float, t: float, a: float, b: float, c: float, d: float) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shape(
    self, s: float, t: float, a: float, b: float, c: float, d: float
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a lateral shape profile to the road (3-degree polynomial).

    Parameters
    ----------
    s : float
        The s-coordinate where the shape starts.
    t : float
        The t-coordinate of the lateral profile.
    a : float
        The a coefficient of the polynomial.
    b : float
        The b coefficient of the polynomial.
    c : float
        The c coefficient of the polynomial.
    d : float
        The d coefficient of the polynomial.

    Returns
    -------
    Road
        The updated Road object.
    &#34;&#34;&#34;
    self.lateralprofile.add_shape(
        _Poly3Profile(s, a, b, c, d, t, elevation_type=&#34;shape&#34;)
    )
    self._shape_adjusted = True
    return self</code></pre>
</details>
<div class="desc"><p>Add a lateral shape profile to the road (3-degree polynomial).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The s-coordinate where the shape starts.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>The t-coordinate of the lateral profile.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>The a coefficient of the polynomial.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The b coefficient of the polynomial.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>The c coefficient of the polynomial.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>The d coefficient of the polynomial.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_signal"><code class="name flex">
<span>def <span class="ident">add_signal</span></span>(<span>self,<br>signal: <a title="scenariogeneration.xodr.signals_objects.Signal" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Signal">Signal</a> | list[<a title="scenariogeneration.xodr.signals_objects.Signal" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Signal">Signal</a>]) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal(self, signal: Union[Signal, list[Signal]]) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a signal or a list of signals to the road.

    Parameters
    ----------
    signal : Signal or list[Signal]
        The signal(s) to be added to the road.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    TypeError
        If `signal` or any element in the list is not of type `Signal` or
        `SignalReference`.
    &#34;&#34;&#34;
    if isinstance(signal, list):
        if any(
            [
                not any(
                    isinstance(x, Signal) or isinstance(x, SignalReference)
                )
                for x in signal
            ]
        ):
            raise TypeError(
                &#34;signal contains elements that are not of type Signal&#34;
            )
        for single_signal in signal:
            single_signal._update_id()
        self.signals = self.signals + signal
    else:
        if not (
            isinstance(signal, Signal)
            or isinstance(signal, SignalReference)
        ):
            raise TypeError(&#34;signal is not of type Signal&#34;)
        signal._update_id()
        self.signals.append(signal)
    return self</code></pre>
</details>
<div class="desc"><p>Add a signal or a list of signals to the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>Signal</code> or <code>list[Signal]</code></dt>
<dd>The signal(s) to be added to the road.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>signal</code> or any element in the list is not of type <code>Signal</code> or
<code>SignalReference</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_successor"><code class="name flex">
<span>def <span class="ident">add_successor</span></span>(<span>self,<br>element_type: <a title="scenariogeneration.xodr.enumerations.ElementType" href="enumerations.html#scenariogeneration.xodr.enumerations.ElementType">ElementType</a>,<br>element_id: str | int,<br>contact_point: <a title="scenariogeneration.xodr.enumerations.ContactPoint" href="enumerations.html#scenariogeneration.xodr.enumerations.ContactPoint">ContactPoint</a> | None = None,<br>lane_offset: int = 0) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_successor(
    self,
    element_type: ElementType,
    element_id: Union[int, str],
    contact_point: Optional[ContactPoint] = None,
    lane_offset: int = 0,
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a successor link to the road.

    Parameters
    ----------
    element_type : ElementType
        The type of the linked road element.
    element_id : int or str
        The identifier of the linked road element.
    contact_point : ContactPoint, optional
        The contact point of the link. Default is None.
    lane_offset : int, optional
        The lane offset for the successor. Default is 0.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    ValueError
        If a successor already exists for the road.
    &#34;&#34;&#34;

    if self.successor:
        raise ValueError(&#34;only one successor is allowed&#34;)
    self.successor = _Link(
        &#34;successor&#34;,
        element_id,
        enumchecker(element_type, ElementType),
        contact_point,
    )
    self.links.add_link(self.successor)
    self.lane_offset_suc[str(element_id)] = lane_offset
    return self</code></pre>
</details>
<div class="desc"><p>Add a successor link to the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element_type</code></strong> :&ensp;<code>ElementType</code></dt>
<dd>The type of the linked road element.</dd>
<dt><strong><code>element_id</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>The identifier of the linked road element.</dd>
<dt><strong><code>contact_point</code></strong> :&ensp;<code>ContactPoint</code>, optional</dt>
<dd>The contact point of the link. Default is None.</dd>
<dt><strong><code>lane_offset</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The lane offset for the successor. Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a successor already exists for the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_superelevation"><code class="name flex">
<span>def <span class="ident">add_superelevation</span></span>(<span>self, s: float, a: float, b: float, c: float, d: float) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_superelevation(
    self, s: float, a: float, b: float, c: float, d: float
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a superelevation profile to the road (3-degree polynomial).

    Parameters
    ----------
    s : float
        The s-coordinate where the superelevation starts.
    a : float
        The a coefficient of the polynomial.
    b : float
        The b coefficient of the polynomial.
    c : float
        The c coefficient of the polynomial.
    d : float
        The d coefficient of the polynomial.

    Returns
    -------
    Road
        The updated Road object.
    &#34;&#34;&#34;
    self.lateralprofile.add_superelevation(
        _Poly3Profile(s, a, b, c, d, elevation_type=&#34;superelevation&#34;)
    )
    self._superelevation_adjusted = True
    return self</code></pre>
</details>
<div class="desc"><p>Add a superelevation profile to the road (3-degree polynomial).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>The s-coordinate where the superelevation starts.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>The a coefficient of the polynomial.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The b coefficient of the polynomial.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>The c coefficient of the polynomial.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>The d coefficient of the polynomial.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_tunnel"><code class="name flex">
<span>def <span class="ident">add_tunnel</span></span>(<span>self,<br>tunnel: <a title="scenariogeneration.xodr.signals_objects.Tunnel" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Tunnel">Tunnel</a> | list[<a title="scenariogeneration.xodr.signals_objects.Tunnel" href="signals_objects.html#scenariogeneration.xodr.signals_objects.Tunnel">Tunnel</a>]) ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tunnel(self, tunnel: Union[Tunnel, list[Tunnel]]) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a tunnel or a list of tunnels to the road.

    Parameters
    ----------
    tunnel : Tunnel or list[Tunnel]
        The tunnel(s) to be added to the road.

    Returns
    -------
    Road
        The updated Road object.

    Raises
    ------
    TypeError
        If `tunnel` or any element in the list is not of type `Tunnel`.
    &#34;&#34;&#34;
    if isinstance(tunnel, list):
        if any([not isinstance(x, Tunnel) for x in tunnel]):
            raise TypeError(
                &#34;tunnel contains elements that are not of type Tunnel&#34;
            )
        self.objects.extend(tunnel)
    else:
        if not isinstance(tunnel, Tunnel):
            raise TypeError(&#34;tunnel is not of type Tunnel&#34;)
        self.objects.append(tunnel)
    return self</code></pre>
</details>
<div class="desc"><p>Add a tunnel or a list of tunnels to the road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tunnel</code></strong> :&ensp;<code>Tunnel</code> or <code>list[Tunnel]</code></dt>
<dd>The tunnel(s) to be added to the road.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>tunnel</code> or any element in the list is not of type <code>Tunnel</code>.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.add_type"><code class="name flex">
<span>def <span class="ident">add_type</span></span>(<span>self,<br>road_type: <a title="scenariogeneration.xodr.enumerations.RoadType" href="enumerations.html#scenariogeneration.xodr.enumerations.RoadType">RoadType</a>,<br>s: float = 0,<br>country: str | None = None,<br>speed: float | str | None = None,<br>speed_unit: str = 'm/s') ‑> <a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_type(
    self,
    road_type: RoadType,
    s: float = 0,
    country: Optional[str] = None,
    speed: Optional[Union[float, str]] = None,
    speed_unit: str = &#34;m/s&#34;,
) -&gt; &#34;Road&#34;:
    &#34;&#34;&#34;Add a type to the road (not to mix with junction or
    initialization).

    Parameters
    ----------
    road_type : RoadType
        The type of road.
    s : float, optional
        The distance where the type starts. Default is 0.
    country : str, optional
        Country code (should follow ISO 3166-1, alpha-2). Default is None.
    speed : float or str, optional
        The maximum speed allowed. Default is None.
    speed_unit : str, optional
        Unit of the speed. Can be &#39;m/s&#39;, &#39;mph&#39;, or &#39;km/h&#39;. Default is &#39;m/s&#39;.

    Returns
    -------
    Road
        The updated Road object.
    &#34;&#34;&#34;
    self.types.append(_Type(road_type, s, country, speed, speed_unit))
    return self</code></pre>
</details>
<div class="desc"><p>Add a type to the road (not to mix with junction or
initialization).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>road_type</code></strong> :&ensp;<code>RoadType</code></dt>
<dd>The type of road.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The distance where the type starts. Default is 0.</dd>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Country code (should follow ISO 3166-1, alpha-2). Default is None.</dd>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code> or <code>str</code>, optional</dt>
<dd>The maximum speed allowed. Default is None.</dd>
<dt><strong><code>speed_unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unit of the speed. Can be 'm/s', 'mph', or 'km/h'. Default is 'm/s'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></dt>
<dd>The updated Road object.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the road as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the road.
    &#34;&#34;&#34;
    retdict = {}
    if self.name:
        retdict[&#34;name&#34;] = self.name
    if self.rule:
        retdict[&#34;rule&#34;] = enum2str(self.rule)
    retdict[&#34;id&#34;] = str(self.id)
    retdict[&#34;junction&#34;] = str(self.road_type)
    retdict[&#34;length&#34;] = str(self.planview.get_total_length())
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the road as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the road.

    Returns
    -------
    ET.Element
        The XML ElementTree representation of the road.
    &#34;&#34;&#34;
    element = ET.Element(&#34;road&#34;, attrib=self.get_attributes())
    self._add_additional_data_to_element(element)
    element.append(self.links.get_element())
    if self.types:
        for r in self.types:
            element.append(r.get_element())
    element.append(self.planview.get_element())
    element.append(self.elevationprofile.get_element())
    element.append(self.lateralprofile.get_element())
    element.append(self.lanes.get_element())
    if len(self.objects) &gt; 0:
        objectselement = ET.SubElement(element, &#34;objects&#34;)
        for road_object in self.objects:
            objectselement.append(road_object.get_element())
    if len(self.signals) &gt; 0:
        signalselement = ET.SubElement(element, &#34;signals&#34;)
        for signal in self.signals:
            signalselement.append(signal.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the road.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML ElementTree representation of the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.get_end_point"><code class="name flex">
<span>def <span class="ident">get_end_point</span></span>(<span>self) ‑> tuple[float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_point(self) -&gt; tuple[float, float, float]:
    &#34;&#34;&#34;Get the x, y, and heading of the end of the road.

    Returns
    -------
    tuple[float, float, float]
        A tuple containing:
        - x : float
            The end x-coordinate.
        - y : float
            The end y-coordinate.
        - h : float
            The end heading.
    &#34;&#34;&#34;
    return (
        self.planview.present_x,
        self.planview.present_y,
        self.planview.present_h,
    )</code></pre>
</details>
<div class="desc"><p>Get the x, y, and heading of the end of the road.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[float, float, float]</code></dt>
<dd>A tuple containing:
- x : float
The end x-coordinate.
- y : float
The end y-coordinate.
- h : float
The end heading.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xodr.opendrive.Road.is_adjusted"><code class="name flex">
<span>def <span class="ident">is_adjusted</span></span>(<span>self, domain: str = 'planview') ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_adjusted(self, domain: str = &#34;planview&#34;) -&gt; bool:
    &#34;&#34;&#34;Check if the road has been properly defined in the specified
    domain.

    Parameters
    ----------
    domain : str, optional
        The domain to check. Valid values are &#34;planview&#34;, &#34;elevation&#34;,
        &#34;superelevation&#34;, or &#34;shape&#34;. Default is &#34;planview&#34;.

    Returns
    -------
    bool
        True if the road is properly defined in the specified domain,
        False otherwise.

    Raises
    ------
    ValueError
        If the domain is not one of the valid values.
    &#34;&#34;&#34;
    if domain == &#34;planview&#34;:
        return self.planview.adjusted
    elif domain == &#34;elevation&#34;:
        return self._elevation_adjusted
    elif domain == &#34;superelevation&#34;:
        return self._superelevation_adjusted
    elif domain == &#34;shape&#34;:
        return self._shape_adjusted
    else:
        raise ValueError(
            &#34;domain can only be: geometry, elevation, superelevation, or shape , not &#34;
            + domain
        )</code></pre>
</details>
<div class="desc"><p>Check if the road has been properly defined in the specified
domain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>domain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The domain to check. Valid values are "planview", "elevation",
"superelevation", or "shape". Default is "planview".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the road is properly defined in the specified domain,
False otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the domain is not one of the valid values.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenariogeneration.xodr.utils.XodrBase" href="utils.html#scenariogeneration.xodr.utils.XodrBase">XodrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_dataquality" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_dataquality">add_dataquality</a></code></li>
<li><code><a title="scenariogeneration.xodr.utils.XodrBase.add_userdata" href="utils.html#scenariogeneration.xodr.utils.XodrBase.add_userdata">add_userdata</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xodr.opendrive.OpenDrive" href="#scenariogeneration.xodr.opendrive.OpenDrive">OpenDrive</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.add_junction" href="#scenariogeneration.xodr.opendrive.OpenDrive.add_junction">add_junction</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.add_junction_creator" href="#scenariogeneration.xodr.opendrive.OpenDrive.add_junction_creator">add_junction_creator</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.add_road" href="#scenariogeneration.xodr.opendrive.OpenDrive.add_road">add_road</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.adjust_elevations" href="#scenariogeneration.xodr.opendrive.OpenDrive.adjust_elevations">adjust_elevations</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.adjust_roadmarks" href="#scenariogeneration.xodr.opendrive.OpenDrive.adjust_roadmarks">adjust_roadmarks</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.adjust_roads_and_lanes" href="#scenariogeneration.xodr.opendrive.OpenDrive.adjust_roads_and_lanes">adjust_roads_and_lanes</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.adjust_startpoints" href="#scenariogeneration.xodr.opendrive.OpenDrive.adjust_startpoints">adjust_startpoints</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.get_element" href="#scenariogeneration.xodr.opendrive.OpenDrive.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.OpenDrive.write_xml" href="#scenariogeneration.xodr.opendrive.OpenDrive.write_xml">write_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xodr.opendrive.Road" href="#scenariogeneration.xodr.opendrive.Road">Road</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_elevation" href="#scenariogeneration.xodr.opendrive.Road.add_elevation">add_elevation</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_neighbor" href="#scenariogeneration.xodr.opendrive.Road.add_neighbor">add_neighbor</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_object" href="#scenariogeneration.xodr.opendrive.Road.add_object">add_object</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_object_roadside" href="#scenariogeneration.xodr.opendrive.Road.add_object_roadside">add_object_roadside</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_predecessor" href="#scenariogeneration.xodr.opendrive.Road.add_predecessor">add_predecessor</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_shape" href="#scenariogeneration.xodr.opendrive.Road.add_shape">add_shape</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_signal" href="#scenariogeneration.xodr.opendrive.Road.add_signal">add_signal</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_successor" href="#scenariogeneration.xodr.opendrive.Road.add_successor">add_successor</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_superelevation" href="#scenariogeneration.xodr.opendrive.Road.add_superelevation">add_superelevation</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_tunnel" href="#scenariogeneration.xodr.opendrive.Road.add_tunnel">add_tunnel</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.add_type" href="#scenariogeneration.xodr.opendrive.Road.add_type">add_type</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.get_attributes" href="#scenariogeneration.xodr.opendrive.Road.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.get_element" href="#scenariogeneration.xodr.opendrive.Road.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.get_end_point" href="#scenariogeneration.xodr.opendrive.Road.get_end_point">get_end_point</a></code></li>
<li><code><a title="scenariogeneration.xodr.opendrive.Road.is_adjusted" href="#scenariogeneration.xodr.opendrive.Road.is_adjusted">is_adjusted</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
