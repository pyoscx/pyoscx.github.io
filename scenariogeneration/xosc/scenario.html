<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>scenariogeneration.xosc.scenario API documentation</title>
<meta name="description" content="the scenario module contains the main class for generating OpenSCENARIO files aswell as the roadnetwork" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.scenario</code></h1>
</header>
<section id="section-intro">
<p>the scenario module contains the main class for generating OpenSCENARIO files aswell as the roadnetwork</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; the scenario module contains the main class for generating OpenSCENARIO files aswell as the roadnetwork 

&#34;&#34;&#34;

from .position import _PositionFactory
from .exceptions import OpenSCENARIOVersionError, NotEnoughInputArguments

import xml.etree.ElementTree as ET
import xml.dom.minidom as mini


from ..helpers import printToFile
from .utils import FileHeader, ParameterDeclarations, Catalog, TrafficSignalController
from .enumerations import VersionBase, XMLNS, XSI
from .entities import Entities
from .storyboard import StoryBoard

class Scenario():
    &#34;&#34;&#34; The Scenario class collects all parts of OpenScenario and creates a .xml file
        
        Parameters
        ----------
            header (FileHeader): the header of the scenario file

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
                Default: 1

            licence (License): optional license to the file header
                Default: None

            createtion_date (datetime.datetime): optional creation date of the scenario
                Default: None (will be at the time of generation)

        Attributes
        ----------
            header (FileHeader): the header of the scenario file

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            header (FileHeader): header of the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            write_xml(filename)
                write a open scenario xml

    &#34;&#34;&#34;
    _XMLNS = XMLNS
    _XSI = XSI
    def __init__(self,name,author,parameters,entities,storyboard,roadnetwork,catalog,osc_minor_version=1,license=None,creation_date=None):

        &#34;&#34;&#34; Initalizes the Scenario class, and creates the header.

        Parameters
        ----------
            name (str): name of the scenario

            author (str): the author fo the scenario

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
                Default: 1
            
            licence (License): optional license to the file header
                Default: None

            createtion_date (datetime.datetime): optional creation date of the scenario
                Default: None (will be at the time of generation)

        &#34;&#34;&#34;
        if not isinstance(entities,Entities):
            raise TypeError(&#39;entities input is not of type Entities&#39;)
        if not isinstance(storyboard,StoryBoard):
            raise TypeError(&#39;storyboard input is not of type StoryBoard&#39;)
        if not isinstance(roadnetwork,RoadNetwork):
            raise TypeError(&#39;roadnetwork input is not of type RoadNetwork&#39;)
        if not isinstance(catalog,Catalog):
            raise TypeError(&#39;catalog input is not of type StorCatalogyBoard&#39;)
        if not isinstance(parameters,ParameterDeclarations):
            raise TypeError(&#39;parameters input is not of type ParameterDeclarations&#39;)

        self.entities = entities
        self.storyboard = storyboard
        self.roadnetwork = roadnetwork
        self.catalog = catalog 
        self.parameters = parameters
        self.header = FileHeader(author,name,revMinor=osc_minor_version,license=license,creation_date=creation_date)

    def __eq__(self,other):
        if isinstance(other,Scenario):
            if self.entities == other.entities and \
            self.storyboard == other.storyboard and \
            self.roadnetwork == other.roadnetwork and \
            self.catalog == other.catalog and \
            self.header == other.header and \
            self.parameters == other.parameters:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Scenario

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A Scenario element (same as generated by the class itself)

            Returns
            -------
                scenario (Scenario): a Scenario object

        &#34;&#34;&#34;
        header = FileHeader.parse(element.find(&#39;FileHeader&#39;))
        parameters = ParameterDeclarations.parse(element.find(&#39;ParameterDeclarations&#39;))
        catalog = Catalog.parse(element.find(&#39;CatalogLocations&#39;))
        storyboard = StoryBoard.parse(element.find(&#39;Storyboard&#39;))
        entities = Entities.parse(element.find(&#39;Entities&#39;))
        roadnetwork = RoadNetwork.parse(element.find(&#39;RoadNetwork&#39;))

        return Scenario(header.description, header.author, parameters,entities,storyboard,roadnetwork,catalog,header._revMinor)
        


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Scenario

        &#34;&#34;&#34;
        element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:self._XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:self._XSI})
        element.append(self.header.get_element())
        element.append(self.parameters.get_element())
        element.append(self.catalog.get_element())
        element.append(self.roadnetwork.get_element())
        element.append(self.entities.get_element())
        element.append(self.storyboard.get_element())

        return element

    def write_xml(self, filename, prettyprint = True, encoding = &#39;utf-8&#39;):
        &#34;&#34;&#34; write_xml writes the OpenSCENARIO xml file

        Parameters
        ----------
            filename (str): path and filename of the wanted xml file

            prettyprint (bool): pretty print or ugly print?
                Default: True
                
            encoding (str): specifies the output encoding
                Default: &#39;utf-8&#39;

        &#34;&#34;&#34;
        printToFile(self.get_element(),filename,prettyprint)
        



class RoadNetwork(VersionBase):
    &#34;&#34;&#34; The RoadNetwork class creates the RoadNetwork of the openScenario
        
        Parameters
        ----------
            roadfile (str): path to the opendrive file

            scenegraph (str): path to the opensceengraph file (optional)

        Attributes
        ----------
            road_file (str): path to the opendrive file

            scene (str): path to the opensceengraph file 

            traffic_signals (list of TrafficSignalController): all traffic signals in the roadnetwork

            used_area_positions (list of Positions): the positions that determines the used area of the roadnetwork
            
        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class



    &#34;&#34;&#34;
    def __init__(self,roadfile=None,scenegraph=None):
        &#34;&#34;&#34; Initalizes the RoadNetwork

        Parameters
        ----------
            roadfile (str): path to the opendrive file (optional)

            scenegraph (str): path to the opensceengraph file (optional)

        &#34;&#34;&#34;
        self.road_file = roadfile
        self.scene = scenegraph
        self.traffic_signals = []
        self.used_area_positions = []

    def __eq__(self,other):
        if isinstance(other,RoadNetwork):
            if self.road_file == other.road_file and \
            self.scene == other.scene and \
            self.traffic_signals == other.traffic_signals and \
            self.used_area_positions == other.used_area_positions:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of RoadNetwork

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A RoadNetwork element (same as generated by the class itself)

            Returns
            -------
                roadnetwork (RoadNetwork): a RoadNetwork object

        &#34;&#34;&#34;
        logicFile = None
        if element.find(&#39;LogicFile&#39;) is not None:
            logicFile = element.find(&#39;LogicFile&#39;).attrib[&#39;filepath&#39;]
        
        sceneGraphFile = None
        if element.find(&#39;SceneGraphFile&#39;) is not None:
            sceneGraphFile = element.find(&#39;SceneGraphFile&#39;).attrib[&#39;filepath&#39;]

        roadnetwork = RoadNetwork(roadfile=logicFile, scenegraph= sceneGraphFile)

        position_elements = element.findall(&#39;UsedArea/Position&#39;)
        if position_elements is not None:
            for position in position_elements:
                roadnetwork.add_used_area_position(_PositionFactory.parse_position(position))

        tsc_elements = element.findall(&#39;TrafficSignals/TrafficSignalController&#39;)
        if tsc_elements is not None:
            for tsc_element in tsc_elements:
                controller = TrafficSignalController.parse(tsc_element)
                roadnetwork.add_traffic_signal_controller(controller)
        
        return roadnetwork


    def add_traffic_signal_controller(self,traffic_signal_controller):
        &#34;&#34;&#34; adds a TrafficSignalController to the RoadNetwork

            Parameters
            ----------
                traffic_signal_controller (TrafficSignalController): the traffic signal controller to add

        &#34;&#34;&#34;
        if not isinstance(traffic_signal_controller,TrafficSignalController):
            raise TypeError(&#39;traffic_signal_controller input is not of type TrafficSignalController&#39;)
        self.traffic_signals.append(traffic_signal_controller)
    
    def add_used_area_position(self,position):
        &#34;&#34;&#34; adds a position to determine the usedArea of the roadnetwork used, this feature was added in OpenSCENARIO V1.1.
            Atleast 2 positions are required.

            Parameters
            ----------
                position (*Position): any position to determine the used area
        
        &#34;&#34;&#34;
        self.used_area_positions.append(position)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RoadNetwork

        &#34;&#34;&#34;
        roadnetwork = ET.Element(&#39;RoadNetwork&#39;)
        if self.road_file:
            ET.SubElement(roadnetwork,&#39;LogicFile&#39;,{&#39;filepath&#39;: self.road_file})
        if self.scene:
            ET.SubElement(roadnetwork,&#39;SceneGraphFile&#39;,{&#39;filepath&#39;:self.scene})
        if self.traffic_signals:
            trafsign_element = ET.SubElement(roadnetwork,&#39;TrafficSignals&#39;)
            for ts in self.traffic_signals:
                trafsign_element.append(ts.get_element())
        if len(self.used_area_positions) == 1:
            raise NotEnoughInputArguments(&#39;To use &#34;usedArea&#34; more than 1 used_area_position is needed.&#39;)
        elif len(self.used_area_positions) &gt; 1 and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;UsedArea is not supported in OpenSCENARIO V1.0, was introduced in OpenSCENARIO V1.1&#39;)
        elif len(self.used_area_positions) &gt; 1 and not self.isVersion(minor=0):
            usedarea = ET.SubElement(roadnetwork,&#39;UsedArea&#39;)
            for p in self.used_area_positions:
                usedarea.append(p.get_element())

        return roadnetwork
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.scenario.RoadNetwork"><code class="flex name class">
<span>class <span class="ident">RoadNetwork</span></span>
<span>(</span><span>roadfile=None, scenegraph=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The RoadNetwork class creates the RoadNetwork of the openScenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>roadfile (str): path to the opendrive file

scenegraph (str): path to the opensceengraph file (optional)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>road_file (str): path to the opendrive file

scene (str): path to the opensceengraph file

traffic_signals (list of TrafficSignalController): all traffic signals in the roadnetwork

used_area_positions (list of Positions): the positions that determines the used area of the roadnetwork
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>Initalizes the RoadNetwork</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>roadfile (str): path to the opendrive file (optional)

scenegraph (str): path to the opensceengraph file (optional)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadNetwork(VersionBase):
    &#34;&#34;&#34; The RoadNetwork class creates the RoadNetwork of the openScenario
        
        Parameters
        ----------
            roadfile (str): path to the opendrive file

            scenegraph (str): path to the opensceengraph file (optional)

        Attributes
        ----------
            road_file (str): path to the opendrive file

            scene (str): path to the opensceengraph file 

            traffic_signals (list of TrafficSignalController): all traffic signals in the roadnetwork

            used_area_positions (list of Positions): the positions that determines the used area of the roadnetwork
            
        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class



    &#34;&#34;&#34;
    def __init__(self,roadfile=None,scenegraph=None):
        &#34;&#34;&#34; Initalizes the RoadNetwork

        Parameters
        ----------
            roadfile (str): path to the opendrive file (optional)

            scenegraph (str): path to the opensceengraph file (optional)

        &#34;&#34;&#34;
        self.road_file = roadfile
        self.scene = scenegraph
        self.traffic_signals = []
        self.used_area_positions = []

    def __eq__(self,other):
        if isinstance(other,RoadNetwork):
            if self.road_file == other.road_file and \
            self.scene == other.scene and \
            self.traffic_signals == other.traffic_signals and \
            self.used_area_positions == other.used_area_positions:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of RoadNetwork

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A RoadNetwork element (same as generated by the class itself)

            Returns
            -------
                roadnetwork (RoadNetwork): a RoadNetwork object

        &#34;&#34;&#34;
        logicFile = None
        if element.find(&#39;LogicFile&#39;) is not None:
            logicFile = element.find(&#39;LogicFile&#39;).attrib[&#39;filepath&#39;]
        
        sceneGraphFile = None
        if element.find(&#39;SceneGraphFile&#39;) is not None:
            sceneGraphFile = element.find(&#39;SceneGraphFile&#39;).attrib[&#39;filepath&#39;]

        roadnetwork = RoadNetwork(roadfile=logicFile, scenegraph= sceneGraphFile)

        position_elements = element.findall(&#39;UsedArea/Position&#39;)
        if position_elements is not None:
            for position in position_elements:
                roadnetwork.add_used_area_position(_PositionFactory.parse_position(position))

        tsc_elements = element.findall(&#39;TrafficSignals/TrafficSignalController&#39;)
        if tsc_elements is not None:
            for tsc_element in tsc_elements:
                controller = TrafficSignalController.parse(tsc_element)
                roadnetwork.add_traffic_signal_controller(controller)
        
        return roadnetwork


    def add_traffic_signal_controller(self,traffic_signal_controller):
        &#34;&#34;&#34; adds a TrafficSignalController to the RoadNetwork

            Parameters
            ----------
                traffic_signal_controller (TrafficSignalController): the traffic signal controller to add

        &#34;&#34;&#34;
        if not isinstance(traffic_signal_controller,TrafficSignalController):
            raise TypeError(&#39;traffic_signal_controller input is not of type TrafficSignalController&#39;)
        self.traffic_signals.append(traffic_signal_controller)
    
    def add_used_area_position(self,position):
        &#34;&#34;&#34; adds a position to determine the usedArea of the roadnetwork used, this feature was added in OpenSCENARIO V1.1.
            Atleast 2 positions are required.

            Parameters
            ----------
                position (*Position): any position to determine the used area
        
        &#34;&#34;&#34;
        self.used_area_positions.append(position)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RoadNetwork

        &#34;&#34;&#34;
        roadnetwork = ET.Element(&#39;RoadNetwork&#39;)
        if self.road_file:
            ET.SubElement(roadnetwork,&#39;LogicFile&#39;,{&#39;filepath&#39;: self.road_file})
        if self.scene:
            ET.SubElement(roadnetwork,&#39;SceneGraphFile&#39;,{&#39;filepath&#39;:self.scene})
        if self.traffic_signals:
            trafsign_element = ET.SubElement(roadnetwork,&#39;TrafficSignals&#39;)
            for ts in self.traffic_signals:
                trafsign_element.append(ts.get_element())
        if len(self.used_area_positions) == 1:
            raise NotEnoughInputArguments(&#39;To use &#34;usedArea&#34; more than 1 used_area_position is needed.&#39;)
        elif len(self.used_area_positions) &gt; 1 and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;UsedArea is not supported in OpenSCENARIO V1.0, was introduced in OpenSCENARIO V1.1&#39;)
        elif len(self.used_area_positions) &gt; 1 and not self.isVersion(minor=0):
            usedarea = ET.SubElement(roadnetwork,&#39;UsedArea&#39;)
            for p in self.used_area_positions:
                usedarea.append(p.get_element())

        return roadnetwork</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.scenario.RoadNetwork.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of RoadNetwork</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A RoadNetwork element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>roadnetwork (RoadNetwork): a RoadNetwork object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of RoadNetwork

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A RoadNetwork element (same as generated by the class itself)

        Returns
        -------
            roadnetwork (RoadNetwork): a RoadNetwork object

    &#34;&#34;&#34;
    logicFile = None
    if element.find(&#39;LogicFile&#39;) is not None:
        logicFile = element.find(&#39;LogicFile&#39;).attrib[&#39;filepath&#39;]
    
    sceneGraphFile = None
    if element.find(&#39;SceneGraphFile&#39;) is not None:
        sceneGraphFile = element.find(&#39;SceneGraphFile&#39;).attrib[&#39;filepath&#39;]

    roadnetwork = RoadNetwork(roadfile=logicFile, scenegraph= sceneGraphFile)

    position_elements = element.findall(&#39;UsedArea/Position&#39;)
    if position_elements is not None:
        for position in position_elements:
            roadnetwork.add_used_area_position(_PositionFactory.parse_position(position))

    tsc_elements = element.findall(&#39;TrafficSignals/TrafficSignalController&#39;)
    if tsc_elements is not None:
        for tsc_element in tsc_elements:
            controller = TrafficSignalController.parse(tsc_element)
            roadnetwork.add_traffic_signal_controller(controller)
    
    return roadnetwork</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.scenario.RoadNetwork.add_traffic_signal_controller"><code class="name flex">
<span>def <span class="ident">add_traffic_signal_controller</span></span>(<span>self, traffic_signal_controller)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a TrafficSignalController to the RoadNetwork</p>
<h2 id="parameters">Parameters</h2>
<pre><code>traffic_signal_controller (TrafficSignalController): the traffic signal controller to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_traffic_signal_controller(self,traffic_signal_controller):
    &#34;&#34;&#34; adds a TrafficSignalController to the RoadNetwork

        Parameters
        ----------
            traffic_signal_controller (TrafficSignalController): the traffic signal controller to add

    &#34;&#34;&#34;
    if not isinstance(traffic_signal_controller,TrafficSignalController):
        raise TypeError(&#39;traffic_signal_controller input is not of type TrafficSignalController&#39;)
    self.traffic_signals.append(traffic_signal_controller)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.scenario.RoadNetwork.add_used_area_position"><code class="name flex">
<span>def <span class="ident">add_used_area_position</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a position to determine the usedArea of the roadnetwork used, this feature was added in OpenSCENARIO V1.1.
Atleast 2 positions are required.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): any position to determine the used area
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_used_area_position(self,position):
    &#34;&#34;&#34; adds a position to determine the usedArea of the roadnetwork used, this feature was added in OpenSCENARIO V1.1.
        Atleast 2 positions are required.

        Parameters
        ----------
            position (*Position): any position to determine the used area
    
    &#34;&#34;&#34;
    self.used_area_positions.append(position)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.scenario.RoadNetwork.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RoadNetwork</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RoadNetwork

    &#34;&#34;&#34;
    roadnetwork = ET.Element(&#39;RoadNetwork&#39;)
    if self.road_file:
        ET.SubElement(roadnetwork,&#39;LogicFile&#39;,{&#39;filepath&#39;: self.road_file})
    if self.scene:
        ET.SubElement(roadnetwork,&#39;SceneGraphFile&#39;,{&#39;filepath&#39;:self.scene})
    if self.traffic_signals:
        trafsign_element = ET.SubElement(roadnetwork,&#39;TrafficSignals&#39;)
        for ts in self.traffic_signals:
            trafsign_element.append(ts.get_element())
    if len(self.used_area_positions) == 1:
        raise NotEnoughInputArguments(&#39;To use &#34;usedArea&#34; more than 1 used_area_position is needed.&#39;)
    elif len(self.used_area_positions) &gt; 1 and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;UsedArea is not supported in OpenSCENARIO V1.0, was introduced in OpenSCENARIO V1.1&#39;)
    elif len(self.used_area_positions) &gt; 1 and not self.isVersion(minor=0):
        usedarea = ET.SubElement(roadnetwork,&#39;UsedArea&#39;)
        for p in self.used_area_positions:
            usedarea.append(p.get_element())

    return roadnetwork</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.scenario.Scenario"><code class="flex name class">
<span>class <span class="ident">Scenario</span></span>
<span>(</span><span>name, author, parameters, entities, storyboard, roadnetwork, catalog, osc_minor_version=1, license=None, creation_date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Scenario class collects all parts of OpenScenario and creates a .xml file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>header (FileHeader): the header of the scenario file

parameters (ParameterDeclarations): the parameters to be used in the scenario

entities (Entities): the entities in the scenario

storyboard (StoryBoard): the storyboard of the scenario

roadnetwork (RoadNetwork): the roadnetwork of the scenario

catalog (Catalog): the catalogs used in the scenario

osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
    Default: 1

licence (License): optional license to the file header
    Default: None

createtion_date (datetime.datetime): optional creation date of the scenario
    Default: None (will be at the time of generation)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>header (FileHeader): the header of the scenario file

parameters (ParameterDeclarations): the parameters to be used in the scenario

entities (Entities): the entities in the scenario

storyboard (StoryBoard): the storyboard of the scenario

roadnetwork (RoadNetwork): the roadnetwork of the scenario

catalog (Catalog): the catalogs used in the scenario

header (FileHeader): header of the scenario
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

write_xml(filename)
    write a open scenario xml
</code></pre>
<p>Initalizes the Scenario class, and creates the header.</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the scenario

author (str): the author fo the scenario

parameters (ParameterDeclarations): the parameters to be used in the scenario

entities (Entities): the entities in the scenario

storyboard (StoryBoard): the storyboard of the scenario

roadnetwork (RoadNetwork): the roadnetwork of the scenario

catalog (Catalog): the catalogs used in the scenario

osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
    Default: 1

licence (License): optional license to the file header
    Default: None

createtion_date (datetime.datetime): optional creation date of the scenario
    Default: None (will be at the time of generation)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scenario():
    &#34;&#34;&#34; The Scenario class collects all parts of OpenScenario and creates a .xml file
        
        Parameters
        ----------
            header (FileHeader): the header of the scenario file

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
                Default: 1

            licence (License): optional license to the file header
                Default: None

            createtion_date (datetime.datetime): optional creation date of the scenario
                Default: None (will be at the time of generation)

        Attributes
        ----------
            header (FileHeader): the header of the scenario file

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            header (FileHeader): header of the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            write_xml(filename)
                write a open scenario xml

    &#34;&#34;&#34;
    _XMLNS = XMLNS
    _XSI = XSI
    def __init__(self,name,author,parameters,entities,storyboard,roadnetwork,catalog,osc_minor_version=1,license=None,creation_date=None):

        &#34;&#34;&#34; Initalizes the Scenario class, and creates the header.

        Parameters
        ----------
            name (str): name of the scenario

            author (str): the author fo the scenario

            parameters (ParameterDeclarations): the parameters to be used in the scenario

            entities (Entities): the entities in the scenario

            storyboard (StoryBoard): the storyboard of the scenario

            roadnetwork (RoadNetwork): the roadnetwork of the scenario

            catalog (Catalog): the catalogs used in the scenario

            osc_minor_version (int): used to set if another than the newest version of OpenSCENARIO should be used
                Default: 1
            
            licence (License): optional license to the file header
                Default: None

            createtion_date (datetime.datetime): optional creation date of the scenario
                Default: None (will be at the time of generation)

        &#34;&#34;&#34;
        if not isinstance(entities,Entities):
            raise TypeError(&#39;entities input is not of type Entities&#39;)
        if not isinstance(storyboard,StoryBoard):
            raise TypeError(&#39;storyboard input is not of type StoryBoard&#39;)
        if not isinstance(roadnetwork,RoadNetwork):
            raise TypeError(&#39;roadnetwork input is not of type RoadNetwork&#39;)
        if not isinstance(catalog,Catalog):
            raise TypeError(&#39;catalog input is not of type StorCatalogyBoard&#39;)
        if not isinstance(parameters,ParameterDeclarations):
            raise TypeError(&#39;parameters input is not of type ParameterDeclarations&#39;)

        self.entities = entities
        self.storyboard = storyboard
        self.roadnetwork = roadnetwork
        self.catalog = catalog 
        self.parameters = parameters
        self.header = FileHeader(author,name,revMinor=osc_minor_version,license=license,creation_date=creation_date)

    def __eq__(self,other):
        if isinstance(other,Scenario):
            if self.entities == other.entities and \
            self.storyboard == other.storyboard and \
            self.roadnetwork == other.roadnetwork and \
            self.catalog == other.catalog and \
            self.header == other.header and \
            self.parameters == other.parameters:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Scenario

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A Scenario element (same as generated by the class itself)

            Returns
            -------
                scenario (Scenario): a Scenario object

        &#34;&#34;&#34;
        header = FileHeader.parse(element.find(&#39;FileHeader&#39;))
        parameters = ParameterDeclarations.parse(element.find(&#39;ParameterDeclarations&#39;))
        catalog = Catalog.parse(element.find(&#39;CatalogLocations&#39;))
        storyboard = StoryBoard.parse(element.find(&#39;Storyboard&#39;))
        entities = Entities.parse(element.find(&#39;Entities&#39;))
        roadnetwork = RoadNetwork.parse(element.find(&#39;RoadNetwork&#39;))

        return Scenario(header.description, header.author, parameters,entities,storyboard,roadnetwork,catalog,header._revMinor)
        


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Scenario

        &#34;&#34;&#34;
        element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:self._XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:self._XSI})
        element.append(self.header.get_element())
        element.append(self.parameters.get_element())
        element.append(self.catalog.get_element())
        element.append(self.roadnetwork.get_element())
        element.append(self.entities.get_element())
        element.append(self.storyboard.get_element())

        return element

    def write_xml(self, filename, prettyprint = True, encoding = &#39;utf-8&#39;):
        &#34;&#34;&#34; write_xml writes the OpenSCENARIO xml file

        Parameters
        ----------
            filename (str): path and filename of the wanted xml file

            prettyprint (bool): pretty print or ugly print?
                Default: True
                
            encoding (str): specifies the output encoding
                Default: &#39;utf-8&#39;

        &#34;&#34;&#34;
        printToFile(self.get_element(),filename,prettyprint)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.scenario.Scenario.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A Scenario element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>scenario (Scenario): a Scenario object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Scenario

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Scenario element (same as generated by the class itself)

        Returns
        -------
            scenario (Scenario): a Scenario object

    &#34;&#34;&#34;
    header = FileHeader.parse(element.find(&#39;FileHeader&#39;))
    parameters = ParameterDeclarations.parse(element.find(&#39;ParameterDeclarations&#39;))
    catalog = Catalog.parse(element.find(&#39;CatalogLocations&#39;))
    storyboard = StoryBoard.parse(element.find(&#39;Storyboard&#39;))
    entities = Entities.parse(element.find(&#39;Entities&#39;))
    roadnetwork = RoadNetwork.parse(element.find(&#39;RoadNetwork&#39;))

    return Scenario(header.description, header.author, parameters,entities,storyboard,roadnetwork,catalog,header._revMinor)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.scenario.Scenario.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Scenario</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Scenario

    &#34;&#34;&#34;
    element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:self._XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:self._XSI})
    element.append(self.header.get_element())
    element.append(self.parameters.get_element())
    element.append(self.catalog.get_element())
    element.append(self.roadnetwork.get_element())
    element.append(self.entities.get_element())
    element.append(self.storyboard.get_element())

    return element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.scenario.Scenario.write_xml"><code class="name flex">
<span>def <span class="ident">write_xml</span></span>(<span>self, filename, prettyprint=True, encoding='utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>write_xml writes the OpenSCENARIO xml file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path and filename of the wanted xml file

prettyprint (bool): pretty print or ugly print?
    Default: True

encoding (str): specifies the output encoding
    Default: 'utf-8'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_xml(self, filename, prettyprint = True, encoding = &#39;utf-8&#39;):
    &#34;&#34;&#34; write_xml writes the OpenSCENARIO xml file

    Parameters
    ----------
        filename (str): path and filename of the wanted xml file

        prettyprint (bool): pretty print or ugly print?
            Default: True
            
        encoding (str): specifies the output encoding
            Default: &#39;utf-8&#39;

    &#34;&#34;&#34;
    printToFile(self.get_element(),filename,prettyprint)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.scenario.RoadNetwork" href="#scenariogeneration.xosc.scenario.RoadNetwork">RoadNetwork</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.scenario.RoadNetwork.add_traffic_signal_controller" href="#scenariogeneration.xosc.scenario.RoadNetwork.add_traffic_signal_controller">add_traffic_signal_controller</a></code></li>
<li><code><a title="scenariogeneration.xosc.scenario.RoadNetwork.add_used_area_position" href="#scenariogeneration.xosc.scenario.RoadNetwork.add_used_area_position">add_used_area_position</a></code></li>
<li><code><a title="scenariogeneration.xosc.scenario.RoadNetwork.get_element" href="#scenariogeneration.xosc.scenario.RoadNetwork.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.scenario.RoadNetwork.parse" href="#scenariogeneration.xosc.scenario.RoadNetwork.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.scenario.Scenario" href="#scenariogeneration.xosc.scenario.Scenario">Scenario</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.scenario.Scenario.get_element" href="#scenariogeneration.xosc.scenario.Scenario.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.scenario.Scenario.parse" href="#scenariogeneration.xosc.scenario.Scenario.parse">parse</a></code></li>
<li><code><a title="scenariogeneration.xosc.scenario.Scenario.write_xml" href="#scenariogeneration.xosc.scenario.Scenario.write_xml">write_xml</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>