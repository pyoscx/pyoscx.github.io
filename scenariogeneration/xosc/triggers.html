<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>scenariogeneration.xosc.triggers API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.triggers</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  scenariogeneration
  https://github.com/pyoscx/scenariogeneration
 
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.
 
  Copyright (c) 2022 The scenariogeneration Authors.

&#34;&#34;&#34;

import xml.etree.ElementTree as ET

from .utils import (
    EntityRef,
    convert_bool,
    _PositionType,
    _ValueTriggerType,
    _EntityTriggerType,
    _TriggerType,
)
from .enumerations import (
    CoordinateSystem,
    ObjectType,
    Rule,
    ConditionEdge,
    TriggeringEntitiesRule,
    RelativeDistanceType,
    StoryboardElementType,
    StoryboardElementState,
    VersionBase,
)
from .exceptions import ToManyOptionalArguments, NotAValidElement
from .position import _PositionFactory


class EmptyTrigger(_TriggerType):
    &#34;&#34;&#34;EmptyTrigger creates an empty trigger

    Parameters
    ----------
        triggeringpoint (str): start or stop

    Attributes
    ----------

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalizes the emtpy trigger

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

    def __eq__(self, other):
        if isinstance(other, EmptyTrigger):
            if self._triggerpoint == other._triggerpoint:
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 0
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
        return ET.Element(self._triggerpoint)


class _EntityConditionFactory:
    @staticmethod
    def parse_entity_condition(element):
        if element.find(&#34;EndOfRoadCondition&#34;) is not None:
            return EndOfRoadCondition.parse(element)
        elif element.find(&#34;CollisionCondition&#34;) is not None:
            return CollisionCondition.parse(element)
        elif element.find(&#34;OffroadCondition&#34;) is not None:
            return OffroadCondition.parse(element)
        elif element.find(&#34;TimeHeadwayCondition&#34;) is not None:
            return TimeHeadwayCondition.parse(element)
        elif element.find(&#34;TimeToCollisionCondition&#34;) is not None:
            return TimeToCollisionCondition.parse(element)
        elif element.find(&#34;AccelerationCondition&#34;) is not None:
            return AccelerationCondition.parse(element)
        elif element.find(&#34;StandStillCondition&#34;) is not None:
            return StandStillCondition.parse(element)
        elif element.find(&#34;SpeedCondition&#34;) is not None:
            return SpeedCondition.parse(element)
        elif element.find(&#34;RelativeSpeedCondition&#34;) is not None:
            return RelativeSpeedCondition.parse(element)
        elif element.find(&#34;TraveledDistanceCondition&#34;) is not None:
            return TraveledDistanceCondition.parse(element)
        elif element.find(&#34;ReachPositionCondition&#34;) is not None:
            return ReachPositionCondition.parse(element)
        elif element.find(&#34;DistanceCondition&#34;) is not None:
            return DistanceCondition.parse(element)
        elif element.find(&#34;RelativeDistanceCondition&#34;) is not None:
            return RelativeDistanceCondition.parse(element)
        else:
            raise NotAValidElement(
                &#34;element &#34;, element, &#34;is not a valid entity condition&#34;
            )


class _ValueConditionFactory:
    @staticmethod
    def parse_value_condition(element):
        if element.find(&#34;ParameterCondition&#34;) is not None:
            return ParameterCondition.parse(element.find(&#34;ParameterCondition&#34;))
        elif element.find(&#34;TimeOfDayCondition&#34;) is not None:
            return TimeOfDayCondition.parse(element.find(&#34;TimeOfDayCondition&#34;))
        elif element.find(&#34;SimulationTimeCondition&#34;) is not None:
            return SimulationTimeCondition.parse(
                element.find(&#34;SimulationTimeCondition&#34;)
            )
        elif element.find(&#34;StoryboardElementStateCondition&#34;) is not None:
            return StoryboardElementStateCondition.parse(
                element.find(&#34;StoryboardElementStateCondition&#34;)
            )
        elif element.find(&#34;UserDefinedValueCondition&#34;) is not None:
            return UserDefinedValueCondition.parse(
                element.find(&#34;UserDefinedValueCondition&#34;)
            )
        elif element.find(&#34;TrafficSignalCondition&#34;) is not None:
            return TrafficSignalCondition.parse(element.find(&#34;TrafficSignalCondition&#34;))
        elif element.find(&#34;TrafficSignalControllerCondition&#34;) is not None:
            return TrafficSignalControllerCondition.parse(
                element.find(&#34;TrafficSignalControllerCondition&#34;)
            )
        else:
            raise NotAValidElement(
                &#34;element &#34;, element, &#34;is not a valid entity condition&#34;
            )


class _ConditionFactory:
    @staticmethod
    def parse_condition(element):
        if element.find(&#34;ByEntityCondition/EntityCondition&#34;) is not None:
            return EntityTrigger.parse(element)
        elif element.find(&#34;ByValueCondition&#34;) is not None:
            return ValueTrigger.parse(element)
        else:
            raise NotAValidElement(&#34;element &#34;, element, &#34;is not a valid condition&#34;)


class Trigger(_TriggerType):
    &#34;&#34;&#34;The Trigger class creates a Trigger that can be used if multiple ConditionGroups are wanted
    The Trigger acts like an &#34;OR&#34; logic for all added ConditionGroups

    Parameters
    ----------
        triggeringpoint (str): start or stop
            Default: start

    Attributes
    ----------
        triggeringpoint (str): start or stop

        conditiongroups (list of ConditionGroup): a list of all conditiongroups

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_conditiongroup(conditiongroup)
            Adds a conditiongroup to the trigger

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalize the Trigger

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;
        self.conditiongroups = []

    def __eq__(self, other):
        if isinstance(other, Trigger):
            if (
                self.conditiongroups == other.conditiongroups
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, EntityTrigger) or isinstance(other, ValueTrigger):
            if (
                len(self.conditiongroups) == 1
                and len(self.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditiongroups[0].conditions[0] == other
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(self.conditiongroups) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditiongroups[0] == other
                ):
                    return True
        elif isinstance(other, EmptyTrigger):
            if (
                len(self.conditiongroups) == 0
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ConditionGroup

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            conditiongroup (ConditionGroup): a ConditionGroup object

        &#34;&#34;&#34;

        trigger = Trigger()
        trigger._triggerpoint = element.tag

        conditiongroups = element.findall(&#34;ConditionGroup&#34;)
        for condgr in conditiongroups:
            trigger.add_conditiongroup(ConditionGroup.parse(condgr))

        return trigger

    def add_conditiongroup(self, conditiongroup):
        &#34;&#34;&#34;Adds a conditiongroup to the trigger

        Parameters
        ----------
            conditiongroup (ConditionGroup): a conditiongroup to add to the trigger

        &#34;&#34;&#34;
        if not isinstance(conditiongroup, ConditionGroup):
            raise TypeError(&#34;conditiongroup input not of type ConditionGroup&#34;)
        conditiongroup._set_used_by_parent()
        self.conditiongroups.append(conditiongroup)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
        element = ET.Element(self._triggerpoint)
        if not self.conditiongroups:
            ValueError(&#34;No conditiongroups were added to the trigger&#34;)
        for c in self.conditiongroups:
            element.append(c.get_element())
        return element


class ConditionGroup(_TriggerType):
    &#34;&#34;&#34;The ConditionGroup class creates a Trigger that can be used if multiple Conditions are wanted
    The ConditionGroups acts like an &#34;AND&#34; logic for all added conditions

    Parameters
    ----------
        triggeringpoint (str): start or stop (not needed if used with the Trigger class)
            Default: start

    Attributes
    ----------
        triggeringpoint (str): start or stop

        conditions (list of EntityTriggers and Valuetriggers): a list of all conditions

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_condition(condition)
            Adds a condition to the ConditionGroup

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalize the ConditionGroup

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;
        self.conditions = []

    def __eq__(self, other):
        if isinstance(other, ConditionGroup):
            if (
                self.conditions == other.conditions
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if len(other.conditiongroups) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0] == self
                ):
                    return True
        elif isinstance(other, EntityTrigger) or isinstance(other, ValueTrigger):
            if len(self.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditions[0] == other
                ):
                    return True

        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ConditionGroup
        Note: if

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            conditiongroup (ConditionGroup): a ConditionGroup object

        &#34;&#34;&#34;

        condgr = ConditionGroup()
        conditions = element.findall(&#34;Condition&#34;)
        for cond in conditions:
            condgr.add_condition(_ConditionFactory().parse_condition(cond))

        return condgr

    def add_condition(self, condition):
        &#34;&#34;&#34;Adds a condition (EntityTrigger or ValueTrigger) to the ConditionGroup

        Parameters
        ----------
            condition (EntityTrigger, or ValueTrigger): a condition to add to the ConditionGroup

        &#34;&#34;&#34;
        if not (
            isinstance(condition, EntityTrigger) or isinstance(condition, ValueTrigger)
        ):
            raise TypeError(&#34;condition input not of type EntityTrigger or ValueTrigger&#34;)
        condition._set_used_by_parent()
        self.conditions.append(condition)
        self._used_by_parent = False
        return self

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition group is added to a Trigger&#34;&#34;&#34;
        self._used_by_parent = True

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ConditionGroup&#34;&#34;&#34;
        if not self.conditions:
            raise ValueError(&#34;No conditions were added to the ConditionGroup&#34;)
        condgroup = ET.Element(&#34;ConditionGroup&#34;)

        for c in self.conditions:
            condgroup.append(c.get_element())

        if self._used_by_parent:
            return condgroup
        else:
            # could create a new Trigger here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            element.append(condgroup)
            return element


class EntityTrigger(_TriggerType):
    &#34;&#34;&#34;the EntityTrigger creates an Trigger containing an EntityTrigger

    Parameters
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): on what conditionedge the trigger should act

        entitycondotion (*Condition): an entity condition

        triggeringentity (str): the entity of the trigger

        triggeringrule (TriggeringEntitiesRule): rule of the trigger
            Default: &#39;any&#39;

        triggeringpoint (str): start or stop

    Attributes
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): the condition edge

        entitycondition (*EntityCondition): the entitycondition

        triggerentity (TriggeringEntities): the triggering entity

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        name,
        delay,
        conditionedge,
        entitycondition,
        triggerentity,
        triggeringrule=TriggeringEntitiesRule.any,
        triggeringpoint=&#34;start&#34;,
    ):
        &#34;&#34;&#34;initalize the EntityTrigger

        Parameters
        ----------
            name (str): name of the trigger

            delay (float): the delay of the trigger

            conditionedge (ConditionEdge): on what conditionedge the trigger should act

            entitycondotion (*EntityCondition): an entity condition

            triggeringentity (str): the entity of the trigger

            triggeringrule (TriggeringEntitiesRule): rule of the trigger
                Default: &#39;any&#39;

            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        self.name = name
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

        self.delay = delay
        if not hasattr(ConditionEdge, str(conditionedge)):
            raise ValueError(&#34;not a valid condition edge&#34;)
        self.conditionedge = conditionedge
        if not isinstance(entitycondition, _EntityTriggerType):
            raise TypeError(&#34;entitycondition is not a valid EntityCondition&#34;)
        self.entitycondition = entitycondition
        self.triggerentity = TriggeringEntities(triggeringrule)
        self.triggerentity.add_entity(triggerentity)

        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, EntityTrigger):
            if (
                self.get_attributes() == other.get_attributes()
                and self.triggerentity == other.triggerentity
                and self.entitycondition == other.entitycondition
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 1
                and len(other.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0].conditions[0] == self
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(other.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditions[0] == self
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of EntityTrigger
        NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (EntityTrigger): a EntityTrigger object

        &#34;&#34;&#34;
        if element.tag != &#34;Condition&#34;:
            raise NotAValidElement(
                &#34;ValueTrigger only parses a Condition, not &#34;, element
            )

        name = element.attrib[&#34;name&#34;]
        delay = element.attrib[&#34;delay&#34;]
        conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
        entityconditionelement = element.find(&#34;ByEntityCondition&#34;)
        triggering_entities = TriggeringEntities.parse(
            entityconditionelement.find(&#34;TriggeringEntities&#34;)
        )
        condition = _EntityConditionFactory.parse_entity_condition(
            entityconditionelement.find(&#34;EntityCondition&#34;)
        )
        enttrig = EntityTrigger(name, delay, conditionedge, condition, &#34;&#34;)
        enttrig.triggerentity = triggering_entities

        return enttrig

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition is added to a ConditionGroup&#34;&#34;&#34;
        self._used_by_parent = True

    def add_triggering_entity(self, triggerentity):
        &#34;&#34;&#34;adds additional triggering entities to a trigger

        Parameters
        ----------
            triggeringentity (str)
        &#34;&#34;&#34;
        self.triggerentity.add_entity(triggerentity)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;delay&#34;: str(self.delay),
            &#34;conditionEdge&#34;: self.conditionedge.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
        byentity = ET.SubElement(condition, &#34;ByEntityCondition&#34;)
        byentity.append(self.triggerentity.get_element())
        byentity.append(self.entitycondition.get_element())

        if self._used_by_parent:
            return condition
        else:
            # could create a new Trigger ConditionGroup here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
            condgroup.append(condition)
            return element


class ValueTrigger(_TriggerType):
    &#34;&#34;&#34;the ValueTrigger creates a Trigger of the type ValueTrigger of openscenario

    Parameters
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): on what conditionedge the trigger should act

        valuecondition (*ValueCondition): a value condition

        triggeringentity (str): the entity of the trigger

        triggeringrule (str): rule of the trigger
            Default: &#39;any&#39;

        triggeringpoint (str): start or stop

    Attributes
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): the condition edge

        valuecondition (*ValueCondition): the value condition

        triggerentity (TriggeringEntities): the triggering entity

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self, name, delay, conditionedge, valuecondition, triggeringpoint=&#34;start&#34;
    ):
        &#34;&#34;&#34;initalize the ValueTrigger

        Parameters
        ----------
            name (str): name of the trigger

            delay (float): the delay of the trigger

            conditionedge (ConditionEdge): on what conditionedge the trigger should act

            valuecondition (*ValueCondition): a value condition

            triggeringentity (str): the entity of the trigger

            triggeringrule (str): rule of the trigger
                Default: &#39;any&#39;
            #TODO CHECK THIS
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        self.name = name
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

        self.delay = delay
        if not hasattr(ConditionEdge, str(conditionedge)):
            raise ValueError(&#34;not a valid condition edge&#34;)
        self.conditionedge = conditionedge
        if not isinstance(valuecondition, _ValueTriggerType):
            raise TypeError(&#34;entitycondition is not a valid EntityCondition&#34;)
        self.valuecondition = valuecondition
        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, ValueTrigger):
            if (
                self.get_attributes() == other.get_attributes()
                and self.valuecondition == other.valuecondition
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 1
                and len(other.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0].conditions[0] == self
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(other.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditions[0] == self
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ValueTrigger
        NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ValueTrigger): a ValueTrigger object

        &#34;&#34;&#34;
        if element.tag != &#34;Condition&#34;:
            raise NotAValidElement(
                &#34;ValueTrigger only parses a Condition, not &#34;, element
            )

        name = element.attrib[&#34;name&#34;]
        delay = element.attrib[&#34;delay&#34;]
        conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
        condition = _ValueConditionFactory.parse_value_condition(
            element.find(&#34;ByValueCondition&#34;)
        )
        return ValueTrigger(name, delay, conditionedge, condition)

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition is added to a ConditionGroup&#34;&#34;&#34;
        self._used_by_parent = True

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;delay&#34;: str(self.delay),
            &#34;conditionEdge&#34;: self.conditionedge.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
        byvalue = ET.SubElement(condition, &#34;ByValueCondition&#34;)
        byvalue.append(self.valuecondition.get_element())
        if self._used_by_parent:
            return condition
        else:
            # could create a new Trigger ConditionGroup here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
            condgroup.append(condition)
            return element


class TriggeringEntities(VersionBase):
    &#34;&#34;&#34;the TriggeringEntities class is used by Value and Entity Triggers to defined the trigger entity

    Parameters
    ----------
        triggeringrule (TriggeringEntitiesRule): all or any

    Attributes
    ----------
        entity (list of EntityRef): refernce to the entity

        triggeringrule (TriggeringEntitiesRule): all or any

    Methods
    -------
        add_entity(entity)
            adds a entityref to the triggering entities

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, triggeringrule):
        &#34;&#34;&#34;initalize the TriggeringEntities

        Parameters
        ----------
            entity (TriggeringEntitiesRule): name of the entity

            triggeringrule (str): all or any

        &#34;&#34;&#34;
        if not hasattr(TriggeringEntitiesRule, str(triggeringrule)):
            raise ValueError(&#34;not a vaild triggering rule&#34;)
        self.entity = []
        self.triggeringrule = triggeringrule

    def __eq__(self, other):
        if isinstance(other, TriggeringEntities):
            if (
                self.get_attributes() == other.get_attributes()
                and self.entity == other.entity
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TriggeringEntities

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            triggeringentities (TriggeringEntities): a TriggeringEntities object

        &#34;&#34;&#34;

        rule = getattr(TriggeringEntitiesRule, element.attrib[&#34;triggeringEntitiesRule&#34;])
        triggeringentities = TriggeringEntities(rule)
        entrefs = element.findall(&#34;EntityRef&#34;)
        for ent in entrefs:
            entityref = EntityRef.parse(ent)
            triggeringentities.add_entity(entityref.entity)
        return triggeringentities

    def add_entity(self, entity):
        &#34;&#34;&#34;add_entity adds an entity to the TriggeringEntities

        Parameters
        ----------
            entity (str): name of the entity to add

        &#34;&#34;&#34;
        self.entity.append(EntityRef(entity))
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {&#34;triggeringEntitiesRule&#34;: self.triggeringrule.get_name()}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;TriggeringEntities&#34;, attrib=self.get_attributes())
        for ent in self.entity:
            element.append(ent.get_element())
        return element


&#34;&#34;&#34; Entity conditions


&#34;&#34;&#34;


class EndOfRoadCondition(_EntityTriggerType):
    &#34;&#34;&#34;the EndOfRoadCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): the duration at the en of road

    Attributes
    ----------
        duration (float): the duration at the en of road

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;initalize the EndOfRoadCondition

        Parameters
        ----------
            duration (float): the duration after the condition

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, EndOfRoadCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of EndOfRoadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (EndOfRoadCondition): a EndOfRoadCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;EndOfRoadCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return EndOfRoadCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the EndOfRoadCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the EndOfRoadCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;EndOfRoadCondition&#34;, attrib=self.get_attributes())
        return element


class CollisionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the CollisionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        entity (str or ObjectType): name of the entity to collide with

    Attributes
    ----------
        entity (str or ObjectType): name of the entity to collide with

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, entity):
        &#34;&#34;&#34;the CollisionCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            entity (str or ObjectType): name of the entity to collide with

        &#34;&#34;&#34;

        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, CollisionCondition):
            if self.entity == other.entity:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of CollisionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (CollisionCondition): a CollisionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;CollisionCondition&#34;)
        bytype = condition.find(&#34;ByType&#34;)
        if bytype is not None:
            entity = getattr(ObjectType, bytype.attrib[&#34;type&#34;])
        else:
            entityref = EntityRef.parse(condition.find(&#34;EntityRef&#34;))
            entity = entityref.entity
        return CollisionCondition(entity)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the CollisionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        colcond = ET.SubElement(element, &#34;CollisionCondition&#34;)
        if isinstance(self.entity, str):
            colcond.append(EntityRef(self.entity).get_element())
        else:
            ET.SubElement(colcond, &#34;ByType&#34;, {&#34;type&#34;: self.entity.get_name()})
        return element


class OffroadCondition(_EntityTriggerType):
    &#34;&#34;&#34;the OffroadCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): the duration of offroad

    Attributes
    ----------
        duration (float): the duration of offroad

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;initalize the OffroadCondition

        Parameters
        ----------
            duration (float): the duration of offroad

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, OffroadCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of OffroadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (OffroadCondition): a OffroadCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;OffroadCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return OffroadCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the OffroadCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the OffroadCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;OffroadCondition&#34;, attrib=self.get_attributes())
        return element


class TimeHeadwayCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TimeHeadwayCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        entity (str): name of the entity for the headway

        value (float): time of headway

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road
    Attributes
    ----------
        entity (str): name of the entity for the headway

        value (float): time of headway

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        value,
        rule,
        alongroute=True,
        freespace=True,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        &#34;&#34;&#34;initalize the TimeHeadwayCondition

        Parameters
        ----------
            entity (str): name of the entity for the headway

            value (float): time of headway

            rule (Rule): condition rule of triggering

            alongroute (bool): if the route should count
                Default: True

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
                Default: RelativeDistanceType.longitudinal

            coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
                Default: CoordinateSystem.road
        &#34;&#34;&#34;
        self.entity = entity
        self.value = value
        if not isinstance(alongroute, bool):
            raise TypeError(&#34;alongroute input not of type bool&#34;)
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, TimeHeadwayCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeHeadwayCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeHeadwayCondition): a TimeHeadwayCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TimeHeadwayCondition&#34;)
        entity = condition.attrib[&#34;entityRef&#34;]
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])

        return TimeHeadwayCondition(
            entity, value, rule, alongroute, freespace, reldisttype, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeHeadwayCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;entityRef&#34;] = self.entity
        basedict[&#34;value&#34;] = str(self.value)
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.get_name()
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeHeadwayCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;TimeHeadwayCondition&#34;, attrib=self.get_attributes())
        return element


class TimeToCollisionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TimeToCollisionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------

        value (float): time to collision

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        optionals:
            entity (str): the entity to trigger collision on

            position (*Position): a position for collision

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road

    Attributes
    ----------
        value (float): time before collision

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
        Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
        Default: True
        optionals:
            entity (EntityRef):  entity for the collision

            position (*Position): a position for collision

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        alongroute=True,
        freespace=True,
        entity=None,
        position=None,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        &#34;&#34;&#34;initalize the TimeToCollisionCondition

        Parameters
        ----------

            value (float): time to collision

            rule (Rule): condition rule of triggering

            alongroute (bool): if the route should count
                Default: True

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            optionals:
                entity (str): the entity to trigger collision on

                position (*Position): a position for collision

            distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
                Default: RelativeDistanceType.longitudinal

            coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
                Default: CoordinateSystem.road
        &#34;&#34;&#34;
        self.value = value
        if not isinstance(alongroute, bool):
            raise TypeError(&#34;alongroute input not of type bool&#34;)
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.freespace = freespace
        self.alongroute = alongroute
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.use_entity = None
        if (entity != None) and (position != None):
            raise ToManyOptionalArguments(
                &#34;Can only have either entity of position, not both&#34;
            )
        if entity:
            self.entity = EntityRef(entity)
            self.use_entity = True
        if position:
            if not isinstance(position, _PositionType):
                raise TypeError(&#34;input position is not a valid Position&#34;)
            self.position = position
            self.use_entity = False

        if self.use_entity == None:
            raise ValueError(&#34;neither position or entity was set.&#34;)

        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, TimeToCollisionCondition):
            if self.get_attributes() == other.get_attributes():
                if (
                    self.use_entity
                    and other.use_entity
                    and self.entity
                    and other.entity
                ) or (
                    not self.use_entity
                    and not other.use_entity
                    and self.position
                    and other.position
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeToCollisionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeToCollisionCondition): a TimeToCollisionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TimeToCollisionCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        entity = None
        position = None
        if condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;) is not None:
            entityref = EntityRef.parse(
                condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;)
            )
            entity = entityref.entity
        elif condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;) is not None:
            position = _PositionFactory.parse_position(
                condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;)
            )
        else:
            raise ValueError(
                &#34;No TimeToCollisionConditionTarget found while parsing TimeToCollisionCondition.&#34;
            )
        return TimeToCollisionCondition(
            value,
            rule,
            alongroute,
            freespace,
            entity,
            position,
            reldisttype,
            coordsystem,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeToCollisionCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeToCollisionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        collisionevent = ET.SubElement(
            element, &#34;TimeToCollisionCondition&#34;, attrib=self.get_attributes()
        )

        targetelement = ET.SubElement(collisionevent, &#34;TimeToCollisionConditionTarget&#34;)

        if self.use_entity:
            targetelement.append(self.entity.get_element())
        else:
            targetelement.append(self.position.get_element())

        return element


class AccelerationCondition(_EntityTriggerType):
    &#34;&#34;&#34;the AccelerationCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;the AccelerationCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): acceleration

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, AccelerationCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AccelerationCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (AccelerationCondition): a AccelerationCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;AccelerationCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return AccelerationCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AccelerationCondition as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value), &#34;rule&#34;: self.rule.get_name()}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AccelerationCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;AccelerationCondition&#34;, attrib=self.get_attributes())
        return element


class StandStillCondition(_EntityTriggerType):
    &#34;&#34;&#34;the StandStillCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): time of standstill

    Attributes
    ----------
        duration (float): time of standstill

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;the StandStillCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            duration (float): time of standstill

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, StandStillCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of StandStillCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (StandStillCondition): a StandStillCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;StandStillCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return StandStillCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the StandStillCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the StandStillCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;StandStillCondition&#34;, attrib=self.get_attributes())
        return element


class SpeedCondition(_EntityTriggerType):
    &#34;&#34;&#34;the SpeedCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): speed to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (float): speed to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;initalize the SpeedCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): speed to trigger on

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, SpeedCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SpeedCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (SpeedCondition): a SpeedCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;SpeedCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return SpeedCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SpeedCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict
        # return merge_dicts({&#39;value&#39;:str(self.value)},self.rule.get_attributes())

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SpeedCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;SpeedCondition&#34;, attrib=self.get_attributes())
        return element


class RelativeSpeedCondition(_EntityTriggerType):
    &#34;&#34;&#34;the RelativeSpeedCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

        entity (str): name of the entity to be relative to

    Attributes
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

        entity (str): name of the entity to be relative to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule, entity):
        &#34;&#34;&#34;initalize the RelativeSpeedCondition

        Parameters
        ----------
            value (float): acceleration

            rule (Rule): condition rule of triggering

            entity (str): name of the entity to be relative to

        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, RelativeSpeedCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeSpeedCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (RelativeSpeedCondition): a RelativeSpeedCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;RelativeSpeedCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        entity = condition.attrib[&#34;entityRef&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return RelativeSpeedCondition(value, rule, entity)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeSpeedCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        basedict[&#34;entityRef&#34;] = self.entity
        return basedict
        # return merge_dicts({&#39;value&#39;:str(self.value),&#39;entityRef&#39;:self.entity},self.rule.get_attributes())

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeSpeedCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;RelativeSpeedCondition&#34;, attrib=self.get_attributes())
        return element


class TraveledDistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): how far it has traveled

    Attributes
    ----------
        value (float): how far it has traveled

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value):
        &#34;&#34;&#34;the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): how far it has traveled

        &#34;&#34;&#34;
        self.value = value

    def __eq__(self, other):
        if isinstance(other, TraveledDistanceCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TraveledDistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TraveledDistanceCondition): a TraveledDistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TraveledDistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        return TraveledDistanceCondition(value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TraveledDistanceCondition as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TraveledDistanceCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(
            element, &#34;TraveledDistanceCondition&#34;, attrib=self.get_attributes()
        )
        return element


class ReachPositionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the ReachPositionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        position (*Position): any position to reach

        tolerance (float): tolerance of the position

    Attributes
    ----------
        position (*Position): any position to reach

        tolerance (float): tolerance of the position

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, position, tolerance):
        &#34;&#34;&#34;initalize the ReachPositionCondition

        Parameters
        ----------
            position (*Position): any position to reach

            tolerance (float): tolerance of the position

        &#34;&#34;&#34;
        if not (isinstance(position, _PositionType)):
            raise TypeError(&#34;position input is not a valid Position&#34;)
        self.position = position
        self.tolerance = tolerance

    def __eq__(self, other):
        if isinstance(other, ReachPositionCondition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ReachPositionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ReachPositionCondition): a ReachPositionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;ReachPositionCondition&#34;)
        tolerance = condition.attrib[&#34;tolerance&#34;]
        position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
        return ReachPositionCondition(position, tolerance)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ReachPositionCondition as a dict&#34;&#34;&#34;
        return {&#34;tolerance&#34;: str(self.tolerance)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ReachPositionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        reachposcond = ET.SubElement(
            element, &#34;ReachPositionCondition&#34;, attrib=self.get_attributes()
        )
        reachposcond.append(self.position.get_element())
        return element


class DistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the DistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        position (*Position): any position to reach

        alongroute (bool): if the route should count (depricated in V.1.0)
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road

    Attributes
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        position (*Position): any position to reach

        alongroute (bool): if the route should count

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        distance_type (RelativeDistanceType): how the relative distance should be calculated

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        position,
        alongroute=True,
        freespace=True,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        self.value = value
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        if not (isinstance(position, _PositionType)):
            raise TypeError(&#34;position input is not a valid Position&#34;)
        self.position = position
        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, DistanceCondition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of DistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (DistanceCondition): a DistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;DistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        position = None

        position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
        return DistanceCondition(
            value, rule, position, alongroute, freespace, reldisttype, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DistanceCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)

        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name

        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the DistanceCondition&#34;&#34;&#34;

        element = ET.Element(&#34;EntityCondition&#34;)
        distancecond = ET.SubElement(
            element, &#34;DistanceCondition&#34;, attrib=self.get_attributes()
        )
        distancecond.append(self.position.get_element())
        return element


class RelativeDistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the RelativeDistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        dist_type (RelativeDistanceType): type of relative distance

        entity (str): name of the entity fore relative distance

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
            Default: CoordinateSystem.entity

    Attributes
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        entity (str): name of the entity fore relative distance

        dist_type (RelativeDistanceType): type of relative distance

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        dist_type,
        entity,
        alongroute=True,
        freespace=True,
        coordinate_system=CoordinateSystem.entity,
    ):
        &#34;&#34;&#34;initalize the RelativeDistanceCondition

        Parameters
        ----------
            value (float): distance to position

            rule (Rule): condition rule of triggering

            dist_type (RelativeDistanceType): type of relative distance

            entity (str): name of the entity fore relative distance

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
                Default: CoordinateSystem.entity
        &#34;&#34;&#34;
        self.value = value
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(RelativeDistanceType, str(dist_type)):
            raise TypeError(&#34;dist_type is not of type RelativeDistanceType&#34;)
        self.dist_type = dist_type
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.entity = entity
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, RelativeDistanceCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeDistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (RelativeDistanceCondition): a RelativeDistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;RelativeDistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        entity = condition.attrib[&#34;entityRef&#34;]
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road

        return RelativeDistanceCondition(
            value, rule, reldisttype, entity, alongroute, freespace, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeDistanceCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;entityRef&#34;] = self.entity
        basedict[&#34;rule&#34;] = self.rule.get_name()
        basedict[&#34;relativeDistanceType&#34;] = self.dist_type.get_name()
        if not self.isVersion(minor=0):
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeDistanceCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(
            element, &#34;RelativeDistanceCondition&#34;, attrib=self.get_attributes()
        )
        return element


&#34;&#34;&#34; Value Conditions

&#34;&#34;&#34;


class ParameterCondition(_ValueTriggerType):
    &#34;&#34;&#34;the ParameterCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        parameter (str): the parameter to trigger on

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        parameter (str): the parameter to trigger on

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, parameter, value, rule):
        &#34;&#34;&#34;initalize the ParameterCondition

        Parameters
        ----------
            parameter (str): the parameter to trigger on

            value (int): value to trigger on

            rule (Rule): condition rule of triggering

        &#34;&#34;&#34;
        self.parameter = parameter
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, ParameterCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ParameterCondition): a ParameterCondition object

        &#34;&#34;&#34;
        parameter = element.attrib[&#34;parameterRef&#34;]
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return ParameterCondition(parameter, value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterCondition as a dict&#34;&#34;&#34;
        basedict = {&#34;parameterRef&#34;: self.parameter, &#34;value&#34;: str(self.value)}
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterCondition&#34;&#34;&#34;
        return ET.Element(&#34;ParameterCondition&#34;, attrib=self.get_attributes())


class TimeOfDayCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TimeOfDayCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        rule (Rule): condition rule of triggering

        time of day (str): datetime ??? format unknown

    Attributes
    ----------
        rule (Rule): condition rule of triggering

        time of day (str): datetime ??? format unknown

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, rule, datetime):
        &#34;&#34;&#34;initalize the TimeOfDayCondition
        Parameters
        ----------
            rule (Rule): condition rule of triggering

            time of day (str): datetime ??? format unknown

        &#34;&#34;&#34;
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.datetime = datetime

    def __eq__(self, other):
        if isinstance(other, TimeOfDayCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeOfDayCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeOfDayCondition): a TimeOfDayCondition object

        &#34;&#34;&#34;

        datetime = element.attrib[&#34;datetime&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return TimeOfDayCondition(rule, datetime)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeOfDayCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;datetime&#34;] = self.datetime
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeOfDayCondition&#34;&#34;&#34;
        return ET.Element(&#34;TimeOfDayCondition&#34;, attrib=self.get_attributes())


class SimulationTimeCondition(_ValueTriggerType):
    &#34;&#34;&#34;the SimulationTimeCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        value (int): simulation time

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (int): simulation time

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;initalize the SimulationTimeCondition

        Parameters
        ----------
            value (int): simulation time

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, SimulationTimeCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SimulationTimeCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (SimulationTimeCondition): a SimulationTimeCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;SimulationTimeCondition&#34;)
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return SimulationTimeCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SimulationTimeCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SimulationTimeCondition&#34;&#34;&#34;
        return ET.Element(&#34;SimulationTimeCondition&#34;, attrib=self.get_attributes())


class StoryboardElementStateCondition(_ValueTriggerType):
    &#34;&#34;&#34;the StoryboardElementStateCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        element (StoryboardElementType): the element to trigger on

        reference (str): reference of the parameter

        state (StoryboardElementState): state to trigger on

    Attributes
    ----------
        element (StoryboardElementType): the element to trigger on

        reference (str): reference of the parameter

        state (StoryboardElementState): state to trigger on

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, element, reference, state):
        &#34;&#34;&#34;initalize the StoryboardElementStateCondition

        Parameters
        ----------
            element (StoryboardElementType): the element to trigger on

            reference (str): reference of the parameter

            state (StoryBoardElementState): state to trigger on
        &#34;&#34;&#34;
        if not hasattr(StoryboardElementType, str(element)):
            raise TypeError(&#34;element input is not of type StoryBoardElementType&#34;)
        if not hasattr(StoryboardElementState, str(state)):
            raise TypeError(&#34;state input is not of type StoryBoardElementState&#34;)
        self.element = element
        self.reference = reference
        self.state = state

    def __eq__(self, other):
        if isinstance(other, StoryboardElementStateCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of StoryboardElementStateCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (StoryboardElementStateCondition): a StoryboardElementStateCondition object

        &#34;&#34;&#34;
        ref = element.attrib[&#34;storyboardElementRef&#34;]
        sbet = getattr(StoryboardElementType, element.attrib[&#34;storyboardElementType&#34;])
        state = getattr(StoryboardElementState, element.attrib[&#34;state&#34;])
        return StoryboardElementStateCondition(sbet, ref, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the StoryboardElementStateCondition as a dict&#34;&#34;&#34;
        return {
            &#34;storyboardElementType&#34;: self.element.get_name(),
            &#34;storyboardElementRef&#34;: self.reference,
            &#34;state&#34;: self.state.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the StoryboardElementStateCondition&#34;&#34;&#34;
        return ET.Element(
            &#34;StoryboardElementStateCondition&#34;, attrib=self.get_attributes()
        )


class UserDefinedValueCondition(_ValueTriggerType):
    &#34;&#34;&#34;the UserDefinedValueCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        name (str): name of the parameter

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        name (str): name of the parameter

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, value, rule):
        &#34;&#34;&#34;initalize the UserDefinedValueCondition

        Parameters
        ----------
            name (str): name of the parameter

            value (int): value to trigger on

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.name = name
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, UserDefinedValueCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of UserDefinedValueCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (UserDefinedValueCondition): a UserDefinedValueCondition object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return UserDefinedValueCondition(name, value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the UserDefinedValueCondition as a dict&#34;&#34;&#34;
        basedict = {&#34;name&#34;: self.name, &#34;value&#34;: str(self.value)}
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedValueCondition&#34;&#34;&#34;
        return ET.Element(&#34;UserDefinedValueCondition&#34;, attrib=self.get_attributes())


class TrafficSignalCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TrafficSignalCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        name (str): name of the traficsignal ???

        state (str): state of the signal

    Attributes
    ----------
        name (str): name of the traficsignal ???

        state (str): state of the signal

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, state):
        &#34;&#34;&#34;initalize the TrafficSignalCondition

        Parameters
        ----------
            name (str): name of the traficsignal ???

            state (str): state of the signal

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self, other):
        if isinstance(other, TrafficSignalCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TrafficSignalCondition): a TrafficSignalCondition object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        state = element.attrib[&#34;state&#34;]

        return TrafficSignalCondition(name, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalCondition as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalCondition&#34;&#34;&#34;
        return ET.Element(&#34;TrafficSignalCondition&#34;, attrib=self.get_attributes())


class TrafficSignalControllerCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TrafficSignalControllerCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        trafficsignalref (str): ???

        phase (str): ???

    Attributes
    ----------
        trafficsignalref (str): ???

        phase (str): ???

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, trafficsignalref, phase):
        &#34;&#34;&#34;initalize the TrafficSignalControllerCondition

        Parameters
        ----------
            trafficsignalref (str): ???

            phase (str): ???

        &#34;&#34;&#34;
        self.trafficsignalref = trafficsignalref
        self.phase = phase

    def __eq__(self, other):
        if isinstance(other, TrafficSignalControllerCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TrafficSignalControllerCondition): a TrafficSignalControllerCondition object

        &#34;&#34;&#34;
        trafficsignalref = element.attrib[&#34;trafficSignalControllerRef&#34;]
        phase = element.attrib[&#34;phase&#34;]

        return TrafficSignalControllerCondition(trafficsignalref, phase)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerCondition as a dict&#34;&#34;&#34;
        return {
            &#34;trafficSignalControllerRef&#34;: self.trafficsignalref,
            &#34;phase&#34;: self.phase,
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerCondition&#34;&#34;&#34;
        return ET.Element(
            &#34;TrafficSignalControllerCondition&#34;, attrib=self.get_attributes()
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.triggers.AccelerationCondition"><code class="flex name class">
<span>class <span class="ident">AccelerationCondition</span></span>
<span>(</span><span>value, rule)</span>
</code></dt>
<dd>
<div class="desc"><p>the AccelerationCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>the AccelerationCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccelerationCondition(_EntityTriggerType):
    &#34;&#34;&#34;the AccelerationCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;the AccelerationCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): acceleration

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, AccelerationCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AccelerationCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (AccelerationCondition): a AccelerationCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;AccelerationCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return AccelerationCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AccelerationCondition as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value), &#34;rule&#34;: self.rule.get_name()}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AccelerationCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;AccelerationCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.AccelerationCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AccelerationCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (AccelerationCondition): a AccelerationCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AccelerationCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (AccelerationCondition): a AccelerationCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;AccelerationCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    return AccelerationCondition(value, rule)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.AccelerationCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AccelerationCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AccelerationCondition as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value), &#34;rule&#34;: self.rule.get_name()}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.AccelerationCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AccelerationCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AccelerationCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;AccelerationCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.CollisionCondition"><code class="flex name class">
<span>class <span class="ident">CollisionCondition</span></span>
<span>(</span><span>entity)</span>
</code></dt>
<dd>
<div class="desc"><p>the CollisionCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str or ObjectType): name of the entity to collide with
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str or ObjectType): name of the entity to collide with
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>the CollisionCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str or ObjectType): name of the entity to collide with
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CollisionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the CollisionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        entity (str or ObjectType): name of the entity to collide with

    Attributes
    ----------
        entity (str or ObjectType): name of the entity to collide with

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, entity):
        &#34;&#34;&#34;the CollisionCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            entity (str or ObjectType): name of the entity to collide with

        &#34;&#34;&#34;

        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, CollisionCondition):
            if self.entity == other.entity:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of CollisionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (CollisionCondition): a CollisionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;CollisionCondition&#34;)
        bytype = condition.find(&#34;ByType&#34;)
        if bytype is not None:
            entity = getattr(ObjectType, bytype.attrib[&#34;type&#34;])
        else:
            entityref = EntityRef.parse(condition.find(&#34;EntityRef&#34;))
            entity = entityref.entity
        return CollisionCondition(entity)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the CollisionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        colcond = ET.SubElement(element, &#34;CollisionCondition&#34;)
        if isinstance(self.entity, str):
            colcond.append(EntityRef(self.entity).get_element())
        else:
            ET.SubElement(colcond, &#34;ByType&#34;, {&#34;type&#34;: self.entity.get_name()})
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.CollisionCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of CollisionCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (CollisionCondition): a CollisionCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of CollisionCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (CollisionCondition): a CollisionCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;CollisionCondition&#34;)
    bytype = condition.find(&#34;ByType&#34;)
    if bytype is not None:
        entity = getattr(ObjectType, bytype.attrib[&#34;type&#34;])
    else:
        entityref = EntityRef.parse(condition.find(&#34;EntityRef&#34;))
        entity = entityref.entity
    return CollisionCondition(entity)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.CollisionCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the CollisionCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the CollisionCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    colcond = ET.SubElement(element, &#34;CollisionCondition&#34;)
    if isinstance(self.entity, str):
        colcond.append(EntityRef(self.entity).get_element())
    else:
        ET.SubElement(colcond, &#34;ByType&#34;, {&#34;type&#34;: self.entity.get_name()})
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.ConditionGroup"><code class="flex name class">
<span>class <span class="ident">ConditionGroup</span></span>
<span>(</span><span>triggeringpoint='start')</span>
</code></dt>
<dd>
<div class="desc"><p>The ConditionGroup class creates a Trigger that can be used if multiple Conditions are wanted
The ConditionGroups acts like an "AND" logic for all added conditions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop (not needed if used with the Trigger class)
    Default: start
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>triggeringpoint (str): start or stop

conditions (list of EntityTriggers and Valuetriggers): a list of all conditions
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_condition(condition)
    Adds a condition to the ConditionGroup
</code></pre>
<p>initalize the ConditionGroup</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConditionGroup(_TriggerType):
    &#34;&#34;&#34;The ConditionGroup class creates a Trigger that can be used if multiple Conditions are wanted
    The ConditionGroups acts like an &#34;AND&#34; logic for all added conditions

    Parameters
    ----------
        triggeringpoint (str): start or stop (not needed if used with the Trigger class)
            Default: start

    Attributes
    ----------
        triggeringpoint (str): start or stop

        conditions (list of EntityTriggers and Valuetriggers): a list of all conditions

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_condition(condition)
            Adds a condition to the ConditionGroup

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalize the ConditionGroup

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;
        self.conditions = []

    def __eq__(self, other):
        if isinstance(other, ConditionGroup):
            if (
                self.conditions == other.conditions
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if len(other.conditiongroups) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0] == self
                ):
                    return True
        elif isinstance(other, EntityTrigger) or isinstance(other, ValueTrigger):
            if len(self.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditions[0] == other
                ):
                    return True

        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ConditionGroup
        Note: if

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            conditiongroup (ConditionGroup): a ConditionGroup object

        &#34;&#34;&#34;

        condgr = ConditionGroup()
        conditions = element.findall(&#34;Condition&#34;)
        for cond in conditions:
            condgr.add_condition(_ConditionFactory().parse_condition(cond))

        return condgr

    def add_condition(self, condition):
        &#34;&#34;&#34;Adds a condition (EntityTrigger or ValueTrigger) to the ConditionGroup

        Parameters
        ----------
            condition (EntityTrigger, or ValueTrigger): a condition to add to the ConditionGroup

        &#34;&#34;&#34;
        if not (
            isinstance(condition, EntityTrigger) or isinstance(condition, ValueTrigger)
        ):
            raise TypeError(&#34;condition input not of type EntityTrigger or ValueTrigger&#34;)
        condition._set_used_by_parent()
        self.conditions.append(condition)
        self._used_by_parent = False
        return self

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition group is added to a Trigger&#34;&#34;&#34;
        self._used_by_parent = True

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ConditionGroup&#34;&#34;&#34;
        if not self.conditions:
            raise ValueError(&#34;No conditions were added to the ConditionGroup&#34;)
        condgroup = ET.Element(&#34;ConditionGroup&#34;)

        for c in self.conditions:
            condgroup.append(c.get_element())

        if self._used_by_parent:
            return condgroup
        else:
            # could create a new Trigger here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            element.append(condgroup)
            return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._TriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ConditionGroup.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ConditionGroup
Note: if</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>conditiongroup (ConditionGroup): a ConditionGroup object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ConditionGroup
    Note: if

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        conditiongroup (ConditionGroup): a ConditionGroup object

    &#34;&#34;&#34;

    condgr = ConditionGroup()
    conditions = element.findall(&#34;Condition&#34;)
    for cond in conditions:
        condgr.add_condition(_ConditionFactory().parse_condition(cond))

    return condgr</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ConditionGroup.add_condition"><code class="name flex">
<span>def <span class="ident">add_condition</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a condition (EntityTrigger or ValueTrigger) to the ConditionGroup</p>
<h2 id="parameters">Parameters</h2>
<pre><code>condition (EntityTrigger, or ValueTrigger): a condition to add to the ConditionGroup
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_condition(self, condition):
    &#34;&#34;&#34;Adds a condition (EntityTrigger or ValueTrigger) to the ConditionGroup

    Parameters
    ----------
        condition (EntityTrigger, or ValueTrigger): a condition to add to the ConditionGroup

    &#34;&#34;&#34;
    if not (
        isinstance(condition, EntityTrigger) or isinstance(condition, ValueTrigger)
    ):
        raise TypeError(&#34;condition input not of type EntityTrigger or ValueTrigger&#34;)
    condition._set_used_by_parent()
    self.conditions.append(condition)
    self._used_by_parent = False
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.ConditionGroup.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ConditionGroup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ConditionGroup&#34;&#34;&#34;
    if not self.conditions:
        raise ValueError(&#34;No conditions were added to the ConditionGroup&#34;)
    condgroup = ET.Element(&#34;ConditionGroup&#34;)

    for c in self.conditions:
        condgroup.append(c.get_element())

    if self._used_by_parent:
        return condgroup
    else:
        # could create a new Trigger here, but went with this solution for now
        element = ET.Element(self._triggerpoint)
        element.append(condgroup)
        return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.DistanceCondition"><code class="flex name class">
<span>class <span class="ident">DistanceCondition</span></span>
<span>(</span><span>value, rule, position, alongroute=True, freespace=True, distance_type=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>the DistanceCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): distance to position

rule (Rule): condition rule of triggering

position (*Position): any position to reach

alongroute (bool): if the route should count (depricated in V.1.0)
    Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
    Default: RelativeDistanceType.longitudinal

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
    Default: CoordinateSystem.road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): distance to position

rule (Rule): condition rule of triggering

position (*Position): any position to reach

alongroute (bool): if the route should count

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

distance_type (RelativeDistanceType): how the relative distance should be calculated

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the DistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        position (*Position): any position to reach

        alongroute (bool): if the route should count (depricated in V.1.0)
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road

    Attributes
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        position (*Position): any position to reach

        alongroute (bool): if the route should count

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        distance_type (RelativeDistanceType): how the relative distance should be calculated

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        position,
        alongroute=True,
        freespace=True,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        self.value = value
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        if not (isinstance(position, _PositionType)):
            raise TypeError(&#34;position input is not a valid Position&#34;)
        self.position = position
        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, DistanceCondition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of DistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (DistanceCondition): a DistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;DistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        position = None

        position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
        return DistanceCondition(
            value, rule, position, alongroute, freespace, reldisttype, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DistanceCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)

        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name

        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the DistanceCondition&#34;&#34;&#34;

        element = ET.Element(&#34;EntityCondition&#34;)
        distancecond = ET.SubElement(
            element, &#34;DistanceCondition&#34;, attrib=self.get_attributes()
        )
        distancecond.append(self.position.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.DistanceCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of DistanceCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (DistanceCondition): a DistanceCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of DistanceCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (DistanceCondition): a DistanceCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;DistanceCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
    if &#34;alongRoute&#34; in condition.attrib:
        alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
    else:
        alongroute = True

    if &#34;relativeDistanceType&#34; in condition.attrib:
        reldisttype = getattr(
            RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
        )
    else:
        reldisttype = RelativeDistanceType.longitudinal

    if &#34;coordinateSystem&#34; in condition.attrib:
        coordsystem = getattr(
            CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
        )
    else:
        coordsystem = CoordinateSystem.road
    position = None

    position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
    return DistanceCondition(
        value, rule, position, alongroute, freespace, reldisttype, coordsystem
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.DistanceCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the DistanceCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the DistanceCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)

    basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    if self.isVersion(minor=0):
        basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
    else:
        basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
        basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name

    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.DistanceCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the DistanceCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the DistanceCondition&#34;&#34;&#34;

    element = ET.Element(&#34;EntityCondition&#34;)
    distancecond = ET.SubElement(
        element, &#34;DistanceCondition&#34;, attrib=self.get_attributes()
    )
    distancecond.append(self.position.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.EmptyTrigger"><code class="flex name class">
<span>class <span class="ident">EmptyTrigger</span></span>
<span>(</span><span>triggeringpoint='start')</span>
</code></dt>
<dd>
<div class="desc"><p>EmptyTrigger creates an empty trigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop
</code></pre>
<h2 id="attributes">Attributes</h2>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the emtpy trigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyTrigger(_TriggerType):
    &#34;&#34;&#34;EmptyTrigger creates an empty trigger

    Parameters
    ----------
        triggeringpoint (str): start or stop

    Attributes
    ----------

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalizes the emtpy trigger

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

    def __eq__(self, other):
        if isinstance(other, EmptyTrigger):
            if self._triggerpoint == other._triggerpoint:
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 0
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
        return ET.Element(self._triggerpoint)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._TriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.EmptyTrigger.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Trigger</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
    return ET.Element(self._triggerpoint)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.EndOfRoadCondition"><code class="flex name class">
<span>class <span class="ident">EndOfRoadCondition</span></span>
<span>(</span><span>duration)</span>
</code></dt>
<dd>
<div class="desc"><p>the EndOfRoadCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>duration (float): the duration at the en of road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>duration (float): the duration at the en of road
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the EndOfRoadCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>duration (float): the duration after the condition
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EndOfRoadCondition(_EntityTriggerType):
    &#34;&#34;&#34;the EndOfRoadCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): the duration at the en of road

    Attributes
    ----------
        duration (float): the duration at the en of road

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;initalize the EndOfRoadCondition

        Parameters
        ----------
            duration (float): the duration after the condition

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, EndOfRoadCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of EndOfRoadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (EndOfRoadCondition): a EndOfRoadCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;EndOfRoadCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return EndOfRoadCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the EndOfRoadCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the EndOfRoadCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;EndOfRoadCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.EndOfRoadCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of EndOfRoadCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (EndOfRoadCondition): a EndOfRoadCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of EndOfRoadCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (EndOfRoadCondition): a EndOfRoadCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;EndOfRoadCondition&#34;)
    duration = condition.attrib[&#34;duration&#34;]
    return EndOfRoadCondition(duration)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.EndOfRoadCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the EndOfRoadCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the EndOfRoadCondition as a dict&#34;&#34;&#34;
    return {&#34;duration&#34;: str(self.duration)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.EndOfRoadCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the EndOfRoadCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the EndOfRoadCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;EndOfRoadCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.EntityTrigger"><code class="flex name class">
<span>class <span class="ident">EntityTrigger</span></span>
<span>(</span><span>name, delay, conditionedge, entitycondition, triggerentity, triggeringrule=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, triggeringpoint='start')</span>
</code></dt>
<dd>
<div class="desc"><p>the EntityTrigger creates an Trigger containing an EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): on what conditionedge the trigger should act

entitycondotion (*Condition): an entity condition

triggeringentity (str): the entity of the trigger

triggeringrule (TriggeringEntitiesRule): rule of the trigger
    Default: 'any'

triggeringpoint (str): start or stop
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): the condition edge

entitycondition (*EntityCondition): the entitycondition

triggerentity (TriggeringEntities): the triggering entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): on what conditionedge the trigger should act

entitycondotion (*EntityCondition): an entity condition

triggeringentity (str): the entity of the trigger

triggeringrule (TriggeringEntitiesRule): rule of the trigger
    Default: 'any'

triggeringpoint (str): start or stop
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntityTrigger(_TriggerType):
    &#34;&#34;&#34;the EntityTrigger creates an Trigger containing an EntityTrigger

    Parameters
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): on what conditionedge the trigger should act

        entitycondotion (*Condition): an entity condition

        triggeringentity (str): the entity of the trigger

        triggeringrule (TriggeringEntitiesRule): rule of the trigger
            Default: &#39;any&#39;

        triggeringpoint (str): start or stop

    Attributes
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): the condition edge

        entitycondition (*EntityCondition): the entitycondition

        triggerentity (TriggeringEntities): the triggering entity

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        name,
        delay,
        conditionedge,
        entitycondition,
        triggerentity,
        triggeringrule=TriggeringEntitiesRule.any,
        triggeringpoint=&#34;start&#34;,
    ):
        &#34;&#34;&#34;initalize the EntityTrigger

        Parameters
        ----------
            name (str): name of the trigger

            delay (float): the delay of the trigger

            conditionedge (ConditionEdge): on what conditionedge the trigger should act

            entitycondotion (*EntityCondition): an entity condition

            triggeringentity (str): the entity of the trigger

            triggeringrule (TriggeringEntitiesRule): rule of the trigger
                Default: &#39;any&#39;

            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        self.name = name
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

        self.delay = delay
        if not hasattr(ConditionEdge, str(conditionedge)):
            raise ValueError(&#34;not a valid condition edge&#34;)
        self.conditionedge = conditionedge
        if not isinstance(entitycondition, _EntityTriggerType):
            raise TypeError(&#34;entitycondition is not a valid EntityCondition&#34;)
        self.entitycondition = entitycondition
        self.triggerentity = TriggeringEntities(triggeringrule)
        self.triggerentity.add_entity(triggerentity)

        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, EntityTrigger):
            if (
                self.get_attributes() == other.get_attributes()
                and self.triggerentity == other.triggerentity
                and self.entitycondition == other.entitycondition
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 1
                and len(other.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0].conditions[0] == self
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(other.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditions[0] == self
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of EntityTrigger
        NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (EntityTrigger): a EntityTrigger object

        &#34;&#34;&#34;
        if element.tag != &#34;Condition&#34;:
            raise NotAValidElement(
                &#34;ValueTrigger only parses a Condition, not &#34;, element
            )

        name = element.attrib[&#34;name&#34;]
        delay = element.attrib[&#34;delay&#34;]
        conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
        entityconditionelement = element.find(&#34;ByEntityCondition&#34;)
        triggering_entities = TriggeringEntities.parse(
            entityconditionelement.find(&#34;TriggeringEntities&#34;)
        )
        condition = _EntityConditionFactory.parse_entity_condition(
            entityconditionelement.find(&#34;EntityCondition&#34;)
        )
        enttrig = EntityTrigger(name, delay, conditionedge, condition, &#34;&#34;)
        enttrig.triggerentity = triggering_entities

        return enttrig

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition is added to a ConditionGroup&#34;&#34;&#34;
        self._used_by_parent = True

    def add_triggering_entity(self, triggerentity):
        &#34;&#34;&#34;adds additional triggering entities to a trigger

        Parameters
        ----------
            triggeringentity (str)
        &#34;&#34;&#34;
        self.triggerentity.add_entity(triggerentity)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;delay&#34;: str(self.delay),
            &#34;conditionEdge&#34;: self.conditionedge.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
        byentity = ET.SubElement(condition, &#34;ByEntityCondition&#34;)
        byentity.append(self.triggerentity.get_element())
        byentity.append(self.entitycondition.get_element())

        if self._used_by_parent:
            return condition
        else:
            # could create a new Trigger ConditionGroup here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
            condgroup.append(condition)
            return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._TriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.EntityTrigger.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of EntityTrigger
NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (EntityTrigger): a EntityTrigger object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of EntityTrigger
    NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (EntityTrigger): a EntityTrigger object

    &#34;&#34;&#34;
    if element.tag != &#34;Condition&#34;:
        raise NotAValidElement(
            &#34;ValueTrigger only parses a Condition, not &#34;, element
        )

    name = element.attrib[&#34;name&#34;]
    delay = element.attrib[&#34;delay&#34;]
    conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
    entityconditionelement = element.find(&#34;ByEntityCondition&#34;)
    triggering_entities = TriggeringEntities.parse(
        entityconditionelement.find(&#34;TriggeringEntities&#34;)
    )
    condition = _EntityConditionFactory.parse_entity_condition(
        entityconditionelement.find(&#34;EntityCondition&#34;)
    )
    enttrig = EntityTrigger(name, delay, conditionedge, condition, &#34;&#34;)
    enttrig.triggerentity = triggering_entities

    return enttrig</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.EntityTrigger.add_triggering_entity"><code class="name flex">
<span>def <span class="ident">add_triggering_entity</span></span>(<span>self, triggerentity)</span>
</code></dt>
<dd>
<div class="desc"><p>adds additional triggering entities to a trigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>triggeringentity (str)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_triggering_entity(self, triggerentity):
    &#34;&#34;&#34;adds additional triggering entities to a trigger

    Parameters
    ----------
        triggeringentity (str)
    &#34;&#34;&#34;
    self.triggerentity.add_entity(triggerentity)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.EntityTrigger.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;delay&#34;: str(self.delay),
        &#34;conditionEdge&#34;: self.conditionedge.get_name(),
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.EntityTrigger.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
    condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
    byentity = ET.SubElement(condition, &#34;ByEntityCondition&#34;)
    byentity.append(self.triggerentity.get_element())
    byentity.append(self.entitycondition.get_element())

    if self._used_by_parent:
        return condition
    else:
        # could create a new Trigger ConditionGroup here, but went with this solution for now
        element = ET.Element(self._triggerpoint)
        condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
        condgroup.append(condition)
        return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.OffroadCondition"><code class="flex name class">
<span>class <span class="ident">OffroadCondition</span></span>
<span>(</span><span>duration)</span>
</code></dt>
<dd>
<div class="desc"><p>the OffroadCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>duration (float): the duration of offroad
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>duration (float): the duration of offroad
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the OffroadCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>duration (float): the duration of offroad
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OffroadCondition(_EntityTriggerType):
    &#34;&#34;&#34;the OffroadCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): the duration of offroad

    Attributes
    ----------
        duration (float): the duration of offroad

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;initalize the OffroadCondition

        Parameters
        ----------
            duration (float): the duration of offroad

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, OffroadCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of OffroadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (OffroadCondition): a OffroadCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;OffroadCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return OffroadCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the OffroadCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the OffroadCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;OffroadCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.OffroadCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of OffroadCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (OffroadCondition): a OffroadCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of OffroadCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (OffroadCondition): a OffroadCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;OffroadCondition&#34;)
    duration = condition.attrib[&#34;duration&#34;]
    return OffroadCondition(duration)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.OffroadCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the OffroadCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the OffroadCondition as a dict&#34;&#34;&#34;
    return {&#34;duration&#34;: str(self.duration)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.OffroadCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the OffroadCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the OffroadCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;OffroadCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.ParameterCondition"><code class="flex name class">
<span>class <span class="ident">ParameterCondition</span></span>
<span>(</span><span>parameter, value, rule)</span>
</code></dt>
<dd>
<div class="desc"><p>the ParameterCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter (str): the parameter to trigger on

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter (str): the parameter to trigger on

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameter (str): the parameter to trigger on

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterCondition(_ValueTriggerType):
    &#34;&#34;&#34;the ParameterCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        parameter (str): the parameter to trigger on

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        parameter (str): the parameter to trigger on

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, parameter, value, rule):
        &#34;&#34;&#34;initalize the ParameterCondition

        Parameters
        ----------
            parameter (str): the parameter to trigger on

            value (int): value to trigger on

            rule (Rule): condition rule of triggering

        &#34;&#34;&#34;
        self.parameter = parameter
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, ParameterCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ParameterCondition): a ParameterCondition object

        &#34;&#34;&#34;
        parameter = element.attrib[&#34;parameterRef&#34;]
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return ParameterCondition(parameter, value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterCondition as a dict&#34;&#34;&#34;
        basedict = {&#34;parameterRef&#34;: self.parameter, &#34;value&#34;: str(self.value)}
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterCondition&#34;&#34;&#34;
        return ET.Element(&#34;ParameterCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ParameterCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (ParameterCondition): a ParameterCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (ParameterCondition): a ParameterCondition object

    &#34;&#34;&#34;
    parameter = element.attrib[&#34;parameterRef&#34;]
    value = element.attrib[&#34;value&#34;]
    rule = getattr(Rule, element.attrib[&#34;rule&#34;])
    return ParameterCondition(parameter, value, rule)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ParameterCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ParameterCondition as a dict&#34;&#34;&#34;
    basedict = {&#34;parameterRef&#34;: self.parameter, &#34;value&#34;: str(self.value)}
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.ParameterCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterCondition&#34;&#34;&#34;
    return ET.Element(&#34;ParameterCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.ReachPositionCondition"><code class="flex name class">
<span>class <span class="ident">ReachPositionCondition</span></span>
<span>(</span><span>position, tolerance)</span>
</code></dt>
<dd>
<div class="desc"><p>the ReachPositionCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): any position to reach

tolerance (float): tolerance of the position
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>position (*Position): any position to reach

tolerance (float): tolerance of the position
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ReachPositionCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>position (*Position): any position to reach

tolerance (float): tolerance of the position
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReachPositionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the ReachPositionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        position (*Position): any position to reach

        tolerance (float): tolerance of the position

    Attributes
    ----------
        position (*Position): any position to reach

        tolerance (float): tolerance of the position

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, position, tolerance):
        &#34;&#34;&#34;initalize the ReachPositionCondition

        Parameters
        ----------
            position (*Position): any position to reach

            tolerance (float): tolerance of the position

        &#34;&#34;&#34;
        if not (isinstance(position, _PositionType)):
            raise TypeError(&#34;position input is not a valid Position&#34;)
        self.position = position
        self.tolerance = tolerance

    def __eq__(self, other):
        if isinstance(other, ReachPositionCondition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ReachPositionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ReachPositionCondition): a ReachPositionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;ReachPositionCondition&#34;)
        tolerance = condition.attrib[&#34;tolerance&#34;]
        position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
        return ReachPositionCondition(position, tolerance)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ReachPositionCondition as a dict&#34;&#34;&#34;
        return {&#34;tolerance&#34;: str(self.tolerance)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ReachPositionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        reachposcond = ET.SubElement(
            element, &#34;ReachPositionCondition&#34;, attrib=self.get_attributes()
        )
        reachposcond.append(self.position.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ReachPositionCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ReachPositionCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (ReachPositionCondition): a ReachPositionCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ReachPositionCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (ReachPositionCondition): a ReachPositionCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;ReachPositionCondition&#34;)
    tolerance = condition.attrib[&#34;tolerance&#34;]
    position = _PositionFactory.parse_position(condition.find(&#34;Position&#34;))
    return ReachPositionCondition(position, tolerance)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ReachPositionCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ReachPositionCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ReachPositionCondition as a dict&#34;&#34;&#34;
    return {&#34;tolerance&#34;: str(self.tolerance)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.ReachPositionCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ReachPositionCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ReachPositionCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    reachposcond = ET.SubElement(
        element, &#34;ReachPositionCondition&#34;, attrib=self.get_attributes()
    )
    reachposcond.append(self.position.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.RelativeDistanceCondition"><code class="flex name class">
<span>class <span class="ident">RelativeDistanceCondition</span></span>
<span>(</span><span>value, rule, dist_type, entity, alongroute=True, freespace=True, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeDistanceCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): distance to position

rule (Rule): condition rule of triggering

dist_type (RelativeDistanceType): type of relative distance

entity (str): name of the entity fore relative distance

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
    Default: CoordinateSystem.entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): distance to position

rule (Rule): condition rule of triggering

entity (str): name of the entity fore relative distance

dist_type (RelativeDistanceType): type of relative distance

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the RelativeDistanceCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): distance to position

rule (Rule): condition rule of triggering

dist_type (RelativeDistanceType): type of relative distance

entity (str): name of the entity fore relative distance

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
    Default: CoordinateSystem.entity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeDistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the RelativeDistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        dist_type (RelativeDistanceType): type of relative distance

        entity (str): name of the entity fore relative distance

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
            Default: CoordinateSystem.entity

    Attributes
    ----------
        value (float): distance to position

        rule (Rule): condition rule of triggering

        entity (str): name of the entity fore relative distance

        dist_type (RelativeDistanceType): type of relative distance

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        dist_type,
        entity,
        alongroute=True,
        freespace=True,
        coordinate_system=CoordinateSystem.entity,
    ):
        &#34;&#34;&#34;initalize the RelativeDistanceCondition

        Parameters
        ----------
            value (float): distance to position

            rule (Rule): condition rule of triggering

            dist_type (RelativeDistanceType): type of relative distance

            entity (str): name of the entity fore relative distance

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            coordinate_system (CoordinateSystem): what coordinate system to use (valid from V1.1)
                Default: CoordinateSystem.entity
        &#34;&#34;&#34;
        self.value = value
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(RelativeDistanceType, str(dist_type)):
            raise TypeError(&#34;dist_type is not of type RelativeDistanceType&#34;)
        self.dist_type = dist_type
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.entity = entity
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, RelativeDistanceCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeDistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (RelativeDistanceCondition): a RelativeDistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;RelativeDistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        entity = condition.attrib[&#34;entityRef&#34;]
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road

        return RelativeDistanceCondition(
            value, rule, reldisttype, entity, alongroute, freespace, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeDistanceCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;entityRef&#34;] = self.entity
        basedict[&#34;rule&#34;] = self.rule.get_name()
        basedict[&#34;relativeDistanceType&#34;] = self.dist_type.get_name()
        if not self.isVersion(minor=0):
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeDistanceCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(
            element, &#34;RelativeDistanceCondition&#34;, attrib=self.get_attributes()
        )
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.RelativeDistanceCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of RelativeDistanceCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (RelativeDistanceCondition): a RelativeDistanceCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of RelativeDistanceCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (RelativeDistanceCondition): a RelativeDistanceCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;RelativeDistanceCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
    entity = condition.attrib[&#34;entityRef&#34;]
    if &#34;alongRoute&#34; in condition.attrib:
        alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
    else:
        alongroute = True

    if &#34;relativeDistanceType&#34; in condition.attrib:
        reldisttype = getattr(
            RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
        )
    else:
        reldisttype = RelativeDistanceType.longitudinal

    if &#34;coordinateSystem&#34; in condition.attrib:
        coordsystem = getattr(
            CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
        )
    else:
        coordsystem = CoordinateSystem.road

    return RelativeDistanceCondition(
        value, rule, reldisttype, entity, alongroute, freespace, coordsystem
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeDistanceCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeDistanceCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)
    basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
    basedict[&#34;entityRef&#34;] = self.entity
    basedict[&#34;rule&#34;] = self.rule.get_name()
    basedict[&#34;relativeDistanceType&#34;] = self.dist_type.get_name()
    if not self.isVersion(minor=0):
        basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeDistanceCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeDistanceCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(
        element, &#34;RelativeDistanceCondition&#34;, attrib=self.get_attributes()
    )
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.RelativeSpeedCondition"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedCondition</span></span>
<span>(</span><span>value, rule, entity)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeSpeedCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering

entity (str): name of the entity to be relative to
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering

entity (str): name of the entity to be relative to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the RelativeSpeedCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): acceleration

rule (Rule): condition rule of triggering

entity (str): name of the entity to be relative to
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedCondition(_EntityTriggerType):
    &#34;&#34;&#34;the RelativeSpeedCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

        entity (str): name of the entity to be relative to

    Attributes
    ----------
        value (float): acceleration

        rule (Rule): condition rule of triggering

        entity (str): name of the entity to be relative to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule, entity):
        &#34;&#34;&#34;initalize the RelativeSpeedCondition

        Parameters
        ----------
            value (float): acceleration

            rule (Rule): condition rule of triggering

            entity (str): name of the entity to be relative to

        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, RelativeSpeedCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeSpeedCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (RelativeSpeedCondition): a RelativeSpeedCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;RelativeSpeedCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        entity = condition.attrib[&#34;entityRef&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return RelativeSpeedCondition(value, rule, entity)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeSpeedCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        basedict[&#34;entityRef&#34;] = self.entity
        return basedict
        # return merge_dicts({&#39;value&#39;:str(self.value),&#39;entityRef&#39;:self.entity},self.rule.get_attributes())

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeSpeedCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;RelativeSpeedCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.RelativeSpeedCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of RelativeSpeedCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (RelativeSpeedCondition): a RelativeSpeedCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of RelativeSpeedCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (RelativeSpeedCondition): a RelativeSpeedCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;RelativeSpeedCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    entity = condition.attrib[&#34;entityRef&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    return RelativeSpeedCondition(value, rule, entity)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeSpeedCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeSpeedCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    basedict[&#34;entityRef&#34;] = self.entity
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeSpeedCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeSpeedCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;RelativeSpeedCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.SimulationTimeCondition"><code class="flex name class">
<span>class <span class="ident">SimulationTimeCondition</span></span>
<span>(</span><span>value, rule)</span>
</code></dt>
<dd>
<div class="desc"><p>the SimulationTimeCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (int): simulation time

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (int): simulation time

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the SimulationTimeCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (int): simulation time

rule (Rule): condition rule of triggering
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimulationTimeCondition(_ValueTriggerType):
    &#34;&#34;&#34;the SimulationTimeCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        value (int): simulation time

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (int): simulation time

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;initalize the SimulationTimeCondition

        Parameters
        ----------
            value (int): simulation time

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, SimulationTimeCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SimulationTimeCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (SimulationTimeCondition): a SimulationTimeCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;SimulationTimeCondition&#34;)
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return SimulationTimeCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SimulationTimeCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SimulationTimeCondition&#34;&#34;&#34;
        return ET.Element(&#34;SimulationTimeCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.SimulationTimeCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of SimulationTimeCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (SimulationTimeCondition): a SimulationTimeCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of SimulationTimeCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (SimulationTimeCondition): a SimulationTimeCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;SimulationTimeCondition&#34;)
    value = element.attrib[&#34;value&#34;]
    rule = getattr(Rule, element.attrib[&#34;rule&#34;])
    return SimulationTimeCondition(value, rule)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.SimulationTimeCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the SimulationTimeCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the SimulationTimeCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.SimulationTimeCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the SimulationTimeCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the SimulationTimeCondition&#34;&#34;&#34;
    return ET.Element(&#34;SimulationTimeCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.SpeedCondition"><code class="flex name class">
<span>class <span class="ident">SpeedCondition</span></span>
<span>(</span><span>value, rule)</span>
</code></dt>
<dd>
<div class="desc"><p>the SpeedCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): speed to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): speed to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the SpeedCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): speed to trigger on

rule (Rule): condition rule of triggering
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpeedCondition(_EntityTriggerType):
    &#34;&#34;&#34;the SpeedCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): speed to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        value (float): speed to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, rule):
        &#34;&#34;&#34;initalize the SpeedCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): speed to trigger on

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, SpeedCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SpeedCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (SpeedCondition): a SpeedCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;SpeedCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        return SpeedCondition(value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SpeedCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict
        # return merge_dicts({&#39;value&#39;:str(self.value)},self.rule.get_attributes())

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SpeedCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;SpeedCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.SpeedCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of SpeedCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (SpeedCondition): a SpeedCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of SpeedCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (SpeedCondition): a SpeedCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;SpeedCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    return SpeedCondition(value, rule)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.SpeedCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the SpeedCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the SpeedCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.SpeedCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the SpeedCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the SpeedCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;SpeedCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.StandStillCondition"><code class="flex name class">
<span>class <span class="ident">StandStillCondition</span></span>
<span>(</span><span>duration)</span>
</code></dt>
<dd>
<div class="desc"><p>the StandStillCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>duration (float): time of standstill
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>duration (float): time of standstill
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>the StandStillCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>duration (float): time of standstill
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StandStillCondition(_EntityTriggerType):
    &#34;&#34;&#34;the StandStillCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        duration (float): time of standstill

    Attributes
    ----------
        duration (float): time of standstill

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, duration):
        &#34;&#34;&#34;the StandStillCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            duration (float): time of standstill

        &#34;&#34;&#34;
        self.duration = duration

    def __eq__(self, other):
        if isinstance(other, StandStillCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of StandStillCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (StandStillCondition): a StandStillCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;StandStillCondition&#34;)
        duration = condition.attrib[&#34;duration&#34;]
        return StandStillCondition(duration)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the StandStillCondition as a dict&#34;&#34;&#34;
        return {&#34;duration&#34;: str(self.duration)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the StandStillCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;StandStillCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.StandStillCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of StandStillCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (StandStillCondition): a StandStillCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of StandStillCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (StandStillCondition): a StandStillCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;StandStillCondition&#34;)
    duration = condition.attrib[&#34;duration&#34;]
    return StandStillCondition(duration)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.StandStillCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the StandStillCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the StandStillCondition as a dict&#34;&#34;&#34;
    return {&#34;duration&#34;: str(self.duration)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.StandStillCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the StandStillCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the StandStillCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;StandStillCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.StoryboardElementStateCondition"><code class="flex name class">
<span>class <span class="ident">StoryboardElementStateCondition</span></span>
<span>(</span><span>element, reference, state)</span>
</code></dt>
<dd>
<div class="desc"><p>the StoryboardElementStateCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (StoryboardElementType): the element to trigger on

reference (str): reference of the parameter

state (StoryboardElementState): state to trigger on
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>element (StoryboardElementType): the element to trigger on

reference (str): reference of the parameter

state (StoryboardElementState): state to trigger on
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the StoryboardElementStateCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>element (StoryboardElementType): the element to trigger on

reference (str): reference of the parameter

state (StoryBoardElementState): state to trigger on
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoryboardElementStateCondition(_ValueTriggerType):
    &#34;&#34;&#34;the StoryboardElementStateCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        element (StoryboardElementType): the element to trigger on

        reference (str): reference of the parameter

        state (StoryboardElementState): state to trigger on

    Attributes
    ----------
        element (StoryboardElementType): the element to trigger on

        reference (str): reference of the parameter

        state (StoryboardElementState): state to trigger on

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, element, reference, state):
        &#34;&#34;&#34;initalize the StoryboardElementStateCondition

        Parameters
        ----------
            element (StoryboardElementType): the element to trigger on

            reference (str): reference of the parameter

            state (StoryBoardElementState): state to trigger on
        &#34;&#34;&#34;
        if not hasattr(StoryboardElementType, str(element)):
            raise TypeError(&#34;element input is not of type StoryBoardElementType&#34;)
        if not hasattr(StoryboardElementState, str(state)):
            raise TypeError(&#34;state input is not of type StoryBoardElementState&#34;)
        self.element = element
        self.reference = reference
        self.state = state

    def __eq__(self, other):
        if isinstance(other, StoryboardElementStateCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of StoryboardElementStateCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (StoryboardElementStateCondition): a StoryboardElementStateCondition object

        &#34;&#34;&#34;
        ref = element.attrib[&#34;storyboardElementRef&#34;]
        sbet = getattr(StoryboardElementType, element.attrib[&#34;storyboardElementType&#34;])
        state = getattr(StoryboardElementState, element.attrib[&#34;state&#34;])
        return StoryboardElementStateCondition(sbet, ref, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the StoryboardElementStateCondition as a dict&#34;&#34;&#34;
        return {
            &#34;storyboardElementType&#34;: self.element.get_name(),
            &#34;storyboardElementRef&#34;: self.reference,
            &#34;state&#34;: self.state.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the StoryboardElementStateCondition&#34;&#34;&#34;
        return ET.Element(
            &#34;StoryboardElementStateCondition&#34;, attrib=self.get_attributes()
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of StoryboardElementStateCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (StoryboardElementStateCondition): a StoryboardElementStateCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of StoryboardElementStateCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (StoryboardElementStateCondition): a StoryboardElementStateCondition object

    &#34;&#34;&#34;
    ref = element.attrib[&#34;storyboardElementRef&#34;]
    sbet = getattr(StoryboardElementType, element.attrib[&#34;storyboardElementType&#34;])
    state = getattr(StoryboardElementState, element.attrib[&#34;state&#34;])
    return StoryboardElementStateCondition(sbet, ref, state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the StoryboardElementStateCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the StoryboardElementStateCondition as a dict&#34;&#34;&#34;
    return {
        &#34;storyboardElementType&#34;: self.element.get_name(),
        &#34;storyboardElementRef&#34;: self.reference,
        &#34;state&#34;: self.state.get_name(),
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the StoryboardElementStateCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the StoryboardElementStateCondition&#34;&#34;&#34;
    return ET.Element(
        &#34;StoryboardElementStateCondition&#34;, attrib=self.get_attributes()
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeHeadwayCondition"><code class="flex name class">
<span>class <span class="ident">TimeHeadwayCondition</span></span>
<span>(</span><span>entity, value, rule, alongroute=True, freespace=True, distance_type=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>the TimeHeadwayCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): name of the entity for the headway

value (float): time of headway

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count
    Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
    Default: RelativeDistanceType.longitudinal

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
    Default: CoordinateSystem.road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): name of the entity for the headway

value (float): time of headway

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeHeadwayCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): name of the entity for the headway

value (float): time of headway

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count
    Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
    Default: RelativeDistanceType.longitudinal

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
    Default: CoordinateSystem.road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeHeadwayCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TimeHeadwayCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        entity (str): name of the entity for the headway

        value (float): time of headway

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road
    Attributes
    ----------
        entity (str): name of the entity for the headway

        value (float): time of headway

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        value,
        rule,
        alongroute=True,
        freespace=True,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        &#34;&#34;&#34;initalize the TimeHeadwayCondition

        Parameters
        ----------
            entity (str): name of the entity for the headway

            value (float): time of headway

            rule (Rule): condition rule of triggering

            alongroute (bool): if the route should count
                Default: True

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
                Default: RelativeDistanceType.longitudinal

            coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
                Default: CoordinateSystem.road
        &#34;&#34;&#34;
        self.entity = entity
        self.value = value
        if not isinstance(alongroute, bool):
            raise TypeError(&#34;alongroute input not of type bool&#34;)
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.alongroute = alongroute
        self.freespace = freespace
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, TimeHeadwayCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeHeadwayCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeHeadwayCondition): a TimeHeadwayCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TimeHeadwayCondition&#34;)
        entity = condition.attrib[&#34;entityRef&#34;]
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])

        return TimeHeadwayCondition(
            entity, value, rule, alongroute, freespace, reldisttype, coordsystem
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeHeadwayCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;entityRef&#34;] = self.entity
        basedict[&#34;value&#34;] = str(self.value)
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.get_name()
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeHeadwayCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(element, &#34;TimeHeadwayCondition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeHeadwayCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TimeHeadwayCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TimeHeadwayCondition): a TimeHeadwayCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TimeHeadwayCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TimeHeadwayCondition): a TimeHeadwayCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;TimeHeadwayCondition&#34;)
    entity = condition.attrib[&#34;entityRef&#34;]
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    if &#34;alongRoute&#34; in condition.attrib:
        alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
    else:
        alongroute = True

    if &#34;relativeDistanceType&#34; in condition.attrib:
        reldisttype = getattr(
            RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
        )
    else:
        reldisttype = RelativeDistanceType.longitudinal

    if &#34;coordinateSystem&#34; in condition.attrib:
        coordsystem = getattr(
            CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
        )
    else:
        coordsystem = CoordinateSystem.road
    freespace = convert_bool(condition.attrib[&#34;freespace&#34;])

    return TimeHeadwayCondition(
        entity, value, rule, alongroute, freespace, reldisttype, coordsystem
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TimeHeadwayCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TimeHeadwayCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;entityRef&#34;] = self.entity
    basedict[&#34;value&#34;] = str(self.value)
    if self.isVersion(minor=0):
        basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
    else:
        basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.get_name()
        basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
    basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TimeHeadwayCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TimeHeadwayCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(element, &#34;TimeHeadwayCondition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeOfDayCondition"><code class="flex name class">
<span>class <span class="ident">TimeOfDayCondition</span></span>
<span>(</span><span>rule, datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>the TimeOfDayCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rule (Rule): condition rule of triggering

time of day (str): datetime ??? format unknown
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rule (Rule): condition rule of triggering

time of day (str): datetime ??? format unknown
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeOfDayCondition
Parameters</p>
<hr>
<pre><code>rule (Rule): condition rule of triggering

time of day (str): datetime ??? format unknown
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeOfDayCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TimeOfDayCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        rule (Rule): condition rule of triggering

        time of day (str): datetime ??? format unknown

    Attributes
    ----------
        rule (Rule): condition rule of triggering

        time of day (str): datetime ??? format unknown

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, rule, datetime):
        &#34;&#34;&#34;initalize the TimeOfDayCondition
        Parameters
        ----------
            rule (Rule): condition rule of triggering

            time of day (str): datetime ??? format unknown

        &#34;&#34;&#34;
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.datetime = datetime

    def __eq__(self, other):
        if isinstance(other, TimeOfDayCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeOfDayCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeOfDayCondition): a TimeOfDayCondition object

        &#34;&#34;&#34;

        datetime = element.attrib[&#34;datetime&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return TimeOfDayCondition(rule, datetime)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeOfDayCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;datetime&#34;] = self.datetime
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeOfDayCondition&#34;&#34;&#34;
        return ET.Element(&#34;TimeOfDayCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeOfDayCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TimeOfDayCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TimeOfDayCondition): a TimeOfDayCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TimeOfDayCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TimeOfDayCondition): a TimeOfDayCondition object

    &#34;&#34;&#34;

    datetime = element.attrib[&#34;datetime&#34;]
    rule = getattr(Rule, element.attrib[&#34;rule&#34;])
    return TimeOfDayCondition(rule, datetime)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeOfDayCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TimeOfDayCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TimeOfDayCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;datetime&#34;] = self.datetime
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeOfDayCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TimeOfDayCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TimeOfDayCondition&#34;&#34;&#34;
    return ET.Element(&#34;TimeOfDayCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeToCollisionCondition"><code class="flex name class">
<span>class <span class="ident">TimeToCollisionCondition</span></span>
<span>(</span><span>value, rule, alongroute=True, freespace=True, entity=None, position=None, distance_type=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>the TimeToCollisionCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): time to collision

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count
    Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

optionals:
    entity (str): the entity to trigger collision on

    position (*Position): a position for collision

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
    Default: RelativeDistanceType.longitudinal

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
    Default: CoordinateSystem.road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): time before collision

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count
Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
Default: True
optionals:
    entity (EntityRef):  entity for the collision

    position (*Position): a position for collision

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeToCollisionCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): time to collision

rule (Rule): condition rule of triggering

alongroute (bool): if the route should count
    Default: True

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

optionals:
    entity (str): the entity to trigger collision on

    position (*Position): a position for collision

distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
    Default: RelativeDistanceType.longitudinal

coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
    Default: CoordinateSystem.road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeToCollisionCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TimeToCollisionCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------

        value (float): time to collision

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
            Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        optionals:
            entity (str): the entity to trigger collision on

            position (*Position): a position for collision

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
            Default: RelativeDistanceType.longitudinal

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
            Default: CoordinateSystem.road

    Attributes
    ----------
        value (float): time before collision

        rule (Rule): condition rule of triggering

        alongroute (bool): if the route should count
        Default: True

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
        Default: True
        optionals:
            entity (EntityRef):  entity for the collision

            position (*Position): a position for collision

        distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)

        coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        value,
        rule,
        alongroute=True,
        freespace=True,
        entity=None,
        position=None,
        distance_type=RelativeDistanceType.longitudinal,
        coordinate_system=CoordinateSystem.road,
    ):
        &#34;&#34;&#34;initalize the TimeToCollisionCondition

        Parameters
        ----------

            value (float): time to collision

            rule (Rule): condition rule of triggering

            alongroute (bool): if the route should count
                Default: True

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            optionals:
                entity (str): the entity to trigger collision on

                position (*Position): a position for collision

            distance_type (RelativeDistanceType): how the relative distance should be calculated (valid from V1.1)
                Default: RelativeDistanceType.longitudinal

            coordinate_system (CoordinateSystem): what coordinate system to use for the relative distance (valid from V1.1)
                Default: CoordinateSystem.road
        &#34;&#34;&#34;
        self.value = value
        if not isinstance(alongroute, bool):
            raise TypeError(&#34;alongroute input not of type bool&#34;)
        if not isinstance(freespace, bool):
            raise TypeError(&#34;freespace input not of type bool&#34;)
        self.freespace = freespace
        self.alongroute = alongroute
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule
        self.use_entity = None
        if (entity != None) and (position != None):
            raise ToManyOptionalArguments(
                &#34;Can only have either entity of position, not both&#34;
            )
        if entity:
            self.entity = EntityRef(entity)
            self.use_entity = True
        if position:
            if not isinstance(position, _PositionType):
                raise TypeError(&#34;input position is not a valid Position&#34;)
            self.position = position
            self.use_entity = False

        if self.use_entity == None:
            raise ValueError(&#34;neither position or entity was set.&#34;)

        if not hasattr(RelativeDistanceType, str(distance_type)):
            raise ValueError(distance_type + &#34;; is not a valid RelativeDistanceType.&#34;)
        if not hasattr(CoordinateSystem, str(coordinate_system)):
            raise ValueError(coordinate_system + &#34;; is not a valid CoordinateSystem.&#34;)
        self.relative_distance_type = distance_type
        self.coordinate_system = coordinate_system

    def __eq__(self, other):
        if isinstance(other, TimeToCollisionCondition):
            if self.get_attributes() == other.get_attributes():
                if (
                    self.use_entity
                    and other.use_entity
                    and self.entity
                    and other.entity
                ) or (
                    not self.use_entity
                    and not other.use_entity
                    and self.position
                    and other.position
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeToCollisionCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TimeToCollisionCondition): a TimeToCollisionCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TimeToCollisionCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
        freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
        if &#34;alongRoute&#34; in condition.attrib:
            alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
        else:
            alongroute = True

        if &#34;relativeDistanceType&#34; in condition.attrib:
            reldisttype = getattr(
                RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
            )
        else:
            reldisttype = RelativeDistanceType.longitudinal

        if &#34;coordinateSystem&#34; in condition.attrib:
            coordsystem = getattr(
                CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
            )
        else:
            coordsystem = CoordinateSystem.road
        entity = None
        position = None
        if condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;) is not None:
            entityref = EntityRef.parse(
                condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;)
            )
            entity = entityref.entity
        elif condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;) is not None:
            position = _PositionFactory.parse_position(
                condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;)
            )
        else:
            raise ValueError(
                &#34;No TimeToCollisionConditionTarget found while parsing TimeToCollisionCondition.&#34;
            )
        return TimeToCollisionCondition(
            value,
            rule,
            alongroute,
            freespace,
            entity,
            position,
            reldisttype,
            coordsystem,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeToCollisionCondition as a dict&#34;&#34;&#34;
        basedict = {}
        basedict[&#34;value&#34;] = str(self.value)
        if self.isVersion(minor=0):
            basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
        else:
            basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
            basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name
        basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeToCollisionCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        collisionevent = ET.SubElement(
            element, &#34;TimeToCollisionCondition&#34;, attrib=self.get_attributes()
        )

        targetelement = ET.SubElement(collisionevent, &#34;TimeToCollisionConditionTarget&#34;)

        if self.use_entity:
            targetelement.append(self.entity.get_element())
        else:
            targetelement.append(self.position.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeToCollisionCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TimeToCollisionCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TimeToCollisionCondition): a TimeToCollisionCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TimeToCollisionCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TimeToCollisionCondition): a TimeToCollisionCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;TimeToCollisionCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    rule = getattr(Rule, condition.attrib[&#34;rule&#34;])
    freespace = convert_bool(condition.attrib[&#34;freespace&#34;])
    if &#34;alongRoute&#34; in condition.attrib:
        alongroute = convert_bool(condition.attrib[&#34;alongRoute&#34;])
    else:
        alongroute = True

    if &#34;relativeDistanceType&#34; in condition.attrib:
        reldisttype = getattr(
            RelativeDistanceType, condition.attrib[&#34;relativeDistanceType&#34;]
        )
    else:
        reldisttype = RelativeDistanceType.longitudinal

    if &#34;coordinateSystem&#34; in condition.attrib:
        coordsystem = getattr(
            CoordinateSystem, condition.attrib[&#34;coordinateSystem&#34;]
        )
    else:
        coordsystem = CoordinateSystem.road
    entity = None
    position = None
    if condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;) is not None:
        entityref = EntityRef.parse(
            condition.find(&#34;TimeToCollisionConditionTarget/EntityRef&#34;)
        )
        entity = entityref.entity
    elif condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;) is not None:
        position = _PositionFactory.parse_position(
            condition.find(&#34;TimeToCollisionConditionTarget/Position&#34;)
        )
    else:
        raise ValueError(
            &#34;No TimeToCollisionConditionTarget found while parsing TimeToCollisionCondition.&#34;
        )
    return TimeToCollisionCondition(
        value,
        rule,
        alongroute,
        freespace,
        entity,
        position,
        reldisttype,
        coordsystem,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TimeToCollisionCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TimeToCollisionCondition as a dict&#34;&#34;&#34;
    basedict = {}
    basedict[&#34;value&#34;] = str(self.value)
    if self.isVersion(minor=0):
        basedict[&#34;alongRoute&#34;] = convert_bool(self.alongroute)
    else:
        basedict[&#34;relativeDistanceType&#34;] = self.relative_distance_type.name
        basedict[&#34;coordinateSystem&#34;] = self.coordinate_system.name
    basedict[&#34;freespace&#34;] = convert_bool(self.freespace)
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TimeToCollisionCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TimeToCollisionCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    collisionevent = ET.SubElement(
        element, &#34;TimeToCollisionCondition&#34;, attrib=self.get_attributes()
    )

    targetelement = ET.SubElement(collisionevent, &#34;TimeToCollisionConditionTarget&#34;)

    if self.use_entity:
        targetelement.append(self.entity.get_element())
    else:
        targetelement.append(self.position.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalCondition"><code class="flex name class">
<span>class <span class="ident">TrafficSignalCondition</span></span>
<span>(</span><span>name, state)</span>
</code></dt>
<dd>
<div class="desc"><p>the TrafficSignalCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the traficsignal ???

state (str): state of the signal
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the traficsignal ???

state (str): state of the signal
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the traficsignal ???

state (str): state of the signal
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TrafficSignalCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        name (str): name of the traficsignal ???

        state (str): state of the signal

    Attributes
    ----------
        name (str): name of the traficsignal ???

        state (str): state of the signal

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, state):
        &#34;&#34;&#34;initalize the TrafficSignalCondition

        Parameters
        ----------
            name (str): name of the traficsignal ???

            state (str): state of the signal

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self, other):
        if isinstance(other, TrafficSignalCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TrafficSignalCondition): a TrafficSignalCondition object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        state = element.attrib[&#34;state&#34;]

        return TrafficSignalCondition(name, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalCondition as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalCondition&#34;&#34;&#34;
        return ET.Element(&#34;TrafficSignalCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSignalCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TrafficSignalCondition): a TrafficSignalCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSignalCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TrafficSignalCondition): a TrafficSignalCondition object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    state = element.attrib[&#34;state&#34;]

    return TrafficSignalCondition(name, state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalCondition as a dict&#34;&#34;&#34;
    return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSignalCondition&#34;&#34;&#34;
    return ET.Element(&#34;TrafficSignalCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition"><code class="flex name class">
<span>class <span class="ident">TrafficSignalControllerCondition</span></span>
<span>(</span><span>trafficsignalref, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>the TrafficSignalControllerCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>trafficsignalref (str): ???

phase (str): ???
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>trafficsignalref (str): ???

phase (str): ???
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalControllerCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>trafficsignalref (str): ???

phase (str): ???
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalControllerCondition(_ValueTriggerType):
    &#34;&#34;&#34;the TrafficSignalControllerCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        trafficsignalref (str): ???

        phase (str): ???

    Attributes
    ----------
        trafficsignalref (str): ???

        phase (str): ???

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, trafficsignalref, phase):
        &#34;&#34;&#34;initalize the TrafficSignalControllerCondition

        Parameters
        ----------
            trafficsignalref (str): ???

            phase (str): ???

        &#34;&#34;&#34;
        self.trafficsignalref = trafficsignalref
        self.phase = phase

    def __eq__(self, other):
        if isinstance(other, TrafficSignalControllerCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TrafficSignalControllerCondition): a TrafficSignalControllerCondition object

        &#34;&#34;&#34;
        trafficsignalref = element.attrib[&#34;trafficSignalControllerRef&#34;]
        phase = element.attrib[&#34;phase&#34;]

        return TrafficSignalControllerCondition(trafficsignalref, phase)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerCondition as a dict&#34;&#34;&#34;
        return {
            &#34;trafficSignalControllerRef&#34;: self.trafficsignalref,
            &#34;phase&#34;: self.phase,
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerCondition&#34;&#34;&#34;
        return ET.Element(
            &#34;TrafficSignalControllerCondition&#34;, attrib=self.get_attributes()
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSignalControllerCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TrafficSignalControllerCondition): a TrafficSignalControllerCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TrafficSignalControllerCondition): a TrafficSignalControllerCondition object

    &#34;&#34;&#34;
    trafficsignalref = element.attrib[&#34;trafficSignalControllerRef&#34;]
    phase = element.attrib[&#34;phase&#34;]

    return TrafficSignalControllerCondition(trafficsignalref, phase)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalControllerCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerCondition as a dict&#34;&#34;&#34;
    return {
        &#34;trafficSignalControllerRef&#34;: self.trafficsignalref,
        &#34;phase&#34;: self.phase,
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalControllerCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerCondition&#34;&#34;&#34;
    return ET.Element(
        &#34;TrafficSignalControllerCondition&#34;, attrib=self.get_attributes()
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TraveledDistanceCondition"><code class="flex name class">
<span>class <span class="ident">TraveledDistanceCondition</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): how far it has traveled
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): how far it has traveled
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): how far it has traveled
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TraveledDistanceCondition(_EntityTriggerType):
    &#34;&#34;&#34;the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger

    Parameters
    ----------
        value (float): how far it has traveled

    Attributes
    ----------
        value (float): how far it has traveled

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value):
        &#34;&#34;&#34;the TraveledDistanceCondition class is an Entity Condition used by the EntityTrigger

        Parameters
        ----------
            value (float): how far it has traveled

        &#34;&#34;&#34;
        self.value = value

    def __eq__(self, other):
        if isinstance(other, TraveledDistanceCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TraveledDistanceCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (TraveledDistanceCondition): a TraveledDistanceCondition object

        &#34;&#34;&#34;
        condition = element.find(&#34;TraveledDistanceCondition&#34;)
        value = condition.attrib[&#34;value&#34;]
        return TraveledDistanceCondition(value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TraveledDistanceCondition as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TraveledDistanceCondition&#34;&#34;&#34;
        element = ET.Element(&#34;EntityCondition&#34;)
        ET.SubElement(
            element, &#34;TraveledDistanceCondition&#34;, attrib=self.get_attributes()
        )
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._EntityTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TraveledDistanceCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TraveledDistanceCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (TraveledDistanceCondition): a TraveledDistanceCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TraveledDistanceCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (TraveledDistanceCondition): a TraveledDistanceCondition object

    &#34;&#34;&#34;
    condition = element.find(&#34;TraveledDistanceCondition&#34;)
    value = condition.attrib[&#34;value&#34;]
    return TraveledDistanceCondition(value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TraveledDistanceCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TraveledDistanceCondition as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TraveledDistanceCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TraveledDistanceCondition&#34;&#34;&#34;
    element = ET.Element(&#34;EntityCondition&#34;)
    ET.SubElement(
        element, &#34;TraveledDistanceCondition&#34;, attrib=self.get_attributes()
    )
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.Trigger"><code class="flex name class">
<span>class <span class="ident">Trigger</span></span>
<span>(</span><span>triggeringpoint='start')</span>
</code></dt>
<dd>
<div class="desc"><p>The Trigger class creates a Trigger that can be used if multiple ConditionGroups are wanted
The Trigger acts like an "OR" logic for all added ConditionGroups</p>
<h2 id="parameters">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop
    Default: start
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>triggeringpoint (str): start or stop

conditiongroups (list of ConditionGroup): a list of all conditiongroups
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_conditiongroup(conditiongroup)
    Adds a conditiongroup to the trigger
</code></pre>
<p>initalize the Trigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>triggeringpoint (str): start or stop
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trigger(_TriggerType):
    &#34;&#34;&#34;The Trigger class creates a Trigger that can be used if multiple ConditionGroups are wanted
    The Trigger acts like an &#34;OR&#34; logic for all added ConditionGroups

    Parameters
    ----------
        triggeringpoint (str): start or stop
            Default: start

    Attributes
    ----------
        triggeringpoint (str): start or stop

        conditiongroups (list of ConditionGroup): a list of all conditiongroups

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_conditiongroup(conditiongroup)
            Adds a conditiongroup to the trigger

    &#34;&#34;&#34;

    def __init__(self, triggeringpoint=&#34;start&#34;):
        &#34;&#34;&#34;initalize the Trigger

        Parameters
        ----------
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;
        self.conditiongroups = []

    def __eq__(self, other):
        if isinstance(other, Trigger):
            if (
                self.conditiongroups == other.conditiongroups
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, EntityTrigger) or isinstance(other, ValueTrigger):
            if (
                len(self.conditiongroups) == 1
                and len(self.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditiongroups[0].conditions[0] == other
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(self.conditiongroups) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and self.conditiongroups[0] == other
                ):
                    return True
        elif isinstance(other, EmptyTrigger):
            if (
                len(self.conditiongroups) == 0
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ConditionGroup

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            conditiongroup (ConditionGroup): a ConditionGroup object

        &#34;&#34;&#34;

        trigger = Trigger()
        trigger._triggerpoint = element.tag

        conditiongroups = element.findall(&#34;ConditionGroup&#34;)
        for condgr in conditiongroups:
            trigger.add_conditiongroup(ConditionGroup.parse(condgr))

        return trigger

    def add_conditiongroup(self, conditiongroup):
        &#34;&#34;&#34;Adds a conditiongroup to the trigger

        Parameters
        ----------
            conditiongroup (ConditionGroup): a conditiongroup to add to the trigger

        &#34;&#34;&#34;
        if not isinstance(conditiongroup, ConditionGroup):
            raise TypeError(&#34;conditiongroup input not of type ConditionGroup&#34;)
        conditiongroup._set_used_by_parent()
        self.conditiongroups.append(conditiongroup)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
        element = ET.Element(self._triggerpoint)
        if not self.conditiongroups:
            ValueError(&#34;No conditiongroups were added to the trigger&#34;)
        for c in self.conditiongroups:
            element.append(c.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._TriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.Trigger.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ConditionGroup</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>conditiongroup (ConditionGroup): a ConditionGroup object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ConditionGroup

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        conditiongroup (ConditionGroup): a ConditionGroup object

    &#34;&#34;&#34;

    trigger = Trigger()
    trigger._triggerpoint = element.tag

    conditiongroups = element.findall(&#34;ConditionGroup&#34;)
    for condgr in conditiongroups:
        trigger.add_conditiongroup(ConditionGroup.parse(condgr))

    return trigger</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.Trigger.add_conditiongroup"><code class="name flex">
<span>def <span class="ident">add_conditiongroup</span></span>(<span>self, conditiongroup)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a conditiongroup to the trigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>conditiongroup (ConditionGroup): a conditiongroup to add to the trigger
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_conditiongroup(self, conditiongroup):
    &#34;&#34;&#34;Adds a conditiongroup to the trigger

    Parameters
    ----------
        conditiongroup (ConditionGroup): a conditiongroup to add to the trigger

    &#34;&#34;&#34;
    if not isinstance(conditiongroup, ConditionGroup):
        raise TypeError(&#34;conditiongroup input not of type ConditionGroup&#34;)
    conditiongroup._set_used_by_parent()
    self.conditiongroups.append(conditiongroup)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.Trigger.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Trigger</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Trigger&#34;&#34;&#34;
    element = ET.Element(self._triggerpoint)
    if not self.conditiongroups:
        ValueError(&#34;No conditiongroups were added to the trigger&#34;)
    for c in self.conditiongroups:
        element.append(c.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.TriggeringEntities"><code class="flex name class">
<span>class <span class="ident">TriggeringEntities</span></span>
<span>(</span><span>triggeringrule)</span>
</code></dt>
<dd>
<div class="desc"><p>the TriggeringEntities class is used by Value and Entity Triggers to defined the trigger entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>triggeringrule (TriggeringEntitiesRule): all or any
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (list of EntityRef): refernce to the entity

triggeringrule (TriggeringEntitiesRule): all or any
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_entity(entity)
    adds a entityref to the triggering entities

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TriggeringEntities</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (TriggeringEntitiesRule): name of the entity

triggeringrule (str): all or any
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriggeringEntities(VersionBase):
    &#34;&#34;&#34;the TriggeringEntities class is used by Value and Entity Triggers to defined the trigger entity

    Parameters
    ----------
        triggeringrule (TriggeringEntitiesRule): all or any

    Attributes
    ----------
        entity (list of EntityRef): refernce to the entity

        triggeringrule (TriggeringEntitiesRule): all or any

    Methods
    -------
        add_entity(entity)
            adds a entityref to the triggering entities

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, triggeringrule):
        &#34;&#34;&#34;initalize the TriggeringEntities

        Parameters
        ----------
            entity (TriggeringEntitiesRule): name of the entity

            triggeringrule (str): all or any

        &#34;&#34;&#34;
        if not hasattr(TriggeringEntitiesRule, str(triggeringrule)):
            raise ValueError(&#34;not a vaild triggering rule&#34;)
        self.entity = []
        self.triggeringrule = triggeringrule

    def __eq__(self, other):
        if isinstance(other, TriggeringEntities):
            if (
                self.get_attributes() == other.get_attributes()
                and self.entity == other.entity
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TriggeringEntities

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            triggeringentities (TriggeringEntities): a TriggeringEntities object

        &#34;&#34;&#34;

        rule = getattr(TriggeringEntitiesRule, element.attrib[&#34;triggeringEntitiesRule&#34;])
        triggeringentities = TriggeringEntities(rule)
        entrefs = element.findall(&#34;EntityRef&#34;)
        for ent in entrefs:
            entityref = EntityRef.parse(ent)
            triggeringentities.add_entity(entityref.entity)
        return triggeringentities

    def add_entity(self, entity):
        &#34;&#34;&#34;add_entity adds an entity to the TriggeringEntities

        Parameters
        ----------
            entity (str): name of the entity to add

        &#34;&#34;&#34;
        self.entity.append(EntityRef(entity))
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {&#34;triggeringEntitiesRule&#34;: self.triggeringrule.get_name()}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;TriggeringEntities&#34;, attrib=self.get_attributes())
        for ent in self.entity:
            element.append(ent.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TriggeringEntities.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TriggeringEntities</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>triggeringentities (TriggeringEntities): a TriggeringEntities object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TriggeringEntities

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        triggeringentities (TriggeringEntities): a TriggeringEntities object

    &#34;&#34;&#34;

    rule = getattr(TriggeringEntitiesRule, element.attrib[&#34;triggeringEntitiesRule&#34;])
    triggeringentities = TriggeringEntities(rule)
    entrefs = element.findall(&#34;EntityRef&#34;)
    for ent in entrefs:
        entityref = EntityRef.parse(ent)
        triggeringentities.add_entity(entityref.entity)
    return triggeringentities</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.TriggeringEntities.add_entity"><code class="name flex">
<span>def <span class="ident">add_entity</span></span>(<span>self, entity)</span>
</code></dt>
<dd>
<div class="desc"><p>add_entity adds an entity to the TriggeringEntities</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): name of the entity to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entity(self, entity):
    &#34;&#34;&#34;add_entity adds an entity to the TriggeringEntities

    Parameters
    ----------
        entity (str): name of the entity to add

    &#34;&#34;&#34;
    self.entity.append(EntityRef(entity))
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TriggeringEntities.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
    return {&#34;triggeringEntitiesRule&#34;: self.triggeringrule.get_name()}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.TriggeringEntities.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
    element = ET.Element(&#34;TriggeringEntities&#34;, attrib=self.get_attributes())
    for ent in self.entity:
        element.append(ent.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.UserDefinedValueCondition"><code class="flex name class">
<span>class <span class="ident">UserDefinedValueCondition</span></span>
<span>(</span><span>name, value, rule)</span>
</code></dt>
<dd>
<div class="desc"><p>the UserDefinedValueCondition class is an Value Condition used by the ValueTrigger</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the parameter

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the parameter

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the UserDefinedValueCondition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the parameter

value (int): value to trigger on

rule (Rule): condition rule of triggering
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedValueCondition(_ValueTriggerType):
    &#34;&#34;&#34;the UserDefinedValueCondition class is an Value Condition used by the ValueTrigger

    Parameters
    ----------
        name (str): name of the parameter

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Attributes
    ----------
        name (str): name of the parameter

        value (int): value to trigger on

        rule (Rule): condition rule of triggering

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, value, rule):
        &#34;&#34;&#34;initalize the UserDefinedValueCondition

        Parameters
        ----------
            name (str): name of the parameter

            value (int): value to trigger on

            rule (Rule): condition rule of triggering
        &#34;&#34;&#34;
        self.name = name
        self.value = value
        if not hasattr(Rule, str(rule)):
            raise ValueError(rule + &#34;; is not a valid rule.&#34;)
        self.rule = rule

    def __eq__(self, other):
        if isinstance(other, UserDefinedValueCondition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of UserDefinedValueCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (UserDefinedValueCondition): a UserDefinedValueCondition object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        value = element.attrib[&#34;value&#34;]
        rule = getattr(Rule, element.attrib[&#34;rule&#34;])
        return UserDefinedValueCondition(name, value, rule)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the UserDefinedValueCondition as a dict&#34;&#34;&#34;
        basedict = {&#34;name&#34;: self.name, &#34;value&#34;: str(self.value)}
        basedict[&#34;rule&#34;] = self.rule.get_name()
        return basedict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedValueCondition&#34;&#34;&#34;
        return ET.Element(&#34;UserDefinedValueCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ValueTriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.UserDefinedValueCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of UserDefinedValueCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (UserDefinedValueCondition): a UserDefinedValueCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of UserDefinedValueCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (UserDefinedValueCondition): a UserDefinedValueCondition object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    value = element.attrib[&#34;value&#34;]
    rule = getattr(Rule, element.attrib[&#34;rule&#34;])
    return UserDefinedValueCondition(name, value, rule)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the UserDefinedValueCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the UserDefinedValueCondition as a dict&#34;&#34;&#34;
    basedict = {&#34;name&#34;: self.name, &#34;value&#34;: str(self.value)}
    basedict[&#34;rule&#34;] = self.rule.get_name()
    return basedict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the UserDefinedValueCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the UserDefinedValueCondition&#34;&#34;&#34;
    return ET.Element(&#34;UserDefinedValueCondition&#34;, attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.triggers.ValueTrigger"><code class="flex name class">
<span>class <span class="ident">ValueTrigger</span></span>
<span>(</span><span>name, delay, conditionedge, valuecondition, triggeringpoint='start')</span>
</code></dt>
<dd>
<div class="desc"><p>the ValueTrigger creates a Trigger of the type ValueTrigger of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): on what conditionedge the trigger should act

valuecondition (*ValueCondition): a value condition

triggeringentity (str): the entity of the trigger

triggeringrule (str): rule of the trigger
    Default: 'any'

triggeringpoint (str): start or stop
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): the condition edge

valuecondition (*ValueCondition): the value condition

triggerentity (TriggeringEntities): the triggering entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ValueTrigger</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the trigger

delay (float): the delay of the trigger

conditionedge (ConditionEdge): on what conditionedge the trigger should act

valuecondition (*ValueCondition): a value condition

triggeringentity (str): the entity of the trigger

triggeringrule (str): rule of the trigger
    Default: 'any'
#TODO CHECK THIS
triggeringpoint (str): start or stop
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueTrigger(_TriggerType):
    &#34;&#34;&#34;the ValueTrigger creates a Trigger of the type ValueTrigger of openscenario

    Parameters
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): on what conditionedge the trigger should act

        valuecondition (*ValueCondition): a value condition

        triggeringentity (str): the entity of the trigger

        triggeringrule (str): rule of the trigger
            Default: &#39;any&#39;

        triggeringpoint (str): start or stop

    Attributes
    ----------
        name (str): name of the trigger

        delay (float): the delay of the trigger

        conditionedge (ConditionEdge): the condition edge

        valuecondition (*ValueCondition): the value condition

        triggerentity (TriggeringEntities): the triggering entity

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self, name, delay, conditionedge, valuecondition, triggeringpoint=&#34;start&#34;
    ):
        &#34;&#34;&#34;initalize the ValueTrigger

        Parameters
        ----------
            name (str): name of the trigger

            delay (float): the delay of the trigger

            conditionedge (ConditionEdge): on what conditionedge the trigger should act

            valuecondition (*ValueCondition): a value condition

            triggeringentity (str): the entity of the trigger

            triggeringrule (str): rule of the trigger
                Default: &#39;any&#39;
            #TODO CHECK THIS
            triggeringpoint (str): start or stop

        &#34;&#34;&#34;
        self.name = name
        if triggeringpoint not in [&#34;start&#34;, &#34;stop&#34;]:
            raise ValueError(&#34;not a valid triggering point, valid start or stop&#34;)
        if triggeringpoint == &#34;start&#34;:
            self._triggerpoint = &#34;StartTrigger&#34;
        else:
            self._triggerpoint = &#34;StopTrigger&#34;

        self.delay = delay
        if not hasattr(ConditionEdge, str(conditionedge)):
            raise ValueError(&#34;not a valid condition edge&#34;)
        self.conditionedge = conditionedge
        if not isinstance(valuecondition, _ValueTriggerType):
            raise TypeError(&#34;entitycondition is not a valid EntityCondition&#34;)
        self.valuecondition = valuecondition
        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, ValueTrigger):
            if (
                self.get_attributes() == other.get_attributes()
                and self.valuecondition == other.valuecondition
                and self._triggerpoint == other._triggerpoint
            ):
                return True
        elif isinstance(other, Trigger):
            if (
                len(other.conditiongroups) == 1
                and len(other.conditiongroups[0].conditions) == 1
            ):
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditiongroups[0].conditions[0] == self
                ):
                    return True
        elif isinstance(other, ConditionGroup):
            if len(other.conditions) == 1:
                if (
                    self._triggerpoint == other._triggerpoint
                    and other.conditions[0] == self
                ):
                    return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ValueTrigger
        NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            condition (ValueTrigger): a ValueTrigger object

        &#34;&#34;&#34;
        if element.tag != &#34;Condition&#34;:
            raise NotAValidElement(
                &#34;ValueTrigger only parses a Condition, not &#34;, element
            )

        name = element.attrib[&#34;name&#34;]
        delay = element.attrib[&#34;delay&#34;]
        conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
        condition = _ValueConditionFactory.parse_value_condition(
            element.find(&#34;ByValueCondition&#34;)
        )
        return ValueTrigger(name, delay, conditionedge, condition)

    def _set_used_by_parent(self):
        &#34;&#34;&#34;_set_used_by_parent is used internaly if the condition is added to a ConditionGroup&#34;&#34;&#34;
        self._used_by_parent = True

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;delay&#34;: str(self.delay),
            &#34;conditionEdge&#34;: self.conditionedge.get_name(),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
        condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
        byvalue = ET.SubElement(condition, &#34;ByValueCondition&#34;)
        byvalue.append(self.valuecondition.get_element())
        if self._used_by_parent:
            return condition
        else:
            # could create a new Trigger ConditionGroup here, but went with this solution for now
            element = ET.Element(self._triggerpoint)
            condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
            condgroup.append(condition)
            return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._TriggerType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ValueTrigger.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ValueTrigger
NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>condition (ValueTrigger): a ValueTrigger object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ValueTrigger
    NOTE: this parser will ONLY parse the Condition itself, not the CondintionGroup or Trigger that it can generate

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        condition (ValueTrigger): a ValueTrigger object

    &#34;&#34;&#34;
    if element.tag != &#34;Condition&#34;:
        raise NotAValidElement(
            &#34;ValueTrigger only parses a Condition, not &#34;, element
        )

    name = element.attrib[&#34;name&#34;]
    delay = element.attrib[&#34;delay&#34;]
    conditionedge = getattr(ConditionEdge, element.attrib[&#34;conditionEdge&#34;])
    condition = _ValueConditionFactory.parse_value_condition(
        element.find(&#34;ByValueCondition&#34;)
    )
    return ValueTrigger(name, delay, conditionedge, condition)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.triggers.ValueTrigger.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LaneOffsetAction as a dict&#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;delay&#34;: str(self.delay),
        &#34;conditionEdge&#34;: self.conditionedge.get_name(),
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.triggers.ValueTrigger.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LaneOffsetAction&#34;&#34;&#34;
    condition = ET.Element(&#34;Condition&#34;, attrib=self.get_attributes())
    byvalue = ET.SubElement(condition, &#34;ByValueCondition&#34;)
    byvalue.append(self.valuecondition.get_element())
    if self._used_by_parent:
        return condition
    else:
        # could create a new Trigger ConditionGroup here, but went with this solution for now
        element = ET.Element(self._triggerpoint)
        condgroup = ET.SubElement(element, &#34;ConditionGroup&#34;)
        condgroup.append(condition)
        return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.AccelerationCondition" href="#scenariogeneration.xosc.triggers.AccelerationCondition">AccelerationCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.AccelerationCondition.get_attributes" href="#scenariogeneration.xosc.triggers.AccelerationCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.AccelerationCondition.get_element" href="#scenariogeneration.xosc.triggers.AccelerationCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.AccelerationCondition.parse" href="#scenariogeneration.xosc.triggers.AccelerationCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.CollisionCondition" href="#scenariogeneration.xosc.triggers.CollisionCondition">CollisionCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.CollisionCondition.get_element" href="#scenariogeneration.xosc.triggers.CollisionCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.CollisionCondition.parse" href="#scenariogeneration.xosc.triggers.CollisionCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.ConditionGroup" href="#scenariogeneration.xosc.triggers.ConditionGroup">ConditionGroup</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.ConditionGroup.add_condition" href="#scenariogeneration.xosc.triggers.ConditionGroup.add_condition">add_condition</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ConditionGroup.get_element" href="#scenariogeneration.xosc.triggers.ConditionGroup.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ConditionGroup.parse" href="#scenariogeneration.xosc.triggers.ConditionGroup.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.DistanceCondition" href="#scenariogeneration.xosc.triggers.DistanceCondition">DistanceCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.DistanceCondition.get_attributes" href="#scenariogeneration.xosc.triggers.DistanceCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.DistanceCondition.get_element" href="#scenariogeneration.xosc.triggers.DistanceCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.DistanceCondition.parse" href="#scenariogeneration.xosc.triggers.DistanceCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.EmptyTrigger" href="#scenariogeneration.xosc.triggers.EmptyTrigger">EmptyTrigger</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.EmptyTrigger.get_element" href="#scenariogeneration.xosc.triggers.EmptyTrigger.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.EndOfRoadCondition" href="#scenariogeneration.xosc.triggers.EndOfRoadCondition">EndOfRoadCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.EndOfRoadCondition.get_attributes" href="#scenariogeneration.xosc.triggers.EndOfRoadCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.EndOfRoadCondition.get_element" href="#scenariogeneration.xosc.triggers.EndOfRoadCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.EndOfRoadCondition.parse" href="#scenariogeneration.xosc.triggers.EndOfRoadCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.EntityTrigger" href="#scenariogeneration.xosc.triggers.EntityTrigger">EntityTrigger</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.EntityTrigger.add_triggering_entity" href="#scenariogeneration.xosc.triggers.EntityTrigger.add_triggering_entity">add_triggering_entity</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.EntityTrigger.get_attributes" href="#scenariogeneration.xosc.triggers.EntityTrigger.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.EntityTrigger.get_element" href="#scenariogeneration.xosc.triggers.EntityTrigger.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.EntityTrigger.parse" href="#scenariogeneration.xosc.triggers.EntityTrigger.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.OffroadCondition" href="#scenariogeneration.xosc.triggers.OffroadCondition">OffroadCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.OffroadCondition.get_attributes" href="#scenariogeneration.xosc.triggers.OffroadCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.OffroadCondition.get_element" href="#scenariogeneration.xosc.triggers.OffroadCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.OffroadCondition.parse" href="#scenariogeneration.xosc.triggers.OffroadCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.ParameterCondition" href="#scenariogeneration.xosc.triggers.ParameterCondition">ParameterCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.ParameterCondition.get_attributes" href="#scenariogeneration.xosc.triggers.ParameterCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ParameterCondition.get_element" href="#scenariogeneration.xosc.triggers.ParameterCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ParameterCondition.parse" href="#scenariogeneration.xosc.triggers.ParameterCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.ReachPositionCondition" href="#scenariogeneration.xosc.triggers.ReachPositionCondition">ReachPositionCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.ReachPositionCondition.get_attributes" href="#scenariogeneration.xosc.triggers.ReachPositionCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ReachPositionCondition.get_element" href="#scenariogeneration.xosc.triggers.ReachPositionCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ReachPositionCondition.parse" href="#scenariogeneration.xosc.triggers.ReachPositionCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.RelativeDistanceCondition" href="#scenariogeneration.xosc.triggers.RelativeDistanceCondition">RelativeDistanceCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_attributes" href="#scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_element" href="#scenariogeneration.xosc.triggers.RelativeDistanceCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.RelativeDistanceCondition.parse" href="#scenariogeneration.xosc.triggers.RelativeDistanceCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.RelativeSpeedCondition" href="#scenariogeneration.xosc.triggers.RelativeSpeedCondition">RelativeSpeedCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_attributes" href="#scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_element" href="#scenariogeneration.xosc.triggers.RelativeSpeedCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.RelativeSpeedCondition.parse" href="#scenariogeneration.xosc.triggers.RelativeSpeedCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.SimulationTimeCondition" href="#scenariogeneration.xosc.triggers.SimulationTimeCondition">SimulationTimeCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.SimulationTimeCondition.get_attributes" href="#scenariogeneration.xosc.triggers.SimulationTimeCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.SimulationTimeCondition.get_element" href="#scenariogeneration.xosc.triggers.SimulationTimeCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.SimulationTimeCondition.parse" href="#scenariogeneration.xosc.triggers.SimulationTimeCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.SpeedCondition" href="#scenariogeneration.xosc.triggers.SpeedCondition">SpeedCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.SpeedCondition.get_attributes" href="#scenariogeneration.xosc.triggers.SpeedCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.SpeedCondition.get_element" href="#scenariogeneration.xosc.triggers.SpeedCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.SpeedCondition.parse" href="#scenariogeneration.xosc.triggers.SpeedCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.StandStillCondition" href="#scenariogeneration.xosc.triggers.StandStillCondition">StandStillCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.StandStillCondition.get_attributes" href="#scenariogeneration.xosc.triggers.StandStillCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.StandStillCondition.get_element" href="#scenariogeneration.xosc.triggers.StandStillCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.StandStillCondition.parse" href="#scenariogeneration.xosc.triggers.StandStillCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.StoryboardElementStateCondition" href="#scenariogeneration.xosc.triggers.StoryboardElementStateCondition">StoryboardElementStateCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_attributes" href="#scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_element" href="#scenariogeneration.xosc.triggers.StoryboardElementStateCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.StoryboardElementStateCondition.parse" href="#scenariogeneration.xosc.triggers.StoryboardElementStateCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TimeHeadwayCondition" href="#scenariogeneration.xosc.triggers.TimeHeadwayCondition">TimeHeadwayCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_element" href="#scenariogeneration.xosc.triggers.TimeHeadwayCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeHeadwayCondition.parse" href="#scenariogeneration.xosc.triggers.TimeHeadwayCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TimeOfDayCondition" href="#scenariogeneration.xosc.triggers.TimeOfDayCondition">TimeOfDayCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TimeOfDayCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TimeOfDayCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeOfDayCondition.get_element" href="#scenariogeneration.xosc.triggers.TimeOfDayCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeOfDayCondition.parse" href="#scenariogeneration.xosc.triggers.TimeOfDayCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TimeToCollisionCondition" href="#scenariogeneration.xosc.triggers.TimeToCollisionCondition">TimeToCollisionCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_element" href="#scenariogeneration.xosc.triggers.TimeToCollisionCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TimeToCollisionCondition.parse" href="#scenariogeneration.xosc.triggers.TimeToCollisionCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TrafficSignalCondition" href="#scenariogeneration.xosc.triggers.TrafficSignalCondition">TrafficSignalCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TrafficSignalCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalCondition.get_element" href="#scenariogeneration.xosc.triggers.TrafficSignalCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalCondition.parse" href="#scenariogeneration.xosc.triggers.TrafficSignalCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition" href="#scenariogeneration.xosc.triggers.TrafficSignalControllerCondition">TrafficSignalControllerCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_element" href="#scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.parse" href="#scenariogeneration.xosc.triggers.TrafficSignalControllerCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TraveledDistanceCondition" href="#scenariogeneration.xosc.triggers.TraveledDistanceCondition">TraveledDistanceCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_attributes" href="#scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_element" href="#scenariogeneration.xosc.triggers.TraveledDistanceCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TraveledDistanceCondition.parse" href="#scenariogeneration.xosc.triggers.TraveledDistanceCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.Trigger" href="#scenariogeneration.xosc.triggers.Trigger">Trigger</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.Trigger.add_conditiongroup" href="#scenariogeneration.xosc.triggers.Trigger.add_conditiongroup">add_conditiongroup</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.Trigger.get_element" href="#scenariogeneration.xosc.triggers.Trigger.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.Trigger.parse" href="#scenariogeneration.xosc.triggers.Trigger.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.TriggeringEntities" href="#scenariogeneration.xosc.triggers.TriggeringEntities">TriggeringEntities</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.TriggeringEntities.add_entity" href="#scenariogeneration.xosc.triggers.TriggeringEntities.add_entity">add_entity</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TriggeringEntities.get_attributes" href="#scenariogeneration.xosc.triggers.TriggeringEntities.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TriggeringEntities.get_element" href="#scenariogeneration.xosc.triggers.TriggeringEntities.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.TriggeringEntities.parse" href="#scenariogeneration.xosc.triggers.TriggeringEntities.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.UserDefinedValueCondition" href="#scenariogeneration.xosc.triggers.UserDefinedValueCondition">UserDefinedValueCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_attributes" href="#scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_element" href="#scenariogeneration.xosc.triggers.UserDefinedValueCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.UserDefinedValueCondition.parse" href="#scenariogeneration.xosc.triggers.UserDefinedValueCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.triggers.ValueTrigger" href="#scenariogeneration.xosc.triggers.ValueTrigger">ValueTrigger</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.triggers.ValueTrigger.get_attributes" href="#scenariogeneration.xosc.triggers.ValueTrigger.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ValueTrigger.get_element" href="#scenariogeneration.xosc.triggers.ValueTrigger.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.triggers.ValueTrigger.parse" href="#scenariogeneration.xosc.triggers.ValueTrigger.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>