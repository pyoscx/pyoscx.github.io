<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scenariogeneration.xosc.xosc_reader API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.xosc_reader</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  scenariogeneration
  https://github.com/pyoscx/scenariogeneration
 
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.
 
  Copyright (c) 2022 The scenariogeneration Authors.

&#34;&#34;&#34;
import xml.etree.ElementTree as ET
import os


from .parameters import ParameterValueDistribution
from .scenario import Scenario, Catalog
from .exceptions import NoCatalogFoundError, NotAValidElement
from .entities import Vehicle, Pedestrian, MiscObject
from .utils import ParameterDeclarations, Controller, Environment, CatalogReference
from .storyboard import Maneuver
from .position import Trajectory, Route


class CatalogLoader:
    &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog


    Attributes
    ----------

        all_catalogs (dict with all catalogs): all catalogs loaded

    Methods
    -------
        load_catalog(catalog_reference,catalog_path)
            loads a catalog that can be parsed later on

        get_entry(catalog_reference)
            reads a loaded catalog and returns the object
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog

        Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry

        &#34;&#34;&#34;
        self.all_catalogs = {}

    def load_catalog(self, catalog_reference, catalog_path):
        &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog

        Parameters
        ----------
            catalog_reference (CatalogReference or str): name/reference to the catalog

            catalog_path (str): path to the catalog
        &#34;&#34;&#34;
        if isinstance(catalog_reference, CatalogReference):
            fullpath = os.path.join(
                catalog_path, catalog_reference.catalogname + &#34;.xosc&#34;
            )
            name_ref = catalog_reference.catalogname
        else:
            fullpath = os.path.join(catalog_path, catalog_reference + &#34;.xosc&#34;)
            name_ref = catalog_reference

        with open(fullpath, &#34;r&#34;) as f:
            catalog_element = ET.parse(f).find(&#34;Catalog&#34;)
            self.all_catalogs[name_ref] = catalog_element

    def parse(self, catalog_reference):
        &#34;&#34;&#34;parse reads reads a specific entry from a loaded catalog

        Parameters
        ----------
            catalog_reference (CatalogReference): reference to the catalog

        Returns
        -------
            The catalog entry

        &#34;&#34;&#34;
        if not catalog_reference.catalogname in self.all_catalogs:
            raise NoCatalogFoundError(
                &#34;Catalog &#34; + catalog_reference.catalogname + &#34; is not loaded yet.&#34;
            )
        catalog = self.all_catalogs[catalog_reference.catalogname]
        for entry in catalog:
            if entry.tag == &#34;Vehicle&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Vehicle.parse(entry)
            elif entry.tag == &#34;Pedestrian&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Pedestrian.parse(entry)
            elif entry.tag == &#34;Controller&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Controller.parse(entry)
            elif entry.tag == &#34;MiscObject&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return MiscObject.parse(entry)
            elif entry.tag == &#34;Environment&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Environment.parse(entry)
            elif entry.tag == &#34;Maneuver&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Maneuver.parse(entry)
            elif entry.tag == &#34;Trajectory&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Trajectory.parse(entry)
            elif entry.tag == &#34;Route&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Route.parse(entry)
            else:
                raise NotImplementedError(&#34;This catalogtype is not supported yet.&#34;)

    def read_entry(self, catalog_reference, catalog_path):
        &#34;&#34;&#34;read_entry loads and reads a catalog directly (both load_catalog, and parse)

        The catalog will still be loaded and can be used with parse after this.

        Parameters
        ----------
            catalog_reference (CatalogReference): reference to the catalog

            catalog_path (str): path to the catalog
        &#34;&#34;&#34;
        self.load_catalog(catalog_reference, catalog_path)
        return self.parse(catalog_reference)


def CatalogReader(catalog_reference, catalog_path):
    &#34;&#34;&#34;CatalogReader is a function that will read a openscenario catalog and return the corresponding scenariogeneration.xosc object

    Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry

    NOTE: only Vehicle, and Pedestrian is implemented

    Parameters
    ----------
        catalog_reference (CatalogReference): the catalog reference needed

        catalog_path (str): path to the catalog

    Returns
    -------
        The catalog entry
    &#34;&#34;&#34;

    # TODO: add a raised error if the catalog doesn&#39;t contain the correct data
    loaded_catalog = catalog_reference.catalogname

    with open(
        os.path.join(catalog_path, catalog_reference.catalogname + &#34;.xosc&#34;), &#34;r&#34;
    ) as f:
        loaded_catalog = ET.parse(f)

        catalog = loaded_catalog.find(&#34;Catalog&#34;)

        for entry in catalog:
            if entry.tag == &#34;Vehicle&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Vehicle.parse(entry)
            elif entry.tag == &#34;Pedestrian&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Pedestrian.parse(entry)
            elif entry.tag == &#34;Controller&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Controller.parse(entry)
            elif entry.tag == &#34;MiscObject&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return MiscObject.parse(entry)
            elif entry.tag == &#34;Environment&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Environment.parse(entry)
            elif entry.tag == &#34;Maneuver&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Maneuver.parse(entry)
            elif entry.tag == &#34;Trajectory&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Trajectory.parse(entry)
            elif entry.tag == &#34;Route&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Route.parse(entry)
            else:
                raise NotImplementedError(&#34;This catalogtype is not supported yet.&#34;)

        raise NoCatalogFoundError(
            &#34;A catalog entry with the name &#34;
            + catalog_reference.entryname
            + &#34; could not be found in the given Catalog.&#34;
        )


def ParameterDeclarationReader(file_path):
    &#34;&#34;&#34;ParameterDeclarationReader reads the parameter declaration of a xosc file and creates a ParameterDeclaration object from it

    Parameters
    ----------
        file_path (str): path to the xosc file wanted to be parsed

    &#34;&#34;&#34;
    param_decl = ParameterDeclarations()
    with open(file_path, &#34;r&#34;) as f:
        loaded_xosc = ET.parse(f)
        paramdec = loaded_xosc.find(&#34;ParameterDeclarations&#34;)
        param_decl = ParameterDeclarations.parse(paramdec)

    return param_decl


def ParseOpenScenario(file_path):
    &#34;&#34;&#34;ParseOpenScenario parses a openscenario file (of any type) and returns the python object

    Parameters
    ----------
        file_path (str): full path to the .xosc file

    Returns
    -------
        xosc_object (Scenario, Catalog, or ParameterValueDistribution)
    &#34;&#34;&#34;
    with open(file_path, &#34;r&#34;) as f:
        loaded_xosc = ET.parse(f)
        if loaded_xosc.find(&#34;ParameterValueDistribution&#34;) is not None:
            return ParameterValueDistribution.parse(loaded_xosc)
        elif loaded_xosc.find(&#34;Catalog&#34;) is not None:
            return Catalog.parse(loaded_xosc)
        elif loaded_xosc.find(&#34;Storyboard&#34;) is not None:
            return Scenario.parse(loaded_xosc)
        else:
            raise NotAValidElement(
                &#34;The provided file is not on a OpenSCENARIO compatible format.&#34;
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenariogeneration.xosc.xosc_reader.CatalogReader"><code class="name flex">
<span>def <span class="ident">CatalogReader</span></span>(<span>catalog_reference, catalog_path)</span>
</code></dt>
<dd>
<div class="desc"><p>CatalogReader is a function that will read a openscenario catalog and return the corresponding scenariogeneration.xosc object</p>
<p>Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry</p>
<p>NOTE: only Vehicle, and Pedestrian is implemented</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalog_reference (CatalogReference): the catalog reference needed

catalog_path (str): path to the catalog
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>The catalog entry
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CatalogReader(catalog_reference, catalog_path):
    &#34;&#34;&#34;CatalogReader is a function that will read a openscenario catalog and return the corresponding scenariogeneration.xosc object

    Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry

    NOTE: only Vehicle, and Pedestrian is implemented

    Parameters
    ----------
        catalog_reference (CatalogReference): the catalog reference needed

        catalog_path (str): path to the catalog

    Returns
    -------
        The catalog entry
    &#34;&#34;&#34;

    # TODO: add a raised error if the catalog doesn&#39;t contain the correct data
    loaded_catalog = catalog_reference.catalogname

    with open(
        os.path.join(catalog_path, catalog_reference.catalogname + &#34;.xosc&#34;), &#34;r&#34;
    ) as f:
        loaded_catalog = ET.parse(f)

        catalog = loaded_catalog.find(&#34;Catalog&#34;)

        for entry in catalog:
            if entry.tag == &#34;Vehicle&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Vehicle.parse(entry)
            elif entry.tag == &#34;Pedestrian&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Pedestrian.parse(entry)
            elif entry.tag == &#34;Controller&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Controller.parse(entry)
            elif entry.tag == &#34;MiscObject&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return MiscObject.parse(entry)
            elif entry.tag == &#34;Environment&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Environment.parse(entry)
            elif entry.tag == &#34;Maneuver&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Maneuver.parse(entry)
            elif entry.tag == &#34;Trajectory&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Trajectory.parse(entry)
            elif entry.tag == &#34;Route&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Route.parse(entry)
            else:
                raise NotImplementedError(&#34;This catalogtype is not supported yet.&#34;)

        raise NoCatalogFoundError(
            &#34;A catalog entry with the name &#34;
            + catalog_reference.entryname
            + &#34; could not be found in the given Catalog.&#34;
        )</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.xosc_reader.ParameterDeclarationReader"><code class="name flex">
<span>def <span class="ident">ParameterDeclarationReader</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>ParameterDeclarationReader reads the parameter declaration of a xosc file and creates a ParameterDeclaration object from it</p>
<h2 id="parameters">Parameters</h2>
<pre><code>file_path (str): path to the xosc file wanted to be parsed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParameterDeclarationReader(file_path):
    &#34;&#34;&#34;ParameterDeclarationReader reads the parameter declaration of a xosc file and creates a ParameterDeclaration object from it

    Parameters
    ----------
        file_path (str): path to the xosc file wanted to be parsed

    &#34;&#34;&#34;
    param_decl = ParameterDeclarations()
    with open(file_path, &#34;r&#34;) as f:
        loaded_xosc = ET.parse(f)
        paramdec = loaded_xosc.find(&#34;ParameterDeclarations&#34;)
        param_decl = ParameterDeclarations.parse(paramdec)

    return param_decl</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.xosc_reader.ParseOpenScenario"><code class="name flex">
<span>def <span class="ident">ParseOpenScenario</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>ParseOpenScenario parses a openscenario file (of any type) and returns the python object</p>
<h2 id="parameters">Parameters</h2>
<pre><code>file_path (str): full path to the .xosc file
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>xosc_object (Scenario, Catalog, or ParameterValueDistribution)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParseOpenScenario(file_path):
    &#34;&#34;&#34;ParseOpenScenario parses a openscenario file (of any type) and returns the python object

    Parameters
    ----------
        file_path (str): full path to the .xosc file

    Returns
    -------
        xosc_object (Scenario, Catalog, or ParameterValueDistribution)
    &#34;&#34;&#34;
    with open(file_path, &#34;r&#34;) as f:
        loaded_xosc = ET.parse(f)
        if loaded_xosc.find(&#34;ParameterValueDistribution&#34;) is not None:
            return ParameterValueDistribution.parse(loaded_xosc)
        elif loaded_xosc.find(&#34;Catalog&#34;) is not None:
            return Catalog.parse(loaded_xosc)
        elif loaded_xosc.find(&#34;Storyboard&#34;) is not None:
            return Scenario.parse(loaded_xosc)
        else:
            raise NotAValidElement(
                &#34;The provided file is not on a OpenSCENARIO compatible format.&#34;
            )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.xosc_reader.CatalogLoader"><code class="flex name class">
<span>class <span class="ident">CatalogLoader</span></span>
</code></dt>
<dd>
<div class="desc"><p>CatalogLoader makes it possible to read certain elements from a catalog</p>
<h2 id="attributes">Attributes</h2>
<pre><code>all_catalogs (dict with all catalogs): all catalogs loaded
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>load_catalog(catalog_reference,catalog_path)
    loads a catalog that can be parsed later on

get_entry(catalog_reference)
    reads a loaded catalog and returns the object
</code></pre>
<p>CatalogLoader makes it possible to read certain elements from a catalog</p>
<p>Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatalogLoader:
    &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog


    Attributes
    ----------

        all_catalogs (dict with all catalogs): all catalogs loaded

    Methods
    -------
        load_catalog(catalog_reference,catalog_path)
            loads a catalog that can be parsed later on

        get_entry(catalog_reference)
            reads a loaded catalog and returns the object
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog

        Main use case for this is to be able to parametrize and write scenarios based on a catalog based entry

        &#34;&#34;&#34;
        self.all_catalogs = {}

    def load_catalog(self, catalog_reference, catalog_path):
        &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog

        Parameters
        ----------
            catalog_reference (CatalogReference or str): name/reference to the catalog

            catalog_path (str): path to the catalog
        &#34;&#34;&#34;
        if isinstance(catalog_reference, CatalogReference):
            fullpath = os.path.join(
                catalog_path, catalog_reference.catalogname + &#34;.xosc&#34;
            )
            name_ref = catalog_reference.catalogname
        else:
            fullpath = os.path.join(catalog_path, catalog_reference + &#34;.xosc&#34;)
            name_ref = catalog_reference

        with open(fullpath, &#34;r&#34;) as f:
            catalog_element = ET.parse(f).find(&#34;Catalog&#34;)
            self.all_catalogs[name_ref] = catalog_element

    def parse(self, catalog_reference):
        &#34;&#34;&#34;parse reads reads a specific entry from a loaded catalog

        Parameters
        ----------
            catalog_reference (CatalogReference): reference to the catalog

        Returns
        -------
            The catalog entry

        &#34;&#34;&#34;
        if not catalog_reference.catalogname in self.all_catalogs:
            raise NoCatalogFoundError(
                &#34;Catalog &#34; + catalog_reference.catalogname + &#34; is not loaded yet.&#34;
            )
        catalog = self.all_catalogs[catalog_reference.catalogname]
        for entry in catalog:
            if entry.tag == &#34;Vehicle&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Vehicle.parse(entry)
            elif entry.tag == &#34;Pedestrian&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Pedestrian.parse(entry)
            elif entry.tag == &#34;Controller&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Controller.parse(entry)
            elif entry.tag == &#34;MiscObject&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return MiscObject.parse(entry)
            elif entry.tag == &#34;Environment&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Environment.parse(entry)
            elif entry.tag == &#34;Maneuver&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Maneuver.parse(entry)
            elif entry.tag == &#34;Trajectory&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Trajectory.parse(entry)
            elif entry.tag == &#34;Route&#34;:
                if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                    return Route.parse(entry)
            else:
                raise NotImplementedError(&#34;This catalogtype is not supported yet.&#34;)

    def read_entry(self, catalog_reference, catalog_path):
        &#34;&#34;&#34;read_entry loads and reads a catalog directly (both load_catalog, and parse)

        The catalog will still be loaded and can be used with parse after this.

        Parameters
        ----------
            catalog_reference (CatalogReference): reference to the catalog

            catalog_path (str): path to the catalog
        &#34;&#34;&#34;
        self.load_catalog(catalog_reference, catalog_path)
        return self.parse(catalog_reference)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.xosc_reader.CatalogLoader.load_catalog"><code class="name flex">
<span>def <span class="ident">load_catalog</span></span>(<span>self, catalog_reference, catalog_path)</span>
</code></dt>
<dd>
<div class="desc"><p>CatalogLoader makes it possible to read certain elements from a catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalog_reference (CatalogReference or str): name/reference to the catalog

catalog_path (str): path to the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_catalog(self, catalog_reference, catalog_path):
    &#34;&#34;&#34;CatalogLoader makes it possible to read certain elements from a catalog

    Parameters
    ----------
        catalog_reference (CatalogReference or str): name/reference to the catalog

        catalog_path (str): path to the catalog
    &#34;&#34;&#34;
    if isinstance(catalog_reference, CatalogReference):
        fullpath = os.path.join(
            catalog_path, catalog_reference.catalogname + &#34;.xosc&#34;
        )
        name_ref = catalog_reference.catalogname
    else:
        fullpath = os.path.join(catalog_path, catalog_reference + &#34;.xosc&#34;)
        name_ref = catalog_reference

    with open(fullpath, &#34;r&#34;) as f:
        catalog_element = ET.parse(f).find(&#34;Catalog&#34;)
        self.all_catalogs[name_ref] = catalog_element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.xosc_reader.CatalogLoader.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, catalog_reference)</span>
</code></dt>
<dd>
<div class="desc"><p>parse reads reads a specific entry from a loaded catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalog_reference (CatalogReference): reference to the catalog
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>The catalog entry
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, catalog_reference):
    &#34;&#34;&#34;parse reads reads a specific entry from a loaded catalog

    Parameters
    ----------
        catalog_reference (CatalogReference): reference to the catalog

    Returns
    -------
        The catalog entry

    &#34;&#34;&#34;
    if not catalog_reference.catalogname in self.all_catalogs:
        raise NoCatalogFoundError(
            &#34;Catalog &#34; + catalog_reference.catalogname + &#34; is not loaded yet.&#34;
        )
    catalog = self.all_catalogs[catalog_reference.catalogname]
    for entry in catalog:
        if entry.tag == &#34;Vehicle&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Vehicle.parse(entry)
        elif entry.tag == &#34;Pedestrian&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Pedestrian.parse(entry)
        elif entry.tag == &#34;Controller&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Controller.parse(entry)
        elif entry.tag == &#34;MiscObject&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return MiscObject.parse(entry)
        elif entry.tag == &#34;Environment&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Environment.parse(entry)
        elif entry.tag == &#34;Maneuver&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Maneuver.parse(entry)
        elif entry.tag == &#34;Trajectory&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Trajectory.parse(entry)
        elif entry.tag == &#34;Route&#34;:
            if entry.attrib[&#34;name&#34;] == catalog_reference.entryname:
                return Route.parse(entry)
        else:
            raise NotImplementedError(&#34;This catalogtype is not supported yet.&#34;)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.xosc_reader.CatalogLoader.read_entry"><code class="name flex">
<span>def <span class="ident">read_entry</span></span>(<span>self, catalog_reference, catalog_path)</span>
</code></dt>
<dd>
<div class="desc"><p>read_entry loads and reads a catalog directly (both load_catalog, and parse)</p>
<p>The catalog will still be loaded and can be used with parse after this.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalog_reference (CatalogReference): reference to the catalog

catalog_path (str): path to the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_entry(self, catalog_reference, catalog_path):
    &#34;&#34;&#34;read_entry loads and reads a catalog directly (both load_catalog, and parse)

    The catalog will still be loaded and can be used with parse after this.

    Parameters
    ----------
        catalog_reference (CatalogReference): reference to the catalog

        catalog_path (str): path to the catalog
    &#34;&#34;&#34;
    self.load_catalog(catalog_reference, catalog_path)
    return self.parse(catalog_reference)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scenariogeneration.xosc.xosc_reader.CatalogReader" href="#scenariogeneration.xosc.xosc_reader.CatalogReader">CatalogReader</a></code></li>
<li><code><a title="scenariogeneration.xosc.xosc_reader.ParameterDeclarationReader" href="#scenariogeneration.xosc.xosc_reader.ParameterDeclarationReader">ParameterDeclarationReader</a></code></li>
<li><code><a title="scenariogeneration.xosc.xosc_reader.ParseOpenScenario" href="#scenariogeneration.xosc.xosc_reader.ParseOpenScenario">ParseOpenScenario</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.xosc_reader.CatalogLoader" href="#scenariogeneration.xosc.xosc_reader.CatalogLoader">CatalogLoader</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.xosc_reader.CatalogLoader.load_catalog" href="#scenariogeneration.xosc.xosc_reader.CatalogLoader.load_catalog">load_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.xosc_reader.CatalogLoader.parse" href="#scenariogeneration.xosc.xosc_reader.CatalogLoader.parse">parse</a></code></li>
<li><code><a title="scenariogeneration.xosc.xosc_reader.CatalogLoader.read_entry" href="#scenariogeneration.xosc.xosc_reader.CatalogLoader.read_entry">read_entry</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>