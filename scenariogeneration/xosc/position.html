<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xosc.position API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.position</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.position.Clothoid"><code class="flex name class">
<span>class <span class="ident">Clothoid</span></span>
<span>(</span><span>curvature: float,<br>curvature_change: float,<br>length: float,<br>startposition: scenariogeneration.xosc.utils._PositionType,<br>starttime: float | None = None,<br>stoptime: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Clothoid(_TrajectoryShape):
    &#34;&#34;&#34;The Clothoid class creates a Clothoid shape.

    Parameters
    ----------
    curvature : float
        Start curvature of the clothoid.
    curvature_change : float
        Rate of clothoid curvature change.
    length : float
        Length of the clothoid.
    startposition : _PositionType
        Start position of the clothoid.
    starttime : float, optional
        Start time of the clothoid. Default is None.
    stoptime : float, optional
        End time of the clothoid. Default is None.

    Attributes
    ----------
    curvature : float
        Start curvature of the clothoid.
    curvature_change : float
        Rate of clothoid curvature change.
    length : float
        Length of the clothoid.
    startposition : _PositionType
        Start position of the clothoid.
    starttime : float
        Start time of the clothoid. Default is None.
    stoptime : float
        End time of the clothoid. Default is None.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        curvature: float,
        curvature_change: float,
        length: float,
        startposition: _PositionType,
        starttime: Optional[float] = None,
        stoptime: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Clothoid.

        Parameters
        ----------
        curvature : float
            Start curvature of the clothoid.
        curvature_change : float
            Rate of clothoid curvature change.
        length : float
            Length of the clothoid.
        startposition : _PositionType
            Start position of the clothoid.
        starttime : float, optional
            Start time of the clothoid. Default is None.
        stoptime : float, optional
            End time of the clothoid. Default is None.
        &#34;&#34;&#34;
        # TODO: The input order needs to be changed, curvature_change has
        # cardinality 0, breaking change!
        self.curvature = convert_float(curvature)
        self.curvature_change = convert_float(curvature_change)
        self.length = convert_float(length)
        if not isinstance(startposition, _PositionType):
            raise TypeError(&#34;position input is not a valid position&#34;)
        self.startposition = startposition

        self.starttime = convert_float(starttime)
        self.stoptime = convert_float(stoptime)
        if (self.starttime is None and self.stoptime is not None) or (
            self.starttime is not None and self.stoptime is None
        ):
            raise ValueError(
                &#34;Both start and stoptime has to be set, or none of them&#34;
            )

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Clothoid):
            if (
                self.get_attributes() == other.get_attributes()
                and self.startposition == other.startposition
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Clothoid&#34;:
        &#34;&#34;&#34;Parse the XML element of Clothoid.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Clothoid element (same as generated by the class itself).

        Returns
        -------
        Clothoid
            A Clothoid object.
        &#34;&#34;&#34;
        clothoid_element = find_mandatory_field(element, &#34;Clothoid&#34;)
        start_position = _PositionFactory.parse_position(
            find_mandatory_field(clothoid_element, &#34;Position&#34;)
        )
        length = convert_float(clothoid_element.attrib[&#34;length&#34;])
        curvature = convert_float(clothoid_element.attrib[&#34;curvature&#34;])
        starttime = None
        stoptime = None
        if &#34;startTime&#34; in clothoid_element.attrib:
            starttime = convert_float(clothoid_element.attrib[&#34;startTime&#34;])

        if &#34;stopTime&#34; in clothoid_element.attrib:
            stoptime = convert_float(clothoid_element.attrib[&#34;stopTime&#34;])

        if &#34;curvatureDot&#34; in clothoid_element.attrib:
            curvature_change = convert_float(
                clothoid_element.element[&#34;curvaturePrime&#34;]
            )
        elif &#34;curvaturePrime&#34; in clothoid_element.attrib:
            curvature_change = convert_float(
                clothoid_element.attrib[&#34;curvaturePrime&#34;]
            )
        else:
            raise XMLStructureError(
                &#34;curatureDot or curvaturePrime not found in Clothoid&#34;
            )
        return Clothoid(
            curvature,
            curvature_change,
            length,
            start_position,
            starttime,
            stoptime,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the Clothoid as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Clothoid.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;curvature&#34;] = str(self.curvature)
        if self.isVersion(minor=0):
            retdict[&#34;curvatureDot&#34;] = str(self.curvature_change)
        else:
            retdict[&#34;curvaturePrime&#34;] = str(self.curvature_change)
        retdict[&#34;length&#34;] = str(self.length)
        if self.starttime is not None:
            retdict[&#34;startTime&#34;] = str(self.starttime)
            retdict[&#34;stopTime&#34;] = str(self.stoptime)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Clothoid.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Clothoid.
        &#34;&#34;&#34;
        shape = ET.Element(&#34;Shape&#34;)
        element = ET.SubElement(
            shape, &#34;Clothoid&#34;, attrib=self.get_attributes()
        )
        element.append(self.startposition.get_element())

        return shape</code></pre>
</details>
<div class="desc"><p>The Clothoid class creates a Clothoid shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>Start curvature of the clothoid.</dd>
<dt><strong><code>curvature_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of clothoid curvature change.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the clothoid.</dd>
<dt><strong><code>startposition</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Start position of the clothoid.</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start time of the clothoid. Default is None.</dd>
<dt><strong><code>stoptime</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>End time of the clothoid. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>Start curvature of the clothoid.</dd>
<dt><strong><code>curvature_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of clothoid curvature change.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the clothoid.</dd>
<dt><strong><code>startposition</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Start position of the clothoid.</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>float</code></dt>
<dd>Start time of the clothoid. Default is None.</dd>
<dt><strong><code>stoptime</code></strong> :&ensp;<code>float</code></dt>
<dd>End time of the clothoid. Default is None.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the Clothoid.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>curvature</code></strong> :&ensp;<code>float</code></dt>
<dd>Start curvature of the clothoid.</dd>
<dt><strong><code>curvature_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of clothoid curvature change.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the clothoid.</dd>
<dt><strong><code>startposition</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Start position of the clothoid.</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start time of the clothoid. Default is None.</dd>
<dt><strong><code>stoptime</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>End time of the clothoid. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.position._TrajectoryShape</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Clothoid.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Clothoid" href="#scenariogeneration.xosc.position.Clothoid">Clothoid</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Clothoid&#34;:
    &#34;&#34;&#34;Parse the XML element of Clothoid.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Clothoid element (same as generated by the class itself).

    Returns
    -------
    Clothoid
        A Clothoid object.
    &#34;&#34;&#34;
    clothoid_element = find_mandatory_field(element, &#34;Clothoid&#34;)
    start_position = _PositionFactory.parse_position(
        find_mandatory_field(clothoid_element, &#34;Position&#34;)
    )
    length = convert_float(clothoid_element.attrib[&#34;length&#34;])
    curvature = convert_float(clothoid_element.attrib[&#34;curvature&#34;])
    starttime = None
    stoptime = None
    if &#34;startTime&#34; in clothoid_element.attrib:
        starttime = convert_float(clothoid_element.attrib[&#34;startTime&#34;])

    if &#34;stopTime&#34; in clothoid_element.attrib:
        stoptime = convert_float(clothoid_element.attrib[&#34;stopTime&#34;])

    if &#34;curvatureDot&#34; in clothoid_element.attrib:
        curvature_change = convert_float(
            clothoid_element.element[&#34;curvaturePrime&#34;]
        )
    elif &#34;curvaturePrime&#34; in clothoid_element.attrib:
        curvature_change = convert_float(
            clothoid_element.attrib[&#34;curvaturePrime&#34;]
        )
    else:
        raise XMLStructureError(
            &#34;curatureDot or curvaturePrime not found in Clothoid&#34;
        )
    return Clothoid(
        curvature,
        curvature_change,
        length,
        start_position,
        starttime,
        stoptime,
    )</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Clothoid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Clothoid element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Clothoid" href="#scenariogeneration.xosc.position.Clothoid">Clothoid</a></code></dt>
<dd>A Clothoid object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Clothoid.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the Clothoid as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the Clothoid.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;curvature&#34;] = str(self.curvature)
    if self.isVersion(minor=0):
        retdict[&#34;curvatureDot&#34;] = str(self.curvature_change)
    else:
        retdict[&#34;curvaturePrime&#34;] = str(self.curvature_change)
    retdict[&#34;length&#34;] = str(self.length)
    if self.starttime is not None:
        retdict[&#34;startTime&#34;] = str(self.starttime)
        retdict[&#34;stopTime&#34;] = str(self.stoptime)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Clothoid as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the Clothoid.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Clothoid.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Clothoid.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Clothoid.
    &#34;&#34;&#34;
    shape = ET.Element(&#34;Shape&#34;)
    element = ET.SubElement(
        shape, &#34;Clothoid&#34;, attrib=self.get_attributes()
    )
    element.append(self.startposition.get_element())

    return shape</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Clothoid.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Clothoid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.ClothoidSpline"><code class="flex name class">
<span>class <span class="ident">ClothoidSpline</span></span>
<span>(</span><span>segments: list[<a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a>],<br>time_end: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClothoidSpline(_TrajectoryShape):
    &#34;&#34;&#34;
    The ClothoidSpline class creates a ClothoidSpline shape.

    Parameters
    ----------
    segments : List[ClothoidSplineSegment]
        A list of ClothoidSplineSegments.
    time_end : float
        Optional time specification at the end of the clothoid spline curve.
        Required if timeStart in ClothoidSplineSegment is specified.

    Attributes
    ----------
    segments : List[ClothoidSplineSegment]
        A list of ClothoidSplineSegment objects that define the segments of the clothoid spline.
    time_end : float, optional
        time specification at the end of the clothoid spline curve.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns
        an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        segments: list[ClothoidSplineSegment],
        time_end: Optional[float] = None,
    ):
        &#34;&#34;&#34;Initialize the ClothoidSpline.

        Parameters
        ----------
        segments : List[ClothoidSplineSegment]
            A list of ClothoidSplineSegments.
        time_end : float
            Optional time specification at the end of the clothoid spline curve.
            Required if timeStart in ClothoidSplineSegment is specified.
        &#34;&#34;&#34;

        self.segments = segments
        self.time_end = convert_float(time_end)

    def __eq__(self, other):
        if not isinstance(other, ClothoidSpline):
            return False
        return (
            self.segments == other.segments and self.time_end == other.time_end
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the ClothoidSpline as a dictionary.&#34;&#34;&#34;
        attributes = {}
        if self.time_end is not None:
            attributes[&#34;timeEnd&#34;] = str(self.time_end)
        return attributes

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the ClothoidSpline.&#34;&#34;&#34;
        if self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;ClothoidSpline was introduced in OpenSCENARIO V1.3&#34;
            )

        shape = ET.Element(&#34;Shape&#34;)
        element = ET.SubElement(
            shape, &#34;ClothoidSpline&#34;, attrib=self.get_attributes()
        )
        for segment in self.segments:
            element.append(segment.get_element())
        return shape

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ClothoidSpline&#34;:
        &#34;&#34;&#34;Parse the XML element of ClothoidSpline.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ClothoidSpline element.

        Returns
        -------
        ClothoidSpline
            An instance of ClothoidSpline.
        &#34;&#34;&#34;
        clothoid_spline_element = find_mandatory_field(
            element, &#34;ClothoidSpline&#34;
        )
        time_end = convert_float(clothoid_spline_element.attrib.get(&#34;timeEnd&#34;))
        segments = []

        for segment_element in clothoid_spline_element.findall(
            &#34;ClothoidSplineSegment&#34;
        ):
            segments.append(ClothoidSplineSegment.parse(segment_element))

        return ClothoidSpline(segments=segments, time_end=time_end)</code></pre>
</details>
<div class="desc"><p>The ClothoidSpline class creates a ClothoidSpline shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>List[<a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a>]</code></dt>
<dd>A list of ClothoidSplineSegments.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional time specification at the end of the clothoid spline curve.
Required if timeStart in ClothoidSplineSegment is specified.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>List[<a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a>]</code></dt>
<dd>A list of ClothoidSplineSegment objects that define the segments of the clothoid spline.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>time specification at the end of the clothoid spline curve.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns
an instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ClothoidSpline.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>List[<a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a>]</code></dt>
<dd>A list of ClothoidSplineSegments.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional time specification at the end of the clothoid spline curve.
Required if timeStart in ClothoidSplineSegment is specified.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.position._TrajectoryShape</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ClothoidSpline.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.ClothoidSpline" href="#scenariogeneration.xosc.position.ClothoidSpline">ClothoidSpline</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ClothoidSpline&#34;:
    &#34;&#34;&#34;Parse the XML element of ClothoidSpline.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ClothoidSpline element.

    Returns
    -------
    ClothoidSpline
        An instance of ClothoidSpline.
    &#34;&#34;&#34;
    clothoid_spline_element = find_mandatory_field(
        element, &#34;ClothoidSpline&#34;
    )
    time_end = convert_float(clothoid_spline_element.attrib.get(&#34;timeEnd&#34;))
    segments = []

    for segment_element in clothoid_spline_element.findall(
        &#34;ClothoidSplineSegment&#34;
    ):
        segments.append(ClothoidSplineSegment.parse(segment_element))

    return ClothoidSpline(segments=segments, time_end=time_end)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of ClothoidSpline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ClothoidSpline element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.ClothoidSpline" href="#scenariogeneration.xosc.position.ClothoidSpline">ClothoidSpline</a></code></dt>
<dd>An instance of ClothoidSpline.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ClothoidSpline.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the ClothoidSpline as a dictionary.&#34;&#34;&#34;
    attributes = {}
    if self.time_end is not None:
        attributes[&#34;timeEnd&#34;] = str(self.time_end)
    return attributes</code></pre>
</details>
<div class="desc"><p>Return the attributes of the ClothoidSpline as a dictionary.</p></div>
</dd>
<dt id="scenariogeneration.xosc.position.ClothoidSpline.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the ClothoidSpline.&#34;&#34;&#34;
    if self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;ClothoidSpline was introduced in OpenSCENARIO V1.3&#34;
        )

    shape = ET.Element(&#34;Shape&#34;)
    element = ET.SubElement(
        shape, &#34;ClothoidSpline&#34;, attrib=self.get_attributes()
    )
    for segment in self.segments:
        element.append(segment.get_element())
    return shape</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the ClothoidSpline.</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.ClothoidSplineSegment"><code class="flex name class">
<span>class <span class="ident">ClothoidSplineSegment</span></span>
<span>(</span><span>curvature_start: float,<br>curvature_end: float,<br>length: float,<br>h_offset: float | None = None,<br>time_start: float | None = None,<br>position_start: scenariogeneration.xosc.utils._PositionType | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClothoidSplineSegment(VersionBase):
    &#34;&#34;&#34;
    The ClothoidSplineSegment class creates a segment of a clothoid spline.

     Parameters
    ----------
    curvature_start: float
        Start curvature of the clothoid spline segment.unit:[1/m]
    curvature_end: float
        End curvature of the clothoid spline segment.unit:[1/m]
    length: float
        Length of the clothoid segment.unit: [m]
    h_offset: float
        Optional heading offset in radians of the clothoid segment relative to end of the
         previous segment or to position_start if present. Default is 0.
    time_start: float
        Optional time specification at the start of the clothoid segment.unit: [s]
    position_start:  list of _PositionType
        optional starting position of a clothoid segment. If position_start is omitted for
        the first segment, the entity&#39;s current position is used. For subsequent segments,
        the end position of the previous segment is used.
        If only the heading is omitted, the heading of the previous segment&#39;s end position
        shall be used.

    Attributes
    ----------
    curvature_start : float
        Start curvature of the clothoid spline segment. unit: [1/m]
    curvature_end : float
        End curvature of the clothoid spline segment. unit: [1/m]
    length : float
        Length of the clothoid segment. unit: [m]
    h_offset : float
        Heading offset in radians of the clothoid segment relative to end of the previous segment
        or to position_start if present.
    time_start : float
        Time specification at the start of the clothoid segment. unit: [s]
    position_start : _PositionType
        Starting position of a clothoid segment.

    Methods
    -------

    parse(element)
        Parses an ElementTree created by the class and returns
        an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.

    &#34;&#34;&#34;

    def __init__(
        self,
        curvature_start: float,
        curvature_end: float,
        length: float,
        h_offset: Optional[float] = None,
        time_start: Optional[float] = None,
        position_start: Optional[_PositionType] = None,
    ):
        &#34;&#34;&#34;Initialize the ClothoidSplineSegment.

        Parameters
        ----------
        curvature_start: float
            Start curvature of the clothoid spline segment.unit:[1/m]
        curvature_end: float
            End curvature of the clothoid spline segment.unit:[1/m]
        length: float
                Length of the clothoid segment.unit: [m]
        h_offset: float
            Optional heading offset in radians of the clothoid segment relative to end of the
            previous segment or to position_start if present. Default is 0.
        time_start: float
                Optional time specification at the start of the clothoid segment.unit: [s]
        position_start:  list of _PositionType
            optional starting position of a clothoid segment. If position_start is omitted for
            the first segment, the entity&#39;s current position is used. For subsequent segments,
            the end position of the previous segment is used.
            If only the heading is omitted, the heading of the previous segment&#39;s end position
            shall be used.
        &#34;&#34;&#34;
        self.curvature_end = convert_float(curvature_end)
        self.curvature_start = convert_float(curvature_start)
        self.h_offset = convert_float(h_offset)
        if length &lt;= 0:
            raise ValueError(
                &#34;The clothoid segment length must be greater than zero&#34;
            )
        self.length = convert_float(length)
        self.time_start = convert_float(time_start)

        if position_start is not None:
            if not isinstance(position_start, list) or not all(
                isinstance(pos, _PositionType) for pos in position_start
            ):
                raise TypeError(
                    &#34;position_start elements must be of type _PositionType or None&#34;
                )
        self.position_start = position_start

    def __eq__(self, other):
        if not isinstance(other, ClothoidSplineSegment):
            return False
        return (
            self.curvature_start == other.curvature_start
            and self.curvature_end == other.curvature_end
            and self.length == other.length
            and self.h_offset == other.h_offset
            and self.time_start == other.time_start
            and self.position_start == other.position_start
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the ClothoidSplineSegment as a dictionary.&#34;&#34;&#34;
        attributes = {
            &#34;curvatureStart&#34;: str(self.curvature_start),
            &#34;curvatureEnd&#34;: str(self.curvature_end),
            &#34;length&#34;: str(self.length),
        }
        if self.h_offset is not None:
            attributes[&#34;hOffset&#34;] = str(self.h_offset)
        if self.time_start is not None:
            attributes[&#34;timeStart&#34;] = str(self.time_start)
        return attributes

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree representation of the ClothoidSplineSegment.&#34;&#34;&#34;
        if self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;ClothoidSplineSegment was introduced in OpenSCENARIO V1.3&#34;
            )
        element = ET.Element(
            &#34;ClothoidSplineSegment&#34;, attrib=self.get_attributes()
        )
        if self.position_start:
            for position in self.position_start:
                element.append(position.get_element(&#34;PositionStart&#34;))
        return element

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ClothoidSplineSegment&#34;:
        &#34;&#34;&#34;Parse the XML element of ClothoidSplineSegment.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ClothoidSplineSegment element.

        Returns
        -------
        ClothoidSplineSegment
            An instance of ClothoidSplineSegment.
        &#34;&#34;&#34;
        curvature_start = convert_float(element.attrib[&#34;curvatureStart&#34;])
        curvature_end = convert_float(element.attrib[&#34;curvatureEnd&#34;])
        length = convert_float(element.attrib[&#34;length&#34;])
        h_offset = convert_float(element.attrib.get(&#34;hOffset&#34;))
        time_start = convert_float(element.attrib.get(&#34;timeStart&#34;))
        position_start = []

        pos_start_elem = element.find(&#34;PositionStart&#34;)
        if pos_start_elem is not None:
            position_start.append(
                _PositionFactory.parse_position(pos_start_elem)
            )

        return ClothoidSplineSegment(
            curvature_end=curvature_end,
            curvature_start=curvature_start,
            length=length,
            h_offset=h_offset,
            time_start=time_start,
            position_start=position_start,
        )</code></pre>
</details>
<div class="desc"><p>The ClothoidSplineSegment class creates a segment of a clothoid spline.</p>
<h2 id="parameters">Parameters</h2>
<p>curvature_start: float
Start curvature of the clothoid spline segment.unit:[1/m]
curvature_end: float
End curvature of the clothoid spline segment.unit:[1/m]
length: float
Length of the clothoid segment.unit: [m]
h_offset: float
Optional heading offset in radians of the clothoid segment relative to end of the
previous segment or to position_start if present. Default is 0.
time_start: float
Optional time specification at the start of the clothoid segment.unit: [s]
position_start:
list of _PositionType
optional starting position of a clothoid segment. If position_start is omitted for
the first segment, the entity's current position is used. For subsequent segments,
the end position of the previous segment is used.
If only the heading is omitted, the heading of the previous segment's end position
shall be used.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>curvature_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start curvature of the clothoid spline segment. unit: [1/m]</dd>
<dt><strong><code>curvature_end</code></strong> :&ensp;<code>float</code></dt>
<dd>End curvature of the clothoid spline segment. unit: [1/m]</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the clothoid segment. unit: [m]</dd>
<dt><strong><code>h_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Heading offset in radians of the clothoid segment relative to end of the previous segment
or to position_start if present.</dd>
<dt><strong><code>time_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Time specification at the start of the clothoid segment. unit: [s]</dd>
<dt><strong><code>position_start</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Starting position of a clothoid segment.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns
an instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ClothoidSplineSegment.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>curvature_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start curvature of the clothoid spline segment.unit:[1/m]</dd>
<dt><strong><code>curvature_end</code></strong> :&ensp;<code>float</code></dt>
<dd>End curvature of the clothoid spline segment.unit:[1/m]</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the clothoid segment.unit: [m]</dd>
<dt><strong><code>h_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional heading offset in radians of the clothoid segment relative to end of the
previous segment or to position_start if present. Default is 0.</dd>
<dt><strong><code>time_start</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional time specification at the start of the clothoid segment.unit: [s]</dd>
<dt><strong><code>position_start</code></strong> :&ensp;<code> list</code> of <code>_PositionType</code></dt>
<dd>optional starting position of a clothoid segment. If position_start is omitted for
the first segment, the entity's current position is used. For subsequent segments,
the end position of the previous segment is used.
If only the heading is omitted, the heading of the previous segment's end position
shall be used.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ClothoidSplineSegment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ClothoidSplineSegment&#34;:
    &#34;&#34;&#34;Parse the XML element of ClothoidSplineSegment.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ClothoidSplineSegment element.

    Returns
    -------
    ClothoidSplineSegment
        An instance of ClothoidSplineSegment.
    &#34;&#34;&#34;
    curvature_start = convert_float(element.attrib[&#34;curvatureStart&#34;])
    curvature_end = convert_float(element.attrib[&#34;curvatureEnd&#34;])
    length = convert_float(element.attrib[&#34;length&#34;])
    h_offset = convert_float(element.attrib.get(&#34;hOffset&#34;))
    time_start = convert_float(element.attrib.get(&#34;timeStart&#34;))
    position_start = []

    pos_start_elem = element.find(&#34;PositionStart&#34;)
    if pos_start_elem is not None:
        position_start.append(
            _PositionFactory.parse_position(pos_start_elem)
        )

    return ClothoidSplineSegment(
        curvature_end=curvature_end,
        curvature_start=curvature_start,
        length=length,
        h_offset=h_offset,
        time_start=time_start,
        position_start=position_start,
    )</code></pre>
</details>
<div class="desc"><p>Parse the XML element of ClothoidSplineSegment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ClothoidSplineSegment element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a></code></dt>
<dd>An instance of ClothoidSplineSegment.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ClothoidSplineSegment.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the ClothoidSplineSegment as a dictionary.&#34;&#34;&#34;
    attributes = {
        &#34;curvatureStart&#34;: str(self.curvature_start),
        &#34;curvatureEnd&#34;: str(self.curvature_end),
        &#34;length&#34;: str(self.length),
    }
    if self.h_offset is not None:
        attributes[&#34;hOffset&#34;] = str(self.h_offset)
    if self.time_start is not None:
        attributes[&#34;timeStart&#34;] = str(self.time_start)
    return attributes</code></pre>
</details>
<div class="desc"><p>Return the attributes of the ClothoidSplineSegment as a dictionary.</p></div>
</dd>
<dt id="scenariogeneration.xosc.position.ClothoidSplineSegment.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree representation of the ClothoidSplineSegment.&#34;&#34;&#34;
    if self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;ClothoidSplineSegment was introduced in OpenSCENARIO V1.3&#34;
        )
    element = ET.Element(
        &#34;ClothoidSplineSegment&#34;, attrib=self.get_attributes()
    )
    if self.position_start:
        for position in self.position_start:
            element.append(position.get_element(&#34;PositionStart&#34;))
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree representation of the ClothoidSplineSegment.</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.ControlPoint"><code class="flex name class">
<span>class <span class="ident">ControlPoint</span></span>
<span>(</span><span>position: scenariogeneration.xosc.utils._PositionType,<br>time: float | None = None,<br>weight: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControlPoint(VersionBase):
    &#34;&#34;&#34;The ControlPoint class is used by Nurbs to define points.

    Parameters
    ----------
    position : _PositionType
        A position for the point.
    time : float, optional
        Optional time specification of the point. Default is None.
    weight : float, optional
        Optional weight of the point. Default is None.

    Attributes
    ----------
    position : _PositionType
        A position for the point.
    time : float
        Optional time specification of the point. Default is None.
    weight : float
        Optional weight of the point. Default is None.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        position: _PositionType,
        time: Optional[float] = None,
        weight: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the ControlPoint.

        Parameters
        ----------
        position : _PositionType
            A position for the point.
        time : float, optional
            Optional time specification of the point. Default is None.
        weight : float, optional
            Optional weight of the point. Default is None.
        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid position&#34;)
        self.position = position
        self.time = convert_float(time)
        self.weight = convert_float(weight)

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, ControlPoint):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ControlPoint&#34;:
        &#34;&#34;&#34;Parse the XML element of ControlPoint.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ControlPoint element (same as generated by the class
            itself).

        Returns
        -------
        ControlPoint
            A ControlPoint object.
        &#34;&#34;&#34;
        time = None
        weight = None
        if &#34;time&#34; in element.attrib:
            time = convert_float(element.attrib[&#34;time&#34;])
        if &#34;weight&#34; in element.attrib:
            weight = convert_float(element.attrib[&#34;weight&#34;])
        pos_element = find_mandatory_field(element, &#34;Position&#34;)
        position = _PositionFactory.parse_position(pos_element)

        return ControlPoint(position, time, weight)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the ControlPoint as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the ControlPoint.
        &#34;&#34;&#34;
        retdict = {}
        if self.time is not None:
            retdict[&#34;time&#34;] = str(self.time)
        if self.weight is not None:
            retdict[&#34;weight&#34;] = str(self.weight)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the ControlPoint.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the ControlPoint.
        &#34;&#34;&#34;
        element = ET.Element(&#34;ControlPoint&#34;, attrib=self.get_attributes())
        element.append(self.position.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The ControlPoint class is used by Nurbs to define points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>A position for the point.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Optional time specification of the point. Default is None.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Optional weight of the point. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>A position for the point.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional time specification of the point. Default is None.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional weight of the point. Default is None.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ControlPoint.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>A position for the point.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Optional time specification of the point. Default is None.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Optional weight of the point. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ControlPoint.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ControlPoint&#34;:
    &#34;&#34;&#34;Parse the XML element of ControlPoint.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ControlPoint element (same as generated by the class
        itself).

    Returns
    -------
    ControlPoint
        A ControlPoint object.
    &#34;&#34;&#34;
    time = None
    weight = None
    if &#34;time&#34; in element.attrib:
        time = convert_float(element.attrib[&#34;time&#34;])
    if &#34;weight&#34; in element.attrib:
        weight = convert_float(element.attrib[&#34;weight&#34;])
    pos_element = find_mandatory_field(element, &#34;Position&#34;)
    position = _PositionFactory.parse_position(pos_element)

    return ControlPoint(position, time, weight)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of ControlPoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ControlPoint element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a></code></dt>
<dd>A ControlPoint object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.ControlPoint.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the ControlPoint as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the ControlPoint.
    &#34;&#34;&#34;
    retdict = {}
    if self.time is not None:
        retdict[&#34;time&#34;] = str(self.time)
    if self.weight is not None:
        retdict[&#34;weight&#34;] = str(self.weight)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the ControlPoint as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the ControlPoint.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.ControlPoint.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the ControlPoint.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the ControlPoint.
    &#34;&#34;&#34;
    element = ET.Element(&#34;ControlPoint&#34;, attrib=self.get_attributes())
    element.append(self.position.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the ControlPoint.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the ControlPoint.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.GeoPosition"><code class="flex name class">
<span>class <span class="ident">GeoPosition</span></span>
<span>(</span><span>latitude: float,<br>longitude: float,<br>height: float | None = None,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;,<br>vertical_road_selection: int = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoPosition(_PositionType):
    &#34;&#34;&#34;GeoPosition creates a GeoPosition in OpenSCENARIO.

    Parameters
    ----------
    latitue : float
        Latitude point on earth.
    longitude : float
        Longitude point on earth.
    height : float, optional
        Height above surface. Default is None.
    orientation : Orientation, optional
        Orientation of the entity. Default is Orientation().
    vertical_road_selection : int, optional
        Specifies which road to choose at a given lat/lon when multiple roads overlap,
         with 0 for the top road and negative values for roads below. Default is 0.

    Attributes
    ----------
    latitue : float
        Latitude point on earth.
    longitude : float
        Longitude point on earth.
    height : float
        Height above surface. Default is None.
    orientation : Orientation
        Orientation of the entity.
    vertical_road_selection : int
       Road selected at the given lat/lon when multiple roads overlap.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        latitude: float,
        longitude: float,
        height: Optional[float] = None,
        orientation: Orientation = Orientation(),
        vertical_road_selection: int = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the GeoPosition class.

        Parameters
        ----------
        latitue : float
            Latitude point on earth.
        longitude : float
            Longitude point on earth.
        height : float, optional
            Height above surface. Default is None.
        orientation : Orientation, optional
            Orientation of the entity. Default is Orientation().
        vertical_road_selection : int, optional
            Specifies which road to choose at a given lat/lon when multiple roads overlap,
             with 0 for the top road and negative values for roads below. Default is 0.
        &#34;&#34;&#34;
        self.longitude = convert_float(longitude)
        self.latitude = convert_float(latitude)
        self.height = convert_float(height)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orientation = orientation
        self.vertical_road_selection = convert_int(vertical_road_selection)

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, GeoPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orientation == other.orientation
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;GeoPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of GeoPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        GeoPosition
            A GeoPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;GeoPosition&#34;)
        if &#34;longitude&#34; in position_element.attrib:
            longitude = convert_float(position_element.attrib[&#34;longitude&#34;])
        elif &#34;longitudeDeg&#34; in position_element.attrib:
            longitude = convert_float(position_element.attrib[&#34;longitudeDeg&#34;])
        else:
            raise KeyError(&#34;Cannot find valid longitude for GeoPosition&#34;)

        if &#34;latitude&#34; in position_element.attrib:
            latitude = convert_float(position_element.attrib[&#34;latitude&#34;])
        elif &#34;latitudeDeg&#34; in position_element.attrib:
            latitude = convert_float(position_element.attrib[&#34;latitudeDeg&#34;])
        else:
            raise KeyError(&#34;Cannot find valid latitude for GeoPosition&#34;)

        if &#34;height&#34; in position_element.attrib:
            height = convert_float(position_element.attrib[&#34;height&#34;])
        elif &#34;altitude&#34; in position_element.attrib:
            height = convert_float(position_element.attrib[&#34;altitude&#34;])
        else:
            height = None

        vertical_road_selection = None
        if &#34;verticalRoadSelection&#34; in position_element.attrib:
            vertical_road_selection = convert_int(
                position_element.attrib[&#34;verticalRoadSelection&#34;]
            )

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return GeoPosition(
            latitude, longitude, height, orientation, vertical_road_selection
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the GeoPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the GeoPosition.
        &#34;&#34;&#34;
        retdict = {}
        if self.isVersion(minor=1):
            retdict[&#34;longitude&#34;] = str(self.longitude)
            retdict[&#34;latitude&#34;] = str(self.latitude)
            if self.height is not None:
                retdict[&#34;height&#34;] = str(self.height)
        else:
            retdict[&#34;longitudeDeg&#34;] = str(self.longitude)
            retdict[&#34;latitudeDeg&#34;] = str(self.latitude)
            if self.height is not None:
                retdict[&#34;altitude&#34;] = str(self.height)
            if self.isVersionEqLarger(minor=3):
                if self.vertical_road_selection is not None:
                    retdict[&#34;verticalRoadSelection&#34;] = str(
                        self.vertical_road_selection
                    )
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the GeoPosition.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the GeoPosition.
        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;GeoPosition was introduced in OpenSCENARIO V1.1&#34;
            )
        element = ET.Element(elementname)
        traj_element = ET.SubElement(
            element, &#34;GeoPosition&#34;, self.get_attributes()
        )
        traj_element.append(self.orientation.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>GeoPosition creates a GeoPosition in OpenSCENARIO.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>latitue</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude point on earth.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude point on earth.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height above surface. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
<dt><strong><code>vertical_road_selection</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Specifies which road to choose at a given lat/lon when multiple roads overlap,
with 0 for the top road and negative values for roads below. Default is 0.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>latitue</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude point on earth.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude point on earth.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Height above surface. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the entity.</dd>
<dt><strong><code>vertical_road_selection</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Road selected at the given lat/lon when multiple roads overlap.</p>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the GeoPosition class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>latitue</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude point on earth.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude point on earth.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Height above surface. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
<dt><strong><code>vertical_road_selection</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Specifies which road to choose at a given lat/lon when multiple roads overlap,
with 0 for the top road and negative values for roads below. Default is 0.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.GeoPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.GeoPosition" href="#scenariogeneration.xosc.position.GeoPosition">GeoPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;GeoPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of GeoPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    GeoPosition
        A GeoPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;GeoPosition&#34;)
    if &#34;longitude&#34; in position_element.attrib:
        longitude = convert_float(position_element.attrib[&#34;longitude&#34;])
    elif &#34;longitudeDeg&#34; in position_element.attrib:
        longitude = convert_float(position_element.attrib[&#34;longitudeDeg&#34;])
    else:
        raise KeyError(&#34;Cannot find valid longitude for GeoPosition&#34;)

    if &#34;latitude&#34; in position_element.attrib:
        latitude = convert_float(position_element.attrib[&#34;latitude&#34;])
    elif &#34;latitudeDeg&#34; in position_element.attrib:
        latitude = convert_float(position_element.attrib[&#34;latitudeDeg&#34;])
    else:
        raise KeyError(&#34;Cannot find valid latitude for GeoPosition&#34;)

    if &#34;height&#34; in position_element.attrib:
        height = convert_float(position_element.attrib[&#34;height&#34;])
    elif &#34;altitude&#34; in position_element.attrib:
        height = convert_float(position_element.attrib[&#34;altitude&#34;])
    else:
        height = None

    vertical_road_selection = None
    if &#34;verticalRoadSelection&#34; in position_element.attrib:
        vertical_road_selection = convert_int(
            position_element.attrib[&#34;verticalRoadSelection&#34;]
        )

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return GeoPosition(
        latitude, longitude, height, orientation, vertical_road_selection
    )</code></pre>
</details>
<div class="desc"><p>Parse the XML element of GeoPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.GeoPosition" href="#scenariogeneration.xosc.position.GeoPosition">GeoPosition</a></code></dt>
<dd>A GeoPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.GeoPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the GeoPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the GeoPosition.
    &#34;&#34;&#34;
    retdict = {}
    if self.isVersion(minor=1):
        retdict[&#34;longitude&#34;] = str(self.longitude)
        retdict[&#34;latitude&#34;] = str(self.latitude)
        if self.height is not None:
            retdict[&#34;height&#34;] = str(self.height)
    else:
        retdict[&#34;longitudeDeg&#34;] = str(self.longitude)
        retdict[&#34;latitudeDeg&#34;] = str(self.latitude)
        if self.height is not None:
            retdict[&#34;altitude&#34;] = str(self.height)
        if self.isVersionEqLarger(minor=3):
            if self.vertical_road_selection is not None:
                retdict[&#34;verticalRoadSelection&#34;] = str(
                    self.vertical_road_selection
                )
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the GeoPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the GeoPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.GeoPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the GeoPosition.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the GeoPosition.
    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;GeoPosition was introduced in OpenSCENARIO V1.1&#34;
        )
    element = ET.Element(elementname)
    traj_element = ET.SubElement(
        element, &#34;GeoPosition&#34;, self.get_attributes()
    )
    traj_element.append(self.orientation.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the GeoPosition.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the GeoPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.LanePosition"><code class="flex name class">
<span>class <span class="ident">LanePosition</span></span>
<span>(</span><span>s: float,<br>offset: float,<br>lane_id: str,<br>road_id: str,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LanePosition(_PositionType):
    &#34;&#34;&#34;The LanePosition creates a LanePosition in OpenScenario.

    Parameters
    ----------
    s : float
        Length along the road.
    offset : float
        Offset from the center of the lane.
    lane_id : str
        Lane of the road.
    road_id : str
        ID of the road.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    s : float
        Length along the road.
    offset : float
        Offset from the center of the lane.
    lane_id : str
        Lane of the road.
    road_id : str
        ID of the road.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        offset: float,
        lane_id: str,
        road_id: str,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the LanePosition.

        Parameters
        ----------
        s : float
            Length along the road.
        offset : float
            Offset from the center of the lane.
        lane_id : str
            Lane of the road.
        road_id : str
            ID of the road.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        self.s = convert_float(s)
        self.lane_id = lane_id
        self.offset = convert_float(offset)
        self.road_id = road_id
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, LanePosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;LanePosition&#34;:
        &#34;&#34;&#34;Parse the XML element of LanePosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        LanePosition
            A LanePosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;LanePosition&#34;)
        roadId = position_element.attrib[&#34;roadId&#34;]
        s = convert_float(position_element.attrib[&#34;s&#34;])
        offset = convert_float(position_element.attrib[&#34;offset&#34;])
        laneid = position_element.attrib[&#34;laneId&#34;]

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return LanePosition(s, offset, laneid, roadId, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the LanePosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the LanePosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;roadId&#34;] = str(self.road_id)
        retdict[&#34;laneId&#34;] = str(self.lane_id)
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;offset&#34;] = str(self.offset)

        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the LanePosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the LanePosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        lanepos = ET.SubElement(
            element, &#34;LanePosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            lanepos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The LanePosition creates a LanePosition in OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset from the center of the lane.</dd>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>road_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset from the center of the lane.</dd>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>road_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the LanePosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset from the center of the lane.</dd>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>road_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.LanePosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.LanePosition" href="#scenariogeneration.xosc.position.LanePosition">LanePosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;LanePosition&#34;:
    &#34;&#34;&#34;Parse the XML element of LanePosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    LanePosition
        A LanePosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;LanePosition&#34;)
    roadId = position_element.attrib[&#34;roadId&#34;]
    s = convert_float(position_element.attrib[&#34;s&#34;])
    offset = convert_float(position_element.attrib[&#34;offset&#34;])
    laneid = position_element.attrib[&#34;laneId&#34;]

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return LanePosition(s, offset, laneid, roadId, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of LanePosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.LanePosition" href="#scenariogeneration.xosc.position.LanePosition">LanePosition</a></code></dt>
<dd>A LanePosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.LanePosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the LanePosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the LanePosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;roadId&#34;] = str(self.road_id)
    retdict[&#34;laneId&#34;] = str(self.lane_id)
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;offset&#34;] = str(self.offset)

    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the LanePosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the LanePosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.LanePosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the LanePosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the LanePosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    lanepos = ET.SubElement(
        element, &#34;LanePosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        lanepos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the LanePosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the LanePosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Nurbs"><code class="flex name class">
<span>class <span class="ident">Nurbs</span></span>
<span>(</span><span>order: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nurbs(_TrajectoryShape):
    &#34;&#34;&#34;The Nurbs class creates a Nurbs shape.

    Parameters
    ----------
    order : int
        Order of the nurbs.

    Attributes
    ----------
    order : int
        Order of the nurbs.
    controlpoints : list of ControlPoint
        A list of control points creating the nurbs.
    knots : list of float
        Knots of the nurbs (must be order + len(controlpoints)) in
        descending order.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    add_knots(knots)
        Adds the knots to the nurbs.
    add_control_point(controlpoint)
        Adds a control point to the nurbs.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, order: int) -&gt; None:
        &#34;&#34;&#34;Initialize the Nurbs.

        Parameters
        ----------
        order : int
            Order of the nurbs.
        &#34;&#34;&#34;
        self.order = convert_int(order)
        self.controlpoints = []
        self.knots = []

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Nurbs):
            if (
                self.get_attributes() == other.get_attributes()
                and self.controlpoints == other.controlpoints
                and self.knots == other.knots
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Nurbs&#34;:
        &#34;&#34;&#34;Parse the XML element of Nurbs.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Nurbs element (same as generated by the class itself).

        Returns
        -------
        Nurbs
            A Nurbs object.
        &#34;&#34;&#34;
        nurbs_element = find_mandatory_field(element, &#34;Nurbs&#34;)
        order = convert_int(nurbs_element.attrib[&#34;order&#34;])

        # print(pos_element)
        # position = _PositionFactory.parse_position(pos_element)
        nurbs = Nurbs(order)
        control_point_elements = nurbs_element.findall(&#34;ControlPoint&#34;)
        for cp in control_point_elements:
            nurbs.add_control_point(ControlPoint.parse(cp))
        knots_elements = nurbs_element.findall(&#34;Knot&#34;)
        knots = []
        for k in knots_elements:
            print(k)
            knots.append(convert_float(k.attrib[&#34;value&#34;]))
        nurbs.add_knots(knots)
        return nurbs

    def add_knots(self, knots: list[float]) -&gt; &#34;Nurbs&#34;:
        &#34;&#34;&#34;Add a list of knots to the Nurbs.

        Parameters
        ----------
        knots : list of float
            Knots of the nurbs (must be order + len(controlpoints)) in
            descending order.
        &#34;&#34;&#34;
        self.knots = knots
        return self

    def add_control_point(self, controlpoint: ControlPoint) -&gt; &#34;Nurbs&#34;:
        &#34;&#34;&#34;Add a control point to the Nurbs.

        Parameters
        ----------
        controlpoint : ControlPoint
            A contact point to add to the nurbs.
        &#34;&#34;&#34;
        if not isinstance(controlpoint, ControlPoint):
            raise TypeError(&#34;controlpoint input is not of type ControlPoint&#34;)
        self.controlpoints.append(controlpoint)
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the Nurbs as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Nurbs.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;order&#34;] = str(self.order)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Nurbs.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Nurbs.
        &#34;&#34;&#34;
        shape = ET.Element(&#34;Shape&#34;)
        element = ET.SubElement(shape, &#34;Nurbs&#34;, attrib=self.get_attributes())
        if (len(self.controlpoints) + self.order) != len(self.knots):
            raise ValueError(
                &#34;Number of knots is not equal to the number of contactpoints + order&#34;
            )
        for c in self.controlpoints:
            element.append(c.get_element())
        for k in self.knots:
            ET.SubElement(element, &#34;Knot&#34;, attrib={&#34;value&#34;: str(k)})

        return shape</code></pre>
</details>
<div class="desc"><p>The Nurbs class creates a Nurbs shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>Order of the nurbs.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>Order of the nurbs.</dd>
<dt><strong><code>controlpoints</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a></code></dt>
<dd>A list of control points creating the nurbs.</dd>
<dt><strong><code>knots</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Knots of the nurbs (must be order + len(controlpoints)) in
descending order.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
add_knots(knots)
Adds the knots to the nurbs.
add_control_point(controlpoint)
Adds a control point to the nurbs.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the Nurbs.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>Order of the nurbs.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.position._TrajectoryShape</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Nurbs.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Nurbs" href="#scenariogeneration.xosc.position.Nurbs">Nurbs</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Nurbs&#34;:
    &#34;&#34;&#34;Parse the XML element of Nurbs.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Nurbs element (same as generated by the class itself).

    Returns
    -------
    Nurbs
        A Nurbs object.
    &#34;&#34;&#34;
    nurbs_element = find_mandatory_field(element, &#34;Nurbs&#34;)
    order = convert_int(nurbs_element.attrib[&#34;order&#34;])

    # print(pos_element)
    # position = _PositionFactory.parse_position(pos_element)
    nurbs = Nurbs(order)
    control_point_elements = nurbs_element.findall(&#34;ControlPoint&#34;)
    for cp in control_point_elements:
        nurbs.add_control_point(ControlPoint.parse(cp))
    knots_elements = nurbs_element.findall(&#34;Knot&#34;)
    knots = []
    for k in knots_elements:
        print(k)
        knots.append(convert_float(k.attrib[&#34;value&#34;]))
    nurbs.add_knots(knots)
    return nurbs</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Nurbs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Nurbs element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Nurbs" href="#scenariogeneration.xosc.position.Nurbs">Nurbs</a></code></dt>
<dd>A Nurbs object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Nurbs.add_control_point"><code class="name flex">
<span>def <span class="ident">add_control_point</span></span>(<span>self,<br>controlpoint: <a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a>) ‑> <a title="scenariogeneration.xosc.position.Nurbs" href="#scenariogeneration.xosc.position.Nurbs">Nurbs</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_control_point(self, controlpoint: ControlPoint) -&gt; &#34;Nurbs&#34;:
    &#34;&#34;&#34;Add a control point to the Nurbs.

    Parameters
    ----------
    controlpoint : ControlPoint
        A contact point to add to the nurbs.
    &#34;&#34;&#34;
    if not isinstance(controlpoint, ControlPoint):
        raise TypeError(&#34;controlpoint input is not of type ControlPoint&#34;)
    self.controlpoints.append(controlpoint)
    return self</code></pre>
</details>
<div class="desc"><p>Add a control point to the Nurbs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>controlpoint</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a></code></dt>
<dd>A contact point to add to the nurbs.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Nurbs.add_knots"><code class="name flex">
<span>def <span class="ident">add_knots</span></span>(<span>self, knots: list[float]) ‑> <a title="scenariogeneration.xosc.position.Nurbs" href="#scenariogeneration.xosc.position.Nurbs">Nurbs</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_knots(self, knots: list[float]) -&gt; &#34;Nurbs&#34;:
    &#34;&#34;&#34;Add a list of knots to the Nurbs.

    Parameters
    ----------
    knots : list of float
        Knots of the nurbs (must be order + len(controlpoints)) in
        descending order.
    &#34;&#34;&#34;
    self.knots = knots
    return self</code></pre>
</details>
<div class="desc"><p>Add a list of knots to the Nurbs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>knots</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Knots of the nurbs (must be order + len(controlpoints)) in
descending order.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Nurbs.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the Nurbs as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the Nurbs.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;order&#34;] = str(self.order)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Nurbs as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the Nurbs.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Nurbs.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Nurbs.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Nurbs.
    &#34;&#34;&#34;
    shape = ET.Element(&#34;Shape&#34;)
    element = ET.SubElement(shape, &#34;Nurbs&#34;, attrib=self.get_attributes())
    if (len(self.controlpoints) + self.order) != len(self.knots):
        raise ValueError(
            &#34;Number of knots is not equal to the number of contactpoints + order&#34;
        )
    for c in self.controlpoints:
        element.append(c.get_element())
    for k in self.knots:
        ET.SubElement(element, &#34;Knot&#34;, attrib={&#34;value&#34;: str(k)})

    return shape</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Nurbs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Nurbs.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Polygon"><code class="flex name class">
<span>class <span class="ident">Polygon</span></span>
<span>(</span><span>positions: list[scenariogeneration.xosc.utils._PositionType])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polygon(VersionBase):
    &#34;&#34;&#34;The Polygon class creates a polygon used by the TrafficArea class.

    Parameters
    ----------
    positions : list of Position
        A list of positions that define the polygon.

    Attributes
    ----------
    positions : list of Position
        A list of positions that define the polygon.
    &#34;&#34;&#34;

    def __init__(self, positions: list[_PositionType]) -&gt; None:
        if len(positions) &lt; 3:
            raise ValueError(&#34;Polygon must have at least 3 positions&#34;)
        if not isinstance(positions, list) or not all(
            isinstance(p, _PositionType) for p in positions
        ):
            raise TypeError(
                &#34;positions input is not a list of PositionType objects&#34;
            )
        if positions:
            first_type = type(positions[0])
            if not all(isinstance(p, first_type) for p in positions):
                raise TypeError(
                    &#34;All positions in Polygon must be of the same type&#34;
                )
        self.positions = positions

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, Polygon) and self.positions == other.positions

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Polygon&#34;:
        &#34;&#34;&#34;Parses the XML element of Polygon.

        Parameters
        ----------
        element : ET.Element
            A polygon element (same as generated by the class itself).

        Returns
        -------
        Polygon
            A Polygon object.
        &#34;&#34;&#34;
        positions = []
        for pos_element in element.findall(&#34;Position&#34;):
            position = _PositionFactory.parse_position(pos_element)
            positions.append(position)
        return Polygon(positions)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the ElementTree of the Polygon.

        Returns
        -------
        ET.Element
            The ElementTree representation of the Polygon.
        &#34;&#34;&#34;
        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;Polygon was introduced in OpenSCENARIO V1.3&#34;
            )

        element = ET.Element(&#34;Polygon&#34;)
        for pos in self.positions:
            element.append(pos.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The Polygon class creates a polygon used by the TrafficArea class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>Position</code></dt>
<dd>A list of positions that define the polygon.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>Position</code></dt>
<dd>A list of positions that define the polygon.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Polygon.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Polygon" href="#scenariogeneration.xosc.position.Polygon">Polygon</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Polygon&#34;:
    &#34;&#34;&#34;Parses the XML element of Polygon.

    Parameters
    ----------
    element : ET.Element
        A polygon element (same as generated by the class itself).

    Returns
    -------
    Polygon
        A Polygon object.
    &#34;&#34;&#34;
    positions = []
    for pos_element in element.findall(&#34;Position&#34;):
        position = _PositionFactory.parse_position(pos_element)
        positions.append(position)
    return Polygon(positions)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of Polygon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>ET.Element</code></dt>
<dd>A polygon element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Polygon" href="#scenariogeneration.xosc.position.Polygon">Polygon</a></code></dt>
<dd>A Polygon object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Polygon.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the ElementTree of the Polygon.

    Returns
    -------
    ET.Element
        The ElementTree representation of the Polygon.
    &#34;&#34;&#34;
    if not self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;Polygon was introduced in OpenSCENARIO V1.3&#34;
        )

    element = ET.Element(&#34;Polygon&#34;)
    for pos in self.positions:
        element.append(pos.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Returns the ElementTree of the Polygon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The ElementTree representation of the Polygon.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Polyline"><code class="flex name class">
<span>class <span class="ident">Polyline</span></span>
<span>(</span><span>time: list[float],<br>positions: list[scenariogeneration.xosc.utils._PositionType])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polyline(_TrajectoryShape):
    &#34;&#34;&#34;The Polyline class creates a polyline of (minimum 2) positions.

    Parameters
    ----------
    time : list of float
        A list of timings for the positions.
    positions : list of _PositionType
        List of positions to create the polyline.

    Attributes
    ----------
    time : list of float
        A list of timings for the positions.
    positions : list of _PositionType
        List of positions to create the polyline.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self, time: list[float], positions: list[_PositionType]
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Polyline.

        Parameters
        ----------
        time : list of float
            A list of timings for the positions (as of OpenSCENARIO
            V1.1 this can be empty).
        positions : list of _PositionType
            List of positions to create the polyline.
        &#34;&#34;&#34;
        if time and len(time) &lt; 2:
            raise ValueError(&#34;not enough time inputs&#34;)
        if len(positions) &lt; 2:
            raise ValueError(&#34;not enough position inputs&#34;)
        if time and (len(time) != len(positions)):
            raise ValueError(&#34;time and positions are not the same length&#34;)
        for p in positions:
            if not isinstance(p, _PositionType):
                raise TypeError(&#34;position input is not a valid position&#34;)
        self.positions = positions
        self.time = [convert_float(x) for x in time]

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Polyline):
            if self.time == other.time and self.positions == other.positions:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Polyline&#34;:
        &#34;&#34;&#34;Parse the XML element of Polyline.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Polyline element (same as generated by the class itself).

        Returns
        -------
        Polyline
            A Polyline object.
        &#34;&#34;&#34;
        polyline_element = find_mandatory_field(element, &#34;Polyline&#34;)
        vertexes = polyline_element.findall(&#34;Vertex&#34;)
        time_list = []
        position_list = []
        for vertex in vertexes:
            if &#34;time&#34; in vertex.attrib:
                time_list.append(convert_float(vertex.attrib[&#34;time&#34;]))
            position_list.append(
                _PositionFactory.parse_position(
                    find_mandatory_field(vertex, &#34;Position&#34;)
                )
            )
        return Polyline(time_list, position_list)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Polyline.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Polyline.
        &#34;&#34;&#34;
        shape = ET.Element(&#34;Shape&#34;)
        element = ET.SubElement(shape, (&#34;Polyline&#34;))
        for i, pos in enumerate(self.positions):
            time_dict = {}
            if self.time:
                time_dict = {&#34;time&#34;: str(self.time[i])}
            vert = ET.SubElement(element, &#34;Vertex&#34;, attrib=time_dict)
            vert.append(pos.get_element())
        return shape</code></pre>
</details>
<div class="desc"><p>The Polyline class creates a polyline of (minimum 2) positions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of timings for the positions.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>_PositionType</code></dt>
<dd>List of positions to create the polyline.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of timings for the positions.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>_PositionType</code></dt>
<dd>List of positions to create the polyline.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the Polyline.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of timings for the positions (as of OpenSCENARIO
V1.1 this can be empty).</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>_PositionType</code></dt>
<dd>List of positions to create the polyline.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.position._TrajectoryShape</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Polyline.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Polyline" href="#scenariogeneration.xosc.position.Polyline">Polyline</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Polyline&#34;:
    &#34;&#34;&#34;Parse the XML element of Polyline.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Polyline element (same as generated by the class itself).

    Returns
    -------
    Polyline
        A Polyline object.
    &#34;&#34;&#34;
    polyline_element = find_mandatory_field(element, &#34;Polyline&#34;)
    vertexes = polyline_element.findall(&#34;Vertex&#34;)
    time_list = []
    position_list = []
    for vertex in vertexes:
        if &#34;time&#34; in vertex.attrib:
            time_list.append(convert_float(vertex.attrib[&#34;time&#34;]))
        position_list.append(
            _PositionFactory.parse_position(
                find_mandatory_field(vertex, &#34;Position&#34;)
            )
        )
    return Polyline(time_list, position_list)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Polyline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Polyline element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Polyline" href="#scenariogeneration.xosc.position.Polyline">Polyline</a></code></dt>
<dd>A Polyline object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Polyline.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Polyline.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Polyline.
    &#34;&#34;&#34;
    shape = ET.Element(&#34;Shape&#34;)
    element = ET.SubElement(shape, (&#34;Polyline&#34;))
    for i, pos in enumerate(self.positions):
        time_dict = {}
        if self.time:
            time_dict = {&#34;time&#34;: str(self.time[i])}
        vert = ET.SubElement(element, &#34;Vertex&#34;, attrib=time_dict)
        vert.append(pos.get_element())
    return shape</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Polyline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Polyline.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeLanePosition"><code class="flex name class">
<span>class <span class="ident">RelativeLanePosition</span></span>
<span>(</span><span>lane_id: int,<br>entity: str,<br>offset: float = 0,<br>ds: float | None = None,<br>dsLane: float | None = None,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLanePosition(_PositionType):
    &#34;&#34;&#34;The RelativeLanePosition creates a RelativeLanePosition in OpenScenario.

    Parameters
    ----------
    lane_id : int
        Lane of the road.
    entity : str
        ID of the entity.
    offset : float, optional
        Offset from the center of the lane. Default is 0.
    ds : float, optional
        Length along the road (use this or dsLane). Default is None.
    dsLane : float, optional
        Relative offset along the lane (valid from V1.1) (use this or
        ds). Default is None.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    ds : float
        Length along the road.
    dsLane : float
        Relative offset along the lane (valid from V1.1).
    offset : float
        Offset from the center of the lane.
    road_id : str
        ID of the road.
    lane_id : int
        Lane of the road.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        lane_id: int,
        entity: str,
        offset: float = 0,
        ds: Optional[float] = None,
        dsLane: Optional[float] = None,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RelativeLanePosition.

        Parameters
        ----------
        lane_id : int
            Lane of the road.
        entity : str
            ID of the entity.
        offset : float, optional
            Offset from the center of the lane. Default is 0.
        ds : float, optional
            Length along the road (use this or dsLane). Default is None.
        dsLane : float, optional
            Relative offset along the lane (valid from V1.1) (use this
            or ds). Default is None.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        if ds is not None and dsLane is not None:
            raise ToManyOptionalArguments(
                &#34;Not both of ds and dsLane can be used.&#34;
            )
        if ds is None and dsLane is None:
            raise NotEnoughInputArguments(
                &#34;Either ds or dsLane is needed as input.&#34;
            )
        self.ds = convert_float(ds)
        self.dsLane = convert_float(dsLane)
        self.lane_id = convert_int(lane_id)
        self.offset = convert_float(offset)
        self.entity = entity

        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RelativeLanePosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeLanePosition&#34;:
        &#34;&#34;&#34;Parse the XML element of RelativeLanePosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RelativeLanePosition
            A RelativeLanePosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(
            element, &#34;RelativeLanePosition&#34;
        )
        ds = None
        dslane = None
        if &#34;ds&#34; in position_element.attrib:
            ds = convert_float(position_element.attrib[&#34;ds&#34;])

        offset = convert_float(position_element.attrib[&#34;offset&#34;])
        if &#34;dsLane&#34; in position_element.attrib:
            dslane = convert_float(position_element.attrib[&#34;dsLane&#34;])

        dLane = convert_int(position_element.attrib[&#34;dLane&#34;])

        entityref = position_element.attrib[&#34;entityRef&#34;]
        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return RelativeLanePosition(
            dLane, entityref, offset, ds, dslane, orientation
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the RelativeLanePosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeLanePosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.entity
        if self.ds is not None:
            retdict[&#34;ds&#34;] = str(self.ds)
        if self.dsLane is not None and not self.isVersion(minor=0):
            retdict[&#34;dsLane&#34;] = str(self.dsLane)
        elif self.dsLane is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;dsLane was introduced in OpenSCENARIO V1.1, not in 1.0&#34;
            )
        retdict[&#34;offset&#34;] = str(self.offset)
        retdict[&#34;dLane&#34;] = str(self.lane_id)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RelativeLanePosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RelativeLanePosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        lanepos = ET.SubElement(
            element, &#34;RelativeLanePosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            lanepos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The RelativeLanePosition creates a RelativeLanePosition in OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the entity.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset from the center of the lane. Default is 0.</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length along the road (use this or dsLane). Default is None.</dd>
<dt><strong><code>dsLane</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative offset along the lane (valid from V1.1) (use this or
ds). Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>dsLane</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative offset along the lane (valid from V1.1).</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset from the center of the lane.</dd>
<dt><strong><code>road_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the RelativeLanePosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>lane_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane of the road.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the entity.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset from the center of the lane. Default is 0.</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length along the road (use this or dsLane). Default is None.</dd>
<dt><strong><code>dsLane</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative offset along the lane (valid from V1.1) (use this
or ds). Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeLanePosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RelativeLanePosition" href="#scenariogeneration.xosc.position.RelativeLanePosition">RelativeLanePosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeLanePosition&#34;:
    &#34;&#34;&#34;Parse the XML element of RelativeLanePosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RelativeLanePosition
        A RelativeLanePosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(
        element, &#34;RelativeLanePosition&#34;
    )
    ds = None
    dslane = None
    if &#34;ds&#34; in position_element.attrib:
        ds = convert_float(position_element.attrib[&#34;ds&#34;])

    offset = convert_float(position_element.attrib[&#34;offset&#34;])
    if &#34;dsLane&#34; in position_element.attrib:
        dslane = convert_float(position_element.attrib[&#34;dsLane&#34;])

    dLane = convert_int(position_element.attrib[&#34;dLane&#34;])

    entityref = position_element.attrib[&#34;entityRef&#34;]
    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return RelativeLanePosition(
        dLane, entityref, offset, ds, dslane, orientation
    )</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RelativeLanePosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RelativeLanePosition" href="#scenariogeneration.xosc.position.RelativeLanePosition">RelativeLanePosition</a></code></dt>
<dd>A RelativeLanePosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeLanePosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the RelativeLanePosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeLanePosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.entity
    if self.ds is not None:
        retdict[&#34;ds&#34;] = str(self.ds)
    if self.dsLane is not None and not self.isVersion(minor=0):
        retdict[&#34;dsLane&#34;] = str(self.dsLane)
    elif self.dsLane is not None and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;dsLane was introduced in OpenSCENARIO V1.1, not in 1.0&#34;
        )
    retdict[&#34;offset&#34;] = str(self.offset)
    retdict[&#34;dLane&#34;] = str(self.lane_id)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the RelativeLanePosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeLanePosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeLanePosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RelativeLanePosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RelativeLanePosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    lanepos = ET.SubElement(
        element, &#34;RelativeLanePosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        lanepos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RelativeLanePosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RelativeLanePosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeObjectPosition"><code class="flex name class">
<span>class <span class="ident">RelativeObjectPosition</span></span>
<span>(</span><span>entity: str,<br>dx: float,<br>dy: float,<br>dz: float | None = None,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeObjectPosition(_PositionType):
    &#34;&#34;&#34;The RelativeObjectPosition creates a RelativePosition with the option of
    object as reference.

    Parameters
    ----------
    entity : str
        The entity to be relative to.
    dx : float
        Relative x-coordinate.
    dy : float
        Relative y-coordinate.
    dz : float, optional
        Relative z-coordinate. Default is None.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    target : str
        The entity to be relative to.
    dx : float
        Relative x-coordinate.
    dy : float
        Relative y-coordinate.
    dz : float
        Relative z-coordinate.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        entity: str,
        dx: float,
        dy: float,
        dz: Optional[float] = None,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RelativeObjectPosition.

        Parameters
        ----------
        entity : str
            The entity to be relative to.
        dx : float
            Relative x-coordinate.
        dy : float
            Relative y-coordinate.
        dz : float, optional
            Relative z-coordinate. Default is None.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        self.target = entity
        self.dx = convert_float(dx)
        self.dy = convert_float(dy)
        self.dz = convert_float(dz)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RelativeObjectPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeObjectPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of RelativeObjectPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RelativeObjectPosition
            A RelativeObjectPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(
            element, &#34;RelativeObjectPosition&#34;
        )
        dx = convert_float(position_element.attrib[&#34;dx&#34;])
        dy = convert_float(position_element.attrib[&#34;dy&#34;])
        if &#34;dz&#34; in position_element.attrib:
            dz = convert_float(position_element.attrib[&#34;dz&#34;])
        else:
            dz = None
        entityref = position_element.attrib[&#34;entityRef&#34;]

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return RelativeObjectPosition(entityref, dx, dy, dz, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the RelativeObjectPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeObjectPosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;dx&#34;] = str(self.dx)
        retdict[&#34;dy&#34;] = str(self.dy)
        if self.dz is not None:
            retdict[&#34;dz&#34;] = str(self.dz)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RelativeObjectPosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RelativeObjectPosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        relpos = ET.SubElement(
            element, &#34;RelativeObjectPosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            relpos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The RelativeObjectPosition creates a RelativePosition with the option of
object as reference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative z-coordinate. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative z-coordinate.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the RelativeObjectPosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative z-coordinate. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeObjectPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RelativeObjectPosition" href="#scenariogeneration.xosc.position.RelativeObjectPosition">RelativeObjectPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeObjectPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of RelativeObjectPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RelativeObjectPosition
        A RelativeObjectPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(
        element, &#34;RelativeObjectPosition&#34;
    )
    dx = convert_float(position_element.attrib[&#34;dx&#34;])
    dy = convert_float(position_element.attrib[&#34;dy&#34;])
    if &#34;dz&#34; in position_element.attrib:
        dz = convert_float(position_element.attrib[&#34;dz&#34;])
    else:
        dz = None
    entityref = position_element.attrib[&#34;entityRef&#34;]

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return RelativeObjectPosition(entityref, dx, dy, dz, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RelativeObjectPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RelativeObjectPosition" href="#scenariogeneration.xosc.position.RelativeObjectPosition">RelativeObjectPosition</a></code></dt>
<dd>A RelativeObjectPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeObjectPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the RelativeObjectPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeObjectPosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;dx&#34;] = str(self.dx)
    retdict[&#34;dy&#34;] = str(self.dy)
    if self.dz is not None:
        retdict[&#34;dz&#34;] = str(self.dz)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the RelativeObjectPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeObjectPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeObjectPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RelativeObjectPosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RelativeObjectPosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    relpos = ET.SubElement(
        element, &#34;RelativeObjectPosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        relpos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RelativeObjectPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RelativeObjectPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeRoadPosition"><code class="flex name class">
<span>class <span class="ident">RelativeRoadPosition</span></span>
<span>(</span><span>ds: float,<br>dt: float,<br>entity: str,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeRoadPosition(_PositionType):
    &#34;&#34;&#34;The RelativeRoadPosition creates a RelativeRoadPosition in OpenScenario.

    Parameters
    ----------
    ds : float
        Length along the road.
    dt : float
        Lateral offset from the center.
    entity : str
        ID of the entity.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    ds : float
        Length along the road.
    dt : float
        Lateral offset from the center.
    target : str
        ID of the entity.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        ds: float,
        dt: float,
        entity: str,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RelativeRoadPosition.

        Parameters
        ----------
        ds : float
            Length along the road.
        dt : float
            Lateral offset from the center.
        entity : str
            ID of the entity.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        self.ds = convert_float(ds)
        self.dt = convert_float(dt)
        self.target = entity
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RelativeRoadPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeRoadPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of RelativeRoadPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RelativeRoadPosition
            A RelativeRoadPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(
            element, &#34;RelativeRoadPosition&#34;
        )

        ds = convert_float(position_element.attrib[&#34;ds&#34;])
        dt = convert_float(position_element.attrib[&#34;dt&#34;])
        entityref = position_element.attrib[&#34;entityRef&#34;]

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return RelativeRoadPosition(ds, dt, entityref, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the RelativeRoadPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeRoadPosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;ds&#34;] = str(self.ds)
        retdict[&#34;dt&#34;] = str(self.dt)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RelativeRoadPosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RelativeRoadPosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        roadpos = ET.SubElement(
            element, &#34;RelativeRoadPosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            roadpos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The RelativeRoadPosition creates a RelativeRoadPosition in OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the entity.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the entity.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the RelativeRoadPosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the entity.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeRoadPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RelativeRoadPosition" href="#scenariogeneration.xosc.position.RelativeRoadPosition">RelativeRoadPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeRoadPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of RelativeRoadPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RelativeRoadPosition
        A RelativeRoadPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(
        element, &#34;RelativeRoadPosition&#34;
    )

    ds = convert_float(position_element.attrib[&#34;ds&#34;])
    dt = convert_float(position_element.attrib[&#34;dt&#34;])
    entityref = position_element.attrib[&#34;entityRef&#34;]

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return RelativeRoadPosition(ds, dt, entityref, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RelativeRoadPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RelativeRoadPosition" href="#scenariogeneration.xosc.position.RelativeRoadPosition">RelativeRoadPosition</a></code></dt>
<dd>A RelativeRoadPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeRoadPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the RelativeRoadPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeRoadPosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;ds&#34;] = str(self.ds)
    retdict[&#34;dt&#34;] = str(self.dt)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the RelativeRoadPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeRoadPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeRoadPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RelativeRoadPosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RelativeRoadPosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    roadpos = ET.SubElement(
        element, &#34;RelativeRoadPosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        roadpos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RelativeRoadPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RelativeRoadPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeWorldPosition"><code class="flex name class">
<span>class <span class="ident">RelativeWorldPosition</span></span>
<span>(</span><span>entity: str,<br>dx: float,<br>dy: float,<br>dz: float,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeWorldPosition(_PositionType):
    &#34;&#34;&#34;The RelativeWorldPosition creates a RelativePosition with the option of
    world as reference.

    Parameters
    ----------
    entity : str
        The entity to be relative to.
    dx : float
        Relative x-coordinate.
    dy : float
        Relative y-coordinate.
    dz : float
        Relative z-coordinate.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    target : str
        The entity to be relative to.
    dx : float
        Relative x-coordinate.
    dy : float
        Relative y-coordinate.
    dz : float
        Relative z-coordinate.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        entity: str,
        dx: float,
        dy: float,
        dz: float,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RelativeWorldPosition.

        Parameters
        ----------
        entity : str
            The entity to be relative to.
        dx : float
            Relative x-coordinate.
        dy : float
            Relative y-coordinate.
        dz : float
            Relative z-coordinate.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        self.target = entity
        self.dx = convert_float(dx)
        self.dy = convert_float(dy)
        self.dz = convert_float(dz)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RelativeWorldPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeWorldPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of RelativeWorldPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RelativeWorldPosition
            A RelativeWorldPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(
            element, &#34;RelativeWorldPosition&#34;
        )
        dx = convert_float(position_element.attrib[&#34;dx&#34;])
        dy = convert_float(position_element.attrib[&#34;dy&#34;])
        dz = convert_float(position_element.attrib[&#34;dz&#34;])
        entityref = position_element.attrib[&#34;entityRef&#34;]

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return RelativeWorldPosition(entityref, dx, dy, dz, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the RelativeWorldPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeWorldPosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;dx&#34;] = str(self.dx)
        retdict[&#34;dy&#34;] = str(self.dy)
        retdict[&#34;dz&#34;] = str(self.dz)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RelativeWorldPosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RelativeWorldPosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        relpos = ET.SubElement(
            element, &#34;RelativeWorldPosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            relpos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The RelativeWorldPosition creates a RelativePosition with the option of
world as reference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative z-coordinate.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative z-coordinate.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the RelativeWorldPosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to be relative to.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative x-coordinate.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative y-coordinate.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative z-coordinate.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeWorldPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RelativeWorldPosition" href="#scenariogeneration.xosc.position.RelativeWorldPosition">RelativeWorldPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeWorldPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of RelativeWorldPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RelativeWorldPosition
        A RelativeWorldPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(
        element, &#34;RelativeWorldPosition&#34;
    )
    dx = convert_float(position_element.attrib[&#34;dx&#34;])
    dy = convert_float(position_element.attrib[&#34;dy&#34;])
    dz = convert_float(position_element.attrib[&#34;dz&#34;])
    entityref = position_element.attrib[&#34;entityRef&#34;]

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return RelativeWorldPosition(entityref, dx, dy, dz, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RelativeWorldPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RelativeWorldPosition" href="#scenariogeneration.xosc.position.RelativeWorldPosition">RelativeWorldPosition</a></code></dt>
<dd>A RelativeWorldPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RelativeWorldPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the RelativeWorldPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeWorldPosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;dx&#34;] = str(self.dx)
    retdict[&#34;dy&#34;] = str(self.dy)
    retdict[&#34;dz&#34;] = str(self.dz)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the RelativeWorldPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeWorldPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RelativeWorldPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RelativeWorldPosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RelativeWorldPosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    relpos = ET.SubElement(
        element, &#34;RelativeWorldPosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        relpos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RelativeWorldPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RelativeWorldPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RoadPosition"><code class="flex name class">
<span>class <span class="ident">RoadPosition</span></span>
<span>(</span><span>s: float,<br>t: float,<br>reference_id: int,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadPosition(_PositionType):
    &#34;&#34;&#34;The RoadPosition creates a RoadPosition in OpenScenario.

    Parameters
    ----------
    s : float
        Length along the road.
    t : float
        Lateral offset from the center.
    reference_id : str
        ID of the road.
    orientation : Orientation, optional
        The angular orientation of the entity. Default is Orientation().

    Attributes
    ----------
    s : float
        Length along the road.
    t : float
        Lateral offset from the center.
    id : str
        ID of the road.
    orient : Orientation
        The angular orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        s: float,
        t: float,
        reference_id: int,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RoadPosition.

        Parameters
        ----------
        s : float
            Length along the road.
        t : float
            Lateral offset from the center.
        reference_id : int
            ID of the road.
        orientation : Orientation, optional
            The angular orientation of the entity. Default is
            Orientation().
        &#34;&#34;&#34;
        self.s = convert_float(s)
        self.t = convert_float(t)
        self.id = convert_int(reference_id)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orient = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RoadPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orient == other.orient
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RoadPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of RoadPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RoadPosition
            A RoadPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;RoadPosition&#34;)
        roadId = convert_int(position_element.attrib[&#34;roadId&#34;])
        s = convert_float(position_element.attrib[&#34;s&#34;])
        t = convert_float(position_element.attrib[&#34;t&#34;])

        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        return RoadPosition(s, t, roadId, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the RoadPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the RoadPosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;roadId&#34;] = str(self.id)
        retdict[&#34;s&#34;] = str(self.s)
        retdict[&#34;t&#34;] = str(self.t)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RoadPosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RoadPosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        roadpos = ET.SubElement(
            element, &#34;RoadPosition&#34;, attrib=self.get_attributes()
        )
        if self.orient.is_filled():
            roadpos.append(self.orient.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The RoadPosition creates a RoadPosition in OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>reference_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orient</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>The angular orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the RoadPosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Length along the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset from the center.</dd>
<dt><strong><code>reference_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>The angular orientation of the entity. Default is
Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoadPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RoadPosition" href="#scenariogeneration.xosc.position.RoadPosition">RoadPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RoadPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of RoadPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RoadPosition
        A RoadPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;RoadPosition&#34;)
    roadId = convert_int(position_element.attrib[&#34;roadId&#34;])
    s = convert_float(position_element.attrib[&#34;s&#34;])
    t = convert_float(position_element.attrib[&#34;t&#34;])

    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    return RoadPosition(s, t, roadId, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RoadPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RoadPosition" href="#scenariogeneration.xosc.position.RoadPosition">RoadPosition</a></code></dt>
<dd>A RoadPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoadPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the RoadPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the RoadPosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;roadId&#34;] = str(self.id)
    retdict[&#34;s&#34;] = str(self.s)
    retdict[&#34;t&#34;] = str(self.t)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the RoadPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the RoadPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RoadPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RoadPosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RoadPosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    roadpos = ET.SubElement(
        element, &#34;RoadPosition&#34;, attrib=self.get_attributes()
    )
    if self.orient.is_filled():
        roadpos.append(self.orient.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RoadPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RoadPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RoadRange"><code class="flex name class">
<span>class <span class="ident">RoadRange</span></span>
<span>(</span><span>length: float | None = None, roadcursors: list | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadRange(VersionBase):
    &#34;&#34;&#34;The RoadRange class creates a road range used by the TrafficArea class.
    Defines an area by a range on a specific road.

    Parameters
    ----------
    length : float
                Limits the length of the road range starting from the first road cursor. If omitted or if length exceeds last road cursor, then last road cursor defines the end of the road range. Unit: [m].
    roadcursor : list of RoadCursor
        A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane &#34;validity&#34;.

    Attributes
    ----------
    length : float
        Limits the length of the road range starting from the first road cursor. If omitted or if length exceeds last road cursor, then last road cursor defines the end of the road range. Unit: [m].
    roadcursor : list of RoadCursor
        A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane &#34;validity&#34;.
    &#34;&#34;&#34;

    def __init__(
        self,
        length: Optional[float] = None,
        roadcursors: Optional[list] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initializes the RoadRange.

        Parameters
        ----------
        length : float, optional
            Limits the length of the road range starting from the first road cursor. Default is None.
        roadcursors : list of RoadCursor
            A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane &#34;validity&#34;.
        &#34;&#34;&#34;
        self.length = convert_float(length) if length is not None else None
        self.roadcursors = roadcursors if roadcursors is not None else []

    def __eq__(self, other: object) -&gt; bool:
        return (
            isinstance(other, RoadRange)
            and self.length == other.length
            and self.roadcursors == other.roadcursors
        )

    def add_cursor(
        self,
        roadid: str,
        s: Optional[float] = 0.0,
        lanes: Optional[list[int]] = None,
    ) -&gt; &#34;RoadRange&#34;:
        &#34;&#34;&#34;Adds a road cursor to the road range.

        Parameters
        ----------
        roadid : str
            The ID of the target road taken from the respective road network definition file.
        s : float, optional
                The s-coordinate taken along the road&#39;s reference line from the start point of the target road. If s is omitted and the road cursor depicts the start of a road range, then s=0 is assumed. If s is omitted and the road cursor depicts the end of a road range, then s=max_length is assumed. Unit: [m].
        lane : list of int, optional
                Restriction of the road cursor to specific lanes of a road. If omitted, road cursor is valid for all lanes of the road.
        &#34;&#34;&#34;
        self.roadcursors.append(
            [roadid, s, lanes if lanes is not None else []]
        )
        return self

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RoadRange&#34;:
        &#34;&#34;&#34;Parses the XML element of RoadRange.

        Parameters
        ----------
        element : ET.Element
            A road range element (same as generated by the class itself).

        Returns
        -------
        RoadRange
            A RoadRange object.
        &#34;&#34;&#34;
        length = convert_float(element.attrib.get(&#34;length&#34;))
        roadcursors = []
        for cursor in element.findall(&#34;RoadCursor&#34;):
            roadid = cursor.attrib.get(&#34;roadId&#34;, &#34;&#34;)
            s_value = convert_float(cursor.attrib.get(&#34;s&#34;, 0.0))
            lane_elements = cursor.findall(&#34;Lane&#34;)
            lanes = (
                [int(lane.attrib.get(&#34;id&#34;, &#34;&#34;)) for lane in lane_elements]
                if lane_elements
                else []
            )
            roadcursors.append([roadid, s_value, lanes])
        return RoadRange(length, roadcursors)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the RoadRange as a dictionary.&#34;&#34;&#34;
        retdict = {}
        if self.length is not None:
            retdict[&#34;length&#34;] = str(self.length)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the ElementTree of the RoadRange.

        Returns
        -------
        ET.Element
            The ElementTree representation of the RoadRange.
        &#34;&#34;&#34;
        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;RoadRange was introduced in OpenSCENARIO V1.3&#34;
            )
        if len(self.roadcursors) &lt; 2:
            raise ValueError(
                &#34;At least two road cursors are required for a RoadRange&#34;
            )

        element = ET.Element(&#34;RoadRange&#34;, attrib=self.get_attributes())

        for roadid, s, lanes in self.roadcursors:
            road_cursor_attributes = {&#34;roadId&#34;: str(roadid), &#34;s&#34;: str(s)}
            cursor_el = ET.SubElement(
                element, &#34;RoadCursor&#34;, attrib=road_cursor_attributes
            )
            if lanes is not None:
                for lane in lanes:
                    ET.SubElement(cursor_el, &#34;Lane&#34;, {&#34;id&#34;: str(lane)})
        return element</code></pre>
</details>
<div class="desc"><p>The RoadRange class creates a road range used by the TrafficArea class.
Defines an area by a range on a specific road.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits the length of the road range starting from the first road cursor. If omitted or if length exceeds last road cursor, then last road cursor defines the end of the road range. Unit: [m].</dd>
<dt><strong><code>roadcursor</code></strong> :&ensp;<code>list</code> of <code>RoadCursor</code></dt>
<dd>A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane "validity".</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits the length of the road range starting from the first road cursor. If omitted or if length exceeds last road cursor, then last road cursor defines the end of the road range. Unit: [m].</dd>
<dt><strong><code>roadcursor</code></strong> :&ensp;<code>list</code> of <code>RoadCursor</code></dt>
<dd>A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane "validity".</dd>
</dl>
<p>Initializes the RoadRange.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Limits the length of the road range starting from the first road cursor. Default is None.</dd>
<dt><strong><code>roadcursors</code></strong> :&ensp;<code>list</code> of <code>RoadCursor</code></dt>
<dd>A minimum of 2 road cursors must be provided to specify the start and end of the road range. Intermediate cursors can be used to change the lane "validity".</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoadRange.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RoadRange" href="#scenariogeneration.xosc.position.RoadRange">RoadRange</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RoadRange&#34;:
    &#34;&#34;&#34;Parses the XML element of RoadRange.

    Parameters
    ----------
    element : ET.Element
        A road range element (same as generated by the class itself).

    Returns
    -------
    RoadRange
        A RoadRange object.
    &#34;&#34;&#34;
    length = convert_float(element.attrib.get(&#34;length&#34;))
    roadcursors = []
    for cursor in element.findall(&#34;RoadCursor&#34;):
        roadid = cursor.attrib.get(&#34;roadId&#34;, &#34;&#34;)
        s_value = convert_float(cursor.attrib.get(&#34;s&#34;, 0.0))
        lane_elements = cursor.findall(&#34;Lane&#34;)
        lanes = (
            [int(lane.attrib.get(&#34;id&#34;, &#34;&#34;)) for lane in lane_elements]
            if lane_elements
            else []
        )
        roadcursors.append([roadid, s_value, lanes])
    return RoadRange(length, roadcursors)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of RoadRange.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>ET.Element</code></dt>
<dd>A road range element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RoadRange" href="#scenariogeneration.xosc.position.RoadRange">RoadRange</a></code></dt>
<dd>A RoadRange object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoadRange.add_cursor"><code class="name flex">
<span>def <span class="ident">add_cursor</span></span>(<span>self, roadid: str, s: float | None = 0.0, lanes: list[int] | None = None) ‑> <a title="scenariogeneration.xosc.position.RoadRange" href="#scenariogeneration.xosc.position.RoadRange">RoadRange</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cursor(
    self,
    roadid: str,
    s: Optional[float] = 0.0,
    lanes: Optional[list[int]] = None,
) -&gt; &#34;RoadRange&#34;:
    &#34;&#34;&#34;Adds a road cursor to the road range.

    Parameters
    ----------
    roadid : str
        The ID of the target road taken from the respective road network definition file.
    s : float, optional
            The s-coordinate taken along the road&#39;s reference line from the start point of the target road. If s is omitted and the road cursor depicts the start of a road range, then s=0 is assumed. If s is omitted and the road cursor depicts the end of a road range, then s=max_length is assumed. Unit: [m].
    lane : list of int, optional
            Restriction of the road cursor to specific lanes of a road. If omitted, road cursor is valid for all lanes of the road.
    &#34;&#34;&#34;
    self.roadcursors.append(
        [roadid, s, lanes if lanes is not None else []]
    )
    return self</code></pre>
</details>
<div class="desc"><p>Adds a road cursor to the road range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>roadid</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the target road taken from the respective road network definition file.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The s-coordinate taken along the road's reference line from the start point of the target road. If s is omitted and the road cursor depicts the start of a road range, then s=0 is assumed. If s is omitted and the road cursor depicts the end of a road range, then s=max_length is assumed. Unit: [m].</dd>
<dt><strong><code>lane</code></strong> :&ensp;<code>list</code> of <code>int</code>, optional</dt>
<dd>Restriction of the road cursor to specific lanes of a road. If omitted, road cursor is valid for all lanes of the road.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.RoadRange.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the RoadRange as a dictionary.&#34;&#34;&#34;
    retdict = {}
    if self.length is not None:
        retdict[&#34;length&#34;] = str(self.length)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the RoadRange as a dictionary.</p></div>
</dd>
<dt id="scenariogeneration.xosc.position.RoadRange.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the ElementTree of the RoadRange.

    Returns
    -------
    ET.Element
        The ElementTree representation of the RoadRange.
    &#34;&#34;&#34;
    if not self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;RoadRange was introduced in OpenSCENARIO V1.3&#34;
        )
    if len(self.roadcursors) &lt; 2:
        raise ValueError(
            &#34;At least two road cursors are required for a RoadRange&#34;
        )

    element = ET.Element(&#34;RoadRange&#34;, attrib=self.get_attributes())

    for roadid, s, lanes in self.roadcursors:
        road_cursor_attributes = {&#34;roadId&#34;: str(roadid), &#34;s&#34;: str(s)}
        cursor_el = ET.SubElement(
            element, &#34;RoadCursor&#34;, attrib=road_cursor_attributes
        )
        if lanes is not None:
            for lane in lanes:
                ET.SubElement(cursor_el, &#34;Lane&#34;, {&#34;id&#34;: str(lane)})
    return element</code></pre>
</details>
<div class="desc"><p>Returns the ElementTree of the RoadRange.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The ElementTree representation of the RoadRange.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Route"><code class="flex name class">
<span>class <span class="ident">Route</span></span>
<span>(</span><span>name: str, closed: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Route(_BaseCatalog):
    &#34;&#34;&#34;The Route class creates a route, needs at least two waypoints to be
    valid.

    Parameters
    ----------
    name : str
        Name of the Route.
    closed : bool, optional
        If the waypoints form a loop. Default is False.

    Attributes
    ----------
    name : str
        Name of the Route.
    closed : bool
        If the waypoints form a loop.
    waypoints : list of Waypoint
        A list of waypoints.
    parameters : ParameterDeclarations
        Parameters for the route.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    add_waypoint(position, routestrategy)
        Adds a waypoint to the route (minimum two).
    add_parameter(parameter)
        Adds a parameter to the route.
    append_to_catalog(filename)
        Adds the Route to an existing catalog.
    dump_to_catalog(filename, name, description, author)
        Creates a new catalog with the Route.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, name: str, closed: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize the Route.

        Parameters
        ----------
        name : str
            Name of the Route.
        closed : bool, optional
            If the waypoints form a loop. Default is False.
        &#34;&#34;&#34;
        super().__init__()
        self.name = name
        self.closed = convert_bool(closed)
        self.waypoints = []

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Route):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameters == other.parameters
                and self.waypoints == other.waypoints
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Route&#34;:
        &#34;&#34;&#34;Parse the XML element of Route.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Route element (same as generated by the class itself).

        Returns
        -------
        Route
            A Route object.
        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        closed = convert_bool(element.attrib[&#34;closed&#34;])
        route = Route(name, closed)
        all_wps = element.findall(&#34;Waypoint&#34;)
        for wp in all_wps:
            waypoint = Waypoint.parse(wp)
            route.waypoints.append(waypoint)
        return route

    def add_waypoint(
        self, position: _PositionType, routestrategy: RouteStrategy
    ) -&gt; &#34;Route&#34;:
        &#34;&#34;&#34;Add a waypoint to the Route.

        Parameters
        ----------
        position : _PositionType
            Any position for the route.
        routestrategy : RouteStrategy
            Routing strategy for this waypoint.
        &#34;&#34;&#34;
        # note: the checks for types are done in Waypoint
        self.waypoints.append(Waypoint(position, routestrategy))
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the Route as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Route.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        retdict[&#34;closed&#34;] = get_bool_string(self.closed)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Route.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Route.
        &#34;&#34;&#34;
        if len(self.waypoints) &lt; 2:
            raise ValueError(&#34;Too few waypoints&#34;)
        element = ET.Element(&#34;Route&#34;, attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        for w in self.waypoints:
            element.append(w.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The Route class creates a route, needs at least two waypoints to be
valid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the Route.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the waypoints form a loop. Default is False.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the Route.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the waypoints form a loop.</dd>
<dt><strong><code>waypoints</code></strong> :&ensp;<code>list</code> of <code><a title="scenariogeneration.xosc.position.Waypoint" href="#scenariogeneration.xosc.position.Waypoint">Waypoint</a></code></dt>
<dd>A list of waypoints.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>ParameterDeclarations</code></dt>
<dd>Parameters for the route.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
add_waypoint(position, routestrategy)
Adds a waypoint to the route (minimum two).
add_parameter(parameter)
Adds a parameter to the route.
append_to_catalog(filename)
Adds the Route to an existing catalog.
dump_to_catalog(filename, name, description, author)
Creates a new catalog with the Route.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the Route.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the Route.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the waypoints form a loop. Default is False.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._BaseCatalog</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Route.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Route&#34;:
    &#34;&#34;&#34;Parse the XML element of Route.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Route element (same as generated by the class itself).

    Returns
    -------
    Route
        A Route object.
    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    closed = convert_bool(element.attrib[&#34;closed&#34;])
    route = Route(name, closed)
    all_wps = element.findall(&#34;Waypoint&#34;)
    for wp in all_wps:
        waypoint = Waypoint.parse(wp)
        route.waypoints.append(waypoint)
    return route</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Route.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Route element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code></dt>
<dd>A Route object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Route.add_waypoint"><code class="name flex">
<span>def <span class="ident">add_waypoint</span></span>(<span>self,<br>position: scenariogeneration.xosc.utils._PositionType,<br>routestrategy: <a title="scenariogeneration.xosc.enumerations.RouteStrategy" href="enumerations.html#scenariogeneration.xosc.enumerations.RouteStrategy">RouteStrategy</a>) ‑> <a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_waypoint(
    self, position: _PositionType, routestrategy: RouteStrategy
) -&gt; &#34;Route&#34;:
    &#34;&#34;&#34;Add a waypoint to the Route.

    Parameters
    ----------
    position : _PositionType
        Any position for the route.
    routestrategy : RouteStrategy
        Routing strategy for this waypoint.
    &#34;&#34;&#34;
    # note: the checks for types are done in Waypoint
    self.waypoints.append(Waypoint(position, routestrategy))
    return self</code></pre>
</details>
<div class="desc"><p>Add a waypoint to the Route.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position for the route.</dd>
<dt><strong><code>routestrategy</code></strong> :&ensp;<code>RouteStrategy</code></dt>
<dd>Routing strategy for this waypoint.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Route.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the Route as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the Route.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    retdict[&#34;closed&#34;] = get_bool_string(self.closed)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Route as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the Route.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Route.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Route.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Route.
    &#34;&#34;&#34;
    if len(self.waypoints) &lt; 2:
        raise ValueError(&#34;Too few waypoints&#34;)
    element = ET.Element(&#34;Route&#34;, attrib=self.get_attributes())
    self.add_parameters_to_element(element)
    for w in self.waypoints:
        element.append(w.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Route.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Route.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates"><code class="flex name class">
<span>class <span class="ident">RoutePositionInLaneCoordinates</span></span>
<span>(</span><span>route_ref: <a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a>,<br>s: float,<br>laneid: int,<br>offset: float,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutePositionInLaneCoordinates(_PositionType):
    &#34;&#34;&#34;RoutePositionInLaneCoordinates creates a RoutePosition with the
    InRoutePosition of type PositionInLaneCoordinates.

    Parameters
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    s : float
        S coordinate of the road.
    laneid : int
        T coordinate of the road.
    offset : float, optional
        Lateral offset relative to the lane. Default is 0.
    orientation : Orientation, optional
        Orientation of the entity. Default is Orientation().

    Attributes
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    s : float
        S coordinate of the road.
    laneid : int
        T coordinate of the road.
    offset : float
        Lateral offset relative to the lane.
    orientation : Orientation
        Orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        route_ref: VersionBase,
        s: float,
        laneid: int,
        offset: float,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RoutePositionInLaneCoordinates class.

        Parameters
        ----------
        route_ref : Route or CatalogReference
            Reference to the route the position is calculated from.
        s : float
            S coordinate of the road.
        laneid : int
            T coordinate of the road.
        offset : float, optional
            Lateral offset relative to the lane. Default is 0.
        orientation : Orientation, optional
            Orientation of the entity. Default is Orientation().
        &#34;&#34;&#34;
        if not isinstance(route_ref, (Route, CatalogReference)):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference&#34;
            )
        self.route_ref = route_ref
        self.s = convert_float(s)
        self.laneid = convert_int(laneid)
        self.offset = convert_float(offset)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orientation = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RoutePositionInLaneCoordinates):
            if (
                self.s == other.s
                and self.laneid == other.laneid
                and self.offset == other.offset
                and self.orientation == other.orientation
                and self.route_ref == other.route_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RoutePositionInLaneCoordinates&#34;:
        &#34;&#34;&#34;Parse the XML element of RoutePositionInLaneCoordinates.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RoutePositionInLaneCoordinates
            A RoutePositionInLaneCoordinates object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        lane_coord_element = find_mandatory_field(
            position_element, &#34;InRoutePosition/FromLaneCoordinates&#34;
        )
        s = convert_float(lane_coord_element.attrib[&#34;pathS&#34;])
        lane_id = convert_int(lane_coord_element.attrib[&#34;laneId&#34;])
        try:
            offset = convert_float(lane_coord_element.attrib[&#34;laneOffset&#34;])
        except KeyError:
            offset = 0
        route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
        if route_element.find(&#34;Route&#34;) is not None:
            routeref = Route.parse(
                find_mandatory_field(route_element, &#34;Route&#34;)
            )
        else:
            routeref = CatalogReference.parse(
                find_mandatory_field(route_element, &#34;CatalogReference&#34;)
            )

        return RoutePositionInLaneCoordinates(
            routeref, s, lane_id, offset, orientation
        )

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RoutePositionInLaneCoordinates.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the
            RoutePositionInLaneCoordinates.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        relement = ET.SubElement(element, &#34;RoutePosition&#34;)
        routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
        routeref.append(self.route_ref.get_element())
        relement.append(self.orientation.get_element())
        inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
        ET.SubElement(
            inroute,
            &#34;FromLaneCoordinates&#34;,
            attrib={
                &#34;pathS&#34;: str(self.s),
                &#34;laneId&#34;: str(self.laneid),
                &#34;laneOffset&#34;: str(self.offset),
            },
        )
        return element</code></pre>
</details>
<div class="desc"><p>RoutePositionInLaneCoordinates creates a RoutePosition with the
InRoutePosition of type PositionInLaneCoordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>laneid</code></strong> :&ensp;<code>int</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lateral offset relative to the lane. Default is 0.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>laneid</code></strong> :&ensp;<code>int</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset relative to the lane.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the RoutePositionInLaneCoordinates class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>laneid</code></strong> :&ensp;<code>int</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lateral offset relative to the lane. Default is 0.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInLaneCoordinates">RoutePositionInLaneCoordinates</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RoutePositionInLaneCoordinates&#34;:
    &#34;&#34;&#34;Parse the XML element of RoutePositionInLaneCoordinates.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RoutePositionInLaneCoordinates
        A RoutePositionInLaneCoordinates object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    lane_coord_element = find_mandatory_field(
        position_element, &#34;InRoutePosition/FromLaneCoordinates&#34;
    )
    s = convert_float(lane_coord_element.attrib[&#34;pathS&#34;])
    lane_id = convert_int(lane_coord_element.attrib[&#34;laneId&#34;])
    try:
        offset = convert_float(lane_coord_element.attrib[&#34;laneOffset&#34;])
    except KeyError:
        offset = 0
    route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
    if route_element.find(&#34;Route&#34;) is not None:
        routeref = Route.parse(
            find_mandatory_field(route_element, &#34;Route&#34;)
        )
    else:
        routeref = CatalogReference.parse(
            find_mandatory_field(route_element, &#34;CatalogReference&#34;)
        )

    return RoutePositionInLaneCoordinates(
        routeref, s, lane_id, offset, orientation
    )</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RoutePositionInLaneCoordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInLaneCoordinates">RoutePositionInLaneCoordinates</a></code></dt>
<dd>A RoutePositionInLaneCoordinates object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RoutePositionInLaneCoordinates.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the
        RoutePositionInLaneCoordinates.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    relement = ET.SubElement(element, &#34;RoutePosition&#34;)
    routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
    routeref.append(self.route_ref.get_element())
    relement.append(self.orientation.get_element())
    inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
    ET.SubElement(
        inroute,
        &#34;FromLaneCoordinates&#34;,
        attrib={
            &#34;pathS&#34;: str(self.s),
            &#34;laneId&#34;: str(self.laneid),
            &#34;laneOffset&#34;: str(self.offset),
        },
    )
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RoutePositionInLaneCoordinates.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the
RoutePositionInLaneCoordinates.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates"><code class="flex name class">
<span>class <span class="ident">RoutePositionInRoadCoordinates</span></span>
<span>(</span><span>route_ref: <a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a>,<br>s: float,<br>t: float,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutePositionInRoadCoordinates(_PositionType):
    &#34;&#34;&#34;RoutePositionInRoadCoordinates creates a RoutePosition with the
    InRoutePosition of type PositionInRoadCoordinates.

    Parameters
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    s : float
        S coordinate of the road.
    t : float
        T coordinate of the road.
    orientation : Orientation, optional
        Orientation of the entity. Default is Orientation().

    Attributes
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    s : float
        S coordinate of the road.
    t : float
        T coordinate of the road.
    orientation : Orientation
        Orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        route_ref: VersionBase,
        s: float,
        t: float,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RoutePositionInRoadCoordinates class.

        Parameters
        ----------
        route_ref : Route or CatalogReference
            Reference to the route the position is calculated from.
        s : float
            S coordinate of the road.
        t : float
            T coordinate of the road.
        orientation : Orientation, optional
            Orientation of the entity. Default is Orientation().
        &#34;&#34;&#34;
        if not isinstance(route_ref, (Route, CatalogReference)):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference&#34;
            )
        self.route_ref = route_ref
        self.s = convert_float(s)
        self.t = convert_float(t)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orientation = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RoutePositionInRoadCoordinates):
            if (
                self.s == other.s
                and self.t == other.t
                and self.orientation == other.orientation
                and self.route_ref == other.route_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RoutePositionInRoadCoordinates&#34;:
        &#34;&#34;&#34;Parse the XML element of RoutePositionInRoadCoordinates.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RoutePositionInRoadCoordinates
            A RoutePositionInRoadCoordinates object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        road_coord_element = find_mandatory_field(
            position_element, &#34;InRoutePosition/FromRoadCoordinates&#34;
        )
        s = convert_float(road_coord_element.attrib[&#34;pathS&#34;])
        t = convert_float(road_coord_element.attrib[&#34;t&#34;])
        route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
        if route_element.find(&#34;Route&#34;) is not None:
            routeref = Route.parse(
                find_mandatory_field(route_element, &#34;Route&#34;)
            )
        else:
            routeref = CatalogReference.parse(
                find_mandatory_field(route_element, &#34;CatalogReference&#34;)
            )

        return RoutePositionInRoadCoordinates(routeref, s, t, orientation)

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RoutePositionInRoadCoordinates.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the
            RoutePositionInRoadCoordinates.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        relement = ET.SubElement(element, &#34;RoutePosition&#34;)
        routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
        routeref.append(self.route_ref.get_element())
        relement.append(self.orientation.get_element())
        inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
        ET.SubElement(
            inroute,
            &#34;FromRoadCoordinates&#34;,
            attrib={&#34;pathS&#34;: str(self.s), &#34;t&#34;: str(self.t)},
        )
        return element</code></pre>
</details>
<div class="desc"><p>RoutePositionInRoadCoordinates creates a RoutePosition with the
InRoutePosition of type PositionInRoadCoordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the RoutePositionInRoadCoordinates class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInRoadCoordinates">RoutePositionInRoadCoordinates</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RoutePositionInRoadCoordinates&#34;:
    &#34;&#34;&#34;Parse the XML element of RoutePositionInRoadCoordinates.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RoutePositionInRoadCoordinates
        A RoutePositionInRoadCoordinates object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    road_coord_element = find_mandatory_field(
        position_element, &#34;InRoutePosition/FromRoadCoordinates&#34;
    )
    s = convert_float(road_coord_element.attrib[&#34;pathS&#34;])
    t = convert_float(road_coord_element.attrib[&#34;t&#34;])
    route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
    if route_element.find(&#34;Route&#34;) is not None:
        routeref = Route.parse(
            find_mandatory_field(route_element, &#34;Route&#34;)
        )
    else:
        routeref = CatalogReference.parse(
            find_mandatory_field(route_element, &#34;CatalogReference&#34;)
        )

    return RoutePositionInRoadCoordinates(routeref, s, t, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RoutePositionInRoadCoordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInRoadCoordinates">RoutePositionInRoadCoordinates</a></code></dt>
<dd>A RoutePositionInRoadCoordinates object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RoutePositionInRoadCoordinates.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the
        RoutePositionInRoadCoordinates.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    relement = ET.SubElement(element, &#34;RoutePosition&#34;)
    routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
    routeref.append(self.route_ref.get_element())
    relement.append(self.orientation.get_element())
    inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
    ET.SubElement(
        inroute,
        &#34;FromRoadCoordinates&#34;,
        attrib={&#34;pathS&#34;: str(self.s), &#34;t&#34;: str(self.t)},
    )
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RoutePositionInRoadCoordinates.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the
RoutePositionInRoadCoordinates.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity"><code class="flex name class">
<span>class <span class="ident">RoutePositionOfCurrentEntity</span></span>
<span>(</span><span>route_ref: <a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a>,<br>entity: str,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutePositionOfCurrentEntity(_PositionType):
    &#34;&#34;&#34;RoutePositionOfCurrentEntity creates a RoutePosition with the
    InRoutePosition of type PositionOfCurrentEntity.

    Parameters
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    entity : str
        Reference to the entity on the route.
    orientation : Orientation, optional
        Orientation of the entity. Default is Orientation().

    Attributes
    ----------
    route_ref : Route or CatalogReference
        Reference to the route the position is calculated from.
    entity : str
        Reference to the entity on the route.
    orientation : Orientation
        Orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        route_ref: VersionBase,
        entity: str,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the RoutePositionOfCurrentEntity class.

        Parameters
        ----------
        route_ref : Route or CatalogReference
            Reference to the route the position is calculated from.
        entity : str
            Reference to the entity on the route.
        orientation : Orientation, optional
            Orientation of the entity. Default is Orientation().
        &#34;&#34;&#34;
        if not isinstance(route_ref, (Route, CatalogReference)):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference&#34;
            )
        self.route_ref = route_ref
        self.entity = entity
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orientation = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, RoutePositionOfCurrentEntity):
            if (
                self.entity == other.entity
                and self.orientation == other.orientation
                and self.route_ref == other.route_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RoutePositionOfCurrentEntity&#34;:
        &#34;&#34;&#34;Parse the XML element of RoutePositionOfCurrentEntity.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RoutePositionOfCurrentEntity
            A RoutePositionOfCurrentEntity object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()
        entityelement = find_mandatory_field(
            position_element, &#34;InRoutePosition/FromCurrentEntity&#34;
        )
        entity = entityelement.attrib[&#34;entityRef&#34;]
        route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
        if route_element.find(&#34;Route&#34;) is not None:
            routeref = Route.parse(
                find_mandatory_field(route_element, &#34;Route&#34;)
            )
        else:
            routeref = CatalogReference.parse(
                find_mandatory_field(route_element, &#34;CatalogReference&#34;)
            )

        return RoutePositionOfCurrentEntity(routeref, entity, orientation)

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the RoutePositionOfCurrentEntity.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the
            RoutePositionOfCurrentEntity.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        relement = ET.SubElement(element, &#34;RoutePosition&#34;)
        routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
        routeref.append(self.route_ref.get_element())
        relement.append(self.orientation.get_element())
        inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
        ET.SubElement(
            inroute, &#34;FromCurrentEntity&#34;, attrib={&#34;entityRef&#34;: self.entity}
        )
        return element</code></pre>
</details>
<div class="desc"><p>RoutePositionOfCurrentEntity creates a RoutePosition with the
InRoutePosition of type PositionOfCurrentEntity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the entity on the route.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the entity on the route.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the RoutePositionOfCurrentEntity class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>route_ref</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code> or <code>CatalogReference</code></dt>
<dd>Reference to the route the position is calculated from.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the entity on the route.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity" href="#scenariogeneration.xosc.position.RoutePositionOfCurrentEntity">RoutePositionOfCurrentEntity</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RoutePositionOfCurrentEntity&#34;:
    &#34;&#34;&#34;Parse the XML element of RoutePositionOfCurrentEntity.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RoutePositionOfCurrentEntity
        A RoutePositionOfCurrentEntity object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;RoutePosition&#34;)
    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()
    entityelement = find_mandatory_field(
        position_element, &#34;InRoutePosition/FromCurrentEntity&#34;
    )
    entity = entityelement.attrib[&#34;entityRef&#34;]
    route_element = find_mandatory_field(position_element, &#34;RouteRef&#34;)
    if route_element.find(&#34;Route&#34;) is not None:
        routeref = Route.parse(
            find_mandatory_field(route_element, &#34;Route&#34;)
        )
    else:
        routeref = CatalogReference.parse(
            find_mandatory_field(route_element, &#34;CatalogReference&#34;)
        )

    return RoutePositionOfCurrentEntity(routeref, entity, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of RoutePositionOfCurrentEntity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity" href="#scenariogeneration.xosc.position.RoutePositionOfCurrentEntity">RoutePositionOfCurrentEntity</a></code></dt>
<dd>A RoutePositionOfCurrentEntity object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the RoutePositionOfCurrentEntity.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the
        RoutePositionOfCurrentEntity.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    relement = ET.SubElement(element, &#34;RoutePosition&#34;)
    routeref = ET.SubElement(relement, &#34;RouteRef&#34;)
    routeref.append(self.route_ref.get_element())
    relement.append(self.orientation.get_element())
    inroute = ET.SubElement(relement, &#34;InRoutePosition&#34;)
    ET.SubElement(
        inroute, &#34;FromCurrentEntity&#34;, attrib={&#34;entityRef&#34;: self.entity}
    )
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the RoutePositionOfCurrentEntity.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the
RoutePositionOfCurrentEntity.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Trajectory"><code class="flex name class">
<span>class <span class="ident">Trajectory</span></span>
<span>(</span><span>name: str, closed: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trajectory(_BaseCatalog):
    &#34;&#34;&#34;The Trajectory class creates a Trajectory.

    Parameters
    ----------
    name : str
        Name of the trajectory.
    closed : bool
        If the trajectory is closed at the end.

    Attributes
    ----------
    name : str
        Name of the trajectory.
    closed : bool
        If the trajectory is closed at the end.
    parameters : ParameterDeclarations
        Parameters for the trajectory.
    shapes : _TrajectoryShape
        The shape building the trajectory.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    add_shape(shape)
        Adds a shape to the trajectory.
    add_parameter(parameter)
        Adds a parameter to the route.
    append_to_catalog(filename)
        Adds the vehicle to an existing catalog.
    dump_to_catalog(filename, name, description, author)
        Creates a new catalog with the vehicle.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, name: str, closed: bool) -&gt; None:
        &#34;&#34;&#34;Initialize the Trajectory.

        Parameters
        ----------
        name : str
            Name of the trajectory.
        closed : bool
            If the trajectory is closed at the end.
        &#34;&#34;&#34;
        super().__init__()
        self.name = name
        self.closed = convert_bool(closed)
        self.shapes = None

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Trajectory):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameters == other.parameters
                and self.shapes == other.shapes
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Trajectory&#34;:
        &#34;&#34;&#34;Parse the XML element of Trajectory.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Trajectory element (same as generated by the class
            itself).

        Returns
        -------
        Trajectory
            A Trajectory object.
        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        closed = convert_bool(element.attrib[&#34;closed&#34;])
        pos_element = find_mandatory_field(element, &#34;Shape&#34;)
        shape = _ShapeFactory.parse_shape(pos_element)
        params_element = element.find(&#34;ParameterDeclarations&#34;)
        if type(params_element) is ET.Element:
            params = ParameterDeclarations.parse(params_element)
        else:
            params = ParameterDeclarations()
        trajectory = Trajectory(name, closed)
        trajectory.add_shape(shape)
        for param in params.parameters:
            trajectory.add_parameter(param)
        return trajectory

    def add_shape(self, shape: _TrajectoryShape) -&gt; &#34;Trajectory&#34;:
        &#34;&#34;&#34;Add a shape to the trajectory (only the same shape can be used).

        Parameters
        ----------
        shape : _TrajectoryShape
            The shape to be added to the trajectory.
        &#34;&#34;&#34;
        if not isinstance(shape, (Polyline, Clothoid, Nurbs, ClothoidSpline)):
            raise TypeError(&#34;shape input neither of type _TrajectoryShape&#34;)
        self.shapes = shape
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the Trajectory as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Trajectory.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        retdict[&#34;closed&#34;] = get_bool_string(self.closed)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Trajectory.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Trajectory.
        &#34;&#34;&#34;
        element = ET.Element(&#34;Trajectory&#34;, attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        if self.shapes:
            element.append(self.shapes.get_element())
        else:
            raise NotEnoughInputArguments(
                &#34;No shape has been added to the trajectory&#34;
            )
        return element</code></pre>
</details>
<div class="desc"><p>The Trajectory class creates a Trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the trajectory.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the trajectory is closed at the end.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the trajectory.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the trajectory is closed at the end.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>ParameterDeclarations</code></dt>
<dd>Parameters for the trajectory.</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>_TrajectoryShape</code></dt>
<dd>The shape building the trajectory.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
add_shape(shape)
Adds a shape to the trajectory.
add_parameter(parameter)
Adds a parameter to the route.
append_to_catalog(filename)
Adds the vehicle to an existing catalog.
dump_to_catalog(filename, name, description, author)
Creates a new catalog with the vehicle.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the Trajectory.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the trajectory.</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the trajectory is closed at the end.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._BaseCatalog</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Trajectory.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Trajectory&#34;:
    &#34;&#34;&#34;Parse the XML element of Trajectory.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Trajectory element (same as generated by the class
        itself).

    Returns
    -------
    Trajectory
        A Trajectory object.
    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    closed = convert_bool(element.attrib[&#34;closed&#34;])
    pos_element = find_mandatory_field(element, &#34;Shape&#34;)
    shape = _ShapeFactory.parse_shape(pos_element)
    params_element = element.find(&#34;ParameterDeclarations&#34;)
    if type(params_element) is ET.Element:
        params = ParameterDeclarations.parse(params_element)
    else:
        params = ParameterDeclarations()
    trajectory = Trajectory(name, closed)
    trajectory.add_shape(shape)
    for param in params.parameters:
        trajectory.add_parameter(param)
    return trajectory</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Trajectory element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></code></dt>
<dd>A Trajectory object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Trajectory.add_shape"><code class="name flex">
<span>def <span class="ident">add_shape</span></span>(<span>self, shape: scenariogeneration.xosc.position._TrajectoryShape) ‑> <a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shape(self, shape: _TrajectoryShape) -&gt; &#34;Trajectory&#34;:
    &#34;&#34;&#34;Add a shape to the trajectory (only the same shape can be used).

    Parameters
    ----------
    shape : _TrajectoryShape
        The shape to be added to the trajectory.
    &#34;&#34;&#34;
    if not isinstance(shape, (Polyline, Clothoid, Nurbs, ClothoidSpline)):
        raise TypeError(&#34;shape input neither of type _TrajectoryShape&#34;)
    self.shapes = shape
    return self</code></pre>
</details>
<div class="desc"><p>Add a shape to the trajectory (only the same shape can be used).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>_TrajectoryShape</code></dt>
<dd>The shape to be added to the trajectory.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Trajectory.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the Trajectory as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the Trajectory.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    retdict[&#34;closed&#34;] = get_bool_string(self.closed)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Trajectory as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the Trajectory.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Trajectory.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Trajectory.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Trajectory.
    &#34;&#34;&#34;
    element = ET.Element(&#34;Trajectory&#34;, attrib=self.get_attributes())
    self.add_parameters_to_element(element)
    if self.shapes:
        element.append(self.shapes.get_element())
    else:
        raise NotEnoughInputArguments(
            &#34;No shape has been added to the trajectory&#34;
        )
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Trajectory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Trajectory.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.TrajectoryPosition"><code class="flex name class">
<span>class <span class="ident">TrajectoryPosition</span></span>
<span>(</span><span>trajectory: <a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a>,<br>s: float,<br>t: float | None = None,<br>orientation: <a title="scenariogeneration.xosc.utils.Orientation" href="utils.html#scenariogeneration.xosc.utils.Orientation">Orientation</a> = &lt;scenariogeneration.xosc.utils.Orientation object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrajectoryPosition(_PositionType):
    &#34;&#34;&#34;TrajectoryPosition creates a TrajectoryPosition in OpenSCENARIO.

    Parameters
    ----------
    trajectory : Trajectory or CatalogReference
        T coordinate of the road.
    s : float
        S coordinate of the trajectory.
    t : float, optional
        S coordinate of the road. Default is None.
    orientation : Orientation, optional
        Orientation of the entity. Default is Orientation().

    Attributes
    ----------
    trajectory : Trajectory or CatalogReference
        T coordinate of the road.
    s : float
        S coordinate of the trajectory.
    t : float
        S coordinate of the road. Default is None.
    orientation : Orientation
        Orientation of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        trajectory: VersionBase,
        s: float,
        t: Optional[float] = None,
        orientation: Orientation = Orientation(),
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the TrajectoryPosition class.

        Parameters
        ----------
        trajectory : Trajectory or CatalogReference
            T coordinate of the road.
        s : float
            S coordinate of the trajectory.
        t : float, optional
            S coordinate of the road. Default is None.
        orientation : Orientation, optional
            Orientation of the entity. Default is Orientation().
        &#34;&#34;&#34;
        if not isinstance(trajectory, (Trajectory, CatalogReference)):
            raise TypeError(
                &#34;trajectory input not of type Trajectory or CatalogReference&#34;
            )
        self.trajectory = trajectory
        self.s = convert_float(s)
        self.t = convert_float(t)
        if not isinstance(orientation, Orientation):
            raise TypeError(&#34;input orientation is not of type Orientation&#34;)
        self.orientation = orientation

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, TrajectoryPosition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.orientation == other.orientation
                and self.trajectory == other.trajectory
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrajectoryPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of TrajectoryPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        TrajectoryPosition
            A TrajectoryPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;TrajectoryPosition&#34;)
        if position_element.find(&#34;Orientation&#34;) is not None:
            orientation = Orientation.parse(
                find_mandatory_field(position_element, &#34;Orientation&#34;)
            )
        else:
            orientation = Orientation()

        s = position_element.attrib[&#34;s&#34;]
        t = None
        if &#34;t&#34; in position_element:
            s = position_element.attrib[&#34;s&#34;]

        trajectory_element = find_mandatory_field(
            position_element, &#34;TrajectoryRef&#34;
        )
        if trajectory_element.find(&#34;Trajectory&#34;) is not None:
            trajectory = Trajectory.parse(
                find_mandatory_field(trajectory_element, &#34;Trajectory&#34;)
            )
        else:
            trajectory = CatalogReference.parse(
                find_mandatory_field(trajectory_element, &#34;CatalogReference&#34;)
            )

        return TrajectoryPosition(trajectory, s, t, orientation)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the TrajectoryPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            TrajectoryPosition.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;s&#34;] = str(self.s)
        if self.t is not None:
            retdict[&#34;t&#34;] = str(self.t)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the TrajectoryPosition.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the TrajectoryPosition.
        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;TrajectoryPosition was introduced in OpenSCENARIO V1.1&#34;
            )

        element = ET.Element(elementname)
        traj_element = ET.SubElement(
            element, &#34;TrajectoryPosition&#34;, attrib=self.get_attributes()
        )
        trajref_element = ET.SubElement(traj_element, &#34;TrajectoryRef&#34;)
        trajref_element.append(self.trajectory.get_element())
        traj_element.append(self.orientation.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>TrajectoryPosition creates a TrajectoryPosition in OpenSCENARIO.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></code> or <code>CatalogReference</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the trajectory.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>S coordinate of the road. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></code> or <code>CatalogReference</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the trajectory.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the road. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code></dt>
<dd>Orientation of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrajectoryPosition class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></code> or <code>CatalogReference</code></dt>
<dd>T coordinate of the road.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>S coordinate of the trajectory.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>S coordinate of the road. Default is None.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>Orientation</code>, optional</dt>
<dd>Orientation of the entity. Default is Orientation().</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.TrajectoryPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.TrajectoryPosition" href="#scenariogeneration.xosc.position.TrajectoryPosition">TrajectoryPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrajectoryPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of TrajectoryPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    TrajectoryPosition
        A TrajectoryPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;TrajectoryPosition&#34;)
    if position_element.find(&#34;Orientation&#34;) is not None:
        orientation = Orientation.parse(
            find_mandatory_field(position_element, &#34;Orientation&#34;)
        )
    else:
        orientation = Orientation()

    s = position_element.attrib[&#34;s&#34;]
    t = None
    if &#34;t&#34; in position_element:
        s = position_element.attrib[&#34;s&#34;]

    trajectory_element = find_mandatory_field(
        position_element, &#34;TrajectoryRef&#34;
    )
    if trajectory_element.find(&#34;Trajectory&#34;) is not None:
        trajectory = Trajectory.parse(
            find_mandatory_field(trajectory_element, &#34;Trajectory&#34;)
        )
    else:
        trajectory = CatalogReference.parse(
            find_mandatory_field(trajectory_element, &#34;CatalogReference&#34;)
        )

    return TrajectoryPosition(trajectory, s, t, orientation)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of TrajectoryPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.TrajectoryPosition" href="#scenariogeneration.xosc.position.TrajectoryPosition">TrajectoryPosition</a></code></dt>
<dd>A TrajectoryPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.TrajectoryPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the TrajectoryPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        TrajectoryPosition.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;s&#34;] = str(self.s)
    if self.t is not None:
        retdict[&#34;t&#34;] = str(self.t)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the TrajectoryPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
TrajectoryPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.TrajectoryPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the TrajectoryPosition.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the TrajectoryPosition.
    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;TrajectoryPosition was introduced in OpenSCENARIO V1.1&#34;
        )

    element = ET.Element(elementname)
    traj_element = ET.SubElement(
        element, &#34;TrajectoryPosition&#34;, attrib=self.get_attributes()
    )
    trajref_element = ET.SubElement(traj_element, &#34;TrajectoryRef&#34;)
    trajref_element.append(self.trajectory.get_element())
    traj_element.append(self.orientation.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the TrajectoryPosition.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the TrajectoryPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.Waypoint"><code class="flex name class">
<span>class <span class="ident">Waypoint</span></span>
<span>(</span><span>position: scenariogeneration.xosc.utils._PositionType,<br>routestrategy: <a title="scenariogeneration.xosc.enumerations.RouteStrategy" href="enumerations.html#scenariogeneration.xosc.enumerations.RouteStrategy">RouteStrategy</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Waypoint(VersionBase):
    &#34;&#34;&#34;The Waypoint class creates a waypoint for a route.

    Parameters
    ----------
    position : _PositionType
        Any position for the route.
    routestrategy : RouteStrategy
        Routing strategy for this waypoint.

    Attributes
    ----------
    position : _PositionType
        Any position for the route.
    routestrategy : RouteStrategy
        Routing strategy for this waypoint.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self, position: _PositionType, routestrategy: RouteStrategy
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the Waypoint.

        Parameters
        ----------
        position : _PositionType
            Any position for the route.
        routestrategy : RouteStrategy
            Routing strategy for this waypoint.
        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position&#34;)
        self.position = position
        self.routestrategy = convert_enum(routestrategy, RouteStrategy)

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Waypoint):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;Waypoint&#34;:
        &#34;&#34;&#34;Parse the XML element of Waypoint.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Waypoint element (same as generated by the class itself).

        Returns
        -------
        Waypoint
            A Waypoint object.
        &#34;&#34;&#34;
        pos_element = find_mandatory_field(element, &#34;Position&#34;)
        position = _PositionFactory.parse_position(pos_element)
        strategy = convert_enum(element.attrib[&#34;routeStrategy&#34;], RouteStrategy)
        return Waypoint(position, strategy)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the Waypoint as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Waypoint.
        &#34;&#34;&#34;
        return {&#34;routeStrategy&#34;: self.routestrategy.get_name()}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the Waypoint.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Waypoint.
        &#34;&#34;&#34;
        element = ET.Element(&#34;Waypoint&#34;, attrib=self.get_attributes())
        element.append(self.position.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The Waypoint class creates a waypoint for a route.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position for the route.</dd>
<dt><strong><code>routestrategy</code></strong> :&ensp;<code>RouteStrategy</code></dt>
<dd>Routing strategy for this waypoint.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position for the route.</dd>
<dt><strong><code>routestrategy</code></strong> :&ensp;<code>RouteStrategy</code></dt>
<dd>Routing strategy for this waypoint.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the Waypoint.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position for the route.</dd>
<dt><strong><code>routestrategy</code></strong> :&ensp;<code>RouteStrategy</code></dt>
<dd>Routing strategy for this waypoint.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Waypoint.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.Waypoint" href="#scenariogeneration.xosc.position.Waypoint">Waypoint</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;Waypoint&#34;:
    &#34;&#34;&#34;Parse the XML element of Waypoint.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A Waypoint element (same as generated by the class itself).

    Returns
    -------
    Waypoint
        A Waypoint object.
    &#34;&#34;&#34;
    pos_element = find_mandatory_field(element, &#34;Position&#34;)
    position = _PositionFactory.parse_position(pos_element)
    strategy = convert_enum(element.attrib[&#34;routeStrategy&#34;], RouteStrategy)
    return Waypoint(position, strategy)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of Waypoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A Waypoint element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.Waypoint" href="#scenariogeneration.xosc.position.Waypoint">Waypoint</a></code></dt>
<dd>A Waypoint object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.Waypoint.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the Waypoint as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the Waypoint.
    &#34;&#34;&#34;
    return {&#34;routeStrategy&#34;: self.routestrategy.get_name()}</code></pre>
</details>
<div class="desc"><p>Return the attributes of the Waypoint as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the Waypoint.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.Waypoint.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the Waypoint.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the Waypoint.
    &#34;&#34;&#34;
    element = ET.Element(&#34;Waypoint&#34;, attrib=self.get_attributes())
    element.append(self.position.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the Waypoint.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the Waypoint.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.position.WorldPosition"><code class="flex name class">
<span>class <span class="ident">WorldPosition</span></span>
<span>(</span><span>x: float = 0,<br>y: float = 0,<br>z: float | None = None,<br>h: float | None = None,<br>p: float | None = None,<br>r: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorldPosition(_PositionType):
    &#34;&#34;&#34;The WorldPosition creates a world position in OpenScenario.

    Parameters
    ----------
    x : float
        X-coordinate of the entity.
    y : float
        Y-coordinate of the entity.
    z : float, optional
        Z-coordinate of the entity. Default is None.
    h : float, optional
        Heading of the entity. Default is None.
    p : float, optional
        Pitch of the entity. Default is None.
    r : float, optional
        Roll of the entity. Default is None.

    Attributes
    ----------
    x : float
        X-coordinate of the entity.
    y : float
        Y-coordinate of the entity.
    z : float
        Z-coordinate of the entity.
    h : float
        Heading of the entity.
    p : float
        Pitch of the entity.
    r : float
        Roll of the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element(elementname)
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        x: float = 0,
        y: float = 0,
        z: Optional[float] = None,
        h: Optional[float] = None,
        p: Optional[float] = None,
        r: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the WorldPosition.

        Parameters
        ----------
        x : float
            X-coordinate of the entity.
        y : float
            Y-coordinate of the entity.
        z : float, optional
            Z-coordinate of the entity. Default is None.
        h : float, optional
            Heading of the entity. Default is None.
        p : float, optional
            Pitch of the entity. Default is None.
        r : float, optional
            Roll of the entity. Default is None.
        &#34;&#34;&#34;
        self.x = convert_float(x)
        self.y = convert_float(y)

        self.z = convert_float(z)
        self.h = convert_float(h)
        self.p = convert_float(p)
        self.r = convert_float(r)

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, WorldPosition):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;WorldPosition&#34;:
        &#34;&#34;&#34;Parse the XML element of WorldPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        WorldPosition
            A WorldPosition object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(element, &#34;WorldPosition&#34;)
        x = convert_float(position_element.attrib[&#34;x&#34;])
        y = convert_float(position_element.attrib[&#34;y&#34;])
        z = None
        h = None
        r = None
        p = None
        if &#34;z&#34; in position_element.attrib:
            z = convert_float(position_element.attrib[&#34;z&#34;])
        if &#34;h&#34; in position_element.attrib:
            h = convert_float(position_element.attrib[&#34;h&#34;])
        if &#34;p&#34; in position_element.attrib:
            p = convert_float(position_element.attrib[&#34;p&#34;])
        if &#34;r&#34; in position_element.attrib:
            r = convert_float(position_element.attrib[&#34;r&#34;])
        return WorldPosition(x, y, z, h, p, r)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Return the attributes of the WorldPosition as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the WorldPosition.
        &#34;&#34;&#34;
        retdict = {&#34;x&#34;: str(self.x), &#34;y&#34;: str(self.y)}
        if self.z is not None:
            retdict[&#34;z&#34;] = str(self.z)
        if self.h is not None:
            retdict[&#34;h&#34;] = str(self.h)
        if self.p is not None:
            retdict[&#34;p&#34;] = str(self.p)
        if self.r is not None:
            retdict[&#34;r&#34;] = str(self.r)
        return retdict

    def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
        &#34;&#34;&#34;Return the ElementTree of the WorldPosition.

        Parameters
        ----------
        elementname : str, optional
            Used if another name is needed for the position. Default is
            &#34;Position&#34;.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the WorldPosition.
        &#34;&#34;&#34;
        element = ET.Element(elementname)
        ET.SubElement(element, &#34;WorldPosition&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>The WorldPosition creates a world position in OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>X-coordinate of the entity.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Y-coordinate of the entity.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Z-coordinate of the entity. Default is None.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Heading of the entity. Default is None.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Pitch of the entity. Default is None.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Roll of the entity. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>X-coordinate of the entity.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Y-coordinate of the entity.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Z-coordinate of the entity.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Heading of the entity.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Pitch of the entity.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Roll of the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element(elementname)
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the WorldPosition.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>X-coordinate of the entity.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Y-coordinate of the entity.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Z-coordinate of the entity. Default is None.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Heading of the entity. Default is None.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Pitch of the entity. Default is None.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Roll of the entity. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._PositionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.WorldPosition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.position.WorldPosition" href="#scenariogeneration.xosc.position.WorldPosition">WorldPosition</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;WorldPosition&#34;:
    &#34;&#34;&#34;Parse the XML element of WorldPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    WorldPosition
        A WorldPosition object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(element, &#34;WorldPosition&#34;)
    x = convert_float(position_element.attrib[&#34;x&#34;])
    y = convert_float(position_element.attrib[&#34;y&#34;])
    z = None
    h = None
    r = None
    p = None
    if &#34;z&#34; in position_element.attrib:
        z = convert_float(position_element.attrib[&#34;z&#34;])
    if &#34;h&#34; in position_element.attrib:
        h = convert_float(position_element.attrib[&#34;h&#34;])
    if &#34;p&#34; in position_element.attrib:
        p = convert_float(position_element.attrib[&#34;p&#34;])
    if &#34;r&#34; in position_element.attrib:
        r = convert_float(position_element.attrib[&#34;r&#34;])
    return WorldPosition(x, y, z, h, p, r)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of WorldPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.position.WorldPosition" href="#scenariogeneration.xosc.position.WorldPosition">WorldPosition</a></code></dt>
<dd>A WorldPosition object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.position.WorldPosition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Return the attributes of the WorldPosition as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the WorldPosition.
    &#34;&#34;&#34;
    retdict = {&#34;x&#34;: str(self.x), &#34;y&#34;: str(self.y)}
    if self.z is not None:
        retdict[&#34;z&#34;] = str(self.z)
    if self.h is not None:
        retdict[&#34;h&#34;] = str(self.h)
    if self.p is not None:
        retdict[&#34;p&#34;] = str(self.p)
    if self.r is not None:
        retdict[&#34;r&#34;] = str(self.r)
    return retdict</code></pre>
</details>
<div class="desc"><p>Return the attributes of the WorldPosition as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the WorldPosition.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.position.WorldPosition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, elementname: str = 'Position') ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, elementname: str = &#34;Position&#34;) -&gt; ET.Element:
    &#34;&#34;&#34;Return the ElementTree of the WorldPosition.

    Parameters
    ----------
    elementname : str, optional
        Used if another name is needed for the position. Default is
        &#34;Position&#34;.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the WorldPosition.
    &#34;&#34;&#34;
    element = ET.Element(elementname)
    ET.SubElement(element, &#34;WorldPosition&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>Return the ElementTree of the WorldPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elementname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used if another name is needed for the position. Default is
"Position".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the WorldPosition.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Clothoid" href="#scenariogeneration.xosc.position.Clothoid">Clothoid</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Clothoid.get_attributes" href="#scenariogeneration.xosc.position.Clothoid.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Clothoid.get_element" href="#scenariogeneration.xosc.position.Clothoid.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Clothoid.parse" href="#scenariogeneration.xosc.position.Clothoid.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.ClothoidSpline" href="#scenariogeneration.xosc.position.ClothoidSpline">ClothoidSpline</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.ClothoidSpline.get_attributes" href="#scenariogeneration.xosc.position.ClothoidSpline.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ClothoidSpline.get_element" href="#scenariogeneration.xosc.position.ClothoidSpline.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ClothoidSpline.parse" href="#scenariogeneration.xosc.position.ClothoidSpline.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.ClothoidSplineSegment" href="#scenariogeneration.xosc.position.ClothoidSplineSegment">ClothoidSplineSegment</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.ClothoidSplineSegment.get_attributes" href="#scenariogeneration.xosc.position.ClothoidSplineSegment.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ClothoidSplineSegment.get_element" href="#scenariogeneration.xosc.position.ClothoidSplineSegment.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ClothoidSplineSegment.parse" href="#scenariogeneration.xosc.position.ClothoidSplineSegment.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.ControlPoint" href="#scenariogeneration.xosc.position.ControlPoint">ControlPoint</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.ControlPoint.get_attributes" href="#scenariogeneration.xosc.position.ControlPoint.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ControlPoint.get_element" href="#scenariogeneration.xosc.position.ControlPoint.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.ControlPoint.parse" href="#scenariogeneration.xosc.position.ControlPoint.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.GeoPosition" href="#scenariogeneration.xosc.position.GeoPosition">GeoPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.GeoPosition.get_attributes" href="#scenariogeneration.xosc.position.GeoPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.GeoPosition.get_element" href="#scenariogeneration.xosc.position.GeoPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.GeoPosition.parse" href="#scenariogeneration.xosc.position.GeoPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.LanePosition" href="#scenariogeneration.xosc.position.LanePosition">LanePosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.LanePosition.get_attributes" href="#scenariogeneration.xosc.position.LanePosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.LanePosition.get_element" href="#scenariogeneration.xosc.position.LanePosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.LanePosition.parse" href="#scenariogeneration.xosc.position.LanePosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Nurbs" href="#scenariogeneration.xosc.position.Nurbs">Nurbs</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Nurbs.add_control_point" href="#scenariogeneration.xosc.position.Nurbs.add_control_point">add_control_point</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Nurbs.add_knots" href="#scenariogeneration.xosc.position.Nurbs.add_knots">add_knots</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Nurbs.get_attributes" href="#scenariogeneration.xosc.position.Nurbs.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Nurbs.get_element" href="#scenariogeneration.xosc.position.Nurbs.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Nurbs.parse" href="#scenariogeneration.xosc.position.Nurbs.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Polygon" href="#scenariogeneration.xosc.position.Polygon">Polygon</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Polygon.get_element" href="#scenariogeneration.xosc.position.Polygon.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Polygon.parse" href="#scenariogeneration.xosc.position.Polygon.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Polyline" href="#scenariogeneration.xosc.position.Polyline">Polyline</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Polyline.get_element" href="#scenariogeneration.xosc.position.Polyline.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Polyline.parse" href="#scenariogeneration.xosc.position.Polyline.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RelativeLanePosition" href="#scenariogeneration.xosc.position.RelativeLanePosition">RelativeLanePosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RelativeLanePosition.get_attributes" href="#scenariogeneration.xosc.position.RelativeLanePosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeLanePosition.get_element" href="#scenariogeneration.xosc.position.RelativeLanePosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeLanePosition.parse" href="#scenariogeneration.xosc.position.RelativeLanePosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RelativeObjectPosition" href="#scenariogeneration.xosc.position.RelativeObjectPosition">RelativeObjectPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RelativeObjectPosition.get_attributes" href="#scenariogeneration.xosc.position.RelativeObjectPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeObjectPosition.get_element" href="#scenariogeneration.xosc.position.RelativeObjectPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeObjectPosition.parse" href="#scenariogeneration.xosc.position.RelativeObjectPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RelativeRoadPosition" href="#scenariogeneration.xosc.position.RelativeRoadPosition">RelativeRoadPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RelativeRoadPosition.get_attributes" href="#scenariogeneration.xosc.position.RelativeRoadPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeRoadPosition.get_element" href="#scenariogeneration.xosc.position.RelativeRoadPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeRoadPosition.parse" href="#scenariogeneration.xosc.position.RelativeRoadPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RelativeWorldPosition" href="#scenariogeneration.xosc.position.RelativeWorldPosition">RelativeWorldPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RelativeWorldPosition.get_attributes" href="#scenariogeneration.xosc.position.RelativeWorldPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeWorldPosition.get_element" href="#scenariogeneration.xosc.position.RelativeWorldPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RelativeWorldPosition.parse" href="#scenariogeneration.xosc.position.RelativeWorldPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RoadPosition" href="#scenariogeneration.xosc.position.RoadPosition">RoadPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RoadPosition.get_attributes" href="#scenariogeneration.xosc.position.RoadPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoadPosition.get_element" href="#scenariogeneration.xosc.position.RoadPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoadPosition.parse" href="#scenariogeneration.xosc.position.RoadPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RoadRange" href="#scenariogeneration.xosc.position.RoadRange">RoadRange</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RoadRange.add_cursor" href="#scenariogeneration.xosc.position.RoadRange.add_cursor">add_cursor</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoadRange.get_attributes" href="#scenariogeneration.xosc.position.RoadRange.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoadRange.get_element" href="#scenariogeneration.xosc.position.RoadRange.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoadRange.parse" href="#scenariogeneration.xosc.position.RoadRange.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Route" href="#scenariogeneration.xosc.position.Route">Route</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Route.add_waypoint" href="#scenariogeneration.xosc.position.Route.add_waypoint">add_waypoint</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Route.get_attributes" href="#scenariogeneration.xosc.position.Route.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Route.get_element" href="#scenariogeneration.xosc.position.Route.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Route.parse" href="#scenariogeneration.xosc.position.Route.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInLaneCoordinates">RoutePositionInLaneCoordinates</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.get_element" href="#scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.parse" href="#scenariogeneration.xosc.position.RoutePositionInLaneCoordinates.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates" href="#scenariogeneration.xosc.position.RoutePositionInRoadCoordinates">RoutePositionInRoadCoordinates</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.get_element" href="#scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.parse" href="#scenariogeneration.xosc.position.RoutePositionInRoadCoordinates.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity" href="#scenariogeneration.xosc.position.RoutePositionOfCurrentEntity">RoutePositionOfCurrentEntity</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.get_element" href="#scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.parse" href="#scenariogeneration.xosc.position.RoutePositionOfCurrentEntity.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Trajectory" href="#scenariogeneration.xosc.position.Trajectory">Trajectory</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Trajectory.add_shape" href="#scenariogeneration.xosc.position.Trajectory.add_shape">add_shape</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Trajectory.get_attributes" href="#scenariogeneration.xosc.position.Trajectory.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Trajectory.get_element" href="#scenariogeneration.xosc.position.Trajectory.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Trajectory.parse" href="#scenariogeneration.xosc.position.Trajectory.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.TrajectoryPosition" href="#scenariogeneration.xosc.position.TrajectoryPosition">TrajectoryPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.TrajectoryPosition.get_attributes" href="#scenariogeneration.xosc.position.TrajectoryPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.TrajectoryPosition.get_element" href="#scenariogeneration.xosc.position.TrajectoryPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.TrajectoryPosition.parse" href="#scenariogeneration.xosc.position.TrajectoryPosition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.Waypoint" href="#scenariogeneration.xosc.position.Waypoint">Waypoint</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.Waypoint.get_attributes" href="#scenariogeneration.xosc.position.Waypoint.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Waypoint.get_element" href="#scenariogeneration.xosc.position.Waypoint.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.Waypoint.parse" href="#scenariogeneration.xosc.position.Waypoint.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.position.WorldPosition" href="#scenariogeneration.xosc.position.WorldPosition">WorldPosition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.position.WorldPosition.get_attributes" href="#scenariogeneration.xosc.position.WorldPosition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.WorldPosition.get_element" href="#scenariogeneration.xosc.position.WorldPosition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.position.WorldPosition.parse" href="#scenariogeneration.xosc.position.WorldPosition.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
