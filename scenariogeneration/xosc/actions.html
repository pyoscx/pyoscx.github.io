<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xosc.actions API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.actions</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneChangeAction</span></span>
<span>(</span><span>lane: int,<br>transition_dynamics: <a title="scenariogeneration.xosc.utils.TransitionDynamics" href="utils.html#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a>,<br>target_lane_offset: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;Creates a LateralAction of type LaneChangeAction with an absolute
    target.

    Parameters
    ----------
    lane : int
        Lane to change to.
    transition_dynamics : TransitionDynamics
        How the change should be made.
    target_lane_offset : float, optional
        Offset in the target lane, if desired. Default is None.

    Attributes
    ----------
    lane : int
        Lane to change to.
    target_lane_offset : float
        Offset in the target lane, if specified.
    transition_dynamics : TransitionDynamics
        How the change should be made.

    Methods
    -------
    parse(element)
        Parses an ElementTree element and returns an instance of the
        class.
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        lane: int,
        transition_dynamics: TransitionDynamics,
        target_lane_offset: float = None,
    ):
        &#34;&#34;&#34;Initialize AbsoluteLaneChangeAction.

        Parameters
        ----------
        lane : int
            Lane to change to.
        transition_dynamics : TransitionDynamics
            How the change should be made.
        target_lane_offset : float, optional
            Offset in the target lane, if desired. Default is None.
        &#34;&#34;&#34;

        self.lane = convert_int(lane)
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(
                &#34;transition_dynamics input not of type TransitionDynamics&#34;
            )
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AbsoluteLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AbsoluteLaneChangeAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AbsoluteLaneChangeAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An AbsoluteLaneChangeAction element (same as generated by
            the class itself).

        Returns
        -------
        AbsoluteLaneChangeAction
            An AbsoluteLaneChangeAction object.
        &#34;&#34;&#34;
        lca_element = find_mandatory_field(
            element, &#34;LateralAction/LaneChangeAction&#34;
        )
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(
                lca_element.attrib[&#34;targetLaneOffset&#34;]
            )
        dynamics = TransitionDynamics.parse(
            find_mandatory_field(lca_element, &#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = find_mandatory_field(
            lca_element, &#34;LaneChangeTarget/AbsoluteTargetLane&#34;
        )
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])

        return AbsoluteLaneChangeAction(lane, dynamics, target_lane_offset)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AbsoluteLaneChangeAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            AbsoluteLaneChangeAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        AbsoluteLaneChangeAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the
            AbsoluteLaneChangeAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(
            lanchangetarget, &#34;AbsoluteTargetLane&#34;, self.get_attributes()
        )
        return element</code></pre>
</details>
<div class="desc"><p>Creates a LateralAction of type LaneChangeAction with an absolute
target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane to change to.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset in the target lane, if desired. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane to change to.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset in the target lane, if specified.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree element and returns an instance of the
class.
get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize AbsoluteLaneChangeAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Lane to change to.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset in the target lane, if desired. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AbsoluteLaneChangeAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AbsoluteLaneChangeAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        An AbsoluteLaneChangeAction element (same as generated by
        the class itself).

    Returns
    -------
    AbsoluteLaneChangeAction
        An AbsoluteLaneChangeAction object.
    &#34;&#34;&#34;
    lca_element = find_mandatory_field(
        element, &#34;LateralAction/LaneChangeAction&#34;
    )
    target_lane_offset = None
    if &#34;targetLaneOffset&#34; in lca_element.attrib:
        target_lane_offset = convert_float(
            lca_element.attrib[&#34;targetLaneOffset&#34;]
        )
    dynamics = TransitionDynamics.parse(
        find_mandatory_field(lca_element, &#34;LaneChangeActionDynamics&#34;)
    )
    targetlane_element = find_mandatory_field(
        lca_element, &#34;LaneChangeTarget/AbsoluteTargetLane&#34;
    )
    lane = convert_int(targetlane_element.attrib[&#34;value&#34;])

    return AbsoluteLaneChangeAction(lane, dynamics, target_lane_offset)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AbsoluteLaneChangeAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>An AbsoluteLaneChangeAction element (same as generated by
the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></code></dt>
<dd>An AbsoluteLaneChangeAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AbsoluteLaneChangeAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        AbsoluteLaneChangeAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.lane)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AbsoluteLaneChangeAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
AbsoluteLaneChangeAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    AbsoluteLaneChangeAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the
        AbsoluteLaneChangeAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    laneoffset = {}
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    if self.target_lane_offset:
        laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(
        lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
    )

    lanechangeaction.append(
        self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
    )
    lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

    ET.SubElement(
        lanchangetarget, &#34;AbsoluteTargetLane&#34;, self.get_attributes()
    )
    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
AbsoluteLaneChangeAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the
AbsoluteLaneChangeAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneOffsetAction</span></span>
<span>(</span><span>value: float,<br>shape: <a title="scenariogeneration.xosc.enumerations.DynamicsShapes" href="enumerations.html#scenariogeneration.xosc.enumerations.DynamicsShapes">DynamicsShapes</a>,<br>maxlatacc: float = None,<br>continuous: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;The AbsoluteLaneOffsetAction class creates a LateralAction of type
    LaneOffsetAction with an absolute target.

    Parameters
    ----------
    value : float
        Lateral offset of the lane.
    shape : DynamicsShapes
        Shape of the offset action.
    maxlatacc : float
        Maximum allowed lateral acceleration.
    continuous : bool, optional
        If the controller tries to keep the relative speed.
        Default is True.

    Attributes
    ----------
    continuous : bool
        If the controller tries to keep the relative speed.
    value : float
        Lateral offset of the lane.
    target : str
        The name of the entity (relative only).
    dynshape : DynamicsShapes
        The shape of the action.
    maxlatacc : float
        Maximum allowed lateral acceleration.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        value: float,
        shape: DynamicsShapes,
        maxlatacc: float = None,
        continuous: bool = True,
    ):
        &#34;&#34;&#34;Initializes the AbsoluteLaneOffsetAction.

        Parameters
        ----------
        value : float
            Lateral offset of the lane.
        shape : DynamicsShapes
            Shape of the offset action.
        maxlatacc : float
            Maximum allowed lateral acceleration.
        continuous : bool, optional
            If the controller tries to keep the relative speed.
            Default is True.
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.dynshape = convert_enum(shape, DynamicsShapes)
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AbsoluteLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AbsoluteLaneOffsetAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AbsoluteLaneOffsetAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An AbsoluteLaneOffsetAction element (same as generated by
            the class itself).

        Returns
        -------
        AbsoluteLaneOffsetAction
            An AbsoluteLaneOffsetAction object.
        &#34;&#34;&#34;
        loa_element = find_mandatory_field(
            element, &#34;LateralAction/LaneOffsetAction&#34;
        )

        continuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = find_mandatory_field(
            loa_element, &#34;LaneOffsetActionDynamics&#34;
        )
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = convert_enum(
            load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes
        )

        atlo_element = find_mandatory_field(
            loa_element, &#34;LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;
        )
        value = atlo_element.attrib[&#34;value&#34;]

        return AbsoluteLaneOffsetAction(value, dynamics, maxacc, continuous)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AbsoluteLaneOffsetAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            AbsoluteLaneOffsetAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        AbsoluteLaneOffsetAction.

        Returns
        -------
        ET.Element
            The root XML element representing the
            AbsoluteLaneOffsetAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(
            laneoftarget, &#34;AbsoluteTargetLaneOffset&#34;, self.get_attributes()
        )

        return element</code></pre>
</details>
<div class="desc"><p>The AbsoluteLaneOffsetAction class creates a LateralAction of type
LaneOffsetAction with an absolute target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset of the lane.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>DynamicsShapes</code></dt>
<dd>Shape of the offset action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the controller tries to keep the relative speed.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset of the lane.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the entity (relative only).</dd>
<dt><strong><code>dynshape</code></strong> :&ensp;<code>DynamicsShapes</code></dt>
<dd>The shape of the action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initializes the AbsoluteLaneOffsetAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Lateral offset of the lane.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>DynamicsShapes</code></dt>
<dd>Shape of the offset action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AbsoluteLaneOffsetAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AbsoluteLaneOffsetAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        An AbsoluteLaneOffsetAction element (same as generated by
        the class itself).

    Returns
    -------
    AbsoluteLaneOffsetAction
        An AbsoluteLaneOffsetAction object.
    &#34;&#34;&#34;
    loa_element = find_mandatory_field(
        element, &#34;LateralAction/LaneOffsetAction&#34;
    )

    continuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
    load_element = find_mandatory_field(
        loa_element, &#34;LaneOffsetActionDynamics&#34;
    )
    maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
    dynamics = convert_enum(
        load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes
    )

    atlo_element = find_mandatory_field(
        loa_element, &#34;LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;
    )
    value = atlo_element.attrib[&#34;value&#34;]

    return AbsoluteLaneOffsetAction(value, dynamics, maxacc, continuous)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AbsoluteLaneOffsetAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>An AbsoluteLaneOffsetAction element (same as generated by
the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></code></dt>
<dd>An AbsoluteLaneOffsetAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AbsoluteLaneOffsetAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        AbsoluteLaneOffsetAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.value)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AbsoluteLaneOffsetAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
AbsoluteLaneOffsetAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    AbsoluteLaneOffsetAction.

    Returns
    -------
    ET.Element
        The root XML element representing the
        AbsoluteLaneOffsetAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    laneoffsetaction = ET.SubElement(
        lataction,
        &#34;LaneOffsetAction&#34;,
        attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
    )
    ET.SubElement(
        laneoffsetaction,
        &#34;LaneOffsetActionDynamics&#34;,
        {
            &#34;maxLateralAcc&#34;: str(self.maxlatacc),
            &#34;dynamicsShape&#34;: self.dynshape.get_name(),
        },
    )
    laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
    ET.SubElement(
        laneoftarget, &#34;AbsoluteTargetLaneOffset&#34;, self.get_attributes()
    )

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
AbsoluteLaneOffsetAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the
AbsoluteLaneOffsetAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteSpeedAction</span></span>
<span>(</span><span>speed: float,<br>transition_dynamics: <a title="scenariogeneration.xosc.utils.TransitionDynamics" href="utils.html#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;Specifies a LongitudinalAction of type SpeedAction with an absolute
    target speed.

    Parameters
    ----------
    speed : float
        The desired speed.
    transition_dynamics : TransitionDynamics
        How the change should be made.

    Attributes
    ----------
    speed : float
        The desired speed.
    transition_dynamics : TransitionDynamics
        How the change should be made.

    Methods
    -------
    parse(element)
        Parses an XML element and returns an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, speed: float, transition_dynamics: TransitionDynamics):
        &#34;&#34;&#34;Initialize the AbsoluteSpeedAction.

        Parameters
        ----------
        speed : float
            The desired speed.
        transition_dynamics : TransitionDynamics
            How the change should be made.
        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(
                &#34;transition_dynamics input not of type TransitionDynamics&#34;
            )
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AbsoluteSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AbsoluteSpeedAction&#34;:
        &#34;&#34;&#34;Parses the XML element of WorldPosition.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        AbsoluteSpeedAction
            A world position object.
        &#34;&#34;&#34;
        speed_element = find_mandatory_field(
            element,
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;,
        )
        td_element = find_mandatory_field(
            element, &#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;
        )
        speed = speed_element.attrib[&#34;value&#34;]
        transition_dynamics = TransitionDynamics.parse(td_element)
        return AbsoluteSpeedAction(speed, transition_dynamics)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AbsoluteSpeedAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the AbsoluteSpeedAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.speed)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the ElementTree of the AbsoluteSpeedAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the AbsoluteSpeedAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)

        speedaction.append(
            self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;)
        )
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(
            speedactiontarget, &#34;AbsoluteTargetSpeed&#34;, self.get_attributes()
        )

        return element</code></pre>
</details>
<div class="desc"><p>Specifies a LongitudinalAction of type SpeedAction with an absolute
target speed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The desired speed.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The desired speed.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an XML element and returns an instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the AbsoluteSpeedAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The desired speed.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction">AbsoluteSpeedAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AbsoluteSpeedAction&#34;:
    &#34;&#34;&#34;Parses the XML element of WorldPosition.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    AbsoluteSpeedAction
        A world position object.
    &#34;&#34;&#34;
    speed_element = find_mandatory_field(
        element,
        &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;,
    )
    td_element = find_mandatory_field(
        element, &#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;
    )
    speed = speed_element.attrib[&#34;value&#34;]
    transition_dynamics = TransitionDynamics.parse(td_element)
    return AbsoluteSpeedAction(speed, transition_dynamics)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of WorldPosition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction">AbsoluteSpeedAction</a></code></dt>
<dd>A world position object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AbsoluteSpeedAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the AbsoluteSpeedAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.speed)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AbsoluteSpeedAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the AbsoluteSpeedAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the ElementTree of the AbsoluteSpeedAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the AbsoluteSpeedAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)

    speedaction.append(
        self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;)
    )
    speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

    ET.SubElement(
        speedactiontarget, &#34;AbsoluteTargetSpeed&#34;, self.get_attributes()
    )

    return element</code></pre>
</details>
<div class="desc"><p>Returns the ElementTree of the AbsoluteSpeedAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the AbsoluteSpeedAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction"><code class="flex name class">
<span>class <span class="ident">AcquirePositionAction</span></span>
<span>(</span><span>position: scenariogeneration.xosc.utils._PositionType)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcquirePositionAction(_PrivateActionType):
    &#34;&#34;&#34;AcquirePositionAction creates a RouteAction of type
    AcquirePositionAction.

    Parameters
    ----------
    position : _PositionType
        Target position.

    Attributes
    ----------
    position : _PositionType
        Target position.

    Methods
    -------
    parse(element : ET.Element) -&gt; AcquirePositionAction
        Parses an ElementTree element and returns an instance of the
        class.
    get_element() -&gt; ET.Element
        Returns the full ElementTree representation of the class.
    &#34;&#34;&#34;

    def __init__(self, position: _PositionType):
        &#34;&#34;&#34;Initializes the AcquirePositionAction.

        Parameters
        ----------
        position : _PositionType
            Target position.
        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AcquirePositionAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AcquirePositionAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AcquirePositionAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A AcquirePositionAction element (same as generated by the
            class itself).

        Returns
        -------
        AcquirePositionAction
            An AcquirePositionAction object.
        &#34;&#34;&#34;
        pos_element = find_mandatory_field(
            element, &#34;RoutingAction/AcquirePositionAction/Position&#34;
        )

        position = _PositionFactory.parse_position(pos_element)

        return AcquirePositionAction(position)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        AcquirePositionAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the PrivateAction with
            nested RoutingAction and AcquirePositionAction elements.
        &#34;&#34;&#34;

        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        posaction = ET.SubElement(routeaction, &#34;AcquirePositionAction&#34;)
        posaction.append(self.position.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>AcquirePositionAction creates a RouteAction of type
AcquirePositionAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Target position.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Target position.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : ET.Element) -&gt; AcquirePositionAction
Parses an ElementTree element and returns an instance of the
class.
get_element() -&gt; ET.Element
Returns the full ElementTree representation of the class.</p>
<p>Initializes the AcquirePositionAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Target position.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AcquirePositionAction" href="#scenariogeneration.xosc.actions.AcquirePositionAction">AcquirePositionAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AcquirePositionAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AcquirePositionAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A AcquirePositionAction element (same as generated by the
        class itself).

    Returns
    -------
    AcquirePositionAction
        An AcquirePositionAction object.
    &#34;&#34;&#34;
    pos_element = find_mandatory_field(
        element, &#34;RoutingAction/AcquirePositionAction/Position&#34;
    )

    position = _PositionFactory.parse_position(pos_element)

    return AcquirePositionAction(position)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AcquirePositionAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A AcquirePositionAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction" href="#scenariogeneration.xosc.actions.AcquirePositionAction">AcquirePositionAction</a></code></dt>
<dd>An AcquirePositionAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    AcquirePositionAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the PrivateAction with
        nested RoutingAction and AcquirePositionAction elements.
    &#34;&#34;&#34;

    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    posaction = ET.SubElement(routeaction, &#34;AcquirePositionAction&#34;)
    posaction.append(self.position.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
AcquirePositionAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the PrivateAction with
nested RoutingAction and AcquirePositionAction elements.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction"><code class="flex name class">
<span>class <span class="ident">ActivateControllerAction</span></span>
<span>(</span><span>lateral: bool | None = None,<br>longitudinal: bool | None = None,<br>animation: bool | None = None,<br>lighting: bool | None = None,<br>controllerRef: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActivateControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ActivateControllerAction creates an ActivateControllerAction of
    OpenSCENARIO.

    Parameters
    ----------
    lateral : bool
        Activate or deactivate the lateral controller.
    longitudinal : bool
        Activate or deactivate the longitudinal controller.
    animation : bool
        Activate or deactivate an animation.
    lighting : bool
        Activate or deactivate lights.
    controllerRef : str
        Reference to a controller assigned to the entity.

    Attributes
    ----------
    lateral : bool
        Activate or deactivate the lateral controller.
    longitudinal : bool
        Activate or deactivate the longitudinal controller.
    animation : bool
        Activate or deactivate an animation.
    lighting : bool
        Activate or deactivate lights.
    controllerRef : Controller
        Reference to a controller assigned to the entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree element and returns an instance of the
        class.
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns the attributes of the class as a dictionary.
    &#34;&#34;&#34;

    def __init__(
        self,
        lateral: Optional[bool] = None,
        longitudinal: Optional[bool] = None,
        animation: Optional[bool] = None,
        lighting: Optional[bool] = None,
        controllerRef: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initializes the ActivateControllerAction.

        Parameters
        ----------
        lateral : bool
            Activate or deactivate the lateral controller.
        longitudinal : bool
            Activate or deactivate the longitudinal controller.
        animation : bool
            Activate or deactivate an animation.
        lighting : bool
            Activate or deactivate lights.
        controllerRef : Controller
            Reference to a controller assigned to the entity.
        &#34;&#34;&#34;
        self.lateral = convert_bool(lateral)
        self.longitudinal = convert_bool(longitudinal)
        self.animation = convert_bool(animation)
        self.lighting = convert_bool(lighting)
        self.controllerRef = controllerRef

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ActivateControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        elif isinstance(other, ControllerAction):
            if (
                self.get_attributes()
                == other.activateControllerAction.get_attributes()
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ActivateControllerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ActivateControllerAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ActivateControllerAction element (same as generated by
            the class itself).

        Returns
        -------
        ActivateControllerAction
            A ActivateControllerAction object.
        &#34;&#34;&#34;
        lateral = None
        longitudinal = None
        animation = None
        lighting = None
        controllerRef = None
        if element.find(&#34;ControllerAction&#34;) is not None:
            aca_element = find_mandatory_field(
                element, &#34;ControllerAction/ActivateControllerAction&#34;
            )
        else:
            aca_element = find_mandatory_field(
                element, &#34;ActivateControllerAction&#34;
            )

        if &#34;lateral&#34; in aca_element.attrib:
            lateral = convert_bool(aca_element.attrib[&#34;lateral&#34;])
        if &#34;longitudinal&#34; in aca_element.attrib:
            longitudinal = convert_bool(aca_element.attrib[&#34;longitudinal&#34;])
        if &#34;animation&#34; in aca_element.attrib:
            animation = convert_bool(aca_element.attrib[&#34;animation&#34;])
        if &#34;lighting&#34; in aca_element.attrib:
            lighting = convert_bool(aca_element.attrib[&#34;lighting&#34;])
        if &#34;controllerRef&#34; in aca_element.attrib:
            controllerRef = aca_element.attrib[&#34;controllerRef&#34;]
        elif &#34;objectControllerRef&#34; in aca_element.attrib:
            controllerRef = aca_element.attrib[&#34;objectControllerRef&#34;]
        return ActivateControllerAction(
            lateral, longitudinal, animation, lighting, controllerRef
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the ActivateControllerAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            ActivateControllerAction.
        &#34;&#34;&#34;
        retdict = {}
        if self.lateral is not None:
            retdict[&#34;lateral&#34;] = get_bool_string(self.lateral)
        if self.longitudinal is not None:
            retdict[&#34;longitudinal&#34;] = get_bool_string(self.longitudinal)
        if self.animation is not None and self.isVersionEqLarger(minor=2):
            retdict[&#34;animation&#34;] = get_bool_string(self.animation)
        if self.lighting is not None and self.isVersionEqLarger(minor=2):
            retdict[&#34;lighting&#34;] = get_bool_string(self.lighting)
        if self.controllerRef is not None and self.isVersion(minor=2):
            retdict[&#34;controllerRef&#34;] = self.controllerRef
        if self.controllerRef is not None and self.isVersionEqLarger(minor=3):
            retdict[&#34;objectControllerRef&#34;] = self.controllerRef
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the ActivateControllerAction.

        Returns
        -------
        ET.Element
            The XML element representing the ActivateControllerAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        if self.isVersion(minor=0):
            ET.SubElement(
                element,
                &#34;ActivateControllerAction&#34;,
                attrib=self.get_attributes(),
            )
        else:
            subelem = ET.SubElement(element, &#34;ControllerAction&#34;)
            ET.SubElement(
                subelem,
                &#34;ActivateControllerAction&#34;,
                attrib=self.get_attributes(),
            )
        return element</code></pre>
</details>
<div class="desc"><p>ActivateControllerAction creates an ActivateControllerAction of
OpenSCENARIO.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lateral</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the lateral controller.</dd>
<dt><strong><code>longitudinal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the longitudinal controller.</dd>
<dt><strong><code>animation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate an animation.</dd>
<dt><strong><code>lighting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate lights.</dd>
<dt><strong><code>controllerRef</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to a controller assigned to the entity.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lateral</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the lateral controller.</dd>
<dt><strong><code>longitudinal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the longitudinal controller.</dd>
<dt><strong><code>animation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate an animation.</dd>
<dt><strong><code>lighting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate lights.</dd>
<dt><strong><code>controllerRef</code></strong> :&ensp;<code>Controller</code></dt>
<dd>Reference to a controller assigned to the entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree element and returns an instance of the
class.
get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns the attributes of the class as a dictionary.</p>
<p>Initializes the ActivateControllerAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>lateral</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the lateral controller.</dd>
<dt><strong><code>longitudinal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate the longitudinal controller.</dd>
<dt><strong><code>animation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate an animation.</dd>
<dt><strong><code>lighting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Activate or deactivate lights.</dd>
<dt><strong><code>controllerRef</code></strong> :&ensp;<code>Controller</code></dt>
<dd>Reference to a controller assigned to the entity.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ActivateControllerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ActivateControllerAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ActivateControllerAction element (same as generated by
        the class itself).

    Returns
    -------
    ActivateControllerAction
        A ActivateControllerAction object.
    &#34;&#34;&#34;
    lateral = None
    longitudinal = None
    animation = None
    lighting = None
    controllerRef = None
    if element.find(&#34;ControllerAction&#34;) is not None:
        aca_element = find_mandatory_field(
            element, &#34;ControllerAction/ActivateControllerAction&#34;
        )
    else:
        aca_element = find_mandatory_field(
            element, &#34;ActivateControllerAction&#34;
        )

    if &#34;lateral&#34; in aca_element.attrib:
        lateral = convert_bool(aca_element.attrib[&#34;lateral&#34;])
    if &#34;longitudinal&#34; in aca_element.attrib:
        longitudinal = convert_bool(aca_element.attrib[&#34;longitudinal&#34;])
    if &#34;animation&#34; in aca_element.attrib:
        animation = convert_bool(aca_element.attrib[&#34;animation&#34;])
    if &#34;lighting&#34; in aca_element.attrib:
        lighting = convert_bool(aca_element.attrib[&#34;lighting&#34;])
    if &#34;controllerRef&#34; in aca_element.attrib:
        controllerRef = aca_element.attrib[&#34;controllerRef&#34;]
    elif &#34;objectControllerRef&#34; in aca_element.attrib:
        controllerRef = aca_element.attrib[&#34;objectControllerRef&#34;]
    return ActivateControllerAction(
        lateral, longitudinal, animation, lighting, controllerRef
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ActivateControllerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ActivateControllerAction element (same as generated by
the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code></dt>
<dd>A ActivateControllerAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the ActivateControllerAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        ActivateControllerAction.
    &#34;&#34;&#34;
    retdict = {}
    if self.lateral is not None:
        retdict[&#34;lateral&#34;] = get_bool_string(self.lateral)
    if self.longitudinal is not None:
        retdict[&#34;longitudinal&#34;] = get_bool_string(self.longitudinal)
    if self.animation is not None and self.isVersionEqLarger(minor=2):
        retdict[&#34;animation&#34;] = get_bool_string(self.animation)
    if self.lighting is not None and self.isVersionEqLarger(minor=2):
        retdict[&#34;lighting&#34;] = get_bool_string(self.lighting)
    if self.controllerRef is not None and self.isVersion(minor=2):
        retdict[&#34;controllerRef&#34;] = self.controllerRef
    if self.controllerRef is not None and self.isVersionEqLarger(minor=3):
        retdict[&#34;objectControllerRef&#34;] = self.controllerRef
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the ActivateControllerAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
ActivateControllerAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the ActivateControllerAction.

    Returns
    -------
    ET.Element
        The XML element representing the ActivateControllerAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    if self.isVersion(minor=0):
        ET.SubElement(
            element,
            &#34;ActivateControllerAction&#34;,
            attrib=self.get_attributes(),
        )
    else:
        subelem = ET.SubElement(element, &#34;ControllerAction&#34;)
        ET.SubElement(
            subelem,
            &#34;ActivateControllerAction&#34;,
            attrib=self.get_attributes(),
        )
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the ActivateControllerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the ActivateControllerAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction"><code class="flex name class">
<span>class <span class="ident">AddEntityAction</span></span>
<span>(</span><span>entityref: str, position: scenariogeneration.xosc.utils._PositionType)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AddEntityAction(_ActionType):
    &#34;&#34;&#34;AddEntityAction class creates an EntityAction to add an entity to the
    scenario.

    Parameters
    ----------
    entityref : str
        Reference name of the newly added vehicle.
    position : _PositionType
        Position where the vehicle should be added.

    Attributes
    ----------
    entityref : str
        Reference name of the newly added vehicle.
    position : _PositionType
        Position where the vehicle should be added.

    Methods
    -------
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, entityref: str, position: _PositionType):
        &#34;&#34;&#34;Initialize the AddEntityAction.

        Parameters
        ----------
        entityref : str
            Reference name of the newly added vehicle.
        position : _PositionType
            Position where the vehicle should be added.
        &#34;&#34;&#34;

        self.entityref = entityref
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not of a known _PositionType&#34;)
        self.position = position

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AddEntityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AddEntityAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AddEntityAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A AddEntityAction element (same as generated by the class
            itself).

        Returns
        -------
        AddEntityAction
            A AddEntityAction object.
        &#34;&#34;&#34;
        ea_element = find_mandatory_field(element, &#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        aea_element = find_mandatory_field(ea_element, &#34;AddEntityAction&#34;)
        position = _PositionFactory.parse_position(
            find_mandatory_field(aea_element, &#34;Position&#34;)
        )
        return AddEntityAction(entityref, position)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AddEntityAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the AddEntityAction.
        &#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the AddEntityAction.

        Returns
        -------
        ET.Element
            The XML element representing the AddEntityAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(
            element, &#34;EntityAction&#34;, attrib=self.get_attributes()
        )
        addentity = ET.SubElement(entityact, &#34;AddEntityAction&#34;)
        addentity.append(self.position.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>AddEntityAction class creates an EntityAction to add an entity to the
scenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the newly added vehicle.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Position where the vehicle should be added.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the newly added vehicle.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Position where the vehicle should be added.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the AddEntityAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the newly added vehicle.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Position where the vehicle should be added.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AddEntityAction" href="#scenariogeneration.xosc.actions.AddEntityAction">AddEntityAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AddEntityAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AddEntityAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A AddEntityAction element (same as generated by the class
        itself).

    Returns
    -------
    AddEntityAction
        A AddEntityAction object.
    &#34;&#34;&#34;
    ea_element = find_mandatory_field(element, &#34;EntityAction&#34;)
    entityref = ea_element.attrib[&#34;entityRef&#34;]
    aea_element = find_mandatory_field(ea_element, &#34;AddEntityAction&#34;)
    position = _PositionFactory.parse_position(
        find_mandatory_field(aea_element, &#34;Position&#34;)
    )
    return AddEntityAction(entityref, position)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AddEntityAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A AddEntityAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AddEntityAction" href="#scenariogeneration.xosc.actions.AddEntityAction">AddEntityAction</a></code></dt>
<dd>A AddEntityAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AddEntityAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the AddEntityAction.
    &#34;&#34;&#34;
    return {&#34;entityRef&#34;: self.entityref}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AddEntityAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the AddEntityAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the AddEntityAction.

    Returns
    -------
    ET.Element
        The XML element representing the AddEntityAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    entityact = ET.SubElement(
        element, &#34;EntityAction&#34;, attrib=self.get_attributes()
    )
    addentity = ET.SubElement(entityact, &#34;AddEntityAction&#34;)
    addentity.append(self.position.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the AddEntityAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the AddEntityAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AnimationAction"><code class="flex name class">
<span>class <span class="ident">AnimationAction</span></span>
<span>(</span><span>animation_type: <a title="scenariogeneration.xosc.enumerations.VehicleComponentType" href="enumerations.html#scenariogeneration.xosc.enumerations.VehicleComponentType">VehicleComponentType</a> | <a title="scenariogeneration.xosc.utils.UserDefinedComponent" href="utils.html#scenariogeneration.xosc.utils.UserDefinedComponent">UserDefinedComponent</a> | <a title="scenariogeneration.xosc.utils.PedestrianAnimation" href="utils.html#scenariogeneration.xosc.utils.PedestrianAnimation">PedestrianAnimation</a> | <a title="scenariogeneration.xosc.utils.AnimationFile" href="utils.html#scenariogeneration.xosc.utils.AnimationFile">AnimationFile</a> | <a title="scenariogeneration.xosc.utils.UserDefinedAnimation" href="utils.html#scenariogeneration.xosc.utils.UserDefinedAnimation">UserDefinedAnimation</a> | scenariogeneration.xosc.utils._ComponentAnimation,<br>duration: float | None = None,<br>loop: bool | None = None,<br>state: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnimationAction(_PrivateActionType):
    &#34;&#34;&#34;AnimationAction creates an AppearanceAction of the Type AnimationAction.

    Parameters
    ----------
    animation_type : VehicleComponentType, UserDefinedComponent,
        PedestrianAnimation, AnimationFile or UserDefinedAnimation
        The animation to be taken place.
    duration : float, optional
        The duration of the animation. Default is None.
    loop : bool, optional
        If the animation should be looped. Default is None.
    state : float, optional
        The state the animation should be put to. Default is None.

    Attributes
    ----------
    animation_type : _ComponentAnimation, PedestrianAnimation,
        AnimationFile or UserDefinedAnimation
        The animation to be taken place.
    duration : float
        The duration of the animation.
    loop : bool
        If the animation should be looped.
    state : float
        The state the animation should be put to.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        animation_type: Union[
            VehicleComponentType,
            UserDefinedComponent,
            PedestrianAnimation,
            AnimationFile,
            UserDefinedAnimation,
            _ComponentAnimation,
        ],
        duration: Optional[float] = None,
        loop: Optional[bool] = None,
        state: Optional[float] = None,
    ):
        &#34;&#34;&#34;Initialize the AnimationAction.

        Parameters
        ----------
        animation_type : VehicleComponentType, UserDefinedComponent,
            PedestrianAnimation, AnimationFile or UserDefinedAnimation
            The animation to be taken place.
        duration : float, optional
            The duration of the animation. Default is None.
        loop : bool, optional
            If the animation should be looped. Default is None.
        state : float, optional
            The state the animation should be put to. Default is None.
        &#34;&#34;&#34;
        if isinstance(animation_type, UserDefinedComponent):
            self.animation_type = _ComponentAnimation(animation_type)
        elif isinstance(
            animation_type,
            (
                PedestrianAnimation,
                AnimationFile,
                UserDefinedAnimation,
                _ComponentAnimation,
            ),
        ):
            self.animation_type = animation_type
        else:
            self.animation_type = _ComponentAnimation(
                _VehicleComponent(animation_type)
            )

        self.duration = convert_float(duration)
        if loop is not None and not isinstance(loop, bool):
            raise TypeError(&#34;loop input is not of type bool&#34;)
        self.loop = loop
        self.state = convert_float(state)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AnimationAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.animation_type == other.animation_type
                and self.state == other.state
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AnimationAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AnimationAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A AnimationAction element (same as generated by the class
            itself).

        Returns
        -------
        AnimationAction
            A AnimationAction object.
        &#34;&#34;&#34;
        animation_element = find_mandatory_field(
            element, &#34;AppearanceAction/AnimationAction&#34;
        )
        duration = None
        if &#34;animationDuration&#34; in animation_element.attrib:
            duration = convert_float(
                animation_element.attrib[&#34;animationDuration&#34;]
            )
        loop = None
        if &#34;loop&#34; in animation_element.attrib:
            loop = convert_bool(animation_element.attrib[&#34;loop&#34;])
        animation_state = find_mandatory_field(
            animation_element, &#34;AnimationState&#34;
        )
        state = None
        if animation_state is not None:
            state = convert_float(animation_state.attrib[&#34;state&#34;])
        animation_type = _AnimationTypeFactory.parse_animationtype(
            find_mandatory_field(animation_element, &#34;AnimationType&#34;)
        )
        return AnimationAction(animation_type, duration, loop, state)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve the attributes of the AnimationAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the AnimationAction.
        &#34;&#34;&#34;

        retdict = {}

        if self.duration is not None:
            retdict[&#34;animationDuration&#34;] = str(self.duration)
        if self.loop is not None:
            retdict[&#34;loop&#34;] = get_bool_string(self.loop)

        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Constructs and returns an ElementTree representation of the
        AnimationAction.

        Returns
        -------
        ET.Element
            The root XML element representing the AnimationAction.
        &#34;&#34;&#34;

        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        animation_element = ET.SubElement(
            appear_element, &#34;AnimationAction&#34;, self.get_attributes()
        )

        animation_type_element = ET.SubElement(
            animation_element, &#34;AnimationType&#34;
        )
        animation_type_element.append(self.animation_type.get_element())
        if self.state is not None:
            ET.SubElement(
                animation_element,
                &#34;AnimationState&#34;,
                attrib={&#34;state&#34;: str(self.state)},
            )

        return element</code></pre>
</details>
<div class="desc"><p>AnimationAction creates an AppearanceAction of the Type AnimationAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animation_type</code></strong> :&ensp;<code>VehicleComponentType, UserDefinedComponent,</code></dt>
<dd>PedestrianAnimation, AnimationFile or UserDefinedAnimation
The animation to be taken place.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The duration of the animation. Default is None.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the animation should be looped. Default is None.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The state the animation should be put to. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>animation_type</code></strong> :&ensp;<code>_ComponentAnimation, PedestrianAnimation,</code></dt>
<dd>AnimationFile or UserDefinedAnimation
The animation to be taken place.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>The duration of the animation.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the animation should be looped.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>float</code></dt>
<dd>The state the animation should be put to.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the class.</p>
<p>Initialize the AnimationAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>animation_type</code></strong> :&ensp;<code>VehicleComponentType, UserDefinedComponent,</code></dt>
<dd>PedestrianAnimation, AnimationFile or UserDefinedAnimation
The animation to be taken place.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The duration of the animation. Default is None.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the animation should be looped. Default is None.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The state the animation should be put to. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AnimationAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AnimationAction" href="#scenariogeneration.xosc.actions.AnimationAction">AnimationAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AnimationAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AnimationAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A AnimationAction element (same as generated by the class
        itself).

    Returns
    -------
    AnimationAction
        A AnimationAction object.
    &#34;&#34;&#34;
    animation_element = find_mandatory_field(
        element, &#34;AppearanceAction/AnimationAction&#34;
    )
    duration = None
    if &#34;animationDuration&#34; in animation_element.attrib:
        duration = convert_float(
            animation_element.attrib[&#34;animationDuration&#34;]
        )
    loop = None
    if &#34;loop&#34; in animation_element.attrib:
        loop = convert_bool(animation_element.attrib[&#34;loop&#34;])
    animation_state = find_mandatory_field(
        animation_element, &#34;AnimationState&#34;
    )
    state = None
    if animation_state is not None:
        state = convert_float(animation_state.attrib[&#34;state&#34;])
    animation_type = _AnimationTypeFactory.parse_animationtype(
        find_mandatory_field(animation_element, &#34;AnimationType&#34;)
    )
    return AnimationAction(animation_type, duration, loop, state)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AnimationAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A AnimationAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AnimationAction" href="#scenariogeneration.xosc.actions.AnimationAction">AnimationAction</a></code></dt>
<dd>A AnimationAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AnimationAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Retrieve the attributes of the AnimationAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the AnimationAction.
    &#34;&#34;&#34;

    retdict = {}

    if self.duration is not None:
        retdict[&#34;animationDuration&#34;] = str(self.duration)
    if self.loop is not None:
        retdict[&#34;loop&#34;] = get_bool_string(self.loop)

    return retdict</code></pre>
</details>
<div class="desc"><p>Retrieve the attributes of the AnimationAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the AnimationAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AnimationAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Constructs and returns an ElementTree representation of the
    AnimationAction.

    Returns
    -------
    ET.Element
        The root XML element representing the AnimationAction.
    &#34;&#34;&#34;

    element = ET.Element(&#34;PrivateAction&#34;)
    appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
    animation_element = ET.SubElement(
        appear_element, &#34;AnimationAction&#34;, self.get_attributes()
    )

    animation_type_element = ET.SubElement(
        animation_element, &#34;AnimationType&#34;
    )
    animation_type_element.append(self.animation_type.get_element())
    if self.state is not None:
        ET.SubElement(
            animation_element,
            &#34;AnimationState&#34;,
            attrib={&#34;state&#34;: str(self.state)},
        )

    return element</code></pre>
</details>
<div class="desc"><p>Constructs and returns an ElementTree representation of the
AnimationAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the AnimationAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction"><code class="flex name class">
<span>class <span class="ident">AssignControllerAction</span></span>
<span>(</span><span>controller: <a title="scenariogeneration.xosc.utils.Controller" href="utils.html#scenariogeneration.xosc.utils.Controller">Controller</a> | <a title="scenariogeneration.xosc.utils.CatalogReference" href="utils.html#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a> | <a title="scenariogeneration.xosc.actions.ObjectController" href="#scenariogeneration.xosc.actions.ObjectController">ObjectController</a>,<br>activateLateral: bool = True,<br>activateLongitudinal: bool = True,<br>activateLighting: bool = False,<br>activateAnimation: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignControllerAction(_PrivateActionType):
    &#34;&#34;&#34;AssignControllerAction creates a ControllerAction of type
    AssignControllerAction.

    Parameters
    ----------
    controller : Controller or CatalogReference
        A controller to assign.
    activateLateral : bool, optional
        If the lateral control should be activated (valid from V1.1).
        Default is True.
    activateLongitudinal : bool, optional
        If the longitudinal control should be activated
        (valid from V1.1). Default is True.
    activateLighting : bool, optional
        If the lighting control should be activated (valid from V1.2).
        Default is False.
    activateAnimation : bool, optional
        If the animation control should be activated (valid from V1.2).
        Default is False.

    Attributes
    ----------
    controller : Controller or CatalogReference
        A controller to assign.
    activateLateral : bool
        Indicates if the lateral control is activated (valid from V1.1).
    activateLongitudinal : bool
        Indicates if the longitudinal control is activated
        (valid from V1.1).
    activateLighting : bool
        Indicates if the lighting control is activated
        (valid from V1.2).
    activateAnimation : bool
        Indicates if the animation control is activated
        (valid from V1.2).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the AssignControllerAction as a
        dictionary.
    &#34;&#34;&#34;

    def __init__(
        self,
        controller: Union[Controller, CatalogReference, ObjectController],
        activateLateral: bool = True,
        activateLongitudinal: bool = True,
        activateLighting: bool = False,
        activateAnimation: bool = False,
    ):
        &#34;&#34;&#34;Initializes the AssignControllerAction.

        Parameters
        ----------
        controller : Controller or CatalogReference
            A controller to assign.
        activateLateral : bool, optional
            If the lateral control should be activated
            (valid from V1.1). Default is True.
        activateLongitudinal : bool, optional
            If the longitudinal control should be activated
            (valid from V1.1). Default is True.
        activateLighting : bool, optional
            If the lighting control should be activated
        activateAnimation:bool, optional
            If the animation control should be activated
        &#34;&#34;&#34;
        if not isinstance(
            controller, (Controller, CatalogReference, ObjectController)
        ):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference or ObjectController&#34;
            )
        self.controller = controller
        self.activateLateral = convert_bool(activateLateral)
        self.activateLongitudinal = convert_bool(activateLongitudinal)
        self.activateLighting = convert_bool(activateLighting)
        self.activateAnimation = convert_bool(activateAnimation)
        self._used_by_parent = False

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AssignControllerAction):
            if self.controller == other.controller:
                return True
        elif isinstance(other, ControllerAction):
            if self.controller == other.assignControllerAction.controller:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AssignControllerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AssignControllerAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A AssignControllerAction element (same as generated by the
            class itself).

        Returns
        -------
        AssignControllerAction
            An AssignControllerAction object.
        &#34;&#34;&#34;
        ca_element = find_mandatory_field(element, &#34;ControllerAction&#34;)
        aca_element = find_mandatory_field(
            ca_element, &#34;AssignControllerAction&#34;
        )
        activate_lateral = True
        if &#34;activateLateral&#34; in aca_element.attrib:
            activate_lateral = convert_bool(
                aca_element.attrib[&#34;activateLateral&#34;]
            )

        activate_longitudinal = True
        if &#34;activateLongitudinal&#34; in aca_element.attrib:
            activate_longitudinal = convert_bool(
                aca_element.attrib[&#34;activateLongitudinal&#34;]
            )
        activate_lighting = False
        if &#34;activateLighting&#34; in aca_element.attrib:
            activate_lighting = convert_bool(
                aca_element.attrib[&#34;activateLighting&#34;]
            )
        activate_animation = False
        if &#34;activateAnimation&#34; in aca_element.attrib:
            activate_animation = convert_bool(
                aca_element.attrib[&#34;activateAnimation&#34;]
            )
        controller = None
        if aca_element.find(&#34;Controller&#34;) is not None:
            controller = Controller.parse(
                find_mandatory_field(aca_element, &#34;Controller&#34;)
            )
        elif aca_element.find(&#34;CatalogReference&#34;) is not None:
            controller = CatalogReference.parse(
                find_mandatory_field(aca_element, &#34;CatalogReference&#34;)
            )
        elif aca_element.find(&#34;ObjectController&#34;) is not None:
            controller = ObjectController.parse(
                find_mandatory_field(aca_element, &#34;ObjectController&#34;)
            )
        else:
            raise NotAValidElement(
                &#34;No Controller found for AssignControllerAction&#34;
            )

        return AssignControllerAction(
            controller,
            activate_lateral,
            activate_longitudinal,
            activate_lighting,
            activate_animation,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AssignControllerAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            AssignControllerAction.
        &#34;&#34;&#34;
        retdict = {}

        if self.isVersionEqLarger(minor=1):
            retdict = {
                &#34;activateLateral&#34;: get_bool_string(self.activateLateral),
                &#34;activateLongitudinal&#34;: get_bool_string(
                    self.activateLongitudinal
                ),
            }
        if self.isVersionEqLarger(minor=2):
            retdict[&#34;activateLighting&#34;] = get_bool_string(
                self.activateLighting
            )
            retdict[&#34;activateAnimation&#34;] = get_bool_string(
                self.activateAnimation
            )
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the AssignControllerAction.

        Returns
        -------
        ET.Element
            The XML element representing the AssignControllerAction.

        Raises
        ------
        OpenSCENARIOVersionError
            If the AssignControllerAction is used alone in OSC 1.0.
        &#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;AssignControllerAction cannot be used alone in OSC 1.0, &#34;
                &#34;please add it to a ControllerAction.&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        assigncontrolleraction = ET.SubElement(
            controlleraction, &#34;AssignControllerAction&#34;, self.get_attributes()
        )
        if self.isVersionEqLarger(minor=3):
            if not isinstance(self.controller, ObjectController):
                raise OpenSCENARIOVersionError(
                    &#34;In version 1.3 and higher, controller must be of type ObjectController.&#34;
                )

        assigncontrolleraction.append(self.controller.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>AssignControllerAction creates a ControllerAction of type
AssignControllerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller</code> or <code>CatalogReference</code></dt>
<dd>A controller to assign.</dd>
<dt><strong><code>activateLateral</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the lateral control should be activated (valid from V1.1).
Default is True.</dd>
<dt><strong><code>activateLongitudinal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the longitudinal control should be activated
(valid from V1.1). Default is True.</dd>
<dt><strong><code>activateLighting</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the lighting control should be activated (valid from V1.2).
Default is False.</dd>
<dt><strong><code>activateAnimation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the animation control should be activated (valid from V1.2).
Default is False.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller</code> or <code>CatalogReference</code></dt>
<dd>A controller to assign.</dd>
<dt><strong><code>activateLateral</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the lateral control is activated (valid from V1.1).</dd>
<dt><strong><code>activateLongitudinal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the longitudinal control is activated
(valid from V1.1).</dd>
<dt><strong><code>activateLighting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the lighting control is activated
(valid from V1.2).</dd>
<dt><strong><code>activateAnimation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the animation control is activated
(valid from V1.2).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the AssignControllerAction as a
dictionary.</p>
<p>Initializes the AssignControllerAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller</code> or <code>CatalogReference</code></dt>
<dd>A controller to assign.</dd>
<dt><strong><code>activateLateral</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the lateral control should be activated
(valid from V1.1). Default is True.</dd>
<dt><strong><code>activateLongitudinal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the longitudinal control should be activated
(valid from V1.1). Default is True.</dd>
<dt><strong><code>activateLighting</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the lighting control should be activated</dd>
</dl>
<p>activateAnimation:bool, optional
If the animation control should be activated</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AssignControllerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AssignControllerAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A AssignControllerAction element (same as generated by the
        class itself).

    Returns
    -------
    AssignControllerAction
        An AssignControllerAction object.
    &#34;&#34;&#34;
    ca_element = find_mandatory_field(element, &#34;ControllerAction&#34;)
    aca_element = find_mandatory_field(
        ca_element, &#34;AssignControllerAction&#34;
    )
    activate_lateral = True
    if &#34;activateLateral&#34; in aca_element.attrib:
        activate_lateral = convert_bool(
            aca_element.attrib[&#34;activateLateral&#34;]
        )

    activate_longitudinal = True
    if &#34;activateLongitudinal&#34; in aca_element.attrib:
        activate_longitudinal = convert_bool(
            aca_element.attrib[&#34;activateLongitudinal&#34;]
        )
    activate_lighting = False
    if &#34;activateLighting&#34; in aca_element.attrib:
        activate_lighting = convert_bool(
            aca_element.attrib[&#34;activateLighting&#34;]
        )
    activate_animation = False
    if &#34;activateAnimation&#34; in aca_element.attrib:
        activate_animation = convert_bool(
            aca_element.attrib[&#34;activateAnimation&#34;]
        )
    controller = None
    if aca_element.find(&#34;Controller&#34;) is not None:
        controller = Controller.parse(
            find_mandatory_field(aca_element, &#34;Controller&#34;)
        )
    elif aca_element.find(&#34;CatalogReference&#34;) is not None:
        controller = CatalogReference.parse(
            find_mandatory_field(aca_element, &#34;CatalogReference&#34;)
        )
    elif aca_element.find(&#34;ObjectController&#34;) is not None:
        controller = ObjectController.parse(
            find_mandatory_field(aca_element, &#34;ObjectController&#34;)
        )
    else:
        raise NotAValidElement(
            &#34;No Controller found for AssignControllerAction&#34;
        )

    return AssignControllerAction(
        controller,
        activate_lateral,
        activate_longitudinal,
        activate_lighting,
        activate_animation,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AssignControllerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A AssignControllerAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code></dt>
<dd>An AssignControllerAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AssignControllerAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        AssignControllerAction.
    &#34;&#34;&#34;
    retdict = {}

    if self.isVersionEqLarger(minor=1):
        retdict = {
            &#34;activateLateral&#34;: get_bool_string(self.activateLateral),
            &#34;activateLongitudinal&#34;: get_bool_string(
                self.activateLongitudinal
            ),
        }
    if self.isVersionEqLarger(minor=2):
        retdict[&#34;activateLighting&#34;] = get_bool_string(
            self.activateLighting
        )
        retdict[&#34;activateAnimation&#34;] = get_bool_string(
            self.activateAnimation
        )
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AssignControllerAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
AssignControllerAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the AssignControllerAction.

    Returns
    -------
    ET.Element
        The XML element representing the AssignControllerAction.

    Raises
    ------
    OpenSCENARIOVersionError
        If the AssignControllerAction is used alone in OSC 1.0.
    &#34;&#34;&#34;
    if self.isVersion(minor=0) and not self._used_by_parent:
        raise OpenSCENARIOVersionError(
            &#34;AssignControllerAction cannot be used alone in OSC 1.0, &#34;
            &#34;please add it to a ControllerAction.&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
    assigncontrolleraction = ET.SubElement(
        controlleraction, &#34;AssignControllerAction&#34;, self.get_attributes()
    )
    if self.isVersionEqLarger(minor=3):
        if not isinstance(self.controller, ObjectController):
            raise OpenSCENARIOVersionError(
                &#34;In version 1.3 and higher, controller must be of type ObjectController.&#34;
            )

    assigncontrolleraction.append(self.controller.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the AssignControllerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the AssignControllerAction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenSCENARIOVersionError</code></dt>
<dd>If the AssignControllerAction is used alone in OSC 1.0.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction"><code class="flex name class">
<span>class <span class="ident">AssignRouteAction</span></span>
<span>(</span><span>route: <a title="scenariogeneration.xosc.position.Route" href="position.html#scenariogeneration.xosc.position.Route">Route</a> | <a title="scenariogeneration.xosc.utils.CatalogReference" href="utils.html#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignRouteAction(_PrivateActionType):
    &#34;&#34;&#34;AssignRouteAction creates a RouteAction of type AssignRouteAction.

    Parameters
    ----------
    route : Route or CatalogReference
        The route to follow.

    Attributes
    ----------
    route : Route or CatalogReference
        The route to follow.

    Methods
    -------
    parse(element : ET.Element) -&gt; AssignRouteAction
        Parses an ElementTree element and returns an instance of the
        class.
    get_element() -&gt; ET.Element
        Returns the full ElementTree representation of the class.
    &#34;&#34;&#34;

    def __init__(self, route: Union[Route, CatalogReference]):
        &#34;&#34;&#34;Initializes the AssignRouteAction.

        Parameters
        ----------
        route : Route or CatalogReference
            The route to follow.
        &#34;&#34;&#34;
        if not isinstance(route, (Route, CatalogReference)):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference&#34;
            )

        self.route = route

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, AssignRouteAction):
            if self.route == other.route:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;AssignRouteAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AssignRouteAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A AssignRouteAction element (same as generated by the class
            itself).

        Returns
        -------
        AssignRouteAction
            A AssignRouteAction object.
        &#34;&#34;&#34;
        ara_element = find_mandatory_field(
            element, &#34;RoutingAction/AssignRouteAction&#34;
        )
        route = None
        if ara_element.find(&#34;Route&#34;) is not None:
            route = Route.parse(find_mandatory_field(ara_element, &#34;Route&#34;))
        elif ara_element.find(&#34;CatalogReference&#34;) is not None:
            route = CatalogReference.parse(
                find_mandatory_field(ara_element, &#34;CatalogReference&#34;)
            )

        return AssignRouteAction(route)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        AssignRouteAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the AssignRouteAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        assignrouteaction = ET.SubElement(routeaction, &#34;AssignRouteAction&#34;)
        assignrouteaction.append(self.route.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>AssignRouteAction creates a RouteAction of type AssignRouteAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>route</code></strong> :&ensp;<code>Route</code> or <code>CatalogReference</code></dt>
<dd>The route to follow.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>route</code></strong> :&ensp;<code>Route</code> or <code>CatalogReference</code></dt>
<dd>The route to follow.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : ET.Element) -&gt; AssignRouteAction
Parses an ElementTree element and returns an instance of the
class.
get_element() -&gt; ET.Element
Returns the full ElementTree representation of the class.</p>
<p>Initializes the AssignRouteAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>route</code></strong> :&ensp;<code>Route</code> or <code>CatalogReference</code></dt>
<dd>The route to follow.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.AssignRouteAction" href="#scenariogeneration.xosc.actions.AssignRouteAction">AssignRouteAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;AssignRouteAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AssignRouteAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A AssignRouteAction element (same as generated by the class
        itself).

    Returns
    -------
    AssignRouteAction
        A AssignRouteAction object.
    &#34;&#34;&#34;
    ara_element = find_mandatory_field(
        element, &#34;RoutingAction/AssignRouteAction&#34;
    )
    route = None
    if ara_element.find(&#34;Route&#34;) is not None:
        route = Route.parse(find_mandatory_field(ara_element, &#34;Route&#34;))
    elif ara_element.find(&#34;CatalogReference&#34;) is not None:
        route = CatalogReference.parse(
            find_mandatory_field(ara_element, &#34;CatalogReference&#34;)
        )

    return AssignRouteAction(route)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AssignRouteAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A AssignRouteAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AssignRouteAction" href="#scenariogeneration.xosc.actions.AssignRouteAction">AssignRouteAction</a></code></dt>
<dd>A AssignRouteAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    AssignRouteAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the AssignRouteAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    assignrouteaction = ET.SubElement(routeaction, &#34;AssignRouteAction&#34;)
    assignrouteaction.append(self.route.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
AssignRouteAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the AssignRouteAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ConnectTrailerAction"><code class="flex name class">
<span>class <span class="ident">ConnectTrailerAction</span></span>
<span>(</span><span>trailer_ref: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectTrailerAction(_PrivateActionType):
    &#34;&#34;&#34;ConnectTrailerAction creates an TrailerAction of the type ConnectTrailerAction.

    Parameters
    ----------
    trailer_ref : str
        reference to the trailer to connect

    Attributes
    ----------
    trailer_ref : str
        reference to the trailer to connect

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, trailer_ref: str):
        &#34;&#34;&#34;Initalize the ConnectTrailerAction.

        Parameters
        ----------
        trailer_ref : str
            reference to the trailer to connect
        &#34;&#34;&#34;
        self.trailer_ref = trailer_ref

    def __eq__(self, other: object) -&gt; bool:
        if (
            isinstance(other, ConnectTrailerAction)
            and self.trailer_ref == other.trailer_ref
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ConnectTrailerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ConnectTrailerAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ConnectTrailerAction element (same as generated by the class
            itself).

        Returns
        -------
        ConnectTrailerAction
            A ConnectTrailerAction object.
        &#34;&#34;&#34;
        connection_element = find_mandatory_field(
            element, &#34;TrailerAction/ConnectTrailerAction&#34;
        )
        ref = connection_element.attrib[&#34;trailerRef&#34;]
        return ConnectTrailerAction(ref)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve the attributes of the AnimationAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the AnimationAction.
        &#34;&#34;&#34;
        return {&#34;trailerRef&#34;: self.trailer_ref}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Constructs and returns an ElementTree representation of the ConnectTrailerAction.

        Returns
        -------
        ET.Element
            The root XML element representing the ConnectTrailerAction.
        &#34;&#34;&#34;
        if self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;ConnectTrailerAction was added in OSC V1.3&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        trailer_element = ET.SubElement(element, &#34;TrailerAction&#34;)
        ET.SubElement(
            trailer_element, &#34;ConnectTrailerAction&#34;, self.get_attributes()
        )
        return element</code></pre>
</details>
<div class="desc"><p>ConnectTrailerAction creates an TrailerAction of the type ConnectTrailerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trailer_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>reference to the trailer to connect</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trailer_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>reference to the trailer to connect</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the class.</p>
<p>Initalize the ConnectTrailerAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>trailer_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>reference to the trailer to connect</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ConnectTrailerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ConnectTrailerAction" href="#scenariogeneration.xosc.actions.ConnectTrailerAction">ConnectTrailerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ConnectTrailerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ConnectTrailerAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ConnectTrailerAction element (same as generated by the class
        itself).

    Returns
    -------
    ConnectTrailerAction
        A ConnectTrailerAction object.
    &#34;&#34;&#34;
    connection_element = find_mandatory_field(
        element, &#34;TrailerAction/ConnectTrailerAction&#34;
    )
    ref = connection_element.attrib[&#34;trailerRef&#34;]
    return ConnectTrailerAction(ref)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ConnectTrailerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ConnectTrailerAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ConnectTrailerAction" href="#scenariogeneration.xosc.actions.ConnectTrailerAction">ConnectTrailerAction</a></code></dt>
<dd>A ConnectTrailerAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ConnectTrailerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Retrieve the attributes of the AnimationAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the AnimationAction.
    &#34;&#34;&#34;
    return {&#34;trailerRef&#34;: self.trailer_ref}</code></pre>
</details>
<div class="desc"><p>Retrieve the attributes of the AnimationAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the AnimationAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ConnectTrailerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Constructs and returns an ElementTree representation of the ConnectTrailerAction.

    Returns
    -------
    ET.Element
        The root XML element representing the ConnectTrailerAction.
    &#34;&#34;&#34;
    if self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;ConnectTrailerAction was added in OSC V1.3&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    trailer_element = ET.SubElement(element, &#34;TrailerAction&#34;)
    ET.SubElement(
        trailer_element, &#34;ConnectTrailerAction&#34;, self.get_attributes()
    )
    return element</code></pre>
</details>
<div class="desc"><p>Constructs and returns an ElementTree representation of the ConnectTrailerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the ConnectTrailerAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ControllerAction"><code class="flex name class">
<span>class <span class="ident">ControllerAction</span></span>
<span>(</span><span>assignControllerAction: ForwardRef('<a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a>') | None = None,<br>overrideControllerValueAction: ForwardRef('<a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a>') | None = None,<br>activateControllerAction: ForwardRef('<a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a>') | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ControllerAction creates a ControllerAction of OpenSCENARIO.

    Parameters
    ----------
    assignControllerAction : AssignControllerAction, optional
        Assign a controller to an entity.
    overrideControllerValueAction : OverrideControllerValueAction,
        optional. Values for brake, clutch, parking brake, steering
        wheel, or gear.
    activateControllerAction : ActivateControllerAction, optional
        Activate/deactivate a controller on the reference
        entity/entities.
        Replaces the deprecated element in PrivateAction in version 1.1.

    Methods
    -------
    parse : ElementTree.Element -&gt; ControllerAction
        Parses an ElementTree element and returns an instance of the
        class.
    get_element : None -&gt; ElementTree.Element
        Returns the full ElementTree representation of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        assignControllerAction: Optional[&#34;AssignControllerAction&#34;] = None,
        overrideControllerValueAction: Optional[
            &#34;OverrideControllerValueAction&#34;
        ] = None,
        activateControllerAction: Optional[&#34;ActivateControllerAction&#34;] = None,
    ):
        &#34;&#34;&#34;Initializes the ControllerAction.

        Parameters
        ----------
        assignControllerAction : AssignControllerAction, optional
            Assign a controller to an entity.
        overrideControllerValueAction : OverrideControllerValueAction,
            optional. Values for brake, clutch, parking brake, steering
            wheel, or gear.
        activateControllerAction : ActivateControllerAction, optional
            Activate/deactivate a controller on the reference entity/entities.
            Replaces the deprecated element in PrivateAction in version 1.1.
        &#34;&#34;&#34;
        if assignControllerAction is not None and not isinstance(
            assignControllerAction, AssignControllerAction
        ):
            raise TypeError(
                &#34;assignControllerAction is not of type AssignControllerAction&#34;
            )
        if overrideControllerValueAction is not None and not isinstance(
            overrideControllerValueAction, OverrideControllerValueAction
        ):
            raise TypeError(
                &#34;overrideControllerValueAction is not of type OverrideControllerValueAction&#34;
            )
        if activateControllerAction is not None and not isinstance(
            activateControllerAction, ActivateControllerAction
        ):
            raise TypeError(
                &#34;activateControllerAction is not of type ActivateControllerAction&#34;
            )
        self.assignControllerAction = assignControllerAction
        self.overrideControllerValueAction = overrideControllerValueAction
        self.activateControllerAction = activateControllerAction
        if self.assignControllerAction is not None:
            self.assignControllerAction._used_by_parent = True
        if self.overrideControllerValueAction is not None:
            self.overrideControllerValueAction._used_by_parent = True

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ControllerAction):
            if (
                self.activateControllerAction == other.activateControllerAction
                and self.overrideControllerValueAction
                == other.overrideControllerValueAction
                and self.assignControllerAction == other.assignControllerAction
            ):
                return True
        if isinstance(other, AssignControllerAction):
            if self.assignControllerAction == other:
                return True
        if isinstance(other, OverrideControllerValueAction):
            if self.overrideControllerValueAction == other:
                return True
        if isinstance(other, ActivateControllerAction):
            if self.activateControllerAction == other:
                return True

        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ControllerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ControllerAction.

        element : xml.etree.ElementTree.Element
            A ControllerAction element (same as generated by the class
            itself).

        ControllerAction
            A ControllerAction object containing one of the following:
            - ActivateControllerAction
            - OverrideControllerValueAction
            - AssignControllerAction
        &#34;&#34;&#34;

        activateControllerAction = None
        overrideControllerValueAction = None
        assignControllerAction = None

        ca_element = find_mandatory_field(element, &#34;ControllerAction&#34;)

        if ca_element.find(&#34;ActivateControllerAction&#34;) is not None:
            activateControllerAction = ActivateControllerAction.parse(element)
        if ca_element.find(&#34;OverrideControllerValueAction&#34;) is not None:
            overrideControllerValueAction = (
                OverrideControllerValueAction.parse(element)
            )
        if ca_element.find(&#34;AssignControllerAction&#34;) is not None:
            assignControllerAction = AssignControllerAction.parse(element)

        return ControllerAction(
            assignControllerAction,
            overrideControllerValueAction,
            activateControllerAction,
        )

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates and returns an XML element tree representation of the
        ControllerAction.

        Returns
        -------
        ET.Element
            The root XML element representing the ControllerAction.

        Raises
        ------
        NotEnoughInputArguments
            If both `assignControllerAction` and
            `overrideControllerValueAction` are not provided
            in version 1.0.
        OpenSCENARIOVersionError
            If `activateControllerAction` is provided in version 1.0.
        &#34;&#34;&#34;

        if self.isVersion(minor=0):
            if (
                self.assignControllerAction is None
                or self.overrideControllerValueAction is None
            ):
                raise NotEnoughInputArguments(
                    &#34;Both assignControllerAction and &#34;
                    &#34;overrideControllerValueAction are required in version 1.0.&#34;
                )
            if self.activateControllerAction is not None:
                raise OpenSCENARIOVersionError(
                    &#34;activateControllerAction is not parameter in version 1.0.&#34;
                )

        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)

        if self.activateControllerAction is not None:
            pa_element = self.activateControllerAction.get_element()
            aca_element = find_mandatory_field(
                pa_element, &#34;ControllerAction/ActivateControllerAction&#34;
            )
            controlleraction.append(aca_element)

        if self.overrideControllerValueAction is not None:
            pa_element = self.overrideControllerValueAction.get_element()
            ocva_element = find_mandatory_field(
                pa_element, &#34;ControllerAction/OverrideControllerValueAction&#34;
            )
            controlleraction.append(ocva_element)

        if self.assignControllerAction is not None:
            pa_element = self.assignControllerAction.get_element()
            aca_element = find_mandatory_field(
                pa_element, &#34;ControllerAction/AssignControllerAction&#34;
            )
            controlleraction.append(aca_element)

        return element</code></pre>
</details>
<div class="desc"><p>ControllerAction creates a ControllerAction of OpenSCENARIO.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assignControllerAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code>, optional</dt>
<dd>Assign a controller to an entity.</dd>
<dt><strong><code>overrideControllerValueAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a>,</code></dt>
<dd>optional. Values for brake, clutch, parking brake, steering
wheel, or gear.</dd>
<dt><strong><code>activateControllerAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code>, optional</dt>
<dd>Activate/deactivate a controller on the reference
entity/entities.
Replaces the deprecated element in PrivateAction in version 1.1.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse : ElementTree.Element -&gt; ControllerAction
Parses an ElementTree element and returns an instance of the
class.
get_element : None -&gt; ElementTree.Element
Returns the full ElementTree representation of the class.</p>
<p>Initializes the ControllerAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>assignControllerAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code>, optional</dt>
<dd>Assign a controller to an entity.</dd>
<dt><strong><code>overrideControllerValueAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a>,</code></dt>
<dd>optional. Values for brake, clutch, parking brake, steering
wheel, or gear.</dd>
<dt><strong><code>activateControllerAction</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code>, optional</dt>
<dd>Activate/deactivate a controller on the reference entity/entities.
Replaces the deprecated element in PrivateAction in version 1.1.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ControllerAction" href="#scenariogeneration.xosc.actions.ControllerAction">ControllerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ControllerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ControllerAction.

    element : xml.etree.ElementTree.Element
        A ControllerAction element (same as generated by the class
        itself).

    ControllerAction
        A ControllerAction object containing one of the following:
        - ActivateControllerAction
        - OverrideControllerValueAction
        - AssignControllerAction
    &#34;&#34;&#34;

    activateControllerAction = None
    overrideControllerValueAction = None
    assignControllerAction = None

    ca_element = find_mandatory_field(element, &#34;ControllerAction&#34;)

    if ca_element.find(&#34;ActivateControllerAction&#34;) is not None:
        activateControllerAction = ActivateControllerAction.parse(element)
    if ca_element.find(&#34;OverrideControllerValueAction&#34;) is not None:
        overrideControllerValueAction = (
            OverrideControllerValueAction.parse(element)
        )
    if ca_element.find(&#34;AssignControllerAction&#34;) is not None:
        assignControllerAction = AssignControllerAction.parse(element)

    return ControllerAction(
        assignControllerAction,
        overrideControllerValueAction,
        activateControllerAction,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ControllerAction.</p>
<p>element : xml.etree.ElementTree.Element
A ControllerAction element (same as generated by the class
itself).</p>
<p>ControllerAction
A ControllerAction object containing one of the following:
- ActivateControllerAction
- OverrideControllerValueAction
- AssignControllerAction</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates and returns an XML element tree representation of the
    ControllerAction.

    Returns
    -------
    ET.Element
        The root XML element representing the ControllerAction.

    Raises
    ------
    NotEnoughInputArguments
        If both `assignControllerAction` and
        `overrideControllerValueAction` are not provided
        in version 1.0.
    OpenSCENARIOVersionError
        If `activateControllerAction` is provided in version 1.0.
    &#34;&#34;&#34;

    if self.isVersion(minor=0):
        if (
            self.assignControllerAction is None
            or self.overrideControllerValueAction is None
        ):
            raise NotEnoughInputArguments(
                &#34;Both assignControllerAction and &#34;
                &#34;overrideControllerValueAction are required in version 1.0.&#34;
            )
        if self.activateControllerAction is not None:
            raise OpenSCENARIOVersionError(
                &#34;activateControllerAction is not parameter in version 1.0.&#34;
            )

    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)

    if self.activateControllerAction is not None:
        pa_element = self.activateControllerAction.get_element()
        aca_element = find_mandatory_field(
            pa_element, &#34;ControllerAction/ActivateControllerAction&#34;
        )
        controlleraction.append(aca_element)

    if self.overrideControllerValueAction is not None:
        pa_element = self.overrideControllerValueAction.get_element()
        ocva_element = find_mandatory_field(
            pa_element, &#34;ControllerAction/OverrideControllerValueAction&#34;
        )
        controlleraction.append(ocva_element)

    if self.assignControllerAction is not None:
        pa_element = self.assignControllerAction.get_element()
        aca_element = find_mandatory_field(
            pa_element, &#34;ControllerAction/AssignControllerAction&#34;
        )
        controlleraction.append(aca_element)

    return element</code></pre>
</details>
<div class="desc"><p>Generates and returns an XML element tree representation of the
ControllerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the ControllerAction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughInputArguments</code></dt>
<dd>If both <code>assignControllerAction</code> and
<code>overrideControllerValueAction</code> are not provided
in version 1.0.</dd>
<dt><code>OpenSCENARIOVersionError</code></dt>
<dd>If <code>activateControllerAction</code> is provided in version 1.0.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction"><code class="flex name class">
<span>class <span class="ident">CustomCommandAction</span></span>
<span>(</span><span>type: str, content: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomCommandAction(_ActionType):
    &#34;&#34;&#34;The CustomCommandAction creates a simulator-defined action.

    Parameters
    ----------
    type : str
        Type of the custom command.
    content : str
        Content of the custom command.

    Methods
    -------
    parse(element : xml.etree.ElementTree.Element) -&gt; CustomCommandAction
        Parses the XML element of a CustomCommandAction and returns an
        instance of the class.
    get_element() -&gt; xml.etree.ElementTree.Element
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(self, type: str, content: str):
        &#34;&#34;&#34;Initialize the CustomCommandAction.

        Parameters
        ----------
        type : str
            Type of the custom command.
        content : str
            Content of the custom command.
        &#34;&#34;&#34;
        self.type = type
        self.content = content

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, CustomCommandAction):
            if other.type == self.type:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;CustomCommandAction&#34;:
        &#34;&#34;&#34;Parse the XML element of a CustomCommandAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A CustomCommandAction element.

        Returns
        -------
        CustomCommandAction
            A CustomCommandAction object.

        Raises
        ------
        NotAValidElement
            If the element is not a valid CustomCommandAction or is
            missing required attributes.
        &#34;&#34;&#34;
        if element.tag != &#34;CustomCommandAction&#34;:
            raise NotAValidElement(
                f&#39;Expected &#34;CustomCommandAction&#34; element, received &#34;{element.tag}&#34;.&#39;
            )
        action_type = element.attrib.get(&#34;type&#34;, None)
        if action_type is None:
            raise NotAValidElement(
                &#39;CustomCommandAction is missing required argument &#34;type&#34;.&#39;
            )

        return CustomCommandAction(action_type, element.text)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generate an ElementTree element for the CustomCommandAction.

        Returns
        -------
        ET.Element
            An XML element representing the CustomCommandAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;CustomCommandAction&#34;, attrib={&#34;type&#34;: self.type})
        element.text = self.content
        return element</code></pre>
</details>
<div class="desc"><p>The CustomCommandAction creates a simulator-defined action.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the custom command.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>Content of the custom command.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : xml.etree.ElementTree.Element) -&gt; CustomCommandAction
Parses the XML element of a CustomCommandAction and returns an
instance of the class.
get_element() -&gt; xml.etree.ElementTree.Element
Returns the full ElementTree of the class.</p>
<p>Initialize the CustomCommandAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the custom command.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>Content of the custom command.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;CustomCommandAction&#34;:
    &#34;&#34;&#34;Parse the XML element of a CustomCommandAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A CustomCommandAction element.

    Returns
    -------
    CustomCommandAction
        A CustomCommandAction object.

    Raises
    ------
    NotAValidElement
        If the element is not a valid CustomCommandAction or is
        missing required attributes.
    &#34;&#34;&#34;
    if element.tag != &#34;CustomCommandAction&#34;:
        raise NotAValidElement(
            f&#39;Expected &#34;CustomCommandAction&#34; element, received &#34;{element.tag}&#34;.&#39;
        )
    action_type = element.attrib.get(&#34;type&#34;, None)
    if action_type is None:
        raise NotAValidElement(
            &#39;CustomCommandAction is missing required argument &#34;type&#34;.&#39;
        )

    return CustomCommandAction(action_type, element.text)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of a CustomCommandAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A CustomCommandAction element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></code></dt>
<dd>A CustomCommandAction object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotAValidElement</code></dt>
<dd>If the element is not a valid CustomCommandAction or is
missing required attributes.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generate an ElementTree element for the CustomCommandAction.

    Returns
    -------
    ET.Element
        An XML element representing the CustomCommandAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;CustomCommandAction&#34;, attrib={&#34;type&#34;: self.type})
    element.text = self.content
    return element</code></pre>
</details>
<div class="desc"><p>Generate an ElementTree element for the CustomCommandAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>An XML element representing the CustomCommandAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction"><code class="flex name class">
<span>class <span class="ident">DeleteEntityAction</span></span>
<span>(</span><span>entityref: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteEntityAction(_ActionType):
    &#34;&#34;&#34;The DeleteEntityAction class creates an EntityAction that removes an
    entity from the scenario.

    Parameters
    ----------
    entityref : str
        Reference name of the vehicle to remove.

    Attributes
    ----------
    entityref : str
        Reference name of the vehicle to remove.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, entityref: str):
        &#34;&#34;&#34;Initialize the DeleteEntityAction.

        Parameters
        ----------
        entityref : str
            Reference name of the vehicle to remove.
        &#34;&#34;&#34;

        self.entityref = entityref

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, DeleteEntityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;DeleteEntityAction&#34;:
        &#34;&#34;&#34;Parses the XML element of DeleteEntityAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A DeleteEntityAction element (same as generated by the class
            itself).

        Returns
        -------
        DeleteEntityAction
            A DeleteEntityAction object.
        &#34;&#34;&#34;
        ea_element = find_mandatory_field(element, &#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        return DeleteEntityAction(entityref)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the DeleteEntityAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            DeleteEntityAction.
        &#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the DeleteEntityAction.

        Returns
        -------
        ET.Element
            The XML element representing the DeleteEntityAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(
            element, &#34;EntityAction&#34;, attrib=self.get_attributes()
        )
        ET.SubElement(entityact, &#34;DeleteEntityAction&#34;)

        return element</code></pre>
</details>
<div class="desc"><p>The DeleteEntityAction class creates an EntityAction that removes an
entity from the scenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the vehicle to remove.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the vehicle to remove.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the DeleteEntityAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entityref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference name of the vehicle to remove.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.DeleteEntityAction" href="#scenariogeneration.xosc.actions.DeleteEntityAction">DeleteEntityAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;DeleteEntityAction&#34;:
    &#34;&#34;&#34;Parses the XML element of DeleteEntityAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A DeleteEntityAction element (same as generated by the class
        itself).

    Returns
    -------
    DeleteEntityAction
        A DeleteEntityAction object.
    &#34;&#34;&#34;
    ea_element = find_mandatory_field(element, &#34;EntityAction&#34;)
    entityref = ea_element.attrib[&#34;entityRef&#34;]
    return DeleteEntityAction(entityref)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of DeleteEntityAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A DeleteEntityAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction" href="#scenariogeneration.xosc.actions.DeleteEntityAction">DeleteEntityAction</a></code></dt>
<dd>A DeleteEntityAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the DeleteEntityAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        DeleteEntityAction.
    &#34;&#34;&#34;
    return {&#34;entityRef&#34;: self.entityref}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the DeleteEntityAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
DeleteEntityAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the DeleteEntityAction.

    Returns
    -------
    ET.Element
        The XML element representing the DeleteEntityAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    entityact = ET.SubElement(
        element, &#34;EntityAction&#34;, attrib=self.get_attributes()
    )
    ET.SubElement(entityact, &#34;DeleteEntityAction&#34;)

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the DeleteEntityAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the DeleteEntityAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.DisconnectTrailerAction"><code class="flex name class">
<span>class <span class="ident">DisconnectTrailerAction</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DisconnectTrailerAction(_PrivateActionType):
    &#34;&#34;&#34;DisconnectTrailerAction creates an TrailerAction of the type DisconnectTrailerAction.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, DisconnectTrailerAction):
            return True

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;DisconnectTrailerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of DisconnectTrailerAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A DisconnectTrailerAction element (same as generated by the class
            itself).

        Returns
        -------
        DisconnectTrailerAction
            A DisconnectTrailerAction object.
        &#34;&#34;&#34;
        return DisconnectTrailerAction()

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Constructs and returns an ElementTree representation of the
        DisconnectTrailerAction.

        Returns
        -------
        ET.Element
            The root XML element representing the DisconnectTrailerAction.
        &#34;&#34;&#34;
        if self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;DisconnectTrailerAction was added in OSC V1.3&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        trailer_element = ET.SubElement(element, &#34;TrailerAction&#34;)
        ET.SubElement(trailer_element, &#34;DisconnectTrailerAction&#34;)
        return element</code></pre>
</details>
<div class="desc"><p>DisconnectTrailerAction creates an TrailerAction of the type DisconnectTrailerAction.</p>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DisconnectTrailerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.DisconnectTrailerAction" href="#scenariogeneration.xosc.actions.DisconnectTrailerAction">DisconnectTrailerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;DisconnectTrailerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of DisconnectTrailerAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A DisconnectTrailerAction element (same as generated by the class
        itself).

    Returns
    -------
    DisconnectTrailerAction
        A DisconnectTrailerAction object.
    &#34;&#34;&#34;
    return DisconnectTrailerAction()</code></pre>
</details>
<div class="desc"><p>Parses the XML element of DisconnectTrailerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A DisconnectTrailerAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.DisconnectTrailerAction" href="#scenariogeneration.xosc.actions.DisconnectTrailerAction">DisconnectTrailerAction</a></code></dt>
<dd>A DisconnectTrailerAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DisconnectTrailerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Constructs and returns an ElementTree representation of the
    DisconnectTrailerAction.

    Returns
    -------
    ET.Element
        The root XML element representing the DisconnectTrailerAction.
    &#34;&#34;&#34;
    if self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;DisconnectTrailerAction was added in OSC V1.3&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    trailer_element = ET.SubElement(element, &#34;TrailerAction&#34;)
    ET.SubElement(trailer_element, &#34;DisconnectTrailerAction&#34;)
    return element</code></pre>
</details>
<div class="desc"><p>Constructs and returns an ElementTree representation of the
DisconnectTrailerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the DisconnectTrailerAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction"><code class="flex name class">
<span>class <span class="ident">EnvironmentAction</span></span>
<span>(</span><span>environment: <a title="scenariogeneration.xosc.utils.Environment" href="utils.html#scenariogeneration.xosc.utils.Environment">Environment</a> | <a title="scenariogeneration.xosc.utils.CatalogReference" href="utils.html#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnvironmentAction(_ActionType):
    &#34;&#34;&#34;The EnvironmentAction class creates a GlobalAction of the type
    EnvironmentAction.

    Parameters
    ----------
    environment : Environment or CatalogReference
        The environment to change to.

    Attributes
    ----------
    environment : Environment or CatalogReference
        The environment to change to.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class itself.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(self, environment: Union[Environment, CatalogReference]):
        &#34;&#34;&#34;Initialize the EnvironmentAction.

        Parameters
        ----------
        environment : Environment or CatalogReference
            The environment to change to.
        &#34;&#34;&#34;
        if not isinstance(environment, (Environment, CatalogReference)):
            raise TypeError(
                &#34;environment input not of type Environment or CatalogReference&#34;
            )
        self.environment = environment

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, EnvironmentAction):
            if self.environment == other.environment:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;EnvironmentAction&#34;:
        &#34;&#34;&#34;Parse the XML element of BoundingBox.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A orientation element (same as generated by the class itself).

        Returns
        -------
        BoundingBox
            A BoundingBox object.
        &#34;&#34;&#34;
        action_element = find_mandatory_field(element, &#34;EnvironmentAction&#34;)
        if action_element.find(&#34;Environment&#34;) is not None:
            environment = Environment.parse(
                find_mandatory_field(action_element, &#34;Environment&#34;)
            )
        elif action_element.find(&#34;CatalogReference&#34;) is not None:
            environment = CatalogReference.parse(
                find_mandatory_field(action_element, &#34;CatalogReference&#34;)
            )

        return EnvironmentAction(environment)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generate an XML element representing a global action.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element for the global action, containing an
            &#34;EnvironmentAction&#34; sub-element with the environment details.
        &#34;&#34;&#34;

        element = ET.Element(&#34;GlobalAction&#34;)
        envaction = ET.SubElement(element, &#34;EnvironmentAction&#34;)
        envaction.append(self.environment.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>The EnvironmentAction class creates a GlobalAction of the type
EnvironmentAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>environment</code></strong> :&ensp;<code>Environment</code> or <code>CatalogReference</code></dt>
<dd>The environment to change to.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>environment</code></strong> :&ensp;<code>Environment</code> or <code>CatalogReference</code></dt>
<dd>The environment to change to.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class itself.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the EnvironmentAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>environment</code></strong> :&ensp;<code>Environment</code> or <code>CatalogReference</code></dt>
<dd>The environment to change to.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.EnvironmentAction" href="#scenariogeneration.xosc.actions.EnvironmentAction">EnvironmentAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;EnvironmentAction&#34;:
    &#34;&#34;&#34;Parse the XML element of BoundingBox.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A orientation element (same as generated by the class itself).

    Returns
    -------
    BoundingBox
        A BoundingBox object.
    &#34;&#34;&#34;
    action_element = find_mandatory_field(element, &#34;EnvironmentAction&#34;)
    if action_element.find(&#34;Environment&#34;) is not None:
        environment = Environment.parse(
            find_mandatory_field(action_element, &#34;Environment&#34;)
        )
    elif action_element.find(&#34;CatalogReference&#34;) is not None:
        environment = CatalogReference.parse(
            find_mandatory_field(action_element, &#34;CatalogReference&#34;)
        )

    return EnvironmentAction(environment)</code></pre>
</details>
<div class="desc"><p>Parse the XML element of BoundingBox.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A orientation element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BoundingBox</code></dt>
<dd>A BoundingBox object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generate an XML element representing a global action.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element for the global action, containing an
        &#34;EnvironmentAction&#34; sub-element with the environment details.
    &#34;&#34;&#34;

    element = ET.Element(&#34;GlobalAction&#34;)
    envaction = ET.SubElement(element, &#34;EnvironmentAction&#34;)
    envaction.append(self.environment.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Generate an XML element representing a global action.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element for the global action, containing an
"EnvironmentAction" sub-element with the environment details.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction"><code class="flex name class">
<span>class <span class="ident">FollowTrajectoryAction</span></span>
<span>(</span><span>trajectory: <a title="scenariogeneration.xosc.position.Trajectory" href="position.html#scenariogeneration.xosc.position.Trajectory">Trajectory</a> | <a title="scenariogeneration.xosc.utils.CatalogReference" href="utils.html#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a>,<br>following_mode: <a title="scenariogeneration.xosc.enumerations.FollowingMode" href="enumerations.html#scenariogeneration.xosc.enumerations.FollowingMode">FollowingMode</a>,<br>reference_domain: str = None,<br>scale: float = None,<br>offset: float = None,<br>initialDistanceOffset: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FollowTrajectoryAction(_PrivateActionType):
    &#34;&#34;&#34;FollowTrajectoryAction creates a RouteAction of type
    FollowTrajectoryAction.

    Parameters
    ----------
    trajectory : Trajectory or CatalogReference
        The trajectory to follow.
    following_mode : FollowingMode
        The following mode of the action.
    reference_domain : ReferenceContext, optional
        How to follow. Default is None.
    scale : float, optional
        Scale factor of the timings (must be combined with
        reference_domain and offset). Default is None.
    offset : float, optional
        Offset for time values (must be combined with reference_domain
        and scale). Default is None.
    initialDistanceOffset : float, optional
        Start at this offset into the trajectory (valid from v1.1).
        Default is None.

    Attributes
    ----------
    trajectory : Trajectory or CatalogReference
        The trajectory to follow.
    following_mode : str
        The following mode of the action.
    timeref : TimeReference
        The time reference of the trajectory.
    initialDistanceOffset : float
        Start at this offset into the trajectory (valid from v1.1).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        trajectory: Union[Trajectory, CatalogReference],
        following_mode: FollowingMode,
        reference_domain: str = None,
        scale: float = None,
        offset: float = None,
        initialDistanceOffset: float = None,
    ):
        &#34;&#34;&#34;Initialize the FollowTrajectoryAction.

        Parameters
        ----------
        trajectory : Trajectory or CatalogReference
            The trajectory to follow.
        following_mode : FollowingMode
            The following mode of the action.
        reference_domain : str, optional
            Absolute or relative time reference (must be combined with
            scale and offset). Default is None.
        scale : float, optional
            Scale factor of the timings (must be combined with
            reference_domain and offset). Default is None.
        offset : float, optional
            Offset for time values (must be combined with r
            eference_domain and scale). Default is None.
        initialDistanceOffset : float, optional
            Start at this offset into the trajectory (valid from v1.1).
            Default is None.
        &#34;&#34;&#34;
        if not isinstance(trajectory, (Trajectory, CatalogReference)):
            raise TypeError(
                &#34;route input not of type Route or CatalogReference&#34;
            )
        self.trajectory = trajectory
        self.following_mode = convert_enum(following_mode, FollowingMode)
        # TODO: check reference_domain
        self.timeref = TimeReference(reference_domain, scale, offset)
        self.initialDistanceOffset = convert_float(initialDistanceOffset)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, FollowTrajectoryAction):
            if (
                self.timeref == other.timeref
                and self.get_attributes() == other.get_attributes()
                and self.trajectory == other.trajectory
                and self.following_mode == other.following_mode
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;FollowTrajectoryAction&#34;:
        &#34;&#34;&#34;Parses the XML element of FollowTrajectoryAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A FollowTrajectoryAction element (same as generated by the
            class itself).

        Returns
        -------
        FollowTrajectoryAction
            A FollowTrajectoryAction object.
        &#34;&#34;&#34;
        fta_element = find_mandatory_field(
            element, &#34;RoutingAction/FollowTrajectoryAction&#34;
        )
        initial_distance_offset = None
        if &#34;initialDistanceOffset&#34; in fta_element.attrib:
            initial_distance_offset = convert_float(
                fta_element.attrib[&#34;initialDistanceOffset&#34;]
            )

        timeref = TimeReference.parse(
            find_mandatory_field(fta_element, &#34;TimeReference&#34;)
        )
        reference_domain = timeref.reference_domain
        offset = timeref.offset
        scale = timeref.scale

        tfm_element = find_mandatory_field(
            fta_element, &#34;TrajectoryFollowingMode&#34;
        )
        following_mode = convert_enum(
            tfm_element.attrib[&#34;followingMode&#34;], FollowingMode
        )

        if fta_element.find(&#34;TrajectoryRef&#34;) is not None:
            fta_element = find_mandatory_field(fta_element, &#34;TrajectoryRef&#34;)
        trajectory = None
        if fta_element.find(&#34;Trajectory&#34;) is not None:
            trajectory = Trajectory.parse(
                find_mandatory_field(fta_element, &#34;Trajectory&#34;)
            )
        if fta_element.find(&#34;CatalogReference&#34;) is not None:
            trajectory = CatalogReference.parse(
                find_mandatory_field(fta_element, &#34;CatalogReference&#34;)
            )

        return FollowTrajectoryAction(
            trajectory,
            following_mode,
            reference_domain,
            scale,
            offset,
            initial_distance_offset,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the FollowTrajectoryAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            FollowTrajectoryAction.
        &#34;&#34;&#34;

        if self.initialDistanceOffset:
            return {&#34;initialDistanceOffset&#34;: str(self.initialDistanceOffset)}
        else:
            # If initialDistanceOffset is not set,
            # return empty to stay backward compatible with v1.0
            return {}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        FollowTrajectoryAction.

        Returns
        -------
        ET.Element
            The root XML element representing the FollowTrajectoryAction
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        trajaction = ET.SubElement(
            routeaction, &#34;FollowTrajectoryAction&#34;, attrib=self.get_attributes()
        )
        if self.isVersion(minor=0):
            trajaction.append(self.trajectory.get_element())
        else:
            trajref = ET.SubElement(trajaction, &#34;TrajectoryRef&#34;)
            trajref.append(self.trajectory.get_element())
        trajaction.append(self.timeref.get_element())
        ET.SubElement(
            trajaction,
            &#34;TrajectoryFollowingMode&#34;,
            attrib={&#34;followingMode&#34;: self.following_mode.get_name()},
        )

        return element</code></pre>
</details>
<div class="desc"><p>FollowTrajectoryAction creates a RouteAction of type
FollowTrajectoryAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>Trajectory</code> or <code>CatalogReference</code></dt>
<dd>The trajectory to follow.</dd>
<dt><strong><code>following_mode</code></strong> :&ensp;<code>FollowingMode</code></dt>
<dd>The following mode of the action.</dd>
<dt><strong><code>reference_domain</code></strong> :&ensp;<code>ReferenceContext</code>, optional</dt>
<dd>How to follow. Default is None.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Scale factor of the timings (must be combined with
reference_domain and offset). Default is None.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset for time values (must be combined with reference_domain
and scale). Default is None.</dd>
<dt><strong><code>initialDistanceOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start at this offset into the trajectory (valid from v1.1).
Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>Trajectory</code> or <code>CatalogReference</code></dt>
<dd>The trajectory to follow.</dd>
<dt><strong><code>following_mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The following mode of the action.</dd>
<dt><strong><code>timeref</code></strong> :&ensp;<code>TimeReference</code></dt>
<dd>The time reference of the trajectory.</dd>
<dt><strong><code>initialDistanceOffset</code></strong> :&ensp;<code>float</code></dt>
<dd>Start at this offset into the trajectory (valid from v1.1).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the FollowTrajectoryAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>Trajectory</code> or <code>CatalogReference</code></dt>
<dd>The trajectory to follow.</dd>
<dt><strong><code>following_mode</code></strong> :&ensp;<code>FollowingMode</code></dt>
<dd>The following mode of the action.</dd>
<dt><strong><code>reference_domain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Absolute or relative time reference (must be combined with
scale and offset). Default is None.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Scale factor of the timings (must be combined with
reference_domain and offset). Default is None.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset for time values (must be combined with r
eference_domain and scale). Default is None.</dd>
<dt><strong><code>initialDistanceOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Start at this offset into the trajectory (valid from v1.1).
Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.FollowTrajectoryAction" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction">FollowTrajectoryAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;FollowTrajectoryAction&#34;:
    &#34;&#34;&#34;Parses the XML element of FollowTrajectoryAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A FollowTrajectoryAction element (same as generated by the
        class itself).

    Returns
    -------
    FollowTrajectoryAction
        A FollowTrajectoryAction object.
    &#34;&#34;&#34;
    fta_element = find_mandatory_field(
        element, &#34;RoutingAction/FollowTrajectoryAction&#34;
    )
    initial_distance_offset = None
    if &#34;initialDistanceOffset&#34; in fta_element.attrib:
        initial_distance_offset = convert_float(
            fta_element.attrib[&#34;initialDistanceOffset&#34;]
        )

    timeref = TimeReference.parse(
        find_mandatory_field(fta_element, &#34;TimeReference&#34;)
    )
    reference_domain = timeref.reference_domain
    offset = timeref.offset
    scale = timeref.scale

    tfm_element = find_mandatory_field(
        fta_element, &#34;TrajectoryFollowingMode&#34;
    )
    following_mode = convert_enum(
        tfm_element.attrib[&#34;followingMode&#34;], FollowingMode
    )

    if fta_element.find(&#34;TrajectoryRef&#34;) is not None:
        fta_element = find_mandatory_field(fta_element, &#34;TrajectoryRef&#34;)
    trajectory = None
    if fta_element.find(&#34;Trajectory&#34;) is not None:
        trajectory = Trajectory.parse(
            find_mandatory_field(fta_element, &#34;Trajectory&#34;)
        )
    if fta_element.find(&#34;CatalogReference&#34;) is not None:
        trajectory = CatalogReference.parse(
            find_mandatory_field(fta_element, &#34;CatalogReference&#34;)
        )

    return FollowTrajectoryAction(
        trajectory,
        following_mode,
        reference_domain,
        scale,
        offset,
        initial_distance_offset,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of FollowTrajectoryAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A FollowTrajectoryAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction">FollowTrajectoryAction</a></code></dt>
<dd>A FollowTrajectoryAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the FollowTrajectoryAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        FollowTrajectoryAction.
    &#34;&#34;&#34;

    if self.initialDistanceOffset:
        return {&#34;initialDistanceOffset&#34;: str(self.initialDistanceOffset)}
    else:
        # If initialDistanceOffset is not set,
        # return empty to stay backward compatible with v1.0
        return {}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the FollowTrajectoryAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
FollowTrajectoryAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    FollowTrajectoryAction.

    Returns
    -------
    ET.Element
        The root XML element representing the FollowTrajectoryAction
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    trajaction = ET.SubElement(
        routeaction, &#34;FollowTrajectoryAction&#34;, attrib=self.get_attributes()
    )
    if self.isVersion(minor=0):
        trajaction.append(self.trajectory.get_element())
    else:
        trajref = ET.SubElement(trajaction, &#34;TrajectoryRef&#34;)
        trajref.append(self.trajectory.get_element())
    trajaction.append(self.timeref.get_element())
    ET.SubElement(
        trajaction,
        &#34;TrajectoryFollowingMode&#34;,
        attrib={&#34;followingMode&#34;: self.following_mode.get_name()},
    )

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
FollowTrajectoryAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the FollowTrajectoryAction</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction"><code class="flex name class">
<span>class <span class="ident">LateralDistanceAction</span></span>
<span>(</span><span>entity: str,<br>distance: float | None = None,<br>freespace: bool = True,<br>continuous: bool = True,<br>max_acceleration: float | None = None,<br>max_deceleration: float | None = None,<br>max_speed: float | None = None,<br>coordinate_system: <a title="scenariogeneration.xosc.enumerations.CoordinateSystem" href="enumerations.html#scenariogeneration.xosc.enumerations.CoordinateSystem">CoordinateSystem</a> = &lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;,<br>displacement: <a title="scenariogeneration.xosc.enumerations.LateralDisplacement" href="enumerations.html#scenariogeneration.xosc.enumerations.LateralDisplacement">LateralDisplacement</a> = &lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LateralDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;
    Parameters
    ----------
    entity : str
        The target name.
    distance : float
        The lateral distance to the entity.
    freespace : bool, optional
        (True) distance between bounding boxes,
        (False) distance between ref point. Default is True.
    continuous : bool, optional
        If the controller tries to keep the relative speed. Default is True.
    max_acceleration : float, optional
        Maximum acceleration allowed. Default is None.
    max_deceleration : float, optional
        Maximum deceleration allowed. Default is None.
    max_speed : float, optional
        Maximum speed allowed. Default is None.
    coordinate_system : CoordinateSystem, optional
        The coordinate system for the distance calculation.
        Default is CoordinateSystem.entity.
    displacement : LateralDisplacement, optional
        Type of displacement wanted. Default is LateralDisplacement.any.

    Attributes
    ----------
    entity : str
        The target name.
    distance : float
        The lateral distance to the entity.
    freespace : bool
        (True) distance between bounding boxes,
        (False) distance between ref point.
    continuous : bool
        If the controller tries to keep the relative speed.
    distance : float
        If the distance metric is used.
    timegap : float
        If timegap metric is used.
    dynamic_constraint : DynamicsConstraints
        Dynamics constraints of the action.
    coordinate_system : CoordinateSystem
        The coordinate system for the distance calculation.
    displacement : LateralDisplacement
        Type of displacement wanted.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        entity: str,
        distance: Optional[float] = None,
        freespace: bool = True,
        continuous: bool = True,
        max_acceleration: Optional[float] = None,
        max_deceleration: Optional[float] = None,
        max_speed: Optional[float] = None,
        coordinate_system: CoordinateSystem = CoordinateSystem.entity,
        displacement: LateralDisplacement = LateralDisplacement.any,
    ):
        &#34;&#34;&#34;Initializes the LateralDistanceAction.

        Parameters
        ----------
        entity : str
            The target name.
        distance : float, optional
            The lateral distance to the entity. Default is None.
        freespace : bool, optional
            If True, distance is measured between bounding boxes;
            if False, distance is measured between reference points.
            Default is True.
        continuous : bool, optional
            If True, the controller tries to maintain the relative speed
            Default is True.
        max_acceleration : float, optional
            Maximum acceleration allowed. Default is None.
        max_deceleration : float, optional
            Maximum deceleration allowed. Default is None.
        max_speed : float, optional
            Maximum speed allowed. Default is None.
        coordinate_system : CoordinateSystem, optional
            The coordinate system for the distance calculation.
            Default is CoordinateSystem.entity.
        displacement : LateralDisplacement, optional
            Type of displacement wanted.
            Default is LateralDisplacement.any.
        &#34;&#34;&#34;
        self.distance = distance
        self.target = entity

        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration, max_deceleration, max_speed
        )
        self.coordinate_system = convert_enum(
            coordinate_system, CoordinateSystem
        )
        self.displacement = convert_enum(displacement, LateralDisplacement)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, LateralDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;LateralDistanceAction&#34;:
        &#34;&#34;&#34;Parses the XML element of LateralDistanceAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A LateralDistanceAction element (same as generated by the
            class itself).

        Returns
        -------
        LateralDistanceAction
            A LateralDistanceAction object.
        &#34;&#34;&#34;
        lda_element = find_mandatory_field(
            element, &#34;LateralAction/LateralDistanceAction&#34;
        )
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        entity = lda_element.attrib[&#34;entityRef&#34;]
        distance = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = lda_element.attrib[&#34;distance&#34;]
        coordinate = None
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem
            )
        displacement = None
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;], LateralDisplacement
            )
        constraints = None
        max_acc = None
        max_dec = None
        max_speed = None
        if lda_element.find(&#34;DynamicConstraints&#34;) is not None:
            constraints = DynamicsConstraints.parse(
                find_mandatory_field(lda_element, &#34;DynamicConstraints&#34;)
            )
            max_acc = constraints.max_acceleration
            max_dec = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LateralDistanceAction(
            entity,
            distance,
            freespace,
            continuous,
            max_acc,
            max_dec,
            max_speed,
            coordinate,
            displacement,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the LateralDistanceAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            LateralDistanceAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance is not None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Constructs and returns an XML element tree representation of the
        LateralDistanceAction.

        Returns
        -------
        ET.Element
            The root XML element representing the LateralDistanceAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        lateraldistanceaction = ET.SubElement(
            lataction, &#34;LateralDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            lateraldistanceaction.append(self.dynamic_constraint.get_element())

        return element</code></pre>
</details>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>The lateral distance to the entity.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>(True) distance between bounding boxes,
(False) distance between ref point. Default is True.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed. Default is True.</dd>
<dt><strong><code>max_acceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum acceleration allowed. Default is None.</dd>
<dt><strong><code>max_deceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum deceleration allowed. Default is None.</dd>
<dt><strong><code>max_speed</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum speed allowed. Default is None.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code>, optional</dt>
<dd>The coordinate system for the distance calculation.
Default is CoordinateSystem.entity.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LateralDisplacement</code>, optional</dt>
<dd>Type of displacement wanted. Default is LateralDisplacement.any.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>The lateral distance to the entity.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code></dt>
<dd>(True) distance between bounding boxes,
(False) distance between ref point.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the controller tries to keep the relative speed.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>If the distance metric is used.</dd>
<dt><strong><code>timegap</code></strong> :&ensp;<code>float</code></dt>
<dd>If timegap metric is used.</dd>
<dt><strong><code>dynamic_constraint</code></strong> :&ensp;<code>DynamicsConstraints</code></dt>
<dd>Dynamics constraints of the action.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code></dt>
<dd>The coordinate system for the distance calculation.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LateralDisplacement</code></dt>
<dd>Type of displacement wanted.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initializes the LateralDistanceAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The lateral distance to the entity. Default is None.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, distance is measured between bounding boxes;
if False, distance is measured between reference points.
Default is True.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the controller tries to maintain the relative speed
Default is True.</dd>
<dt><strong><code>max_acceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum acceleration allowed. Default is None.</dd>
<dt><strong><code>max_deceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum deceleration allowed. Default is None.</dd>
<dt><strong><code>max_speed</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum speed allowed. Default is None.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code>, optional</dt>
<dd>The coordinate system for the distance calculation.
Default is CoordinateSystem.entity.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LateralDisplacement</code>, optional</dt>
<dd>Type of displacement wanted.
Default is LateralDisplacement.any.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.LateralDistanceAction" href="#scenariogeneration.xosc.actions.LateralDistanceAction">LateralDistanceAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;LateralDistanceAction&#34;:
    &#34;&#34;&#34;Parses the XML element of LateralDistanceAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A LateralDistanceAction element (same as generated by the
        class itself).

    Returns
    -------
    LateralDistanceAction
        A LateralDistanceAction object.
    &#34;&#34;&#34;
    lda_element = find_mandatory_field(
        element, &#34;LateralAction/LateralDistanceAction&#34;
    )
    continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
    freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
    entity = lda_element.attrib[&#34;entityRef&#34;]
    distance = None
    if &#34;distance&#34; in lda_element.attrib:
        distance = lda_element.attrib[&#34;distance&#34;]
    coordinate = None
    if &#34;coordinateSystem&#34; in lda_element.attrib:
        coordinate = convert_enum(
            lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem
        )
    displacement = None
    if &#34;displacement&#34; in lda_element.attrib:
        displacement = convert_enum(
            lda_element.attrib[&#34;displacement&#34;], LateralDisplacement
        )
    constraints = None
    max_acc = None
    max_dec = None
    max_speed = None
    if lda_element.find(&#34;DynamicConstraints&#34;) is not None:
        constraints = DynamicsConstraints.parse(
            find_mandatory_field(lda_element, &#34;DynamicConstraints&#34;)
        )
        max_acc = constraints.max_acceleration
        max_dec = constraints.max_deceleration
        max_speed = constraints.max_speed

    return LateralDistanceAction(
        entity,
        distance,
        freespace,
        continuous,
        max_acc,
        max_dec,
        max_speed,
        coordinate,
        displacement,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of LateralDistanceAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A LateralDistanceAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction" href="#scenariogeneration.xosc.actions.LateralDistanceAction">LateralDistanceAction</a></code></dt>
<dd>A LateralDistanceAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the LateralDistanceAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        LateralDistanceAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
    retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
    if self.distance is not None:
        retdict[&#34;distance&#34;] = str(self.distance)
    if not self.isVersion(minor=0):
        retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        retdict[&#34;displacement&#34;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the LateralDistanceAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
LateralDistanceAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Constructs and returns an XML element tree representation of the
    LateralDistanceAction.

    Returns
    -------
    ET.Element
        The root XML element representing the LateralDistanceAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    lateraldistanceaction = ET.SubElement(
        lataction, &#34;LateralDistanceAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamic_constraint.is_filled():
        lateraldistanceaction.append(self.dynamic_constraint.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Constructs and returns an XML element tree representation of the
LateralDistanceAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the LateralDistanceAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LightStateAction"><code class="flex name class">
<span>class <span class="ident">LightStateAction</span></span>
<span>(</span><span>light_type: <a title="scenariogeneration.xosc.enumerations.VehicleLightType" href="enumerations.html#scenariogeneration.xosc.enumerations.VehicleLightType">VehicleLightType</a> | <a title="scenariogeneration.xosc.utils.UserDefinedLight" href="utils.html#scenariogeneration.xosc.utils.UserDefinedLight">UserDefinedLight</a>,<br>mode: <a title="scenariogeneration.xosc.enumerations.LightMode" href="enumerations.html#scenariogeneration.xosc.enumerations.LightMode">LightMode</a>,<br>transition_time: float = 0,<br>flashing_off_duration: float | None = None,<br>flashing_on_duration: float | None = None,<br>intensity: float | None = None,<br>color: <a title="scenariogeneration.xosc.utils.Color" href="utils.html#scenariogeneration.xosc.utils.Color">Color</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightStateAction(_PrivateActionType):
    &#34;&#34;&#34;LightStateAction creates an AppearanceAction of the Type
    LightStateAction.

    Parameters
    ----------
    light_type : VehicleLightType or UserDefinedLight
        The type of the light.
    mode : LightMode
        The new mode of the light.
    transition_time : float, optional
        The transition time of the light. Default is 0.
    flashing_off_duration : float, optional
        How long the light should be off when LightMode is set to
        &#34;flashing&#34;.
    flashing_on_duration : float, optional
        How long the light should be on when LightMode is set to
        &#34;flashing&#34;.
    intensity : float, optional
        The luminous intensity of the light.
    color : Color, optional
        The color of the light.

    Attributes
    ----------
    lightstate : _LightState
        The type of light.
    light_type : VehicleLightType or UserDefinedLight
        The state of the light.
    transition_time : float, optional
        The transition time of the light. Default is 0.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        light_type: Union[VehicleLightType, UserDefinedLight],
        mode: LightMode,
        transition_time: float = 0,
        flashing_off_duration: Optional[float] = None,
        flashing_on_duration: Optional[float] = None,
        intensity: Optional[float] = None,
        color: Optional[Color] = None,
    ):
        &#34;&#34;&#34;Initialize the LightStateAction.

        Parameters
        ----------
        light_type : VehicleLightType or UserDefinedLight
            The type of the light.
        mode : LightMode
            The new mode of the light.
        transition_time : float, optional
            The transition time of the light. Default is 0.
        flashing_off_duration : float, optional
            Duration the light should be off when LightMode is set to
            &#34;flashing&#34;.
        flashing_on_duration : float, optional
            Duration the light should be on when LightMode is set to
            &#34;flashing&#34;.
        intensity : float, optional
            The luminous intensity of the light.
        color : Color, optional
            The color of the light.
        &#34;&#34;&#34;
        try:
            self.light_type = convert_enum(light_type, VehicleLightType)
        except Exception:
            if not isinstance(light_type, UserDefinedLight):
                raise TypeError(
                    &#34;light_type input is not of type VehicleLightType or UserDefinedLight&#34;
                )

            self.light_type = light_type

        self.lightstate = _LightState(
            mode, color, intensity, flashing_off_duration, flashing_on_duration
        )

        self.transition_time = convert_float(transition_time)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, LightStateAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.light_type == other.light_type
                and self.lightstate == other.lightstate
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;LightStateAction&#34;:
        &#34;&#34;&#34;Parses the XML element of LightStateAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A LightStateAction element (same as generated by the class
            itself).

        Returns
        -------
        LightStateAction
            A LightStateAction object.
        &#34;&#34;&#34;
        light_element = find_mandatory_field(
            element, &#34;AppearanceAction/LightStateAction&#34;
        )
        transition_time = None
        if &#34;transitionTime&#34; in light_element.attrib:
            transition_time = convert_float(
                light_element.attrib[&#34;transitionTime&#34;]
            )
        light_state = _LightState.parse(
            find_mandatory_field(light_element, &#34;LightState&#34;)
        )
        type_element = find_mandatory_field(light_element, &#34;LightType&#34;)
        if type_element.find(&#34;UserDefinedLight&#34;) is not None:
            light_type = UserDefinedLight.parse(
                find_mandatory_field(type_element, &#34;UserDefinedLight&#34;)
            )
        else:
            light_type = convert_enum(
                find_mandatory_field(type_element, &#34;VehicleLight&#34;).attrib[
                    &#34;vehicleLightType&#34;
                ],
                VehicleLightType,
            )
        # create with dummy mode
        light_state_action = LightStateAction(
            light_type, LightMode.on, transition_time
        )
        light_state_action.lightstate = light_state
        return light_state_action

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the LightStateAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the LightStateAction.
        &#34;&#34;&#34;
        attr = {&#34;transitionTime&#34;: str(self.transition_time)}
        return attr

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the LightStateAction.&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        light_element = ET.SubElement(
            appear_element, &#34;LightStateAction&#34;, self.get_attributes()
        )
        light_element.append(self.lightstate.get_element())

        light_type_element = ET.SubElement(light_element, &#34;LightType&#34;)
        if hasattr(VehicleLightType, str(self.light_type)):
            ET.SubElement(
                light_type_element,
                &#34;VehicleLight&#34;,
                attrib={&#34;vehicleLightType&#34;: self.light_type.get_name()},
            )
        else:
            light_type_element.append(self.light_type.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>LightStateAction creates an AppearanceAction of the Type
LightStateAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>light_type</code></strong> :&ensp;<code>VehicleLightType</code> or <code>UserDefinedLight</code></dt>
<dd>The type of the light.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>LightMode</code></dt>
<dd>The new mode of the light.</dd>
<dt><strong><code>transition_time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The transition time of the light. Default is 0.</dd>
<dt><strong><code>flashing_off_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>How long the light should be off when LightMode is set to
"flashing".</dd>
<dt><strong><code>flashing_on_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>How long the light should be on when LightMode is set to
"flashing".</dd>
<dt><strong><code>intensity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The luminous intensity of the light.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>Color</code>, optional</dt>
<dd>The color of the light.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lightstate</code></strong> :&ensp;<code>_LightState</code></dt>
<dd>The type of light.</dd>
<dt><strong><code>light_type</code></strong> :&ensp;<code>VehicleLightType</code> or <code>UserDefinedLight</code></dt>
<dd>The state of the light.</dd>
<dt><strong><code>transition_time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The transition time of the light. Default is 0.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the class.</p>
<p>Initialize the LightStateAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>light_type</code></strong> :&ensp;<code>VehicleLightType</code> or <code>UserDefinedLight</code></dt>
<dd>The type of the light.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>LightMode</code></dt>
<dd>The new mode of the light.</dd>
<dt><strong><code>transition_time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The transition time of the light. Default is 0.</dd>
<dt><strong><code>flashing_off_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Duration the light should be off when LightMode is set to
"flashing".</dd>
<dt><strong><code>flashing_on_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Duration the light should be on when LightMode is set to
"flashing".</dd>
<dt><strong><code>intensity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The luminous intensity of the light.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>Color</code>, optional</dt>
<dd>The color of the light.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LightStateAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.LightStateAction" href="#scenariogeneration.xosc.actions.LightStateAction">LightStateAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;LightStateAction&#34;:
    &#34;&#34;&#34;Parses the XML element of LightStateAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A LightStateAction element (same as generated by the class
        itself).

    Returns
    -------
    LightStateAction
        A LightStateAction object.
    &#34;&#34;&#34;
    light_element = find_mandatory_field(
        element, &#34;AppearanceAction/LightStateAction&#34;
    )
    transition_time = None
    if &#34;transitionTime&#34; in light_element.attrib:
        transition_time = convert_float(
            light_element.attrib[&#34;transitionTime&#34;]
        )
    light_state = _LightState.parse(
        find_mandatory_field(light_element, &#34;LightState&#34;)
    )
    type_element = find_mandatory_field(light_element, &#34;LightType&#34;)
    if type_element.find(&#34;UserDefinedLight&#34;) is not None:
        light_type = UserDefinedLight.parse(
            find_mandatory_field(type_element, &#34;UserDefinedLight&#34;)
        )
    else:
        light_type = convert_enum(
            find_mandatory_field(type_element, &#34;VehicleLight&#34;).attrib[
                &#34;vehicleLightType&#34;
            ],
            VehicleLightType,
        )
    # create with dummy mode
    light_state_action = LightStateAction(
        light_type, LightMode.on, transition_time
    )
    light_state_action.lightstate = light_state
    return light_state_action</code></pre>
</details>
<div class="desc"><p>Parses the XML element of LightStateAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A LightStateAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.LightStateAction" href="#scenariogeneration.xosc.actions.LightStateAction">LightStateAction</a></code></dt>
<dd>A LightStateAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LightStateAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the LightStateAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the LightStateAction.
    &#34;&#34;&#34;
    attr = {&#34;transitionTime&#34;: str(self.transition_time)}
    return attr</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the LightStateAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the LightStateAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.LightStateAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the LightStateAction.&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
    light_element = ET.SubElement(
        appear_element, &#34;LightStateAction&#34;, self.get_attributes()
    )
    light_element.append(self.lightstate.get_element())

    light_type_element = ET.SubElement(light_element, &#34;LightType&#34;)
    if hasattr(VehicleLightType, str(self.light_type)):
        ET.SubElement(
            light_type_element,
            &#34;VehicleLight&#34;,
            attrib={&#34;vehicleLightType&#34;: self.light_type.get_name()},
        )
    else:
        light_type_element.append(self.light_type.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the LightStateAction.</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction"><code class="flex name class">
<span>class <span class="ident">LongitudinalDistanceAction</span></span>
<span>(</span><span>entity: str,<br>freespace: bool = True,<br>continuous: bool = True,<br>max_acceleration=None,<br>max_deceleration=None,<br>max_speed: float = None,<br>distance: float = None,<br>timeGap: float = None,<br>coordinate_system: <a title="scenariogeneration.xosc.enumerations.CoordinateSystem" href="enumerations.html#scenariogeneration.xosc.enumerations.CoordinateSystem">CoordinateSystem</a> = &lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;,<br>displacement: <a title="scenariogeneration.xosc.enumerations.LongitudinalDisplacement" href="enumerations.html#scenariogeneration.xosc.enumerations.LongitudinalDisplacement">LongitudinalDisplacement</a> = &lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;,<br>max_acceleration_rate: float = None,<br>max_deceleration_rate: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LongitudinalDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;The LongitudinalAction creates a LongitudinalAction of type
    LongitudinalAction with a distance target.

    Parameters
    ----------
    entity : str
        The target name.
    freespace : bool, optional
        (True) distance between bounding boxes,
        (False) distance between ref point. Default is True.
    continuous : bool, optional
        If the controller tries to keep the relative speed.
        Default is True.
    max_acceleration : float, optional
        Maximum acceleration allowed. Default is None.
    max_deceleration : float, optional
        Maximum deceleration allowed. Default is None.
    max_speed : float, optional
        Maximum speed allowed. Default is None.
    distance : float
        Distance to the entity.
    timegap : float
        Time to the target.
    coordinate_system : CoordinateSystem, optional
        The coordinate system for the distance calculation.
        Default is CoordinateSystem.entity.
    displacement : LongitudinalDisplacement, optional
        Type of displacement wanted.
        Default is LongitudinalDisplacement.any.
    max_acceleration_rate : float, optional
        Max jerk in acceleration (Valid from OpenSCENARIO 1.2).
        Default is None.
    max_deceleration_rate : float, optional
        Max jerk in deceleration (Valid from OpenSCENARIO 1.2).
        Default is None.

    Attributes
    ----------
    entity : str
        The target name.
    freespace : bool
        (True) distance between bounding boxes,
        (False) distance between ref point.
    continuous : bool
        If the controller tries to keep the relative speed.
    distance : float
        The distance to the entity.
    dynamic_constraint : DynamicsConstraints
        Dynamics constraints of the action.
    coordinate_system : CoordinateSystem
        The coordinate system for the distance calculation.
    displacement : LongitudinalDisplacement
        Type of displacement wanted.
    max_acceleration_rate : float
        Max jerk in acceleration (Valid from OpenSCENARIO 1.2).
    max_deceleration_rate : float
        Max jerk in deceleration (Valid from OpenSCENARIO 1.2).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        entity: str,
        freespace: bool = True,
        continuous: bool = True,
        max_acceleration=None,
        max_deceleration=None,
        max_speed: float = None,
        distance: float = None,
        timeGap: float = None,
        coordinate_system: CoordinateSystem = CoordinateSystem.entity,
        displacement: LongitudinalDisplacement = LongitudinalDisplacement.any,
        max_acceleration_rate: float = None,
        max_deceleration_rate: float = None,
    ):
        &#34;&#34;&#34;Initialize the LongitudinalDistanceAction.

        Parameters
        ----------
        entity : str
            The target name.
        freespace : bool, optional
            (True) distance between bounding boxes,
            (False) distance between ref point. Default is True.
        continuous : bool, optional
            If the controller tries to keep the relative speed.
            Default is True.
        max_acceleration : float, optional
            Maximum acceleration allowed. Default is None.
        max_deceleration : float, optional
            Maximum deceleration allowed. Default is None.
        max_speed : float, optional
            Maximum speed allowed. Default is None.
        distance : float
            Distance to the entity.
        timegap : float
            Time to the target.
        coordinate_system : CoordinateSystem, optional
            The coordinate system for the distance calculation.
            Default is CoordinateSystem.entity.
        displacement : LongitudinalDisplacement, optional
            Type of displacement wanted.
            Default is LongitudinalDisplacement.any.
        max_acceleration_rate : float, optional
            Max jerk in acceleration (Valid from OpenSCENARIO 1.2).
            Default is None.
        max_deceleration_rate : float, optional
            Max jerk in deceleration (Valid from OpenSCENARIO 1.2).
            Default is None.
        &#34;&#34;&#34;
        self.target = entity
        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration,
            max_deceleration,
            max_speed,
            max_acceleration_rate,
            max_deceleration_rate,
        )

        if distance is not None and timeGap is not None:
            raise ToManyOptionalArguments(
                &#34;Not both of distance and timeGap can be used.&#34;
            )
        if distance is None and timeGap is None:
            raise NotEnoughInputArguments(
                &#34;Either ds or dsLane is needed as input.&#34;
            )
        self.distance = convert_float(distance)
        self.timeGap = convert_float(timeGap)

        self.coordinate_system = convert_enum(
            coordinate_system, CoordinateSystem
        )
        self.displacement = convert_enum(
            displacement, LongitudinalDisplacement
        )

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, LongitudinalDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;LongitudinalDistanceAction&#34;:
        &#34;&#34;&#34;Parses the XML element of LongitudinalAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A LongitudinalDistanceAction element
            (same as generated by the class itself).

        Returns
        -------
        LongitudinalDistanceAction
            A LongitudinalDistanceAction object.
        &#34;&#34;&#34;
        lda_element = find_mandatory_field(
            element, &#34;LongitudinalAction/LongitudinalDistanceAction&#34;
        )
        entity = lda_element.attrib[&#34;entityRef&#34;]
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        distance = None
        timeGap = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = convert_float(lda_element.attrib[&#34;distance&#34;])
        if &#34;timeGap&#34; in lda_element.attrib:
            timeGap = convert_float(lda_element.attrib[&#34;timeGap&#34;])

        coordinate_system = CoordinateSystem.entity
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate_system = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem, False
            )
        displacement = LongitudinalDisplacement.any
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;],
                LongitudinalDisplacement,
                False,
            )
        max_acceleration = None
        max_deceleration = None
        max_speed = None
        constraints = None
        if lda_element.find(&#34;DynamicConstraints&#34;) is not None:
            constraints = DynamicsConstraints.parse(
                find_mandatory_field(lda_element, &#34;DynamicConstraints&#34;)
            )
            max_acceleration = constraints.max_acceleration
            max_deceleration = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LongitudinalDistanceAction(
            entity,
            freespace,
            continuous,
            max_acceleration,
            max_deceleration,
            max_speed,
            distance,
            timeGap,
            coordinate_system,
            displacement,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the LongitudinalDistanceAction as a
        dictionary.

        as a dictionary   Reas a dictionary   turns
        -------
        dict
            A dictionary containing the attributes of the
            LongitudinalDistanceAction
        &#34;&#34;&#34;

        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance is not None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if self.timeGap is not None:
            retdict[&#34;timeGap&#34;] = str(self.timeGap)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        LongitudinalDistanceAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the
            LongitudinalDistanceAction.
        &#34;&#34;&#34;

        element = ET.Element(&#34;PrivateAction&#34;)
        longact = ET.SubElement(element, &#34;LongitudinalAction&#34;)

        longdistaction = ET.SubElement(
            longact, &#34;LongitudinalDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The LongitudinalAction creates a LongitudinalAction of type
LongitudinalAction with a distance target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>(True) distance between bounding boxes,
(False) distance between ref point. Default is True.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
<dt><strong><code>max_acceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum acceleration allowed. Default is None.</dd>
<dt><strong><code>max_deceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum deceleration allowed. Default is None.</dd>
<dt><strong><code>max_speed</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum speed allowed. Default is None.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance to the entity.</dd>
<dt><strong><code>timegap</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to the target.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code>, optional</dt>
<dd>The coordinate system for the distance calculation.
Default is CoordinateSystem.entity.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LongitudinalDisplacement</code>, optional</dt>
<dd>Type of displacement wanted.
Default is LongitudinalDisplacement.any.</dd>
<dt><strong><code>max_acceleration_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Max jerk in acceleration (Valid from OpenSCENARIO 1.2).
Default is None.</dd>
<dt><strong><code>max_deceleration_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Max jerk in deceleration (Valid from OpenSCENARIO 1.2).
Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code></dt>
<dd>(True) distance between bounding boxes,
(False) distance between ref point.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the controller tries to keep the relative speed.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>The distance to the entity.</dd>
<dt><strong><code>dynamic_constraint</code></strong> :&ensp;<code>DynamicsConstraints</code></dt>
<dd>Dynamics constraints of the action.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code></dt>
<dd>The coordinate system for the distance calculation.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LongitudinalDisplacement</code></dt>
<dd>Type of displacement wanted.</dd>
<dt><strong><code>max_acceleration_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Max jerk in acceleration (Valid from OpenSCENARIO 1.2).</dd>
<dt><strong><code>max_deceleration_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Max jerk in deceleration (Valid from OpenSCENARIO 1.2).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the LongitudinalDistanceAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The target name.</dd>
<dt><strong><code>freespace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>(True) distance between bounding boxes,
(False) distance between ref point. Default is True.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
<dt><strong><code>max_acceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum acceleration allowed. Default is None.</dd>
<dt><strong><code>max_deceleration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum deceleration allowed. Default is None.</dd>
<dt><strong><code>max_speed</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum speed allowed. Default is None.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance to the entity.</dd>
<dt><strong><code>timegap</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to the target.</dd>
<dt><strong><code>coordinate_system</code></strong> :&ensp;<code>CoordinateSystem</code>, optional</dt>
<dd>The coordinate system for the distance calculation.
Default is CoordinateSystem.entity.</dd>
<dt><strong><code>displacement</code></strong> :&ensp;<code>LongitudinalDisplacement</code>, optional</dt>
<dd>Type of displacement wanted.
Default is LongitudinalDisplacement.any.</dd>
<dt><strong><code>max_acceleration_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Max jerk in acceleration (Valid from OpenSCENARIO 1.2).
Default is None.</dd>
<dt><strong><code>max_deceleration_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Max jerk in deceleration (Valid from OpenSCENARIO 1.2).
Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction">LongitudinalDistanceAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;LongitudinalDistanceAction&#34;:
    &#34;&#34;&#34;Parses the XML element of LongitudinalAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A LongitudinalDistanceAction element
        (same as generated by the class itself).

    Returns
    -------
    LongitudinalDistanceAction
        A LongitudinalDistanceAction object.
    &#34;&#34;&#34;
    lda_element = find_mandatory_field(
        element, &#34;LongitudinalAction/LongitudinalDistanceAction&#34;
    )
    entity = lda_element.attrib[&#34;entityRef&#34;]
    freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
    continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
    distance = None
    timeGap = None
    if &#34;distance&#34; in lda_element.attrib:
        distance = convert_float(lda_element.attrib[&#34;distance&#34;])
    if &#34;timeGap&#34; in lda_element.attrib:
        timeGap = convert_float(lda_element.attrib[&#34;timeGap&#34;])

    coordinate_system = CoordinateSystem.entity
    if &#34;coordinateSystem&#34; in lda_element.attrib:
        coordinate_system = convert_enum(
            lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem, False
        )
    displacement = LongitudinalDisplacement.any
    if &#34;displacement&#34; in lda_element.attrib:
        displacement = convert_enum(
            lda_element.attrib[&#34;displacement&#34;],
            LongitudinalDisplacement,
            False,
        )
    max_acceleration = None
    max_deceleration = None
    max_speed = None
    constraints = None
    if lda_element.find(&#34;DynamicConstraints&#34;) is not None:
        constraints = DynamicsConstraints.parse(
            find_mandatory_field(lda_element, &#34;DynamicConstraints&#34;)
        )
        max_acceleration = constraints.max_acceleration
        max_deceleration = constraints.max_deceleration
        max_speed = constraints.max_speed

    return LongitudinalDistanceAction(
        entity,
        freespace,
        continuous,
        max_acceleration,
        max_deceleration,
        max_speed,
        distance,
        timeGap,
        coordinate_system,
        displacement,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of LongitudinalAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A LongitudinalDistanceAction element
(same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction">LongitudinalDistanceAction</a></code></dt>
<dd>A LongitudinalDistanceAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the LongitudinalDistanceAction as a
    dictionary.

    as a dictionary   Reas a dictionary   turns
    -------
    dict
        A dictionary containing the attributes of the
        LongitudinalDistanceAction
    &#34;&#34;&#34;

    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
    retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
    if self.distance is not None:
        retdict[&#34;distance&#34;] = str(self.distance)
    if self.timeGap is not None:
        retdict[&#34;timeGap&#34;] = str(self.timeGap)
    if not self.isVersion(minor=0):
        retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        retdict[&#34;displacement&#34;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the LongitudinalDistanceAction as a
dictionary.</p>
<h2 id="as-a-dictionary-reas-a-dictionary-turns">As A Dictionary
Reas A Dictionary
Turns</h2>
<p>dict
A dictionary containing the attributes of the
LongitudinalDistanceAction</p></div>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    LongitudinalDistanceAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the
        LongitudinalDistanceAction.
    &#34;&#34;&#34;

    element = ET.Element(&#34;PrivateAction&#34;)
    longact = ET.SubElement(element, &#34;LongitudinalAction&#34;)

    longdistaction = ET.SubElement(
        longact, &#34;LongitudinalDistanceAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamic_constraint.is_filled():
        longdistaction.append(self.dynamic_constraint.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
LongitudinalDistanceAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the
LongitudinalDistanceAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ObjectController"><code class="flex name class">
<span>class <span class="ident">ObjectController</span></span>
<span>(</span><span>name: str,<br>catalog_ref: <a title="scenariogeneration.xosc.utils.CatalogReference" href="utils.html#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a> = None,<br>controller: <a title="scenariogeneration.xosc.utils.Controller" href="utils.html#scenariogeneration.xosc.utils.Controller">Controller</a> = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObjectController(VersionBase):
    &#34;&#34;&#34;
    A controller of a scenario object.
    Parameters
    ----------
    name: str
        Name of the ObjectController.
    catalog_ref : CatalogReference , Optional
        Catalog reference to a controller.
    controller: Controller, Optional
        Controller type definition.

    Attributes
    ----------
    name: str
        Identifier of the ObjectController.
    catalog_ref : CatalogReference
        Catalog reference to a controller.
    controller: Controller
        Controller type definition.

    Methods
    -------
    parse(element)
        Parses an ElementTree element and returns an instance of the
        ObjectController class.
    get_element()
        Returns the full ElementTree representation of the class.
    get_attributes()
        Returns the attributes of the class as a dictionary.

    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        catalog_ref: CatalogReference = None,
        controller: Controller = None,
    ):
        &#34;&#34;&#34;Initializes the ObjectController.

        Parameters
        ----------
        name: str
            Name of the ObjectController.
        catalog_ref : CatalogReference , Optional
            Catalog reference to a controller.
        controller: Controller, Optional
            Controller type definition.
        &#34;&#34;&#34;
        self.name = name
        if (catalog_ref is None) == (controller is None):
            raise ValueError(
                &#34;Exactly one of catalog_ref or controller must be provided.&#34;
            )
        self.catalog_ref = catalog_ref
        self.controller = controller

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ObjectController):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ObjectController&#34;:
        &#34;&#34;&#34;Parses the XML element of ObjectController.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ObjectController element (same as generated by the
            class itself).

        Returns
        -------
        ObjectController
            A ObjectController object.
        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        catalog_ref = None
        controller = None
        if element.find(&#34;CatalogReference&#34;) is not None:
            catalog_ref = CatalogReference.parse(
                find_mandatory_field(element, &#34;CatalogReference&#34;)
            )
        elif element.find(&#34;Controller&#34;) is not None:
            controller = Controller.parse(
                find_mandatory_field(element, &#34;Controller&#34;)
            )
        return ObjectController(name, catalog_ref, controller)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the ObjectController as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            ObjectController.
        &#34;&#34;&#34;
        retdict = {&#34;name&#34;: self.name}
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the ObjectController.

        Returns
        -------
        xml.etree.ElementTree.Element
            The XML element representing the ObjectController.
        &#34;&#34;&#34;
        element = ET.Element(&#34;ObjectController&#34;, attrib=self.get_attributes())
        if self.catalog_ref is not None:
            element.append(self.catalog_ref.get_element())
        elif self.controller is not None:
            element.append(self.controller.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>A controller of a scenario object.
Parameters</p>
<hr>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the ObjectController.</dd>
<dt><strong><code>catalog_ref</code></strong> :&ensp;<code>CatalogReference , Optional</code></dt>
<dd>Catalog reference to a controller.</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller, Optional</code></dt>
<dd>Controller type definition.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the ObjectController.</dd>
<dt><strong><code>catalog_ref</code></strong> :&ensp;<code>CatalogReference</code></dt>
<dd>Catalog reference to a controller.</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller</code></dt>
<dd>Controller type definition.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree element and returns an instance of the
ObjectController class.
get_element()
Returns the full ElementTree representation of the class.
get_attributes()
Returns the attributes of the class as a dictionary.</p>
<p>Initializes the ObjectController.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the ObjectController.</dd>
<dt><strong><code>catalog_ref</code></strong> :&ensp;<code>CatalogReference , Optional</code></dt>
<dd>Catalog reference to a controller.</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>Controller, Optional</code></dt>
<dd>Controller type definition.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ObjectController.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ObjectController" href="#scenariogeneration.xosc.actions.ObjectController">ObjectController</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ObjectController&#34;:
    &#34;&#34;&#34;Parses the XML element of ObjectController.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ObjectController element (same as generated by the
        class itself).

    Returns
    -------
    ObjectController
        A ObjectController object.
    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    catalog_ref = None
    controller = None
    if element.find(&#34;CatalogReference&#34;) is not None:
        catalog_ref = CatalogReference.parse(
            find_mandatory_field(element, &#34;CatalogReference&#34;)
        )
    elif element.find(&#34;Controller&#34;) is not None:
        controller = Controller.parse(
            find_mandatory_field(element, &#34;Controller&#34;)
        )
    return ObjectController(name, catalog_ref, controller)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ObjectController.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ObjectController element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ObjectController" href="#scenariogeneration.xosc.actions.ObjectController">ObjectController</a></code></dt>
<dd>A ObjectController object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ObjectController.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the ObjectController as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        ObjectController.
    &#34;&#34;&#34;
    retdict = {&#34;name&#34;: self.name}
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the ObjectController as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
ObjectController.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ObjectController.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the ObjectController.

    Returns
    -------
    xml.etree.ElementTree.Element
        The XML element representing the ObjectController.
    &#34;&#34;&#34;
    element = ET.Element(&#34;ObjectController&#34;, attrib=self.get_attributes())
    if self.catalog_ref is not None:
        element.append(self.catalog_ref.get_element())
    elif self.controller is not None:
        element.append(self.controller.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the ObjectController.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The XML element representing the ObjectController.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction"><code class="flex name class">
<span>class <span class="ident">OverrideControllerValueAction</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OverrideControllerValueAction(_PrivateActionType):
    &#34;&#34;&#34;
    OverrideControllerValueAction creates a
    OverrideControllerValueAction action of OpenSCENARIO which can
    include throttle, brake, clutch, steering wheel, gear, and
    parking brake.
    NOTE: This implementation is compatible with OSC v1.1 where all
    attributes don&#39;t have to be set.

    Attributes
    ----------
    throttle_active : bool, optional
        If the throttle is active. Default is None (not written).
    throttle_value : float
        Value of the throttle.
    brake_active : bool, optional
        If the brake is active. Default is None (not written).
    brake_value : float
        Value of the brake.
    clutch_active : bool, optional
        If the clutch is active. Default is None (not written).
    clutch_value : float
        Value of the clutch.
    steeringwheel_active : bool, optional
        If the steering wheel is active. Default is None (not written).
    steeringwheel_value : float
        Value of the steering wheel.
    gear_active : bool, optional
        If the gear is active. Default is None (not written).
    gear_value : float
        Value of the gear.
    parkingbrake_active : bool, optional
        If the parking brake is active. Default is None (not written).
    parkingbrake_value : float
        Value of the parking brake.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    set_throttle(active, value)
        Sets the throttle value.
    set_brake(active, value)
        Sets the brake value.
    set_steeringwheel(active, value)
        Sets the steering wheel value.
    set_clutch(active, value)
        Sets the clutch value.
    set_gear(active, value)
        Sets the gear value.
    set_parkingbrake(active, value)
        Sets the parking brake value.
    &#34;&#34;&#34;

    def __init__(self):
        self.throttle_active = None
        self.throttle_value = convert_float(0)
        self.throttle_rate = None
        self.brake_active = None
        self.brake_value = convert_float(0)
        self.brake_rate = None
        self.brake_force = False
        self.clutch_active = None
        self.clutch_value = convert_float(0)
        self.clutch_rate = None
        self.steeringwheel_active = None
        self.steeringwheel_value = convert_float(0)
        self.steeringwheel_rate = None
        self.steeringwheel_torque = None
        self.gear_active = None
        self.gear_value = convert_float(0)
        self._gear_maunal = True
        self.parkingbrake_active = None
        self.parkingbrake_value = convert_float(0)
        self.parkingbrake_rate = None
        self.parkingbrake_force = False

        self._used_by_parent = False

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, OverrideControllerValueAction):
            if (
                self.throttle_value == other.throttle_value
                and self.throttle_value == other.throttle_value
                and self.throttle_rate == other.throttle_rate
                and self.brake_active == other.brake_active
                and self.brake_value == other.brake_value
                and self.brake_rate == other.brake_rate
                and self.brake_force == other.brake_force
                and self.clutch_active == other.clutch_active
                and self.clutch_value == other.clutch_value
                and self.clutch_rate == other.clutch_rate
                and self.steeringwheel_active == other.steeringwheel_active
                and self.steeringwheel_value == other.steeringwheel_value
                and self.steeringwheel_rate == other.steeringwheel_rate
                and self.steeringwheel_torque == other.steeringwheel_torque
                and self.gear_active == other.gear_active
                and self.gear_value == other.gear_value
                and self.parkingbrake_active == other.parkingbrake_active
                and self.parkingbrake_value == other.parkingbrake_value
                and self.parkingbrake_force == other.parkingbrake_force
                and self.parkingbrake_rate == other.parkingbrake_rate
            ):
                return True
        elif isinstance(other, ControllerAction):
            if (
                self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_rate
                == other.overrideControllerValueAction.throttle_rate
                and self.brake_active
                == other.overrideControllerValueAction.brake_active
                and self.brake_value
                == other.overrideControllerValueAction.brake_value
                and self.brake_rate
                == other.overrideControllerValueAction.brake_rate
                and self.brake_force
                == other.overrideControllerValueAction.brake_force
                and self.clutch_active
                == other.overrideControllerValueAction.clutch_active
                and self.clutch_value
                == other.overrideControllerValueAction.clutch_value
                and self.clutch_rate
                == other.overrideControllerValueAction.clutch_rate
                and self.steeringwheel_active
                == other.overrideControllerValueAction.steeringwheel_active
                and self.steeringwheel_value
                == other.overrideControllerValueAction.steeringwheel_value
                and self.steeringwheel_rate
                == other.overrideControllerValueAction.steeringwheel_rate
                and self.steeringwheel_torque
                == other.overrideControllerValueAction.steeringwheel_torque
                and self.gear_active
                == other.overrideControllerValueAction.gear_active
                and self.gear_value
                == other.overrideControllerValueAction.gear_value
                and self.parkingbrake_active
                == other.overrideControllerValueAction.parkingbrake_active
                and self.parkingbrake_value
                == other.overrideControllerValueAction.parkingbrake_value
                and self.parkingbrake_force
                == other.overrideControllerValueAction.parkingbrake_force
                and self.parkingbrake_rate
                == other.overrideControllerValueAction.parkingbrake_rate
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;OverrideControllerValueAction&#34;:
        &#34;&#34;&#34;Parses the XML element of OverrideControllerValueAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A OverrideControllerValueAction element (same as generated
            by the class itself).

        Returns
        -------
        OverrideControllerValueAction
            A OverrideControllerValueAction object.
        &#34;&#34;&#34;
        ocv_action = OverrideControllerValueAction()
        ocva_element = find_mandatory_field(
            element, &#34;ControllerAction/OverrideControllerValueAction&#34;
        )

        ocv_action.throttle_active = None
        ocv_action.throttle_value = convert_float(0)
        if ocva_element.find(&#34;Throttle&#34;) is not None:
            throttle_element = find_mandatory_field(ocva_element, &#34;Throttle&#34;)
            ocv_action.throttle_active = convert_bool(
                throttle_element.attrib[&#34;active&#34;]
            )
            ocv_action.throttle_value = convert_float(
                throttle_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in throttle_element.attrib:
                ocv_action.throttle_rate = convert_float(
                    throttle_element.attrib[&#34;maxRate&#34;]
                )

        ocv_action.brake_active = None
        ocv_action.brake_value = convert_float(0)
        if ocva_element.find(&#34;Brake&#34;) is not None:
            brake_element = find_mandatory_field(ocva_element, &#34;Brake&#34;)
            ocv_action.brake_active = convert_bool(
                brake_element.attrib[&#34;active&#34;]
            )
            if &#34;value&#34; in brake_element.attrib:
                ocv_action.brake_value = convert_float(
                    brake_element.attrib[&#34;value&#34;]
                )
            else:
                if brake_element.find(&#34;BrakePercent&#34;) is not None:
                    brake_input_element = find_mandatory_field(
                        brake_element, &#34;BrakePercent&#34;
                    )
                    ocv_action.brake_force = False

                elif brake_element.find(&#34;BrakeForce&#34;) is not None:
                    brake_input_element = find_mandatory_field(
                        brake_element, &#34;BrakeForce&#34;
                    )
                    ocv_action.brake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.brake_value = convert_float(
                    brake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in brake_input_element.attrib:
                    ocv_action.brake_rate = brake_input_element.attrib[
                        &#34;maxRate&#34;
                    ]

        ocv_action.clutch_active = None
        ocv_action.clutch_value = convert_float(0)
        if ocva_element.find(&#34;Clutch&#34;) is not None:
            cluth_element = find_mandatory_field(ocva_element, &#34;Clutch&#34;)
            ocv_action.clutch_active = convert_bool(
                cluth_element.attrib[&#34;active&#34;]
            )
            ocv_action.clutch_value = convert_float(
                cluth_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in cluth_element.attrib:
                ocv_action.clutch_rate = convert_float(
                    cluth_element.attrib[&#34;maxRate&#34;]
                )

        ocv_action.parkingbrake_active = None
        ocv_action.parkingbrake_value = convert_float(0)
        if ocva_element.find(&#34;ParkingBrake&#34;) is not None:
            parkingbrake_element = find_mandatory_field(
                ocva_element, &#34;ParkingBrake&#34;
            )
            ocv_action.parkingbrake_active = convert_bool(
                parkingbrake_element.attrib[&#34;active&#34;]
            )

            if &#34;value&#34; in parkingbrake_element.attrib:
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_element.attrib[&#34;value&#34;]
                )
            else:
                if parkingbrake_element.find(&#34;BrakePercent&#34;) is not None:
                    parkingbrake_input_element = find_mandatory_field(
                        parkingbrake_element, &#34;BrakePercent&#34;
                    )
                    ocv_action.parkingbrake_force = False

                elif parkingbrake_element.find(&#34;BrakeForce&#34;) is not None:
                    parkingbrake_input_element = find_mandatory_field(
                        parkingbrake_element, &#34;BrakeForce&#34;
                    )
                    ocv_action.parkingbrake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in parkingbrake_input_element.attrib:
                    ocv_action.parkingbrake_rate = convert_float(
                        parkingbrake_input_element.attrib[&#34;maxRate&#34;]
                    )

        ocv_action.steeringwheel_active = None
        ocv_action.steeringwheel_value = convert_float(0)
        if ocva_element.find(&#34;SteeringWheel&#34;) is not None:
            steeringwheel_element = find_mandatory_field(
                ocva_element, &#34;SteeringWheel&#34;
            )
            ocv_action.steeringwheel_active = convert_bool(
                steeringwheel_element.attrib[&#34;active&#34;]
            )
            ocv_action.steeringwheel_value = convert_float(
                steeringwheel_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_rate = convert_float(
                    steeringwheel_element.attrib[&#34;maxRate&#34;]
                )
            if &#34;maxTorque&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_torque = convert_float(
                    steeringwheel_element.attrib[&#34;maxTorque&#34;]
                )

        ocv_action.gear_active = None
        ocv_action.gear_value = convert_float(0)
        if ocva_element.find(&#34;Gear&#34;) is not None:
            gear_element = find_mandatory_field(ocva_element, &#34;Gear&#34;)
            ocv_action.gear_active = convert_bool(
                gear_element.attrib[&#34;active&#34;]
            )
            if &#34;number&#34; in gear_element.attrib:
                ocv_action.gear_value = convert_float(
                    gear_element.attrib[&#34;number&#34;]
                )
            elif gear_element.find(&#34;AutomaticGear&#34;) is not None:
                ocv_action.gear_value = getattr(
                    AutomaticGearType,
                    find_mandatory_field(gear_element, &#34;AutomaticGear&#34;).attrib[
                        &#34;gear&#34;
                    ],
                )

            elif gear_element.find(&#34;ManualGear&#34;) is not None:
                ocv_action.gear_value = convert_float(
                    find_mandatory_field(gear_element, &#34;ManualGear&#34;).attrib[
                        &#34;number&#34;
                    ]
                )
            else:
                raise ValueError(&#34;no gear number found in OverrideGearAction&#34;)

        return ocv_action

    def set_clutch(
        self, active: bool, value: float = 0, rate: Optional[float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Sets the clutch value.

        Parameters
        ----------
        active : bool
            If the clutch should be overridden.
        value : float, optional
            Value of the clutch. Default is 0.
        rate : float, optional
            Rate of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        &#34;&#34;&#34;
        self.clutch_active = convert_bool(active)
        self.clutch_value = convert_float(value)
        self.clutch_rate = rate

    def set_brake(
        self,
        active: bool,
        value: float = 0,
        rate: Optional[float] = None,
        interpret_as_force: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Sets the brake value.

        Parameters
        ----------
        active : bool
            If the brake should be overridden.
        value : float, optional
            Value of the brake. Default is 0.
        rate : float, optional
            The rate of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        interpret_as_force : bool, optional
            Interpret the value as force instead of percent
            (Valid from OpenSCENARIO V1.2). Default is None.
        &#34;&#34;&#34;
        self.brake_active = convert_bool(active)
        self.brake_value = convert_float(value)
        self.brake_rate = rate
        self.brake_force = interpret_as_force

    def set_throttle(
        self, active: bool, value: float = 0, rate: Optional[float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Sets the throttle value.

        Parameters
        ----------
        active : bool
            If the throttle should be overridden.
        value : float, optional
            Value of the throttle. Default is 0.
        rate : float, optional
            Rate of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        &#34;&#34;&#34;
        self.throttle_active = convert_bool(active)
        self.throttle_value = convert_float(value)
        self.throttle_rate = rate

    def set_steeringwheel(
        self,
        active: bool,
        value: float = 0,
        rate: Optional[float] = None,
        torque: Optional[float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Sets the steeringwheel value.

        Parameters
        ----------
        active : bool
            If the steeringwheel should be overridden.
        value : float, optional
            Value of the steeringwheel. Default is 0.
        rate : float, optional
            The Max Rate of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        torque : float, optional
            The Max Torque of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        &#34;&#34;&#34;
        self.steeringwheel_active = convert_bool(active)
        self.steeringwheel_value = convert_float(value)
        self.steeringwheel_rate = convert_float(rate)
        self.steeringwheel_torque = convert_float(torque)

    def set_parkingbrake(
        self,
        active: bool,
        value: float = 0,
        rate: Optional[float] = None,
        interpret_as_force: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Sets the parkingbrake value.

        Parameters
        ----------
        active : bool
            If the parkingbrake should be overridden.
        value : float, optional
            Value of the parkingbrake. Default is 0.
        rate : float, optional
            The rate of the change (Valid from OpenSCENARIO V1.2).
            Default is None.
        interpret_as_force : bool, optional
            Interpret the value as force instead of percent
            (Valid from OpenSCENARIO V1.2). Default is None.
        &#34;&#34;&#34;
        self.parkingbrake_active = convert_bool(active)
        self.parkingbrake_value = convert_float(value)
        self.parkingbrake_rate = rate
        self.parkingbrake_force = interpret_as_force

    def set_gear(
        self, active: bool, value: Union[float, AutomaticGearType] = 0
    ) -&gt; None:
        &#34;&#34;&#34;Sets the gear value.

        Parameters
        ----------
        active : bool
            If the gear should be overridden.
        value : float or AutomaticGearType
            Value of the gear. Default is 0.
        &#34;&#34;&#34;
        self.gear_active = convert_bool(active)
        if hasattr(AutomaticGearType, str(value)):
            self.gear_value = value
            self._gear_maunal = False
        else:
            self.gear_value = convert_float(value)
            self._gear_maunal = True

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the OverrideControllerValueAction.

        Returns
        -------
        ET.Element
            The XML element representing the
            OverrideControllerValueAction.

        Raises
        ------
        OpenSCENARIOVersionError
            If the OverrideControllerValueAction is used alone in
            OSC 1.0.
        &#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;OverrideControllerValueAction cannot be used alone in &#34;
                &#34;OSC 1.0, please add it to a ControllerAction&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        overrideaction = ET.SubElement(
            controlleraction, &#34;OverrideControllerValueAction&#34;
        )

        if (
            self.throttle_active is None
            and self.brake_active is None
            and self.clutch_active is None
            and self.parkingbrake_active is None
            and self.steeringwheel_active is None
            and self.gear_active is None
        ):
            raise NoActionsDefinedError(
                &#34;No actions were added to the OverrideControllerValueAction&#34;
            )
        if self.throttle_active is not None:
            throttle_dict = {
                &#34;active&#34;: get_bool_string(self.throttle_active),
                &#34;value&#34;: str(self.throttle_value),
            }
            if self.throttle_rate is not None and self.isVersionEqLarger(
                minor=2
            ):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(
                minor=2
            ):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Throttle&#34;,
                throttle_dict,
            )
        if self.brake_active is not None:
            if not self.isVersionEqLarger(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.brake_active),
                        &#34;value&#34;: str(self.brake_value),
                    },
                )
            else:
                override_brake = ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {&#34;active&#34;: get_bool_string(self.brake_active)},
                )
                brake_dict = {&#34;value&#34;: str(self.brake_value)}
                if self.brake_rate is not None:
                    brake_dict[&#34;maxRate&#34;] = str(self.brake_rate)
                if self.brake_force:
                    ET.SubElement(
                        override_brake, &#34;BrakeForce&#34;, attrib=brake_dict
                    )
                else:
                    ET.SubElement(
                        override_brake, &#34;BrakePercent&#34;, attrib=brake_dict
                    )

        if self.clutch_active is not None:
            if self.throttle_rate is not None and self.isVersionEqLarger(
                minor=2
            ):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(
                minor=2
            ):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            clutch_dict = {
                &#34;active&#34;: get_bool_string(self.clutch_active),
                &#34;value&#34;: str(self.clutch_value),
            }
            if self.clutch_rate is not None and self.isVersionEqLarger(
                minor=2
            ):
                clutch_dict[&#34;maxRate&#34;] = str(self.clutch_rate)
            elif self.clutch_rate is not None and not self.isVersionEqLarger(
                minor=2
            ):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Clutch&#34;,
                clutch_dict,
            )
        if self.parkingbrake_active is not None:
            if not self.isVersionEqLarger(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.parkingbrake_active),
                        &#34;value&#34;: str(self.parkingbrake_value),
                    },
                )
            else:
                override_parking = ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {&#34;active&#34;: get_bool_string(self.parkingbrake_active)},
                )
                parkingbrake_dict = {&#34;value&#34;: str(self.parkingbrake_value)}
                if self.parkingbrake_rate is not None:
                    parkingbrake_dict[&#34;maxRate&#34;] = str(self.parkingbrake_rate)
                if self.parkingbrake_force:
                    ET.SubElement(
                        override_parking,
                        &#34;BrakeForce&#34;,
                        attrib=parkingbrake_dict,
                    )
                else:
                    ET.SubElement(
                        override_parking,
                        &#34;BrakePercent&#34;,
                        attrib=parkingbrake_dict,
                    )
        if self.steeringwheel_active is not None:
            steering_dict = {
                &#34;active&#34;: get_bool_string(self.steeringwheel_active),
                &#34;value&#34;: str(self.steeringwheel_value),
            }
            if self.steeringwheel_torque is not None:
                if self.isVersionEqLarger(minor=2):
                    steering_dict[&#34;maxTorque&#34;] = str(self.steeringwheel_torque)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxTorque was introduced in OpenSCENARIO v1.2&#34;
                    )
            if self.steeringwheel_rate is not None:
                if self.isVersionEqLarger(minor=2):
                    steering_dict[&#34;maxRate&#34;] = str(self.steeringwheel_rate)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                    )
            ET.SubElement(
                overrideaction,
                &#34;SteeringWheel&#34;,
                steering_dict,
            )

        if self.gear_active is not None:
            if not self.isVersionEqLarger(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                        &#34;number&#34;: str(self.gear_value),
                    },
                )
            else:
                override_gear_action = ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                    },
                )
                if self._gear_maunal:
                    ET.SubElement(
                        override_gear_action,
                        &#34;ManualGear&#34;,
                        {&#34;number&#34;: str(int(self.gear_value))},
                    )
                else:
                    ET.SubElement(
                        override_gear_action,
                        &#34;AutomaticGear&#34;,
                        {&#34;gear&#34;: self.gear_value.get_name()},
                    )

        return element</code></pre>
</details>
<div class="desc"><p>OverrideControllerValueAction creates a
OverrideControllerValueAction action of OpenSCENARIO which can
include throttle, brake, clutch, steering wheel, gear, and
parking brake.
NOTE: This implementation is compatible with OSC v1.1 where all
attributes don't have to be set.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>throttle_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the throttle is active. Default is None (not written).</dd>
<dt><strong><code>throttle_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the throttle.</dd>
<dt><strong><code>brake_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the brake is active. Default is None (not written).</dd>
<dt><strong><code>brake_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the brake.</dd>
<dt><strong><code>clutch_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the clutch is active. Default is None (not written).</dd>
<dt><strong><code>clutch_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the clutch.</dd>
<dt><strong><code>steeringwheel_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the steering wheel is active. Default is None (not written).</dd>
<dt><strong><code>steeringwheel_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the steering wheel.</dd>
<dt><strong><code>gear_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the gear is active. Default is None (not written).</dd>
<dt><strong><code>gear_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the gear.</dd>
<dt><strong><code>parkingbrake_active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the parking brake is active. Default is None (not written).</dd>
<dt><strong><code>parkingbrake_value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the parking brake.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the class.
set_throttle(active, value)
Sets the throttle value.
set_brake(active, value)
Sets the brake value.
set_steeringwheel(active, value)
Sets the steering wheel value.
set_clutch(active, value)
Sets the clutch value.
set_gear(active, value)
Sets the gear value.
set_parkingbrake(active, value)
Sets the parking brake value.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;OverrideControllerValueAction&#34;:
    &#34;&#34;&#34;Parses the XML element of OverrideControllerValueAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A OverrideControllerValueAction element (same as generated
        by the class itself).

    Returns
    -------
    OverrideControllerValueAction
        A OverrideControllerValueAction object.
    &#34;&#34;&#34;
    ocv_action = OverrideControllerValueAction()
    ocva_element = find_mandatory_field(
        element, &#34;ControllerAction/OverrideControllerValueAction&#34;
    )

    ocv_action.throttle_active = None
    ocv_action.throttle_value = convert_float(0)
    if ocva_element.find(&#34;Throttle&#34;) is not None:
        throttle_element = find_mandatory_field(ocva_element, &#34;Throttle&#34;)
        ocv_action.throttle_active = convert_bool(
            throttle_element.attrib[&#34;active&#34;]
        )
        ocv_action.throttle_value = convert_float(
            throttle_element.attrib[&#34;value&#34;]
        )
        if &#34;maxRate&#34; in throttle_element.attrib:
            ocv_action.throttle_rate = convert_float(
                throttle_element.attrib[&#34;maxRate&#34;]
            )

    ocv_action.brake_active = None
    ocv_action.brake_value = convert_float(0)
    if ocva_element.find(&#34;Brake&#34;) is not None:
        brake_element = find_mandatory_field(ocva_element, &#34;Brake&#34;)
        ocv_action.brake_active = convert_bool(
            brake_element.attrib[&#34;active&#34;]
        )
        if &#34;value&#34; in brake_element.attrib:
            ocv_action.brake_value = convert_float(
                brake_element.attrib[&#34;value&#34;]
            )
        else:
            if brake_element.find(&#34;BrakePercent&#34;) is not None:
                brake_input_element = find_mandatory_field(
                    brake_element, &#34;BrakePercent&#34;
                )
                ocv_action.brake_force = False

            elif brake_element.find(&#34;BrakeForce&#34;) is not None:
                brake_input_element = find_mandatory_field(
                    brake_element, &#34;BrakeForce&#34;
                )
                ocv_action.brake_force = True
            else:
                raise ValueError(&#34;No value found while parsing brake.&#34;)
            ocv_action.brake_value = convert_float(
                brake_input_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in brake_input_element.attrib:
                ocv_action.brake_rate = brake_input_element.attrib[
                    &#34;maxRate&#34;
                ]

    ocv_action.clutch_active = None
    ocv_action.clutch_value = convert_float(0)
    if ocva_element.find(&#34;Clutch&#34;) is not None:
        cluth_element = find_mandatory_field(ocva_element, &#34;Clutch&#34;)
        ocv_action.clutch_active = convert_bool(
            cluth_element.attrib[&#34;active&#34;]
        )
        ocv_action.clutch_value = convert_float(
            cluth_element.attrib[&#34;value&#34;]
        )
        if &#34;maxRate&#34; in cluth_element.attrib:
            ocv_action.clutch_rate = convert_float(
                cluth_element.attrib[&#34;maxRate&#34;]
            )

    ocv_action.parkingbrake_active = None
    ocv_action.parkingbrake_value = convert_float(0)
    if ocva_element.find(&#34;ParkingBrake&#34;) is not None:
        parkingbrake_element = find_mandatory_field(
            ocva_element, &#34;ParkingBrake&#34;
        )
        ocv_action.parkingbrake_active = convert_bool(
            parkingbrake_element.attrib[&#34;active&#34;]
        )

        if &#34;value&#34; in parkingbrake_element.attrib:
            ocv_action.parkingbrake_value = convert_float(
                parkingbrake_element.attrib[&#34;value&#34;]
            )
        else:
            if parkingbrake_element.find(&#34;BrakePercent&#34;) is not None:
                parkingbrake_input_element = find_mandatory_field(
                    parkingbrake_element, &#34;BrakePercent&#34;
                )
                ocv_action.parkingbrake_force = False

            elif parkingbrake_element.find(&#34;BrakeForce&#34;) is not None:
                parkingbrake_input_element = find_mandatory_field(
                    parkingbrake_element, &#34;BrakeForce&#34;
                )
                ocv_action.parkingbrake_force = True
            else:
                raise ValueError(&#34;No value found while parsing brake.&#34;)
            ocv_action.parkingbrake_value = convert_float(
                parkingbrake_input_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in parkingbrake_input_element.attrib:
                ocv_action.parkingbrake_rate = convert_float(
                    parkingbrake_input_element.attrib[&#34;maxRate&#34;]
                )

    ocv_action.steeringwheel_active = None
    ocv_action.steeringwheel_value = convert_float(0)
    if ocva_element.find(&#34;SteeringWheel&#34;) is not None:
        steeringwheel_element = find_mandatory_field(
            ocva_element, &#34;SteeringWheel&#34;
        )
        ocv_action.steeringwheel_active = convert_bool(
            steeringwheel_element.attrib[&#34;active&#34;]
        )
        ocv_action.steeringwheel_value = convert_float(
            steeringwheel_element.attrib[&#34;value&#34;]
        )
        if &#34;maxRate&#34; in steeringwheel_element.attrib:
            ocv_action.steeringwheel_rate = convert_float(
                steeringwheel_element.attrib[&#34;maxRate&#34;]
            )
        if &#34;maxTorque&#34; in steeringwheel_element.attrib:
            ocv_action.steeringwheel_torque = convert_float(
                steeringwheel_element.attrib[&#34;maxTorque&#34;]
            )

    ocv_action.gear_active = None
    ocv_action.gear_value = convert_float(0)
    if ocva_element.find(&#34;Gear&#34;) is not None:
        gear_element = find_mandatory_field(ocva_element, &#34;Gear&#34;)
        ocv_action.gear_active = convert_bool(
            gear_element.attrib[&#34;active&#34;]
        )
        if &#34;number&#34; in gear_element.attrib:
            ocv_action.gear_value = convert_float(
                gear_element.attrib[&#34;number&#34;]
            )
        elif gear_element.find(&#34;AutomaticGear&#34;) is not None:
            ocv_action.gear_value = getattr(
                AutomaticGearType,
                find_mandatory_field(gear_element, &#34;AutomaticGear&#34;).attrib[
                    &#34;gear&#34;
                ],
            )

        elif gear_element.find(&#34;ManualGear&#34;) is not None:
            ocv_action.gear_value = convert_float(
                find_mandatory_field(gear_element, &#34;ManualGear&#34;).attrib[
                    &#34;number&#34;
                ]
            )
        else:
            raise ValueError(&#34;no gear number found in OverrideGearAction&#34;)

    return ocv_action</code></pre>
</details>
<div class="desc"><p>Parses the XML element of OverrideControllerValueAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A OverrideControllerValueAction element (same as generated
by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a></code></dt>
<dd>A OverrideControllerValueAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the OverrideControllerValueAction.

    Returns
    -------
    ET.Element
        The XML element representing the
        OverrideControllerValueAction.

    Raises
    ------
    OpenSCENARIOVersionError
        If the OverrideControllerValueAction is used alone in
        OSC 1.0.
    &#34;&#34;&#34;
    if self.isVersion(minor=0) and not self._used_by_parent:
        raise OpenSCENARIOVersionError(
            &#34;OverrideControllerValueAction cannot be used alone in &#34;
            &#34;OSC 1.0, please add it to a ControllerAction&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
    overrideaction = ET.SubElement(
        controlleraction, &#34;OverrideControllerValueAction&#34;
    )

    if (
        self.throttle_active is None
        and self.brake_active is None
        and self.clutch_active is None
        and self.parkingbrake_active is None
        and self.steeringwheel_active is None
        and self.gear_active is None
    ):
        raise NoActionsDefinedError(
            &#34;No actions were added to the OverrideControllerValueAction&#34;
        )
    if self.throttle_active is not None:
        throttle_dict = {
            &#34;active&#34;: get_bool_string(self.throttle_active),
            &#34;value&#34;: str(self.throttle_value),
        }
        if self.throttle_rate is not None and self.isVersionEqLarger(
            minor=2
        ):
            throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
        elif self.throttle_rate is not None and not self.isVersion(
            minor=2
        ):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        ET.SubElement(
            overrideaction,
            &#34;Throttle&#34;,
            throttle_dict,
        )
    if self.brake_active is not None:
        if not self.isVersionEqLarger(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;Brake&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.brake_active),
                    &#34;value&#34;: str(self.brake_value),
                },
            )
        else:
            override_brake = ET.SubElement(
                overrideaction,
                &#34;Brake&#34;,
                {&#34;active&#34;: get_bool_string(self.brake_active)},
            )
            brake_dict = {&#34;value&#34;: str(self.brake_value)}
            if self.brake_rate is not None:
                brake_dict[&#34;maxRate&#34;] = str(self.brake_rate)
            if self.brake_force:
                ET.SubElement(
                    override_brake, &#34;BrakeForce&#34;, attrib=brake_dict
                )
            else:
                ET.SubElement(
                    override_brake, &#34;BrakePercent&#34;, attrib=brake_dict
                )

    if self.clutch_active is not None:
        if self.throttle_rate is not None and self.isVersionEqLarger(
            minor=2
        ):
            throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
        elif self.throttle_rate is not None and not self.isVersion(
            minor=2
        ):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        clutch_dict = {
            &#34;active&#34;: get_bool_string(self.clutch_active),
            &#34;value&#34;: str(self.clutch_value),
        }
        if self.clutch_rate is not None and self.isVersionEqLarger(
            minor=2
        ):
            clutch_dict[&#34;maxRate&#34;] = str(self.clutch_rate)
        elif self.clutch_rate is not None and not self.isVersionEqLarger(
            minor=2
        ):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        ET.SubElement(
            overrideaction,
            &#34;Clutch&#34;,
            clutch_dict,
        )
    if self.parkingbrake_active is not None:
        if not self.isVersionEqLarger(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;ParkingBrake&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.parkingbrake_active),
                    &#34;value&#34;: str(self.parkingbrake_value),
                },
            )
        else:
            override_parking = ET.SubElement(
                overrideaction,
                &#34;ParkingBrake&#34;,
                {&#34;active&#34;: get_bool_string(self.parkingbrake_active)},
            )
            parkingbrake_dict = {&#34;value&#34;: str(self.parkingbrake_value)}
            if self.parkingbrake_rate is not None:
                parkingbrake_dict[&#34;maxRate&#34;] = str(self.parkingbrake_rate)
            if self.parkingbrake_force:
                ET.SubElement(
                    override_parking,
                    &#34;BrakeForce&#34;,
                    attrib=parkingbrake_dict,
                )
            else:
                ET.SubElement(
                    override_parking,
                    &#34;BrakePercent&#34;,
                    attrib=parkingbrake_dict,
                )
    if self.steeringwheel_active is not None:
        steering_dict = {
            &#34;active&#34;: get_bool_string(self.steeringwheel_active),
            &#34;value&#34;: str(self.steeringwheel_value),
        }
        if self.steeringwheel_torque is not None:
            if self.isVersionEqLarger(minor=2):
                steering_dict[&#34;maxTorque&#34;] = str(self.steeringwheel_torque)
            else:
                raise OpenSCENARIOVersionError(
                    &#34;maxTorque was introduced in OpenSCENARIO v1.2&#34;
                )
        if self.steeringwheel_rate is not None:
            if self.isVersionEqLarger(minor=2):
                steering_dict[&#34;maxRate&#34;] = str(self.steeringwheel_rate)
            else:
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
        ET.SubElement(
            overrideaction,
            &#34;SteeringWheel&#34;,
            steering_dict,
        )

    if self.gear_active is not None:
        if not self.isVersionEqLarger(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;Gear&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.gear_active),
                    &#34;number&#34;: str(self.gear_value),
                },
            )
        else:
            override_gear_action = ET.SubElement(
                overrideaction,
                &#34;Gear&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.gear_active),
                },
            )
            if self._gear_maunal:
                ET.SubElement(
                    override_gear_action,
                    &#34;ManualGear&#34;,
                    {&#34;number&#34;: str(int(self.gear_value))},
                )
            else:
                ET.SubElement(
                    override_gear_action,
                    &#34;AutomaticGear&#34;,
                    {&#34;gear&#34;: self.gear_value.get_name()},
                )

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the OverrideControllerValueAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the
OverrideControllerValueAction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenSCENARIOVersionError</code></dt>
<dd>If the OverrideControllerValueAction is used alone in
OSC 1.0.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake"><code class="name flex">
<span>def <span class="ident">set_brake</span></span>(<span>self,<br>active: bool,<br>value: float = 0,<br>rate: float | None = None,<br>interpret_as_force: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_brake(
    self,
    active: bool,
    value: float = 0,
    rate: Optional[float] = None,
    interpret_as_force: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Sets the brake value.

    Parameters
    ----------
    active : bool
        If the brake should be overridden.
    value : float, optional
        Value of the brake. Default is 0.
    rate : float, optional
        The rate of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    interpret_as_force : bool, optional
        Interpret the value as force instead of percent
        (Valid from OpenSCENARIO V1.2). Default is None.
    &#34;&#34;&#34;
    self.brake_active = convert_bool(active)
    self.brake_value = convert_float(value)
    self.brake_rate = rate
    self.brake_force = interpret_as_force</code></pre>
</details>
<div class="desc"><p>Sets the brake value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the brake should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value of the brake. Default is 0.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The rate of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
<dt><strong><code>interpret_as_force</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret the value as force instead of percent
(Valid from OpenSCENARIO V1.2). Default is None.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch"><code class="name flex">
<span>def <span class="ident">set_clutch</span></span>(<span>self, active: bool, value: float = 0, rate: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_clutch(
    self, active: bool, value: float = 0, rate: Optional[float] = None
) -&gt; None:
    &#34;&#34;&#34;Sets the clutch value.

    Parameters
    ----------
    active : bool
        If the clutch should be overridden.
    value : float, optional
        Value of the clutch. Default is 0.
    rate : float, optional
        Rate of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    &#34;&#34;&#34;
    self.clutch_active = convert_bool(active)
    self.clutch_value = convert_float(value)
    self.clutch_rate = rate</code></pre>
</details>
<div class="desc"><p>Sets the clutch value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the clutch should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value of the clutch. Default is 0.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Rate of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear"><code class="name flex">
<span>def <span class="ident">set_gear</span></span>(<span>self,<br>active: bool,<br>value: float | <a title="scenariogeneration.xosc.enumerations.AutomaticGearType" href="enumerations.html#scenariogeneration.xosc.enumerations.AutomaticGearType">AutomaticGearType</a> = 0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gear(
    self, active: bool, value: Union[float, AutomaticGearType] = 0
) -&gt; None:
    &#34;&#34;&#34;Sets the gear value.

    Parameters
    ----------
    active : bool
        If the gear should be overridden.
    value : float or AutomaticGearType
        Value of the gear. Default is 0.
    &#34;&#34;&#34;
    self.gear_active = convert_bool(active)
    if hasattr(AutomaticGearType, str(value)):
        self.gear_value = value
        self._gear_maunal = False
    else:
        self.gear_value = convert_float(value)
        self._gear_maunal = True</code></pre>
</details>
<div class="desc"><p>Sets the gear value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the gear should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>AutomaticGearType</code></dt>
<dd>Value of the gear. Default is 0.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake"><code class="name flex">
<span>def <span class="ident">set_parkingbrake</span></span>(<span>self,<br>active: bool,<br>value: float = 0,<br>rate: float | None = None,<br>interpret_as_force: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parkingbrake(
    self,
    active: bool,
    value: float = 0,
    rate: Optional[float] = None,
    interpret_as_force: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Sets the parkingbrake value.

    Parameters
    ----------
    active : bool
        If the parkingbrake should be overridden.
    value : float, optional
        Value of the parkingbrake. Default is 0.
    rate : float, optional
        The rate of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    interpret_as_force : bool, optional
        Interpret the value as force instead of percent
        (Valid from OpenSCENARIO V1.2). Default is None.
    &#34;&#34;&#34;
    self.parkingbrake_active = convert_bool(active)
    self.parkingbrake_value = convert_float(value)
    self.parkingbrake_rate = rate
    self.parkingbrake_force = interpret_as_force</code></pre>
</details>
<div class="desc"><p>Sets the parkingbrake value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the parkingbrake should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value of the parkingbrake. Default is 0.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The rate of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
<dt><strong><code>interpret_as_force</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret the value as force instead of percent
(Valid from OpenSCENARIO V1.2). Default is None.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel"><code class="name flex">
<span>def <span class="ident">set_steeringwheel</span></span>(<span>self,<br>active: bool,<br>value: float = 0,<br>rate: float | None = None,<br>torque: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_steeringwheel(
    self,
    active: bool,
    value: float = 0,
    rate: Optional[float] = None,
    torque: Optional[float] = None,
) -&gt; None:
    &#34;&#34;&#34;Sets the steeringwheel value.

    Parameters
    ----------
    active : bool
        If the steeringwheel should be overridden.
    value : float, optional
        Value of the steeringwheel. Default is 0.
    rate : float, optional
        The Max Rate of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    torque : float, optional
        The Max Torque of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    &#34;&#34;&#34;
    self.steeringwheel_active = convert_bool(active)
    self.steeringwheel_value = convert_float(value)
    self.steeringwheel_rate = convert_float(rate)
    self.steeringwheel_torque = convert_float(torque)</code></pre>
</details>
<div class="desc"><p>Sets the steeringwheel value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the steeringwheel should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value of the steeringwheel. Default is 0.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The Max Rate of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
<dt><strong><code>torque</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The Max Torque of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle"><code class="name flex">
<span>def <span class="ident">set_throttle</span></span>(<span>self, active: bool, value: float = 0, rate: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_throttle(
    self, active: bool, value: float = 0, rate: Optional[float] = None
) -&gt; None:
    &#34;&#34;&#34;Sets the throttle value.

    Parameters
    ----------
    active : bool
        If the throttle should be overridden.
    value : float, optional
        Value of the throttle. Default is 0.
    rate : float, optional
        Rate of the change (Valid from OpenSCENARIO V1.2).
        Default is None.
    &#34;&#34;&#34;
    self.throttle_active = convert_bool(active)
    self.throttle_value = convert_float(value)
    self.throttle_rate = rate</code></pre>
</details>
<div class="desc"><p>Sets the throttle value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the throttle should be overridden.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value of the throttle. Default is 0.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Rate of the change (Valid from OpenSCENARIO V1.2).
Default is None.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction"><code class="flex name class">
<span>class <span class="ident">ParameterAddAction</span></span>
<span>(</span><span>parameter_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterAddAction(_ActionType):
    &#34;&#34;&#34;The ParameterAddAction class creates a ParameterAction of type
    ParameterModifyAction which adds a value to an existing Parameter (valid to
    V1.1, deprecated since V1.2).

    Parameters
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be added to the parameter.

    Attributes
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be added to the parameter.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, parameter_ref: str, value: float):
        &#34;&#34;&#34;Initialize the ParameterAddAction.

        Parameters
        ----------
        parameter_ref : str
            Name of the parameter.
        value : float
            The value that should be added to the parameter.
        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ParameterAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ParameterAddAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ParameterAddAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ParameterAddAction element (same as generated by the
            class itself).

        Returns
        -------
        ParameterAddAction
            A ParameterAddAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
        rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
        mbv_element = find_mandatory_field(rule_element, &#34;AddValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterAddAction(parameterRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the ParameterAddAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            ParameterAddAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the ParameterAddAction.

        Returns
        -------
        ET.Element
            The XML element representing the ParameterAddAction.
        &#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterAddAction was deprecated in OSC 1.2, please use VariableAddAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The ParameterAddAction class creates a ParameterAction of type
ParameterModifyAction which adds a value to an existing Parameter (valid to
V1.1, deprecated since V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the parameter.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the parameter.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ParameterAddAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the parameter.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ParameterAddAction" href="#scenariogeneration.xosc.actions.ParameterAddAction">ParameterAddAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ParameterAddAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ParameterAddAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ParameterAddAction element (same as generated by the
        class itself).

    Returns
    -------
    ParameterAddAction
        A ParameterAddAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

    ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
    rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
    mbv_element = find_mandatory_field(rule_element, &#34;AddValue&#34;)
    value = convert_float(mbv_element.attrib[&#34;value&#34;])

    return ParameterAddAction(parameterRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ParameterAddAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ParameterAddAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ParameterAddAction" href="#scenariogeneration.xosc.actions.ParameterAddAction">ParameterAddAction</a></code></dt>
<dd>A ParameterAddAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the ParameterAddAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        ParameterAddAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the ParameterAddAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
ParameterAddAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the ParameterAddAction.

    Returns
    -------
    ET.Element
        The XML element representing the ParameterAddAction.
    &#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterAddAction was deprecated in OSC 1.2, please use VariableAddAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the ParameterAddAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the ParameterAddAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction"><code class="flex name class">
<span>class <span class="ident">ParameterMultiplyAction</span></span>
<span>(</span><span>parameter_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterMultiplyAction(_ActionType):
    &#34;&#34;&#34;The ParameterMultiplyAction class creates a ParameterAction of type
    ParameterModifyAction which multiplies a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2).

    Parameters
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be multiplied to the parameter.

    Attributes
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be multiplied to the parameter.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, parameter_ref: str, value: float):
        &#34;&#34;&#34;Initialize the ParameterMultiplyAction.

        Parameters
        ----------
        parameter_ref : str
            Name of the parameter.
        value : float
            The value that should be added to the parameter.
        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ParameterMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ParameterMultiplyAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ParameterMultiplyAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ParameterMultiplyAction element (same as generated by the
            class itself).

        Returns
        -------
        ParameterMultiplyAction
            A ParameterMultiplyAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
        rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
        mbv_element = find_mandatory_field(rule_element, &#34;MultiplyByValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterMultiplyAction(parameterRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the ParameterMultiplyAction as a dict.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            ParameterMultiplyAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the ParameterMultiplyAction.

        Returns
        -------
        ET.Element
            The XML element representing the ParameterMultiplyAction.
        &#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterMultiplyAction was deprecated in OSC 1.2, &#34;
                &#34;please use VariableMultiplyAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The ParameterMultiplyAction class creates a ParameterAction of type
ParameterModifyAction which multiplies a value to an existing Parameter
(valid to V1.1, deprecated since V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be multiplied to the parameter.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be multiplied to the parameter.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ParameterMultiplyAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the parameter.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ParameterMultiplyAction" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction">ParameterMultiplyAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ParameterMultiplyAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ParameterMultiplyAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ParameterMultiplyAction element (same as generated by the
        class itself).

    Returns
    -------
    ParameterMultiplyAction
        A ParameterMultiplyAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

    ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
    rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
    mbv_element = find_mandatory_field(rule_element, &#34;MultiplyByValue&#34;)
    value = convert_float(mbv_element.attrib[&#34;value&#34;])

    return ParameterMultiplyAction(parameterRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ParameterMultiplyAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ParameterMultiplyAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction">ParameterMultiplyAction</a></code></dt>
<dd>A ParameterMultiplyAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the ParameterMultiplyAction as a dict.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        ParameterMultiplyAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the ParameterMultiplyAction as a dict.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
ParameterMultiplyAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the ParameterMultiplyAction.

    Returns
    -------
    ET.Element
        The XML element representing the ParameterMultiplyAction.
    &#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterMultiplyAction was deprecated in OSC 1.2, &#34;
            &#34;please use VariableMultiplyAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the ParameterMultiplyAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the ParameterMultiplyAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction"><code class="flex name class">
<span>class <span class="ident">ParameterSetAction</span></span>
<span>(</span><span>parameter_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterSetAction(_ActionType):
    &#34;&#34;&#34;The ParameterSetAction class creates a ParameterAction which adds a
    value to an existing Parameter (valid to V1.1, deprecated since V1.2).

    Parameters
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be set to the parameter.

    Attributes
    ----------
    parameter_ref : str
        Name of the parameter.
    value : float
        The value that should be set to the parameter.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an instance
        of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, parameter_ref: str, value: float):
        &#34;&#34;&#34;Initialize the ParameterSetAction.

        Parameters
        ----------
        parameter_ref : str
            Name of the parameter.
        value : float
            The value that should be added to the parameter.
        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, ParameterSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;ParameterSetAction&#34;:
        &#34;&#34;&#34;Parses the XML element of ParameterSetAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A ParameterSetAction element (same as generated by the class
            itself).

        Returns
        -------
        ParameterSetAction
            A ParameterSetAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]
        psa_element = find_mandatory_field(pa_element, &#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        psa = ParameterSetAction(parameterRef, value)
        psa.setVersion(minor=1)
        return psa  # ParameterSetAction(parameterRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the ParameterSetAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            ParameterSetAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the ParameterSetAction.

        Returns
        -------
        ET.Element
            The XML element representing the ParameterSetAction.
        &#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterSetAction was deprecated in OSC 1.2, please use VariableSetAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The ParameterSetAction class creates a ParameterAction which adds a
value to an existing Parameter (valid to V1.1, deprecated since V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be set to the parameter.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be set to the parameter.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an instance
of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the ParameterSetAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>parameter_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the parameter.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.ParameterSetAction" href="#scenariogeneration.xosc.actions.ParameterSetAction">ParameterSetAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;ParameterSetAction&#34;:
    &#34;&#34;&#34;Parses the XML element of ParameterSetAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A ParameterSetAction element (same as generated by the class
        itself).

    Returns
    -------
    ParameterSetAction
        A ParameterSetAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]
    psa_element = find_mandatory_field(pa_element, &#34;SetAction&#34;)
    value = psa_element.attrib[&#34;value&#34;]
    psa = ParameterSetAction(parameterRef, value)
    psa.setVersion(minor=1)
    return psa  # ParameterSetAction(parameterRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of ParameterSetAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A ParameterSetAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.ParameterSetAction" href="#scenariogeneration.xosc.actions.ParameterSetAction">ParameterSetAction</a></code></dt>
<dd>A ParameterSetAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the ParameterSetAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        ParameterSetAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the ParameterSetAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
ParameterSetAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the ParameterSetAction.

    Returns
    -------
    ET.Element
        The XML element representing the ParameterSetAction.
    &#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterSetAction was deprecated in OSC 1.2, please use VariableSetAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the ParameterSetAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the ParameterSetAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RandomRouteAction"><code class="flex name class">
<span>class <span class="ident">RandomRouteAction</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomRouteAction(_PrivateActionType):
    &#34;&#34;&#34;RandomRouteAction creates a RouteAction of type RandomRouteAction.

    Methods
    -------
    parse(element : ET.Element) -&gt; AssignRouteAction
        Parses an ElementTree element and returns an instance of the
        class.
    get_element() -&gt; ET.Element
        Returns the full ElementTree representation of the class.
    &#34;&#34;&#34;

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RandomRouteAction):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RandomRouteAction&#34;:
        &#34;&#34;&#34;Parses the XML element of RandomRouteAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A RandomRouteAction element (same as generated by the class
            itself).

        Returns
        -------
        RandomRouteAction
            A RandomRouteAction object.
        &#34;&#34;&#34;
        ara_element = find_mandatory_field(
            element, &#34;RoutingAction/RandomRouteAction&#34;
        )
        return RandomRouteAction()

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        RandomRouteAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the RandomRouteAction.
        &#34;&#34;&#34;
        if self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;RandomRouteAction was introduced in OSC V1.3&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        ET.SubElement(routeaction, &#34;RandomRouteAction&#34;)

        return element</code></pre>
</details>
<div class="desc"><p>RandomRouteAction creates a RouteAction of type RandomRouteAction.</p>
<h2 id="methods">Methods</h2>
<p>parse(element : ET.Element) -&gt; AssignRouteAction
Parses an ElementTree element and returns an instance of the
class.
get_element() -&gt; ET.Element
Returns the full ElementTree representation of the class.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RandomRouteAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.RandomRouteAction" href="#scenariogeneration.xosc.actions.RandomRouteAction">RandomRouteAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RandomRouteAction&#34;:
    &#34;&#34;&#34;Parses the XML element of RandomRouteAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A RandomRouteAction element (same as generated by the class
        itself).

    Returns
    -------
    RandomRouteAction
        A RandomRouteAction object.
    &#34;&#34;&#34;
    ara_element = find_mandatory_field(
        element, &#34;RoutingAction/RandomRouteAction&#34;
    )
    return RandomRouteAction()</code></pre>
</details>
<div class="desc"><p>Parses the XML element of RandomRouteAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A RandomRouteAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.RandomRouteAction" href="#scenariogeneration.xosc.actions.RandomRouteAction">RandomRouteAction</a></code></dt>
<dd>A RandomRouteAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RandomRouteAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    RandomRouteAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the RandomRouteAction.
    &#34;&#34;&#34;
    if self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;RandomRouteAction was introduced in OSC V1.3&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    ET.SubElement(routeaction, &#34;RandomRouteAction&#34;)

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
RandomRouteAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the RandomRouteAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneChangeAction</span></span>
<span>(</span><span>lane: int,<br>entity: str,<br>transition_dynamics: <a title="scenariogeneration.xosc.utils.TransitionDynamics" href="utils.html#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a>,<br>target_lane_offset: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;Creates a LateralAction of type LaneChangeAction with a relative target.

    Parameters
    ----------
    lane : int
        Relative lane number.
    entity : str
        The entity to run relative to.
    transition_dynamics : TransitionDynamics
        How the change should be made.
    target_lane_offset : float, optional
        Offset in the target lane, if desired (default is None).

    Attributes
    ----------
    lane : int
        Relative lane number.
    target : str
        Target for relative lane change.
    target_lane_offset : float
        Offset in the target lane, if specified.
    transition_dynamics : TransitionDynamics
        How the change should be made.

    Methods
    -------
    parse(element)
        Parses an XML element and returns an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        lane: int,
        entity: str,
        transition_dynamics: TransitionDynamics,
        target_lane_offset: float = None,
    ):
        &#34;&#34;&#34;Initialize RelativeLaneChangeAction.

        Parameters
        ----------
        lane : int
            Relative lane number.
        entity : str
            The entity to run relative to.
        transition_dynamics : TransitionDynamics
            How the change should be made.
        target_lane_offset : float, optional
            Offset in the target lane, if desired. Default is None.
        &#34;&#34;&#34;
        self.lane = convert_int(lane)
        self.target = entity
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(
                &#34;transition_dynamics input not of type TransitionDynamics&#34;
            )
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RelativeLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeLaneChangeAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AbsoluteLaneChangeAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An AbsoluteLaneChangeAction element (same as generated by
            the class itself).

        Returns
        -------
        AbsoluteLaneChangeAction
            An AbsoluteLaneChangeAction object.
        &#34;&#34;&#34;
        lca_element = find_mandatory_field(
            element, &#34;LateralAction/LaneChangeAction&#34;
        )
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(
                lca_element.attrib[&#34;targetLaneOffset&#34;]
            )
        dynamics = TransitionDynamics.parse(
            find_mandatory_field(lca_element, &#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = find_mandatory_field(
            lca_element, &#34;LaneChangeTarget/RelativeTargetLane&#34;
        )
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])
        target = targetlane_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneChangeAction(
            lane, target, dynamics, target_lane_offset
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the RelativeLaneChangeAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeLaneChangeAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the RelativeLaneChangeAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The XML element representing the RelativeLaneChangeAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset is not None:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(
            lanchangetarget, &#34;RelativeTargetLane&#34;, self.get_attributes()
        )
        return element</code></pre>
</details>
<div class="desc"><p>Creates a LateralAction of type LaneChangeAction with a relative target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Relative lane number.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to run relative to.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset in the target lane, if desired (default is None).</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Relative lane number.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target for relative lane change.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset in the target lane, if specified.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an XML element and returns an instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize RelativeLaneChangeAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>int</code></dt>
<dd>Relative lane number.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The entity to run relative to.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
<dt><strong><code>target_lane_offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset in the target lane, if desired. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction">RelativeLaneChangeAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeLaneChangeAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AbsoluteLaneChangeAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        An AbsoluteLaneChangeAction element (same as generated by
        the class itself).

    Returns
    -------
    AbsoluteLaneChangeAction
        An AbsoluteLaneChangeAction object.
    &#34;&#34;&#34;
    lca_element = find_mandatory_field(
        element, &#34;LateralAction/LaneChangeAction&#34;
    )
    target_lane_offset = None
    if &#34;targetLaneOffset&#34; in lca_element.attrib:
        target_lane_offset = convert_float(
            lca_element.attrib[&#34;targetLaneOffset&#34;]
        )
    dynamics = TransitionDynamics.parse(
        find_mandatory_field(lca_element, &#34;LaneChangeActionDynamics&#34;)
    )
    targetlane_element = find_mandatory_field(
        lca_element, &#34;LaneChangeTarget/RelativeTargetLane&#34;
    )
    lane = convert_int(targetlane_element.attrib[&#34;value&#34;])
    target = targetlane_element.attrib[&#34;entityRef&#34;]

    return RelativeLaneChangeAction(
        lane, target, dynamics, target_lane_offset
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AbsoluteLaneChangeAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>An AbsoluteLaneChangeAction element (same as generated by
the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></code></dt>
<dd>An AbsoluteLaneChangeAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the RelativeLaneChangeAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeLaneChangeAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.lane)
    retdict[&#34;entityRef&#34;] = self.target
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the RelativeLaneChangeAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeLaneChangeAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the RelativeLaneChangeAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The XML element representing the RelativeLaneChangeAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    laneoffset = {}
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    if self.target_lane_offset is not None:
        laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(
        lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
    )

    lanechangeaction.append(
        self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
    )
    lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

    ET.SubElement(
        lanchangetarget, &#34;RelativeTargetLane&#34;, self.get_attributes()
    )
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the RelativeLaneChangeAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The XML element representing the RelativeLaneChangeAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneOffsetAction</span></span>
<span>(</span><span>value: float,<br>entity: str,<br>shape: <a title="scenariogeneration.xosc.enumerations.DynamicsShapes" href="enumerations.html#scenariogeneration.xosc.enumerations.DynamicsShapes">DynamicsShapes</a>,<br>maxlatacc: float,<br>continuous: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;Creates a LateralAction of type LaneOffsetAction with a relative target.

    Parameters
    ----------
    value : float
        Relative lateral offset of the target.
    entity : str
        Name of the entity.
    shape : str
        Shape of the offset action.
    maxlatacc : float
        Maximum allowed lateral acceleration.
    continuous : bool, optional
        If the controller tries to keep the relative speed.
        Default is True.

    Attributes
    ----------
    continuous : bool
        If the controller tries to keep the relative speed.
    value : float
        Relative lateral offset of the target.
    target : str
        The name of the entity.
    dynshape : str
        The shape of the action.
    maxlatacc : float
        Maximum allowed lateral acceleration.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        value: float,
        entity: str,
        shape: DynamicsShapes,
        maxlatacc: float,
        continuous: bool = True,
    ):
        &#34;&#34;&#34;Initializes the RelativeLaneOffsetAction.

        Parameters
        ----------
        value : float
            Relative lateral offset of the target.
        entity : str
            Name of the entity.
        shape : DynamicsShapes
            Shape of the offset action.
        maxlatacc : float
            Maximum allowed lateral acceleration.
        continuous : bool, optional
            If the controller tries to keep the relative speed.
            Default is True.
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.target = entity
        self.dynshape = convert_enum(shape, DynamicsShapes)
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RelativeLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
                and self.target == other.target
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeLaneOffsetAction&#34;:
        &#34;&#34;&#34;Parses the XML element of AbsoluteLaneOffsetAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An AbsoluteLaneOffsetAction element (same as generated by
            the class itself).

        Returns
        -------
        AbsoluteLaneOffsetAction
            An AbsoluteLaneOffsetAction object.
        &#34;&#34;&#34;
        loa_element = find_mandatory_field(
            element, &#34;LateralAction/LaneOffsetAction&#34;
        )

        contiuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = find_mandatory_field(
            loa_element, &#34;LaneOffsetActionDynamics&#34;
        )
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = convert_enum(
            load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes
        )

        rtlo_element = find_mandatory_field(
            loa_element, &#34;LaneOffsetTarget/RelativeTargetLaneOffset&#34;
        )
        value = convert_float(rtlo_element.attrib[&#34;value&#34;])
        entity = rtlo_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneOffsetAction(
            value, entity, dynamics, maxacc, contiuous
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the RelativeLaneOffsetAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            RelativeLaneOffsetAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        RelativeLaneOffsetAction.

        Returns
        -------
        ET.Element
            The root XML element representing the
            RelativeLaneOffsetAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(
            laneoftarget,
            &#34;RelativeTargetLaneOffset&#34;,
            attrib=self.get_attributes(),
        )

        return element</code></pre>
</details>
<div class="desc"><p>Creates a LateralAction of type LaneOffsetAction with a relative target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative lateral offset of the target.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the entity.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>str</code></dt>
<dd>Shape of the offset action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the controller tries to keep the relative speed.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative lateral offset of the target.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the entity.</dd>
<dt><strong><code>dynshape</code></strong> :&ensp;<code>str</code></dt>
<dd>The shape of the action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initializes the RelativeLaneOffsetAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative lateral offset of the target.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the entity.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>DynamicsShapes</code></dt>
<dd>Shape of the offset action.</dd>
<dt><strong><code>maxlatacc</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed lateral acceleration.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the controller tries to keep the relative speed.
Default is True.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction">RelativeLaneOffsetAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeLaneOffsetAction&#34;:
    &#34;&#34;&#34;Parses the XML element of AbsoluteLaneOffsetAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        An AbsoluteLaneOffsetAction element (same as generated by
        the class itself).

    Returns
    -------
    AbsoluteLaneOffsetAction
        An AbsoluteLaneOffsetAction object.
    &#34;&#34;&#34;
    loa_element = find_mandatory_field(
        element, &#34;LateralAction/LaneOffsetAction&#34;
    )

    contiuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
    load_element = find_mandatory_field(
        loa_element, &#34;LaneOffsetActionDynamics&#34;
    )
    maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
    dynamics = convert_enum(
        load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes
    )

    rtlo_element = find_mandatory_field(
        loa_element, &#34;LaneOffsetTarget/RelativeTargetLaneOffset&#34;
    )
    value = convert_float(rtlo_element.attrib[&#34;value&#34;])
    entity = rtlo_element.attrib[&#34;entityRef&#34;]

    return RelativeLaneOffsetAction(
        value, entity, dynamics, maxacc, contiuous
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of AbsoluteLaneOffsetAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>An AbsoluteLaneOffsetAction element (same as generated by
the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></code></dt>
<dd>An AbsoluteLaneOffsetAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the RelativeLaneOffsetAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        RelativeLaneOffsetAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.value)
    retdict[&#34;entityRef&#34;] = self.target
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the RelativeLaneOffsetAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
RelativeLaneOffsetAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    RelativeLaneOffsetAction.

    Returns
    -------
    ET.Element
        The root XML element representing the
        RelativeLaneOffsetAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    laneoffsetaction = ET.SubElement(
        lataction,
        &#34;LaneOffsetAction&#34;,
        attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
    )
    ET.SubElement(
        laneoffsetaction,
        &#34;LaneOffsetActionDynamics&#34;,
        {
            &#34;maxLateralAcc&#34;: str(self.maxlatacc),
            &#34;dynamicsShape&#34;: self.dynshape.get_name(),
        },
    )
    laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
    ET.SubElement(
        laneoftarget,
        &#34;RelativeTargetLaneOffset&#34;,
        attrib=self.get_attributes(),
    )

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
RelativeLaneOffsetAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the
RelativeLaneOffsetAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedAction</span></span>
<span>(</span><span>speed: float,<br>entity: str,<br>transition_dynamics: <a title="scenariogeneration.xosc.utils.TransitionDynamics" href="utils.html#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a>,<br>valuetype: <a title="scenariogeneration.xosc.enumerations.SpeedTargetValueType" href="enumerations.html#scenariogeneration.xosc.enumerations.SpeedTargetValueType">SpeedTargetValueType</a> = &lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;,<br>continuous: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;Creates a LongitudinalAction of type SpeedAction with a relative target.

    Parameters
    ----------
    speed : float
        The desired speed.
    entity : str
        The name of the relative target.
    valuetype : str
        The type of relative speed wanted (used for relative speed).
    continuous : bool
        Whether the controller tries to maintain the relative speed.

    Attributes
    ----------
    speed : float
        The desired speed.
    target : str
        The name of the relative target (used for relative speed).
    valuetype : str
        The type of relative speed wanted (used for relative speed).
    continuous : bool
        Whether the controller tries to maintain the relative speed.
    transition_dynamics : TransitionDynamics
        How the change should be made.

    Methods
    -------
    parse(element : ET.Element) -&gt; &#34;RelativeSpeedAction&#34;
        Parses an ElementTree element and returns an instance of the class.
    get_element() -&gt; ET.Element
        Returns the full ElementTree representation of the class.
    get_attributes() -&gt; dict
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        speed: float,
        entity: str,
        transition_dynamics: TransitionDynamics,
        valuetype: SpeedTargetValueType = SpeedTargetValueType.delta,
        continuous: bool = True,
    ):
        &#34;&#34;&#34;Initializes RelativeSpeedAction.

        Parameters
        ----------
        speed : float
            The speed wanted.
        entity : str
            The name of the relative target.
        transition_dynamics : TransitionDynamics
            How the change should be made.
        valuetype : SpeedTargetValueType
            The type of relative speed wanted.
        continuous : bool
            If the controller tries to keep the relative speed.
        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        self.entity = entity
        if not hasattr(SpeedTargetValueType, str(valuetype)):
            raise TypeError(&#34;valuetype input not of type SpeedTargetValueType&#34;)
        self.valuetype = valuetype

        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(
                &#34;transition_dynamics input not of type TransitionDynamics&#34;
            )
        self.transition_dynamics = transition_dynamics
        self.continuous = convert_bool(continuous)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, RelativeSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;RelativeSpeedAction&#34;:
        &#34;&#34;&#34;Parses the XML element of RelativeSpeedAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        RelativeSpeedAction
            The RelativeSpeedAction object.
        &#34;&#34;&#34;
        speed_element = find_mandatory_field(
            element,
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;,
        )
        td_element = find_mandatory_field(
            element, &#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;
        )
        speed = speed_element.attrib[&#34;value&#34;]
        entity = speed_element.attrib[&#34;entityRef&#34;]
        continuous = convert_bool(speed_element.attrib[&#34;continuous&#34;])
        valuetype = getattr(
            SpeedTargetValueType, speed_element.attrib[&#34;speedTargetValueType&#34;]
        )
        transition_dynamics = TransitionDynamics.parse(td_element)
        return RelativeSpeedAction(
            speed, entity, transition_dynamics, valuetype, continuous
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the RelativeSpeedAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the keys related to the RelativeSpeedAction.
        &#34;&#34;&#34;
        return {
            &#34;entityRef&#34;: self.entity,
            &#34;value&#34;: str(self.speed),
            &#34;speedTargetValueType&#34;: self.valuetype.get_name(),
            &#34;continuous&#34;: get_bool_string(self.continuous),
        }

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the ElementTree of the RelativeSpeedAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the RelativeSpeedAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)
        speedaction.append(
            self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;)
        )
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(
            speedactiontarget, &#34;RelativeTargetSpeed&#34;, self.get_attributes()
        )

        return element</code></pre>
</details>
<div class="desc"><p>Creates a LongitudinalAction of type SpeedAction with a relative target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The desired speed.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the relative target.</dd>
<dt><strong><code>valuetype</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of relative speed wanted (used for relative speed).</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the controller tries to maintain the relative speed.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The desired speed.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the relative target (used for relative speed).</dd>
<dt><strong><code>valuetype</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of relative speed wanted (used for relative speed).</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the controller tries to maintain the relative speed.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : ET.Element) -&gt; "RelativeSpeedAction"
Parses an ElementTree element and returns an instance of the class.
get_element() -&gt; ET.Element
Returns the full ElementTree representation of the class.
get_attributes() -&gt; dict
Returns a dictionary of all attributes of the class.</p>
<p>Initializes RelativeSpeedAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The speed wanted.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the relative target.</dd>
<dt><strong><code>transition_dynamics</code></strong> :&ensp;<code>TransitionDynamics</code></dt>
<dd>How the change should be made.</dd>
<dt><strong><code>valuetype</code></strong> :&ensp;<code>SpeedTargetValueType</code></dt>
<dd>The type of relative speed wanted.</dd>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the controller tries to keep the relative speed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.RelativeSpeedAction" href="#scenariogeneration.xosc.actions.RelativeSpeedAction">RelativeSpeedAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;RelativeSpeedAction&#34;:
    &#34;&#34;&#34;Parses the XML element of RelativeSpeedAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    RelativeSpeedAction
        The RelativeSpeedAction object.
    &#34;&#34;&#34;
    speed_element = find_mandatory_field(
        element,
        &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;,
    )
    td_element = find_mandatory_field(
        element, &#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;
    )
    speed = speed_element.attrib[&#34;value&#34;]
    entity = speed_element.attrib[&#34;entityRef&#34;]
    continuous = convert_bool(speed_element.attrib[&#34;continuous&#34;])
    valuetype = getattr(
        SpeedTargetValueType, speed_element.attrib[&#34;speedTargetValueType&#34;]
    )
    transition_dynamics = TransitionDynamics.parse(td_element)
    return RelativeSpeedAction(
        speed, entity, transition_dynamics, valuetype, continuous
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of RelativeSpeedAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction" href="#scenariogeneration.xosc.actions.RelativeSpeedAction">RelativeSpeedAction</a></code></dt>
<dd>The RelativeSpeedAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the RelativeSpeedAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the keys related to the RelativeSpeedAction.
    &#34;&#34;&#34;
    return {
        &#34;entityRef&#34;: self.entity,
        &#34;value&#34;: str(self.speed),
        &#34;speedTargetValueType&#34;: self.valuetype.get_name(),
        &#34;continuous&#34;: get_bool_string(self.continuous),
    }</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the RelativeSpeedAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the keys related to the RelativeSpeedAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the ElementTree of the RelativeSpeedAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The ElementTree representation of the RelativeSpeedAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)
    speedaction.append(
        self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;)
    )
    speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

    ET.SubElement(
        speedactiontarget, &#34;RelativeTargetSpeed&#34;, self.get_attributes()
    )

    return element</code></pre>
</details>
<div class="desc"><p>Returns the ElementTree of the RelativeSpeedAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The ElementTree representation of the RelativeSpeedAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SetMonitorAction"><code class="flex name class">
<span>class <span class="ident">SetMonitorAction</span></span>
<span>(</span><span>monitor_ref: str, value: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetMonitorAction(_ActionType):
    &#34;&#34;&#34;The SetMonitorAction class creates a GlobalAction of the type
    SetMonitorAction.

    Action used to set the value of an existing monitor. If it is set to false by this action,
    that indicates the scenario was not executed as expected.

    Parameters
    ----------
    monitor_ref : str
        Name of the referenced monitor.
    value: bool
        New value of the monitor.

    Attributes
    ----------
    monitor_ref : str
        The referenced monitor to set the value for.
    value : bool
        The new value of the monitor.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns
        an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, monitor_ref: str, value: bool):
        &#34;&#34;&#34;Initialize the SetMonitorAction.&#34;&#34;&#34;
        if not isinstance(monitor_ref, str) or not isinstance(
            value, (str, bool, int)
        ):
            raise TypeError(
                &#34;monitor_ref must be a string (name of the referenced Monitor) and value must be a bool/str/int&#34;
            )
        self.monitor_ref = str(monitor_ref)
        self.value = convert_bool(value)

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, SetMonitorAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;Returns the attributes of the SetMonitorAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the SetMonitorAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;monitorRef&#34;] = self.monitor_ref
        retdict[&#34;value&#34;] = get_bool_string(self.value)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the SetMonitorAction.

        Returns
        -------
        ET.Element
            The XML element representing the SetMonitorAction.
        &#34;&#34;&#34;
        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;SetMonitorAction was introduced in OpenSCENARIO V1.3&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        ET.SubElement(
            element, &#34;SetMonitorAction&#34;, attrib=self.get_attributes()
        )
        return element

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;SetMonitorAction&#34;:
        &#34;&#34;&#34;Parses the XML element of SetMonitorAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A SetMonitorAction element (same as generated by the class
            itself).
        Returns
        -------
        SetMonitorAction
            A SetMonitorAction object.
        &#34;&#34;&#34;
        monitor_action = find_mandatory_field(element, &#34;SetMonitorAction&#34;)
        monitor_ref = monitor_action.attrib.get(&#34;monitorRef&#34;, None)
        if monitor_ref is None:
            raise NotAValidElement(
                &#39;SetMonitorAction is missing required argument &#34;monitorRef&#34;.&#39;
            )
        value = monitor_action.attrib.get(&#34;value&#34;, None)
        if value is None:
            raise NotAValidElement(
                &#39;SetMonitorAction is missing required argument &#34;value&#34;.&#39;
            )
        return SetMonitorAction(monitor_ref, convert_bool(value))</code></pre>
</details>
<div class="desc"><p>The SetMonitorAction class creates a GlobalAction of the type
SetMonitorAction.</p>
<p>Action used to set the value of an existing monitor. If it is set to false by this action,
that indicates the scenario was not executed as expected.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>monitor_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the referenced monitor.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>New value of the monitor.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>monitor_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>The referenced monitor to set the value for.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>The new value of the monitor.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns
an instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the SetMonitorAction.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SetMonitorAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.SetMonitorAction" href="#scenariogeneration.xosc.actions.SetMonitorAction">SetMonitorAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;SetMonitorAction&#34;:
    &#34;&#34;&#34;Parses the XML element of SetMonitorAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A SetMonitorAction element (same as generated by the class
        itself).
    Returns
    -------
    SetMonitorAction
        A SetMonitorAction object.
    &#34;&#34;&#34;
    monitor_action = find_mandatory_field(element, &#34;SetMonitorAction&#34;)
    monitor_ref = monitor_action.attrib.get(&#34;monitorRef&#34;, None)
    if monitor_ref is None:
        raise NotAValidElement(
            &#39;SetMonitorAction is missing required argument &#34;monitorRef&#34;.&#39;
        )
    value = monitor_action.attrib.get(&#34;value&#34;, None)
    if value is None:
        raise NotAValidElement(
            &#39;SetMonitorAction is missing required argument &#34;value&#34;.&#39;
        )
    return SetMonitorAction(monitor_ref, convert_bool(value))</code></pre>
</details>
<div class="desc"><p>Parses the XML element of SetMonitorAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A SetMonitorAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.SetMonitorAction" href="#scenariogeneration.xosc.actions.SetMonitorAction">SetMonitorAction</a></code></dt>
<dd>A SetMonitorAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SetMonitorAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;Returns the attributes of the SetMonitorAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the SetMonitorAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;monitorRef&#34;] = self.monitor_ref
    retdict[&#34;value&#34;] = get_bool_string(self.value)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the SetMonitorAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the SetMonitorAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.SetMonitorAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the SetMonitorAction.

    Returns
    -------
    ET.Element
        The XML element representing the SetMonitorAction.
    &#34;&#34;&#34;
    if not self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;SetMonitorAction was introduced in OpenSCENARIO V1.3&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    ET.SubElement(
        element, &#34;SetMonitorAction&#34;, attrib=self.get_attributes()
    )
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the SetMonitorAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the SetMonitorAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction"><code class="flex name class">
<span>class <span class="ident">SpeedProfileAction</span></span>
<span>(</span><span>speeds: list[float],<br>following_mode: <a title="scenariogeneration.xosc.enumerations.FollowingMode" href="enumerations.html#scenariogeneration.xosc.enumerations.FollowingMode">FollowingMode</a>,<br>times: list[float] = None,<br>dynamics_constraint: <a title="scenariogeneration.xosc.utils.DynamicsConstraints" href="utils.html#scenariogeneration.xosc.utils.DynamicsConstraints">DynamicsConstraints</a> = None,<br>entity: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpeedProfileAction(_PrivateActionType):
    &#34;&#34;&#34;Specifies a LongitudinalAction of type SpeedProfileAction.

    Parameters
    ----------
    speeds : list of float
        The different speed entries wanted.
    following_mode : FollowingMode
        How to follow the speed changes.
    times : list of float, optional
        Time entries when the speed entries should be achieved.
        Default is None.
    dynamics_constraint : DynamicsConstraints, optional
        Constraints for the speed profile. Default is None.
    entity : str, optional
        Name of an entity. The speeds will then be interpreted as
        relative to that entity. Default is None.

    Attributes
    ----------
    speeds : list of float
        The different speed entries wanted.
    following_mode : FollowingMode
        How to follow the speed changes.
    times : list of float, optional
        Time entries when the speed entries should be achieved.
    dynamics_constraint : DynamicsConstraints, optional
        Constraints for the speed profile.
    entity : str, optional
        Name of an entity. The speeds will then be interpreted as
        relative to that entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        speeds: list[float],
        following_mode: FollowingMode,
        times: list[float] = None,
        dynamics_constraint: DynamicsConstraints = None,
        entity: str = None,
    ):
        &#34;&#34;&#34;Initalize the SpeedProfileAction.

        Parameters
        ----------
            speeds (list of float): the different speed entries wanted

            following_mode (FollowingMode): how to follow the speed
            changes

            times (list of float): optional time entries when the speed
            entries should be achieved. Default is None

            dynamics_constraint (DynamicsConstraints): optional
            constraints for the speed profile. Default is None

            entity (str): name of an entity, the speeds will then be
            interpreted as relative to that entity. Default is None
        &#34;&#34;&#34;
        if times and (len(times) != len(speeds)):
            raise ValueError(&#34;times and speeds are not the same lenght&#34;)
        self.speeds = [convert_float(x) for x in speeds]
        if dynamics_constraint and not isinstance(
            dynamics_constraint, DynamicsConstraints
        ):
            raise TypeError(
                &#34;dynamics_constraint input not of type DynamicsConstraints&#34;
            )
        self.dynamics_constraint = dynamics_constraint
        self.following_mode = convert_enum(following_mode, FollowingMode)
        if times:
            self.times = [convert_float(x) for x in times]
        else:
            self.times = times
        self.entity = entity

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, SpeedProfileAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamics_constraint == other.dynamics_constraint
                and self.entity == other.entity
                and self.speeds == other.speeds
                and self.times == other.times
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;SpeedProfileAction&#34;:
        &#34;&#34;&#34;Parses the XML element of SpeedProfileAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A SpeedProfileAction element (same as generated by the class
              itself).

        Returns
        -------
        SpeedProfileAction
            A SpeedProfileAction object.
        &#34;&#34;&#34;
        speed_profile_element = find_mandatory_field(
            element, &#34;LongitudinalAction/SpeedProfileAction&#34;
        )
        following_mode = convert_enum(
            speed_profile_element.attrib[&#34;followingMode&#34;], FollowingMode
        )
        dynamics_constraint = None
        entity = None

        if &#34;entityRef&#34; in speed_profile_element.attrib:
            entity = speed_profile_element.attrib[&#34;entityRef&#34;]
        if speed_profile_element.find(&#34;DynamicConstraints&#34;) is not None:
            dynamics_constraint = DynamicsConstraints.parse(
                find_mandatory_field(
                    speed_profile_element, &#34;DynamicConstraints&#34;
                )
            )

        entires = speed_profile_element.findall(&#34;SpeedProfileEntry&#34;)
        speeds = []
        times = []
        for i in entires:
            if &#34;time&#34; in i.attrib:
                times.append(convert_float(i.attrib[&#34;time&#34;]))
            speeds.append(convert_float(i.attrib[&#34;speed&#34;]))

        return SpeedProfileAction(
            speeds, following_mode, times, dynamics_constraint, entity
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the SpeedProfileAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            SpeedProfileAction.
        &#34;&#34;&#34;
        retdict = {&#34;followingMode&#34;: self.following_mode.get_name()}
        if self.entity:
            retdict[&#34;entityRef&#34;] = self.entity
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        SpeedProfileAction.

        Returns
        -------
        ET.Element
            The root XML element representing the SpeedProfileAction.

        Raises
        ------
        OpenSCENARIOVersionError
            If the OpenSCENARIO version is less than 1.2.
        &#34;&#34;&#34;
        if not self.isVersionEqLarger(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;SpeedProfileAction was introduced in OpenSCENARIO V1.2&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(
            longaction, &#34;SpeedProfileAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamics_constraint is not None:
            speedaction.append(self.dynamics_constraint.get_element())

        for i, speed in enumerate(self.speeds):
            tmp_dict = {&#34;speed&#34;: str(speed)}
            if self.times:
                tmp_dict[&#34;time&#34;] = str(self.times[i])
            ET.SubElement(speedaction, &#34;SpeedProfileEntry&#34;, attrib=tmp_dict)

        return element</code></pre>
</details>
<div class="desc"><p>Specifies a LongitudinalAction of type SpeedProfileAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speeds</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The different speed entries wanted.</dd>
<dt><strong><code>following_mode</code></strong> :&ensp;<code>FollowingMode</code></dt>
<dd>How to follow the speed changes.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>Time entries when the speed entries should be achieved.
Default is None.</dd>
<dt><strong><code>dynamics_constraint</code></strong> :&ensp;<code>DynamicsConstraints</code>, optional</dt>
<dd>Constraints for the speed profile. Default is None.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of an entity. The speeds will then be interpreted as
relative to that entity. Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>speeds</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The different speed entries wanted.</dd>
<dt><strong><code>following_mode</code></strong> :&ensp;<code>FollowingMode</code></dt>
<dd>How to follow the speed changes.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>Time entries when the speed entries should be achieved.</dd>
<dt><strong><code>dynamics_constraint</code></strong> :&ensp;<code>DynamicsConstraints</code>, optional</dt>
<dd>Constraints for the speed profile.</dd>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of an entity. The speeds will then be interpreted as
relative to that entity.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initalize the SpeedProfileAction.</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speeds (list of float): the different speed entries wanted

following_mode (FollowingMode): how to follow the speed
changes

times (list of float): optional time entries when the speed
entries should be achieved. Default is None

dynamics_constraint (DynamicsConstraints): optional
constraints for the speed profile. Default is None

entity (str): name of an entity, the speeds will then be
interpreted as relative to that entity. Default is None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.SpeedProfileAction" href="#scenariogeneration.xosc.actions.SpeedProfileAction">SpeedProfileAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;SpeedProfileAction&#34;:
    &#34;&#34;&#34;Parses the XML element of SpeedProfileAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A SpeedProfileAction element (same as generated by the class
          itself).

    Returns
    -------
    SpeedProfileAction
        A SpeedProfileAction object.
    &#34;&#34;&#34;
    speed_profile_element = find_mandatory_field(
        element, &#34;LongitudinalAction/SpeedProfileAction&#34;
    )
    following_mode = convert_enum(
        speed_profile_element.attrib[&#34;followingMode&#34;], FollowingMode
    )
    dynamics_constraint = None
    entity = None

    if &#34;entityRef&#34; in speed_profile_element.attrib:
        entity = speed_profile_element.attrib[&#34;entityRef&#34;]
    if speed_profile_element.find(&#34;DynamicConstraints&#34;) is not None:
        dynamics_constraint = DynamicsConstraints.parse(
            find_mandatory_field(
                speed_profile_element, &#34;DynamicConstraints&#34;
            )
        )

    entires = speed_profile_element.findall(&#34;SpeedProfileEntry&#34;)
    speeds = []
    times = []
    for i in entires:
        if &#34;time&#34; in i.attrib:
            times.append(convert_float(i.attrib[&#34;time&#34;]))
        speeds.append(convert_float(i.attrib[&#34;speed&#34;]))

    return SpeedProfileAction(
        speeds, following_mode, times, dynamics_constraint, entity
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of SpeedProfileAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A SpeedProfileAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction" href="#scenariogeneration.xosc.actions.SpeedProfileAction">SpeedProfileAction</a></code></dt>
<dd>A SpeedProfileAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the SpeedProfileAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        SpeedProfileAction.
    &#34;&#34;&#34;
    retdict = {&#34;followingMode&#34;: self.following_mode.get_name()}
    if self.entity:
        retdict[&#34;entityRef&#34;] = self.entity
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the SpeedProfileAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
SpeedProfileAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    SpeedProfileAction.

    Returns
    -------
    ET.Element
        The root XML element representing the SpeedProfileAction.

    Raises
    ------
    OpenSCENARIOVersionError
        If the OpenSCENARIO version is less than 1.2.
    &#34;&#34;&#34;
    if not self.isVersionEqLarger(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;SpeedProfileAction was introduced in OpenSCENARIO V1.2&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(
        longaction, &#34;SpeedProfileAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamics_constraint is not None:
        speedaction.append(self.dynamics_constraint.get_element())

    for i, speed in enumerate(self.speeds):
        tmp_dict = {&#34;speed&#34;: str(speed)}
        if self.times:
            tmp_dict[&#34;time&#34;] = str(self.times[i])
        ET.SubElement(speedaction, &#34;SpeedProfileEntry&#34;, attrib=tmp_dict)

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
SpeedProfileAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The root XML element representing the SpeedProfileAction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenSCENARIOVersionError</code></dt>
<dd>If the OpenSCENARIO version is less than 1.2.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction"><code class="flex name class">
<span>class <span class="ident">SynchronizeAction</span></span>
<span>(</span><span>entity: str,<br>entity_PositionType: scenariogeneration.xosc.utils._PositionType,<br>target_PositionType: scenariogeneration.xosc.utils._PositionType,<br>target_tolerance_master: float | None = None,<br>target_tolerance: float | None = None,<br>final_speed: <a title="scenariogeneration.xosc.utils.AbsoluteSpeed" href="utils.html#scenariogeneration.xosc.utils.AbsoluteSpeed">AbsoluteSpeed</a> | <a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster" href="utils.html#scenariogeneration.xosc.utils.RelativeSpeedToMaster">RelativeSpeedToMaster</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynchronizeAction(_PrivateActionType):
    &#34;&#34;&#34;Synchronizes an entity&#39;s arrival at a destination with a master entity.
    Both entities are provided with their own reference position which shall be
    reached at the same time. Final speed can be specified. Note that the
    reference positions can be different or identical.

    Parameters
    ----------
    entity : str
        Entity to synchronize with.
    entity_PositionType : _PositionType
        The position of the entity to synchronize to.
    target_PositionType : _PositionType
        The position of the target that should synchronize.
    speed : float
        The absolute speed of the target that should synchronize.
    target_tolerance_master : float, optional
        Tolerance offset of the master&#39;s position [m]. (Valid from
        OpenSCENARIO V1.1)
    target_tolerance : float, optional
        Tolerance offset of the target&#39;s position [m]. (Valid from
        OpenSCENARIO V1.1)
    final_speed : AbsoluteSpeed or RelativeSpeedToMaster, optional
        The speed that the synchronized entity should have at its
        target position. (Valid from OpenSCENARIO V1.1)

    Attributes
    ----------
    entity : str
        Entity to synchronize with.
    entity_PositionType : _PositionType
        The position of the entity to synchronize to.
    target_PositionType : _PositionType
        The position of the target that should synchronize.
    speed : float
        The absolute speed of the target that should synchronize.
    target_tolerance_master : float, optional
        Tolerance offset of the master&#39;s position [m]. (Valid from
        OpenSCENARIO V1.1)
    target_tolerance : float, optional
        Tolerance offset of the target&#39;s position [m]. (Valid from
        OpenSCENARIO V1.1)
    final_speed : AbsoluteSpeed or RelativeSpeedToMaster, optional
        The speed that the synchronized entity should have at its
        target position. (Valid from OpenSCENARIO V1.1)

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        entity: str,
        entity_PositionType: _PositionType,
        target_PositionType: _PositionType,
        target_tolerance_master: Optional[float] = None,
        target_tolerance: Optional[float] = None,
        final_speed: Optional[
            Union[AbsoluteSpeed, RelativeSpeedToMaster]
        ] = None,
    ):
        &#34;&#34;&#34;Initialize the SynchronizeAction.

        Parameters
        ----------
        entity : str
            Entity to synchronize with.
        entity_PositionType : _PositionType
            The position of the entity to synchronize to.
        target_PositionType : _PositionType
            The position of the target that should synchronize.
        target_tolerance_master : float, optional
            Tolerance offset of the master&#39;s position [m].
            Valid from OpenSCENARIO V1.1.
        target_tolerance : float, optional
            Tolerance offset of the target&#39;s position [m].
            Valid from OpenSCENARIO V1.1.
        final_speed : AbsoluteSpeed or RelativeSpeedToMaster, optional
            The speed that the synchronized entity should have at its
            target position. Valid from OpenSCENARIO V1.1.
        &#34;&#34;&#34;

        self.entity = entity
        if not isinstance(entity_PositionType, _PositionType):
            raise TypeError(
                &#34;entity_PositionType input is not a valid Position&#34;
            )

        if not isinstance(target_PositionType, _PositionType):
            raise TypeError(
                &#34;target_PositionType input is not a valid Position&#34;
            )
        self.entity_PositionType = entity_PositionType
        self.target_PositionType = target_PositionType
        self.target_tolerance_master = convert_float(target_tolerance_master)
        self.target_tolerance = convert_float(target_tolerance)
        if final_speed and not (
            isinstance(final_speed, (AbsoluteSpeed, RelativeSpeedToMaster))
        ):
            raise TypeError(
                &#34;final_speed input is not AbsoluteSpeed or RelativeSpeedToMaster type&#34;
            )

        self.final_speed = final_speed

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, SynchronizeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.entity_PositionType == other.entity_PositionType
                and self.target_PositionType == other.target_PositionType
                and self.final_speed == other.final_speed
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;SynchronizeAction&#34;:
        &#34;&#34;&#34;Parses the XML element of SynchronizeAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A SynchronizeAction element (same as generated by the class
            itself).

        Returns
        -------
        SynchronizeAction
            A SynchronizeAction object.
        &#34;&#34;&#34;
        sa_element = find_mandatory_field(element, &#34;SynchronizeAction&#34;)
        entity = sa_element.attrib[&#34;masterEntityRef&#34;]

        target_tolerance = None
        if &#34;targetTolerance&#34; in sa_element.attrib:
            target_tolerance = convert_float(
                sa_element.attrib[&#34;targetTolerance&#34;]
            )

        target_tolerance_master = None
        if &#34;targetToleranceMaster&#34; in sa_element.attrib:
            target_tolerance_master = convert_float(
                sa_element.attrib[&#34;targetToleranceMaster&#34;]
            )

        targetPositionMaster = _PositionFactory.parse_position(
            find_mandatory_field(sa_element, &#34;TargetPositionMaster&#34;)
        )
        targetPosition = _PositionFactory.parse_position(
            find_mandatory_field(sa_element, &#34;TargetPosition&#34;)
        )

        finalSpeed = None
        if sa_element.find(&#34;FinalSpeed&#34;) is not None:
            sa_element = find_mandatory_field(sa_element, &#34;FinalSpeed&#34;)
            if sa_element.find(&#34;AbsoluteSpeed&#34;) is not None:
                finalSpeed = AbsoluteSpeed.parse(sa_element)
            if sa_element.find(&#34;RelativeSpeedToMaster&#34;) is not None:
                finalSpeed = RelativeSpeedToMaster.parse(sa_element)

        return SynchronizeAction(
            entity,
            targetPositionMaster,
            targetPosition,
            target_tolerance_master,
            target_tolerance,
            finalSpeed,
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AbsoluteSynchronizeAction as a dict.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            AbsoluteSynchronizeAction.
        &#34;&#34;&#34;
        attr = {&#34;masterEntityRef&#34;: self.entity}
        if self.isVersion(1, 0):
            return attr
        if self.target_tolerance_master is not None:
            attr.update(
                {&#34;targetToleranceMaster&#34;: str(self.target_tolerance_master)}
            )
        if self.target_tolerance is not None:
            attr.update({&#34;targetTolerance&#34;: str(self.target_tolerance)})
        return attr

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the AbsoluteSynchronizeAction.

        Returns
        -------
        ET.Element
            The XML element representing the AbsoluteSynchronizeAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        syncaction = ET.SubElement(
            element, &#34;SynchronizeAction&#34;, self.get_attributes()
        )
        syncaction.append(
            self.entity_PositionType.get_element(&#34;TargetPositionMaster&#34;)
        )
        syncaction.append(
            self.target_PositionType.get_element(&#34;TargetPosition&#34;)
        )
        if self.final_speed is not None:
            syncaction.append(self.final_speed.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Synchronizes an entity's arrival at a destination with a master entity.
Both entities are provided with their own reference position which shall be
reached at the same time. Final speed can be specified. Note that the
reference positions can be different or identical.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to synchronize with.</dd>
<dt><strong><code>entity_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the entity to synchronize to.</dd>
<dt><strong><code>target_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the target that should synchronize.</dd>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The absolute speed of the target that should synchronize.</dd>
<dt><strong><code>target_tolerance_master</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the master's position [m]. (Valid from
OpenSCENARIO V1.1)</dd>
<dt><strong><code>target_tolerance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the target's position [m]. (Valid from
OpenSCENARIO V1.1)</dd>
<dt><strong><code>final_speed</code></strong> :&ensp;<code>AbsoluteSpeed</code> or <code>RelativeSpeedToMaster</code>, optional</dt>
<dd>The speed that the synchronized entity should have at its
target position. (Valid from OpenSCENARIO V1.1)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to synchronize with.</dd>
<dt><strong><code>entity_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the entity to synchronize to.</dd>
<dt><strong><code>target_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the target that should synchronize.</dd>
<dt><strong><code>speed</code></strong> :&ensp;<code>float</code></dt>
<dd>The absolute speed of the target that should synchronize.</dd>
<dt><strong><code>target_tolerance_master</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the master's position [m]. (Valid from
OpenSCENARIO V1.1)</dd>
<dt><strong><code>target_tolerance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the target's position [m]. (Valid from
OpenSCENARIO V1.1)</dd>
<dt><strong><code>final_speed</code></strong> :&ensp;<code>AbsoluteSpeed</code> or <code>RelativeSpeedToMaster</code>, optional</dt>
<dd>The speed that the synchronized entity should have at its
target position. (Valid from OpenSCENARIO V1.1)</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns the attributes of the class.</p>
<p>Initialize the SynchronizeAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to synchronize with.</dd>
<dt><strong><code>entity_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the entity to synchronize to.</dd>
<dt><strong><code>target_PositionType</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>The position of the target that should synchronize.</dd>
<dt><strong><code>target_tolerance_master</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the master's position [m].
Valid from OpenSCENARIO V1.1.</dd>
<dt><strong><code>target_tolerance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance offset of the target's position [m].
Valid from OpenSCENARIO V1.1.</dd>
<dt><strong><code>final_speed</code></strong> :&ensp;<code>AbsoluteSpeed</code> or <code>RelativeSpeedToMaster</code>, optional</dt>
<dd>The speed that the synchronized entity should have at its
target position. Valid from OpenSCENARIO V1.1.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.SynchronizeAction" href="#scenariogeneration.xosc.actions.SynchronizeAction">SynchronizeAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;SynchronizeAction&#34;:
    &#34;&#34;&#34;Parses the XML element of SynchronizeAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A SynchronizeAction element (same as generated by the class
        itself).

    Returns
    -------
    SynchronizeAction
        A SynchronizeAction object.
    &#34;&#34;&#34;
    sa_element = find_mandatory_field(element, &#34;SynchronizeAction&#34;)
    entity = sa_element.attrib[&#34;masterEntityRef&#34;]

    target_tolerance = None
    if &#34;targetTolerance&#34; in sa_element.attrib:
        target_tolerance = convert_float(
            sa_element.attrib[&#34;targetTolerance&#34;]
        )

    target_tolerance_master = None
    if &#34;targetToleranceMaster&#34; in sa_element.attrib:
        target_tolerance_master = convert_float(
            sa_element.attrib[&#34;targetToleranceMaster&#34;]
        )

    targetPositionMaster = _PositionFactory.parse_position(
        find_mandatory_field(sa_element, &#34;TargetPositionMaster&#34;)
    )
    targetPosition = _PositionFactory.parse_position(
        find_mandatory_field(sa_element, &#34;TargetPosition&#34;)
    )

    finalSpeed = None
    if sa_element.find(&#34;FinalSpeed&#34;) is not None:
        sa_element = find_mandatory_field(sa_element, &#34;FinalSpeed&#34;)
        if sa_element.find(&#34;AbsoluteSpeed&#34;) is not None:
            finalSpeed = AbsoluteSpeed.parse(sa_element)
        if sa_element.find(&#34;RelativeSpeedToMaster&#34;) is not None:
            finalSpeed = RelativeSpeedToMaster.parse(sa_element)

    return SynchronizeAction(
        entity,
        targetPositionMaster,
        targetPosition,
        target_tolerance_master,
        target_tolerance,
        finalSpeed,
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of SynchronizeAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A SynchronizeAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.SynchronizeAction" href="#scenariogeneration.xosc.actions.SynchronizeAction">SynchronizeAction</a></code></dt>
<dd>A SynchronizeAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AbsoluteSynchronizeAction as a dict.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        AbsoluteSynchronizeAction.
    &#34;&#34;&#34;
    attr = {&#34;masterEntityRef&#34;: self.entity}
    if self.isVersion(1, 0):
        return attr
    if self.target_tolerance_master is not None:
        attr.update(
            {&#34;targetToleranceMaster&#34;: str(self.target_tolerance_master)}
        )
    if self.target_tolerance is not None:
        attr.update({&#34;targetTolerance&#34;: str(self.target_tolerance)})
    return attr</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AbsoluteSynchronizeAction as a dict.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
AbsoluteSynchronizeAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the AbsoluteSynchronizeAction.

    Returns
    -------
    ET.Element
        The XML element representing the AbsoluteSynchronizeAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    syncaction = ET.SubElement(
        element, &#34;SynchronizeAction&#34;, self.get_attributes()
    )
    syncaction.append(
        self.entity_PositionType.get_element(&#34;TargetPositionMaster&#34;)
    )
    syncaction.append(
        self.target_PositionType.get_element(&#34;TargetPosition&#34;)
    )
    if self.final_speed is not None:
        syncaction.append(self.final_speed.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the AbsoluteSynchronizeAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the AbsoluteSynchronizeAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TeleportAction"><code class="flex name class">
<span>class <span class="ident">TeleportAction</span></span>
<span>(</span><span>position: scenariogeneration.xosc.utils._PositionType)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TeleportAction(_PrivateActionType):
    &#34;&#34;&#34;The TeleportAction creates the Teleport action of OpenScenario.

    Parameters
    ----------
    position : _PositionType
        Any position object.

    Attributes
    ----------
    position : _PositionType
        Any position object.

    Methods
    -------
    parse(element : xml.etree.ElementTree.Element) -&gt; TeleportAction
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element() -&gt; xml.etree.ElementTree.Element
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(self, position: _PositionType):
        &#34;&#34;&#34;Initializes the TeleportAction.

        Parameters
        ----------
        position : _PositionType
            Any position object.
        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, TeleportAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TeleportAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TeleportAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A position element (same as generated by the class itself).

        Returns
        -------
        TeleportAction
            A TeleportAction object.
        &#34;&#34;&#34;
        position_element = find_mandatory_field(
            element, &#34;TeleportAction/Position&#34;
        )

        position = _PositionFactory.parse_position(position_element)
        return TeleportAction(position)

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TeleportAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The XML element representing the TeleportAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        telact = ET.SubElement(element, &#34;TeleportAction&#34;)
        telact.append(self.position.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The TeleportAction creates the Teleport action of OpenScenario.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position object.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position object.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : xml.etree.ElementTree.Element) -&gt; TeleportAction
Parses an ElementTree created by the class and returns an
instance of the class.
get_element() -&gt; xml.etree.ElementTree.Element
Returns the full ElementTree of the class.</p>
<p>Initializes the TeleportAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any position object.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TeleportAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TeleportAction" href="#scenariogeneration.xosc.actions.TeleportAction">TeleportAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TeleportAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TeleportAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A position element (same as generated by the class itself).

    Returns
    -------
    TeleportAction
        A TeleportAction object.
    &#34;&#34;&#34;
    position_element = find_mandatory_field(
        element, &#34;TeleportAction/Position&#34;
    )

    position = _PositionFactory.parse_position(position_element)
    return TeleportAction(position)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TeleportAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A position element (same as generated by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TeleportAction" href="#scenariogeneration.xosc.actions.TeleportAction">TeleportAction</a></code></dt>
<dd>A TeleportAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TeleportAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TeleportAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The XML element representing the TeleportAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    telact = ET.SubElement(element, &#34;TeleportAction&#34;)
    telact.append(self.position.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TeleportAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The XML element representing the TeleportAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficAreaAction"><code class="flex name class">
<span>class <span class="ident">TrafficAreaAction</span></span>
<span>(</span><span>continuous: bool,<br>numberofentities: int,<br>trafficdistribution: <a title="scenariogeneration.xosc.entities.TrafficDistribution" href="entities.html#scenariogeneration.xosc.entities.TrafficDistribution">TrafficDistribution</a>,<br>trafficarea: <a title="scenariogeneration.xosc.position.Polygon" href="position.html#scenariogeneration.xosc.position.Polygon">Polygon</a> | <a title="scenariogeneration.xosc.position.RoadRange" href="position.html#scenariogeneration.xosc.position.RoadRange">RoadRange</a> | list[<a title="scenariogeneration.xosc.position.RoadRange" href="position.html#scenariogeneration.xosc.position.RoadRange">RoadRange</a>],<br>name: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficAreaAction(_ActionType):
    &#34;&#34;&#34;The TrafficAreaAction class creates a TrafficAction of the type
    TrafficAreaAction.

    Parameters
    ----------
    continuous : bool
        If False, traffic is spawned once and then the action ends.
        If True, traffic is spawned continuously and despawned as it leaves
        the area.
    numberofentities : int
        Maximum number of spawned entities in the area.
    trafficdistribution : TrafficDistribution
        Distribution of the traffic in the area.
    trafficarea : Polygon | RoadRange | list[RoadRange]
        Area where the traffic is spawned.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1). Default is None.

    Attributes
    ----------
    continuous : bool
        If False, traffic is spawned once and then the action ends.
        If True, traffic is spawned continuously and despawned as it leaves
        the area.
    numberofentities : int
        Maximum number of spawned entities in the area.
    trafficdistribution : TrafficDistribution
        Distribution of the traffic in the area.
    trafficarea : Polygon | RoadRange | list[RoadRange]
        Area where the traffic is spawned.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1). Default is None.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        continuous: bool,
        numberofentities: int,
        trafficdistribution: TrafficDistribution,
        trafficarea: Union[Polygon, RoadRange, list[RoadRange]],
        name: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize the TrafficAreaAction.
        Parameters
        ----------
        continuous : bool
            If False, traffic is spawned once and then the action ends.
            If True, traffic is spawned continuously and despawned as it
            leaves the area.
        numberofentities : int
            Maximum number of spawned entities in the area.
        trafficdistribution : TrafficDistribution
            Distribution of the traffic in the area.
        trafficarea : Polygon | RoadRange | list[RoadRange]
            Area where the traffic is spawned.
        name : str, optional
            Name of the TrafficAction, can be used to stop the TrafficAction
            (valid from V1.1). Default is None.
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.numberofentities = convert_int(numberofentities)
        if not isinstance(trafficdistribution, TrafficDistribution):
            raise TypeError(
                &#34;trafficdistribution input is not of type TrafficDistribution&#34;
            )
        self.trafficdistribution = trafficdistribution
        if not (
            isinstance(trafficarea, (Polygon, RoadRange))
            or (
                isinstance(trafficarea, list)
                and all(isinstance(x, RoadRange) for x in trafficarea)
            )
        ):
            raise TypeError(
                &#34;trafficarea input is not of type Polygon, RoadRange or list[RoadRange]&#34;
            )
        self.trafficarea = trafficarea
        self.name = name

    def __eq__(self, other: object) -&gt; bool:
        return (
            isinstance(other, TrafficAreaAction)
            and self.get_attributes() == other.get_attributes()
            and self.trafficdistribution == other.trafficdistribution
            and self.trafficarea == other.trafficarea
            and self.name == other.name
        )

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficAreaAction&#34;:
        &#34;&#34;&#34;Parse the XML element of TrafficAreaAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficAreaAction element (same as generated by the class
            itself).

        Returns
        -------
        TrafficAreaAction
            A TrafficAreaAction object.
        &#34;&#34;&#34;
        ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        taa_element = find_mandatory_field(ta_element, &#34;TrafficAreaAction&#34;)

        for elem in taa_element:
            print(elem.tag)

        continuous = convert_bool(taa_element.attrib[&#34;continuous&#34;])
        numberofentities = convert_int(taa_element.attrib[&#34;numberOfEntities&#34;])

        trafficdistribution = TrafficDistribution.parse(
            find_mandatory_field(taa_element, &#34;TrafficDistribution&#34;)
        )
        trafficarea_element = find_mandatory_field(taa_element, &#34;TrafficArea&#34;)

        if trafficarea_element.find(&#34;Polygon&#34;) is not None:
            trafficarea = Polygon.parse(
                find_mandatory_field(trafficarea_element, &#34;Polygon&#34;)
            )
        elif trafficarea_element.findall(&#34;RoadRange&#34;):
            road_ranges = [
                RoadRange.parse(rr)
                for rr in trafficarea_element.findall(&#34;RoadRange&#34;)
            ]
            trafficarea = (
                road_ranges if len(road_ranges) &gt; 1 else road_ranges[0]
            )

        taa_object = TrafficAreaAction(
            continuous,
            numberofentities,
            trafficdistribution,
            trafficarea,
            name,
        )
        return taa_object

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the TrafficAreaAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            TrafficAreaAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        retdict[&#34;numberOfEntities&#34;] = str(self.numberofentities)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TrafficAreaAction.

        Returns
        -------
        ET.Element
            The XML element representing the TrafficAreaAction.
        &#34;&#34;&#34;
        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;TrafficAreaAction was introduced in OpenSCENARIO V1.3&#34;
            )

        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=traffic_attrib
        )

        areaaction = ET.SubElement(
            trafficaction, &#34;TrafficAreaAction&#34;, attrib=self.get_attributes()
        )

        trafficarea = ET.SubElement(areaaction, &#34;TrafficArea&#34;)
        if isinstance(self.trafficarea, Polygon):
            trafficarea.append(self.trafficarea.get_element())
        elif isinstance(self.trafficarea, RoadRange):
            trafficarea.append(self.trafficarea.get_element())
        elif isinstance(self.trafficarea, list):
            for rr in self.trafficarea:
                trafficarea.append(rr.get_element())

        areaaction.append(self.trafficdistribution.get_element())
        # areaaction.append(self.trafficarea.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficAreaAction class creates a TrafficAction of the type
TrafficAreaAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False, traffic is spawned once and then the action ends.
If True, traffic is spawned continuously and despawned as it leaves
the area.</dd>
<dt><strong><code>numberofentities</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of spawned entities in the area.</dd>
<dt><strong><code>trafficdistribution</code></strong> :&ensp;<code>TrafficDistribution</code></dt>
<dd>Distribution of the traffic in the area.</dd>
<dt><strong><code>trafficarea</code></strong> :&ensp;<code>Polygon | RoadRange | list[RoadRange]</code></dt>
<dd>Area where the traffic is spawned.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False, traffic is spawned once and then the action ends.
If True, traffic is spawned continuously and despawned as it leaves
the area.</dd>
<dt><strong><code>numberofentities</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of spawned entities in the area.</dd>
<dt><strong><code>trafficdistribution</code></strong> :&ensp;<code>TrafficDistribution</code></dt>
<dd>Distribution of the traffic in the area.</dd>
<dt><strong><code>trafficarea</code></strong> :&ensp;<code>Polygon | RoadRange | list[RoadRange]</code></dt>
<dd>Area where the traffic is spawned.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_attributes()
Returns a dictionary of all attributes of the class.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the TrafficAreaAction.
Parameters</p>
<hr>
<dl>
<dt><strong><code>continuous</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False, traffic is spawned once and then the action ends.
If True, traffic is spawned continuously and despawned as it
leaves the area.</dd>
<dt><strong><code>numberofentities</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of spawned entities in the area.</dd>
<dt><strong><code>trafficdistribution</code></strong> :&ensp;<code>TrafficDistribution</code></dt>
<dd>Distribution of the traffic in the area.</dd>
<dt><strong><code>trafficarea</code></strong> :&ensp;<code>Polygon | RoadRange | list[RoadRange]</code></dt>
<dd>Area where the traffic is spawned.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficAreaAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficAreaAction" href="#scenariogeneration.xosc.actions.TrafficAreaAction">TrafficAreaAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficAreaAction&#34;:
    &#34;&#34;&#34;Parse the XML element of TrafficAreaAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficAreaAction element (same as generated by the class
        itself).

    Returns
    -------
    TrafficAreaAction
        A TrafficAreaAction object.
    &#34;&#34;&#34;
    ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]

    taa_element = find_mandatory_field(ta_element, &#34;TrafficAreaAction&#34;)

    for elem in taa_element:
        print(elem.tag)

    continuous = convert_bool(taa_element.attrib[&#34;continuous&#34;])
    numberofentities = convert_int(taa_element.attrib[&#34;numberOfEntities&#34;])

    trafficdistribution = TrafficDistribution.parse(
        find_mandatory_field(taa_element, &#34;TrafficDistribution&#34;)
    )
    trafficarea_element = find_mandatory_field(taa_element, &#34;TrafficArea&#34;)

    if trafficarea_element.find(&#34;Polygon&#34;) is not None:
        trafficarea = Polygon.parse(
            find_mandatory_field(trafficarea_element, &#34;Polygon&#34;)
        )
    elif trafficarea_element.findall(&#34;RoadRange&#34;):
        road_ranges = [
            RoadRange.parse(rr)
            for rr in trafficarea_element.findall(&#34;RoadRange&#34;)
        ]
        trafficarea = (
            road_ranges if len(road_ranges) &gt; 1 else road_ranges[0]
        )

    taa_object = TrafficAreaAction(
        continuous,
        numberofentities,
        trafficdistribution,
        trafficarea,
        name,
    )
    return taa_object</code></pre>
</details>
<div class="desc"><p>Parse the XML element of TrafficAreaAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficAreaAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficAreaAction" href="#scenariogeneration.xosc.actions.TrafficAreaAction">TrafficAreaAction</a></code></dt>
<dd>A TrafficAreaAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficAreaAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the TrafficAreaAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        TrafficAreaAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
    retdict[&#34;numberOfEntities&#34;] = str(self.numberofentities)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the TrafficAreaAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
TrafficAreaAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficAreaAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TrafficAreaAction.

    Returns
    -------
    ET.Element
        The XML element representing the TrafficAreaAction.
    &#34;&#34;&#34;
    if not self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;TrafficAreaAction was introduced in OpenSCENARIO V1.3&#34;
        )

    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}
    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=traffic_attrib
    )

    areaaction = ET.SubElement(
        trafficaction, &#34;TrafficAreaAction&#34;, attrib=self.get_attributes()
    )

    trafficarea = ET.SubElement(areaaction, &#34;TrafficArea&#34;)
    if isinstance(self.trafficarea, Polygon):
        trafficarea.append(self.trafficarea.get_element())
    elif isinstance(self.trafficarea, RoadRange):
        trafficarea.append(self.trafficarea.get_element())
    elif isinstance(self.trafficarea, list):
        for rr in self.trafficarea:
            trafficarea.append(rr.get_element())

    areaaction.append(self.trafficdistribution.get_element())
    # areaaction.append(self.trafficarea.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TrafficAreaAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the TrafficAreaAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalControllerAction</span></span>
<span>(</span><span>phase: str, traffic_signalcontroller_ref: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalControllerAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalControllerAction class creates an Infrastructure action
    which activates a controller of a traffic signal.

    Parameters
    ----------
    phase : str
        Phase of the signal.
    traffic_signalcontroller_ref : str
        Reference to the traffic signal controller.

    Attributes
    ----------
    phase : str
        Phase of the signal.
    traffic_signalcontroller_ref : str
        Reference to the traffic signal controller.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, phase: str, traffic_signalcontroller_ref: str):
        &#34;&#34;&#34;Initialize the TrafficSignalControllerAction.

        Parameters
        ----------
        phase : str
            Phase of the signal.
        traffic_signalcontroller_ref : str
            Reference to the traffic signal controller.
        &#34;&#34;&#34;
        self.phase = phase
        self.traffic_signalcontroller_ref = traffic_signalcontroller_ref

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, TrafficSignalControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficSignalControllerAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TrafficSignalControllerAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficSignalControllerAction element (same as generated
            by the class itself).

        Returns
        -------
        TrafficSignalControllerAction
            A TrafficSignalControllerAction object.
        &#34;&#34;&#34;
        isa_element = find_mandatory_field(element, &#34;InfrastructureAction&#34;)
        tsa_element = find_mandatory_field(isa_element, &#34;TrafficSignalAction&#34;)
        tsc_element = find_mandatory_field(
            tsa_element, &#34;TrafficSignalControllerAction&#34;
        )

        phase = tsc_element.attrib[&#34;phase&#34;]
        tsc_ref = tsc_element.attrib[&#34;trafficSignalControllerRef&#34;]

        return TrafficSignalControllerAction(phase, tsc_ref)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the TrafficSignalControllerAction as a
        dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            TrafficSignalControllerAction.
        &#34;&#34;&#34;
        return {
            &#34;phase&#34;: self.phase,
            &#34;trafficSignalControllerRef&#34;: self.traffic_signalcontroller_ref,
        }

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TrafficSignalControllerAction.

        Returns
        -------
        ET.Element
            The XML element representing the TrafficSignalControllerAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(
            tsa, &#34;TrafficSignalControllerAction&#34;, self.get_attributes()
        )

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficSignalControllerAction class creates an Infrastructure action
which activates a controller of a traffic signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phase</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase of the signal.</dd>
<dt><strong><code>traffic_signalcontroller_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the traffic signal controller.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>phase</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase of the signal.</dd>
<dt><strong><code>traffic_signalcontroller_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the traffic signal controller.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSignalControllerAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>phase</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase of the signal.</dd>
<dt><strong><code>traffic_signalcontroller_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the traffic signal controller.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction">TrafficSignalControllerAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficSignalControllerAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TrafficSignalControllerAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficSignalControllerAction element (same as generated
        by the class itself).

    Returns
    -------
    TrafficSignalControllerAction
        A TrafficSignalControllerAction object.
    &#34;&#34;&#34;
    isa_element = find_mandatory_field(element, &#34;InfrastructureAction&#34;)
    tsa_element = find_mandatory_field(isa_element, &#34;TrafficSignalAction&#34;)
    tsc_element = find_mandatory_field(
        tsa_element, &#34;TrafficSignalControllerAction&#34;
    )

    phase = tsc_element.attrib[&#34;phase&#34;]
    tsc_ref = tsc_element.attrib[&#34;trafficSignalControllerRef&#34;]

    return TrafficSignalControllerAction(phase, tsc_ref)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TrafficSignalControllerAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficSignalControllerAction element (same as generated
by the class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction">TrafficSignalControllerAction</a></code></dt>
<dd>A TrafficSignalControllerAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the TrafficSignalControllerAction as a
    dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        TrafficSignalControllerAction.
    &#34;&#34;&#34;
    return {
        &#34;phase&#34;: self.phase,
        &#34;trafficSignalControllerRef&#34;: self.traffic_signalcontroller_ref,
    }</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the TrafficSignalControllerAction as a
dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
TrafficSignalControllerAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TrafficSignalControllerAction.

    Returns
    -------
    ET.Element
        The XML element representing the TrafficSignalControllerAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
    tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
    ET.SubElement(
        tsa, &#34;TrafficSignalControllerAction&#34;, self.get_attributes()
    )

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TrafficSignalControllerAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the TrafficSignalControllerAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalStateAction</span></span>
<span>(</span><span>name: str, state: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalStateAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalStateAction class creates an Infrastructure action
    which controls the state of a traffic signal.

    Parameters
    ----------
    name : str
        ID of the signal in the road network.
    state : str
        The state to set to the traffic light.

    Attributes
    ----------
    name : str
        ID of the signal in the road network.
    state : str
        The state to set to the traffic light.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, name: str, state: str):
        &#34;&#34;&#34;Initialize the TrafficSignalStateAction.

        Parameters
        ----------
        name : str
            ID of the signal in the road network.
        state : str
            The state to set to the traffic light.
        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, TrafficSignalStateAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficSignalStateAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TrafficSignalStateAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficSignalStateAction element (same as generated by the
            class itself).

        Returns
        -------
        TrafficSignalStateAction
            A TrafficSignalStateAction object.
        &#34;&#34;&#34;
        isa_element = find_mandatory_field(element, &#34;InfrastructureAction&#34;)
        tsa_element = find_mandatory_field(isa_element, &#34;TrafficSignalAction&#34;)
        tss_element = find_mandatory_field(
            tsa_element, &#34;TrafficSignalStateAction&#34;
        )
        name = tss_element.attrib[&#34;name&#34;]
        state = tss_element.attrib[&#34;state&#34;]
        return TrafficSignalStateAction(name, state)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the TrafficSignalStateAction as a dict.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            TrafficSignalStateAction.
        &#34;&#34;&#34;
        return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of a
        TrafficSignalStateAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the GlobalAction
            with nested InfrastructureAction and TrafficSignalAction.
        &#34;&#34;&#34;

        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(tsa, &#34;TrafficSignalStateAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficSignalStateAction class creates an Infrastructure action
which controls the state of a traffic signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the signal in the road network.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code></dt>
<dd>The state to set to the traffic light.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the signal in the road network.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code></dt>
<dd>The state to set to the traffic light.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSignalStateAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the signal in the road network.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code></dt>
<dd>The state to set to the traffic light.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficSignalStateAction" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction">TrafficSignalStateAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficSignalStateAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TrafficSignalStateAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficSignalStateAction element (same as generated by the
        class itself).

    Returns
    -------
    TrafficSignalStateAction
        A TrafficSignalStateAction object.
    &#34;&#34;&#34;
    isa_element = find_mandatory_field(element, &#34;InfrastructureAction&#34;)
    tsa_element = find_mandatory_field(isa_element, &#34;TrafficSignalAction&#34;)
    tss_element = find_mandatory_field(
        tsa_element, &#34;TrafficSignalStateAction&#34;
    )
    name = tss_element.attrib[&#34;name&#34;]
    state = tss_element.attrib[&#34;state&#34;]
    return TrafficSignalStateAction(name, state)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TrafficSignalStateAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficSignalStateAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction">TrafficSignalStateAction</a></code></dt>
<dd>A TrafficSignalStateAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the TrafficSignalStateAction as a dict.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        TrafficSignalStateAction.
    &#34;&#34;&#34;
    return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the TrafficSignalStateAction as a dict.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
TrafficSignalStateAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of a
    TrafficSignalStateAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the GlobalAction
        with nested InfrastructureAction and TrafficSignalAction.
    &#34;&#34;&#34;

    element = ET.Element(&#34;GlobalAction&#34;)
    infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
    tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
    ET.SubElement(tsa, &#34;TrafficSignalStateAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of a
TrafficSignalStateAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the GlobalAction
with nested InfrastructureAction and TrafficSignalAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction"><code class="flex name class">
<span>class <span class="ident">TrafficSinkAction</span></span>
<span>(</span><span>radius: float,<br>position: scenariogeneration.xosc.utils._PositionType,<br>trafficdefinition: <a title="scenariogeneration.xosc.utils.TrafficDefinition" href="utils.html#scenariogeneration.xosc.utils.TrafficDefinition">TrafficDefinition</a> | None = None,<br>rate: float | None = None,<br>name: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSinkAction(_ActionType):
    &#34;&#34;&#34;The TrafficSinkAction class creates a TrafficAction of the type
    TrafficSinkAction.

    Parameters
    ----------
    rate : float
        Rate of appearing traffic.
    radius : float
        The radius of the sink around the position.
    position : _PositionType
        Any Position to define the sink.
    trafficdefinition : TrafficDefinition
        Definition of the traffic.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1). Default is None.

    Attributes
    ----------
    rate : float
        Rate of appearing traffic.
    radius : float
        The radius of the sink around the position.
    position : _PositionType
        Any Position to define the sink.
    trafficdefinition : TrafficDefinition
        Definition of the traffic.
    name : str
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an instance
        of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        radius: float,
        position: _PositionType,
        trafficdefinition: Optional[TrafficDefinition] = None,
        rate: Optional[float] = None,
        name: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize the TrafficSinkAction.

        Parameters
        ----------
        rate : float
            Rate of appearing traffic.
        radius : float
            The radius of the source around the position.
        position : _PositionType
            Any Position to define the source.
        trafficdefinition : TrafficDefinition
            Definition of the traffic.
        name : str
            Name of the TrafficAction, can be used to stop the
            TrafficAction (valid from V1.1).
        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if trafficdefinition and not isinstance(
            trafficdefinition, TrafficDefinition
        ):
            raise TypeError(
                &#34;trafficdefinition input is not of type TrafficDefinition&#34;
            )
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.name = name

    def __eq__(self, other: object) -&gt; bool:
        if (
            isinstance(other, TrafficSinkAction)
            and self.get_attributes() == other.get_attributes()
            and self.position == other.position
            and self.trafficdefinition == other.trafficdefinition
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficSinkAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TrafficSinkAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficSinkAction element (same as generated by the class
            itself).

        Returns
        -------
        TrafficSinkAction
            A TrafficSinkAction object.
        &#34;&#34;&#34;
        ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = find_mandatory_field(ta_element, &#34;TrafficSinkAction&#34;)
        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = None
        if &#34;rate&#34; in tsa_element.attrib:
            rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
        trafficdefinition = None
        if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
            trafficdefinition = TrafficDefinition.parse(
                find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
            )

        position = _PositionFactory.parse_position(
            find_mandatory_field(tsa_element, &#34;Position&#34;)
        )

        return TrafficSinkAction(
            radius, position, trafficdefinition, rate, name
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve the attributes of the TrafficSinkAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the TrafficSinkAction.
        &#34;&#34;&#34;
        retdict = {}
        if self.rate:
            retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TrafficSinkAction.

        Returns
        -------
        ET.Element
            The XML element representing the TrafficSinkAction.
        &#34;&#34;&#34;
        if self.trafficdefinition is not None and self.isVersionEqLarger(
            minor=3
        ):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSinkAction with TrafficDefinition was depricated in OSC 1.3&#34;
            )

        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=traffic_attrib
        )
        sinkaction = ET.SubElement(
            trafficaction, &#34;TrafficSinkAction&#34;, attrib=self.get_attributes()
        )
        sinkaction.append(self.position.get_element())
        if self.trafficdefinition:
            sinkaction.append(self.trafficdefinition.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficSinkAction class creates a TrafficAction of the type
TrafficSinkAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the sink around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the sink.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code></dt>
<dd>Definition of the traffic.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the sink around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the sink.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code></dt>
<dd>Definition of the traffic.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an instance
of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSinkAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the source around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the source.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code></dt>
<dd>Definition of the traffic.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the TrafficAction, can be used to stop the
TrafficAction (valid from V1.1).</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficSinkAction" href="#scenariogeneration.xosc.actions.TrafficSinkAction">TrafficSinkAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficSinkAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TrafficSinkAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficSinkAction element (same as generated by the class
        itself).

    Returns
    -------
    TrafficSinkAction
        A TrafficSinkAction object.
    &#34;&#34;&#34;
    ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]

    tsa_element = find_mandatory_field(ta_element, &#34;TrafficSinkAction&#34;)
    radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
    rate = None
    if &#34;rate&#34; in tsa_element.attrib:
        rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
    trafficdefinition = None
    if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
        trafficdefinition = TrafficDefinition.parse(
            find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
        )

    position = _PositionFactory.parse_position(
        find_mandatory_field(tsa_element, &#34;Position&#34;)
    )

    return TrafficSinkAction(
        radius, position, trafficdefinition, rate, name
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TrafficSinkAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficSinkAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction" href="#scenariogeneration.xosc.actions.TrafficSinkAction">TrafficSinkAction</a></code></dt>
<dd>A TrafficSinkAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Retrieve the attributes of the TrafficSinkAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the TrafficSinkAction.
    &#34;&#34;&#34;
    retdict = {}
    if self.rate:
        retdict[&#34;rate&#34;] = str(self.rate)
    retdict[&#34;radius&#34;] = str(self.radius)
    return retdict</code></pre>
</details>
<div class="desc"><p>Retrieve the attributes of the TrafficSinkAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the TrafficSinkAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TrafficSinkAction.

    Returns
    -------
    ET.Element
        The XML element representing the TrafficSinkAction.
    &#34;&#34;&#34;
    if self.trafficdefinition is not None and self.isVersionEqLarger(
        minor=3
    ):
        raise OpenSCENARIOVersionError(
            &#34;TrafficSinkAction with TrafficDefinition was depricated in OSC 1.3&#34;
        )

    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}
    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=traffic_attrib
    )
    sinkaction = ET.SubElement(
        trafficaction, &#34;TrafficSinkAction&#34;, attrib=self.get_attributes()
    )
    sinkaction.append(self.position.get_element())
    if self.trafficdefinition:
        sinkaction.append(self.trafficdefinition.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TrafficSinkAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the TrafficSinkAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction"><code class="flex name class">
<span>class <span class="ident">TrafficSourceAction</span></span>
<span>(</span><span>rate: float,<br>radius: float,<br>position: scenariogeneration.xosc.utils._PositionType,<br>trafficdefinition: <a title="scenariogeneration.xosc.utils.TrafficDefinition" href="utils.html#scenariogeneration.xosc.utils.TrafficDefinition">TrafficDefinition</a> | <a title="scenariogeneration.xosc.entities.TrafficDistribution" href="entities.html#scenariogeneration.xosc.entities.TrafficDistribution">TrafficDistribution</a>,<br>velocity: float | None = None,<br>name: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSourceAction(_ActionType):
    &#34;&#34;&#34;The TrafficSourceAction class creates a TrafficAction of the type
    TrafficSourceAction.

    Parameters
    ----------
    rate : float
        Rate of appearing traffic.
    radius : float
        The radius of the source around the position.
    position : _PositionType
        Any Position to define the source.
    trafficdefinition : TrafficDefinition or TrafficDistribution
        Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3
    velocity : float, optional
        Starting velocity of the traffic. Default is None.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1). Default is None.

    Attributes
    ----------
    rate : float
        Rate of appearing traffic.
    radius : float
        The radius of the source around the position.
    position : _PositionType
        Any Position to define the source.
    trafficdefinition : TrafficDefinition or TrafficDistribution
        Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3
    velocity : float, optional
        Starting velocity of the traffic. Default is None.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        rate: float,
        radius: float,
        position: _PositionType,
        trafficdefinition: Union[TrafficDefinition, TrafficDistribution],
        velocity: Optional[float] = None,
        name: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize the TrafficSourceAction.

        Parameters
        ----------
        rate : float
            Rate of appearing traffic.
        radius : float
            The radius of the source around the position.
        position : _PositionType
            Any Position to define the source.
        trafficdefinition : TrafficDefinition
            Definition of the traffic.
        velocity : float, optional
            Starting velocity of the traffic. Default is None.
        name : str, optional
            Name of the TrafficAction, can be used to stop the
            TrafficAction (valid from V1.1). Default is None.
        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if not isinstance(
            trafficdefinition, (TrafficDefinition, TrafficDistribution)
        ):
            raise TypeError(
                &#34;trafficdefinition input is not of type TrafficDefinitioon or TrafficDistribution. Should be TrafficDefinition for  version &lt;= v1.2, TrafficDistribution otherwise&#34;
            )
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.velocity = convert_float(velocity)
        self.name = name

    def __eq__(self, other: object) -&gt; bool:
        if (
            isinstance(other, TrafficSourceAction)
            and self.get_attributes() == other.get_attributes()
            and self.position == other.position
            and self.trafficdefinition == other.trafficdefinition
            and self.name == other.name
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficSourceAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TrafficSourceAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficSourceAction element (same as generated by the
            class itself).

        Returns
        -------
        TrafficSourceAction
            A TrafficSourceAction object.
        &#34;&#34;&#34;
        ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]
        tsa_element = find_mandatory_field(ta_element, &#34;TrafficSourceAction&#34;)

        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif &#34;speed&#34; in tsa_element.attrib:
            velocity = tsa_element.attrib[&#34;speed&#34;]
        position = _PositionFactory.parse_position(
            find_mandatory_field(tsa_element, &#34;Position&#34;)
        )

        traffic = None
        if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
            traffic = TrafficDefinition.parse(
                find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
            )
        elif tsa_element.find(&#34;TrafficDistribution&#34;) is not None:
            traffic = TrafficDistribution.parse(
                find_mandatory_field(tsa_element, &#34;TrafficDistribution&#34;)
            )

        return TrafficSourceAction(
            rate, radius, position, traffic, velocity, name
        )

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve the attributes of the TrafficSourceAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the TrafficSourceAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        if self.velocity is not None:
            if self.version_minor &lt; 2:
                retdict[&#34;velocity&#34;] = str(self.velocity)
            else:
                retdict[&#34;speed&#34;] = str(self.velocity)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TrafficSourceAction.&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}

        if isinstance(
            self.trafficdefinition, TrafficDefinition
        ) and self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSourceAction with TrafficDefinition was deprecated in OSC 1.3&#34;
            )
        if isinstance(
            self.trafficdefinition, TrafficDistribution
        ) and self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSourceAction with TrafficDistribution was first introduced in OSC 1.3&#34;
            )

        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=traffic_attrib
        )
        sourceaction = ET.SubElement(
            trafficaction, &#34;TrafficSourceAction&#34;, attrib=self.get_attributes()
        )
        sourceaction.append(self.position.get_element())
        sourceaction.append(self.trafficdefinition.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficSourceAction class creates a TrafficAction of the type
TrafficSourceAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the source around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the source.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code> or <code>TrafficDistribution</code></dt>
<dd>Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting velocity of the traffic. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the source around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the source.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code> or <code>TrafficDistribution</code></dt>
<dd>Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting velocity of the traffic. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSourceAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Rate of appearing traffic.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the source around the position.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>_PositionType</code></dt>
<dd>Any Position to define the source.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code></dt>
<dd>Definition of the traffic.</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting velocity of the traffic. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the
TrafficAction (valid from V1.1). Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficSourceAction" href="#scenariogeneration.xosc.actions.TrafficSourceAction">TrafficSourceAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficSourceAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TrafficSourceAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficSourceAction element (same as generated by the
        class itself).

    Returns
    -------
    TrafficSourceAction
        A TrafficSourceAction object.
    &#34;&#34;&#34;
    ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]
    tsa_element = find_mandatory_field(ta_element, &#34;TrafficSourceAction&#34;)

    radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
    rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
    velocity = None
    if &#34;velocity&#34; in tsa_element.attrib:
        velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
    elif &#34;speed&#34; in tsa_element.attrib:
        velocity = tsa_element.attrib[&#34;speed&#34;]
    position = _PositionFactory.parse_position(
        find_mandatory_field(tsa_element, &#34;Position&#34;)
    )

    traffic = None
    if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
        traffic = TrafficDefinition.parse(
            find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
        )
    elif tsa_element.find(&#34;TrafficDistribution&#34;) is not None:
        traffic = TrafficDistribution.parse(
            find_mandatory_field(tsa_element, &#34;TrafficDistribution&#34;)
        )

    return TrafficSourceAction(
        rate, radius, position, traffic, velocity, name
    )</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TrafficSourceAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficSourceAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction" href="#scenariogeneration.xosc.actions.TrafficSourceAction">TrafficSourceAction</a></code></dt>
<dd>A TrafficSourceAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Retrieve the attributes of the TrafficSourceAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the TrafficSourceAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;rate&#34;] = str(self.rate)
    retdict[&#34;radius&#34;] = str(self.radius)
    if self.velocity is not None:
        if self.version_minor &lt; 2:
            retdict[&#34;velocity&#34;] = str(self.velocity)
        else:
            retdict[&#34;speed&#34;] = str(self.velocity)
    return retdict</code></pre>
</details>
<div class="desc"><p>Retrieve the attributes of the TrafficSourceAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the TrafficSourceAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TrafficSourceAction.&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}

    if isinstance(
        self.trafficdefinition, TrafficDefinition
    ) and self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;TrafficSourceAction with TrafficDefinition was deprecated in OSC 1.3&#34;
        )
    if isinstance(
        self.trafficdefinition, TrafficDistribution
    ) and self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;TrafficSourceAction with TrafficDistribution was first introduced in OSC 1.3&#34;
        )

    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=traffic_attrib
    )
    sourceaction = ET.SubElement(
        trafficaction, &#34;TrafficSourceAction&#34;, attrib=self.get_attributes()
    )
    sourceaction.append(self.position.get_element())
    sourceaction.append(self.trafficdefinition.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TrafficSourceAction.</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction"><code class="flex name class">
<span>class <span class="ident">TrafficStopAction</span></span>
<span>(</span><span>name: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficStopAction(_ActionType):
    &#34;&#34;&#34;The TrafficStopAction class creates a TrafficAction of the type
    TrafficStopAction.

    Parameters
    ----------
    name : str, optional
        Name of the Traffic to stop. Default is None.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, name: str = None):
        &#34;&#34;&#34;Initialize the TrafficSwarmAction.

        Parameters
        ----------
        name : str, optional
            Name of the Traffic to stop. Default is None.
        &#34;&#34;&#34;
        self.name = name

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, TrafficStopAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficStopAction&#34;:
        &#34;&#34;&#34;Parses the XML element of TrafficStopAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficStopAction element (same as generated by the class
            itself).

        Returns
        -------
        TrafficStopAction
            A TrafficStopAction object.
        &#34;&#34;&#34;
        trafficaction_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
        name = trafficaction_element.attrib[&#34;trafficName&#34;]
        return TrafficStopAction(name)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the TrafficStopAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the TrafficStopAction.
        &#34;&#34;&#34;
        retdict = {}
        if self.name and not self.isVersion(minor=0):
            retdict[&#34;trafficName&#34;] = str(self.name)
        elif self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;TrafficStopAction was introduced in OpenSCENARIO V1.1&#34;
            )

        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generates an XML element tree representation of the
        TrafficStopAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the GlobalAction
            with a nested TrafficAction and TrafficStopAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=self.get_attributes()
        )
        ET.SubElement(trafficaction, &#34;TrafficStopAction&#34;)

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficStopAction class creates a TrafficAction of the type
TrafficStopAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the Traffic to stop. Default is None.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSwarmAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the Traffic to stop. Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficStopAction" href="#scenariogeneration.xosc.actions.TrafficStopAction">TrafficStopAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficStopAction&#34;:
    &#34;&#34;&#34;Parses the XML element of TrafficStopAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficStopAction element (same as generated by the class
        itself).

    Returns
    -------
    TrafficStopAction
        A TrafficStopAction object.
    &#34;&#34;&#34;
    trafficaction_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
    name = trafficaction_element.attrib[&#34;trafficName&#34;]
    return TrafficStopAction(name)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of TrafficStopAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficStopAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficStopAction" href="#scenariogeneration.xosc.actions.TrafficStopAction">TrafficStopAction</a></code></dt>
<dd>A TrafficStopAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the TrafficStopAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the TrafficStopAction.
    &#34;&#34;&#34;
    retdict = {}
    if self.name and not self.isVersion(minor=0):
        retdict[&#34;trafficName&#34;] = str(self.name)
    elif self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;TrafficStopAction was introduced in OpenSCENARIO V1.1&#34;
        )

    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the TrafficStopAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the TrafficStopAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generates an XML element tree representation of the
    TrafficStopAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the GlobalAction
        with a nested TrafficAction and TrafficStopAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=self.get_attributes()
    )
    ET.SubElement(trafficaction, &#34;TrafficStopAction&#34;)

    return element</code></pre>
</details>
<div class="desc"><p>Generates an XML element tree representation of the
TrafficStopAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the GlobalAction
with a nested TrafficAction and TrafficStopAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction"><code class="flex name class">
<span>class <span class="ident">TrafficSwarmAction</span></span>
<span>(</span><span>semimajoraxis: float,<br>semiminoraxis: float,<br>innerradius: float,<br>offset: float,<br>numberofvehicles: int,<br>centralobject: str,<br>trafficdefinition: <a title="scenariogeneration.xosc.utils.TrafficDefinition" href="utils.html#scenariogeneration.xosc.utils.TrafficDefinition">TrafficDefinition</a> | <a title="scenariogeneration.xosc.entities.TrafficDistribution" href="entities.html#scenariogeneration.xosc.entities.TrafficDistribution">TrafficDistribution</a>,<br>velocity: float | <a title="scenariogeneration.xosc.parameters.Range" href="parameters.html#scenariogeneration.xosc.parameters.Range">Range</a> | None = None,<br>name: str | None = None,<br>direction_of_travel: <a title="scenariogeneration.xosc.utils.DirectionOfTravelDistribution" href="utils.html#scenariogeneration.xosc.utils.DirectionOfTravelDistribution">DirectionOfTravelDistribution</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSwarmAction(_ActionType):
    &#34;&#34;&#34;The TrafficSwarmAction class creates a TrafficAction of the type
    TrafficSwarmAction.

    Parameters
    ----------
    semimajoraxis : float
        Half length of the major axis of the ellipse around the target.
    semiminoraxis : float
        Half length of the minor axis of the ellipse around the target.
    innerradius : float
        Radius of the inner circle.
    offset : float
        Longitudinal offset from the central entity.
    numberofvehicles : int
        Maximum number of vehicles around the entity.
    centralobject : str
        Entity to swarm around.
    trafficdefinition : TrafficDefinition or TrafficDistribution
        Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3
    velocity : float or Range, optional
        Starting velocity (Range replaces velocity in OSC V1.2).
        Default is None.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1). Default is None.
    direction_of_travel : DirectionOfTravelDistribution, optional
        Adds the DirectionOfTravelDistribution to the action (valid from
        OSC V1.2). Default is None.

    Attributes
    ----------
    semimajoraxis : float
        Half length of the major axis of the ellipse around the target.
    semiminoraxis : float
        Half length of the minor axis of the ellipse around the target.
    innerradius : float
        Radius of the inner circle.
    offset : float
        Longitudinal offset from the central entity.
    numberofvehicles : int
        Maximum number of vehicles around the entity.
    centralobject : str
        Entity to swarm around.
    trafficdefinition : TrafficDefinition or TrafficDistribution
        Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3
    velocity : float or Range, optional
        Starting velocity. Default is None.
    name : str, optional
        Name of the TrafficAction, can be used to stop the TrafficAction
        (valid from V1.1).
    direction_of_travel : DirectionOfTravelDistribution, optional
        Adds the DirectionOfTravelDistribution to the action (valid from
        OSC V1.2).

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(
        self,
        semimajoraxis: float,
        semiminoraxis: float,
        innerradius: float,
        offset: float,
        numberofvehicles: int,
        centralobject: str,
        trafficdefinition: Union[TrafficDefinition, TrafficDistribution],
        velocity: Optional[Union[float, Range]] = None,
        name: Optional[str] = None,
        direction_of_travel: Optional[DirectionOfTravelDistribution] = None,
    ):
        &#34;&#34;&#34;Initialize the TrafficSwarmAction.

        Parameters
        ----------
        semimajoraxis : float
            Half length of the major axis of the ellipse around the target.
        semiminoraxis : float
            Half length of the minor axis of the ellipse around the target.
        innerradius : float
            Radius of the inner circle.
        offset : float
            Longitudinal offset from the central entity.
        numberofvehicles : int
            Maximum number of vehicles around the entity.
        centralobject : str
            Entity to swarm around.
        trafficdefinition : TrafficDefinition or TrafficDistribution
        Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3
        velocity : float, optional
            Starting velocity. Default is None.
        name : str, optional
            Name of the TrafficAction, can be used to stop the TrafficAction
            (valid from V1.1). Default is None.
        direction_of_travel : DirectionOfTravelDistribution, optional
            Adds the DirectionOfTravelDistribution to the action (valid from
            OSC V1.2). Default is None.
        &#34;&#34;&#34;
        self.semimajoraxis = convert_float(semimajoraxis)
        self.semiminoraxis = convert_float(semiminoraxis)
        self.innerradius = convert_float(innerradius)
        self.offset = convert_float(offset)
        self.numberofvehicles = convert_int(numberofvehicles)
        self.centralobject = centralobject
        if not isinstance(
            trafficdefinition, (TrafficDefinition, TrafficDistribution)
        ):
            raise TypeError(
                &#34;trafficdefinition input is not of type TrafficDefinitioon or TrafficDistribution. Should be TrafficDefinition for  version &lt;= v1.2, TrafficDistribution otherwise&#34;
            )
        self.trafficdefinition = trafficdefinition
        if velocity is not None:
            if isinstance(velocity, Range):
                self.velocity = velocity
            else:
                self.velocity = convert_float(velocity)
        else:
            self.velocity = None
        self.name = name
        if direction_of_travel is not None and not isinstance(
            direction_of_travel, DirectionOfTravelDistribution
        ):
            raise TypeError(
                &#34;direction_of_travel is not of type DirectionOfTravelDistribution&#34;
            )
        self.direction_of_travel = direction_of_travel

    def __eq__(self, other: object) -&gt; bool:
        if (
            isinstance(other, TrafficSwarmAction)
            and self.get_attributes() == other.get_attributes()
            and self.centralobject == other.centralobject
            and self.trafficdefinition == other.trafficdefinition
            and self.velocity == other.velocity
            and self.direction_of_travel == other.direction_of_travel
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;TrafficSwarmAction&#34;:
        &#34;&#34;&#34;Parse the XML element of TrafficSwarmAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A TrafficSwarmAction element (same as generated by the class
            itself).

        Returns
        -------
        TrafficSwarmAction
            A TrafficSwarmAction object.
        &#34;&#34;&#34;
        ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = find_mandatory_field(ta_element, &#34;TrafficSwarmAction&#34;)

        innerradius = convert_float(tsa_element.attrib[&#34;innerRadius&#34;])
        numberofvehicles = convert_int(tsa_element.attrib[&#34;numberOfVehicles&#34;])
        offset = convert_float(tsa_element.attrib[&#34;offset&#34;])
        semimajoraxis = convert_float(tsa_element.attrib[&#34;semiMajorAxis&#34;])
        semiminoraxis = convert_float(tsa_element.attrib[&#34;semiMinorAxis&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif tsa_element.find(&#34;InitialSpeedRange&#34;) is not None:
            velocity = Range.parse(
                find_mandatory_field(tsa_element, &#34;InitialSpeedRange&#34;)
            )

        traffic = None
        if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
            traffic = TrafficDefinition.parse(
                find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
            )
        elif tsa_element.find(&#34;TrafficDistribution&#34;) is not None:
            traffic = TrafficDistribution.parse(
                find_mandatory_field(tsa_element, &#34;TrafficDistribution&#34;)
            )

        dot = None
        if tsa_element.find(&#34;DirectionOfTravelDistribution&#34;) is not None:
            dot = DirectionOfTravelDistribution.parse(
                find_mandatory_field(
                    tsa_element, &#34;DirectionOfTravelDistribution&#34;
                )
            )
        central_element = find_mandatory_field(tsa_element, &#34;CentralObject&#34;)
        centralobject = central_element.attrib[&#34;entityRef&#34;]
        tsa_object = TrafficSwarmAction(
            semimajoraxis,
            semiminoraxis,
            innerradius,
            offset,
            numberofvehicles,
            centralobject,
            traffic,
            velocity,
            name,
            dot,
        )
        return tsa_object

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the TrafficSwarmAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            TrafficSwarmAction.
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#34;semiMajorAxis&#34;] = str(self.semimajoraxis)
        retdict[&#34;semiMinorAxis&#34;] = str(self.semiminoraxis)
        retdict[&#34;innerRadius&#34;] = str(self.innerradius)
        retdict[&#34;offset&#34;] = str(self.offset)
        retdict[&#34;numberOfVehicles&#34;] = str(self.numberofvehicles)
        if self.velocity is not None and not isinstance(self.velocity, Range):
            retdict[&#34;velocity&#34;] = str(self.velocity)
        return retdict

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the TrafficSwarmAction.

        Returns
        -------
        ET.Element
            The XML element representing the TrafficSwarmAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=traffic_attrib
        )

        swarmaction = ET.SubElement(
            trafficaction, &#34;TrafficSwarmAction&#34;, attrib=self.get_attributes()
        )

        if isinstance(
            self.trafficdefinition, TrafficDefinition
        ) and self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSourceAction with TrafficDefinition was depricated in OSC 1.3&#34;
            )
        if isinstance(
            self.trafficdefinition, TrafficDistribution
        ) and self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSourceAction with TrafficDistribution was first introduced in OSC 1.3&#34;
            )
        swarmaction.append(self.trafficdefinition.get_element())
        ET.SubElement(
            swarmaction,
            &#34;CentralObject&#34;,
            attrib={&#34;entityRef&#34;: self.centralobject},
        )
        if self.velocity is not None:
            if self.version_minor &gt; 1:
                if isinstance(self.velocity, Range):
                    swarmaction.append(
                        self.velocity.get_element(&#34;InitialSpeedRange&#34;)
                    )
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;Range for TrafficSwarmAction was introduced in &#34;
                        &#34;OSC V1.2, velocity should not be used anymore.&#34;
                    )

        if self.direction_of_travel is not None:
            if self.version_minor &lt; 2:
                raise OpenSCENARIOVersionError(
                    &#34;DirectionOfTravelDistribution was added in OSC V1.2&#34;
                )
            swarmaction.append(self.direction_of_travel.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>The TrafficSwarmAction class creates a TrafficAction of the type
TrafficSwarmAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>semimajoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the major axis of the ellipse around the target.</dd>
<dt><strong><code>semiminoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the minor axis of the ellipse around the target.</dd>
<dt><strong><code>innerradius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the inner circle.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitudinal offset from the central entity.</dd>
<dt><strong><code>numberofvehicles</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of vehicles around the entity.</dd>
<dt><strong><code>centralobject</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to swarm around.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code> or <code>TrafficDistribution</code></dt>
<dd>Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code> or <code>Range</code>, optional</dt>
<dd>Starting velocity (Range replaces velocity in OSC V1.2).
Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
<dt><strong><code>direction_of_travel</code></strong> :&ensp;<code>DirectionOfTravelDistribution</code>, optional</dt>
<dd>Adds the DirectionOfTravelDistribution to the action (valid from
OSC V1.2). Default is None.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>semimajoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the major axis of the ellipse around the target.</dd>
<dt><strong><code>semiminoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the minor axis of the ellipse around the target.</dd>
<dt><strong><code>innerradius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the inner circle.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitudinal offset from the central entity.</dd>
<dt><strong><code>numberofvehicles</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of vehicles around the entity.</dd>
<dt><strong><code>centralobject</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to swarm around.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code> or <code>TrafficDistribution</code></dt>
<dd>Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code> or <code>Range</code>, optional</dt>
<dd>Starting velocity. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1).</dd>
<dt><strong><code>direction_of_travel</code></strong> :&ensp;<code>DirectionOfTravelDistribution</code>, optional</dt>
<dd>Adds the DirectionOfTravelDistribution to the action (valid from
OSC V1.2).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the TrafficSwarmAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>semimajoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the major axis of the ellipse around the target.</dd>
<dt><strong><code>semiminoraxis</code></strong> :&ensp;<code>float</code></dt>
<dd>Half length of the minor axis of the ellipse around the target.</dd>
<dt><strong><code>innerradius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the inner circle.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitudinal offset from the central entity.</dd>
<dt><strong><code>numberofvehicles</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of vehicles around the entity.</dd>
<dt><strong><code>centralobject</code></strong> :&ensp;<code>str</code></dt>
<dd>Entity to swarm around.</dd>
<dt><strong><code>trafficdefinition</code></strong> :&ensp;<code>TrafficDefinition</code> or <code>TrafficDistribution</code></dt>
<dd>&nbsp;</dd>
<dt>Definition of the traffic. TrafficDistribution replace TrafficDefinition from V1.3</dt>
<dt><strong><code>velocity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Starting velocity. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the TrafficAction, can be used to stop the TrafficAction
(valid from V1.1). Default is None.</dd>
<dt><strong><code>direction_of_travel</code></strong> :&ensp;<code>DirectionOfTravelDistribution</code>, optional</dt>
<dd>Adds the DirectionOfTravelDistribution to the action (valid from
OSC V1.2). Default is None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.TrafficSwarmAction" href="#scenariogeneration.xosc.actions.TrafficSwarmAction">TrafficSwarmAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;TrafficSwarmAction&#34;:
    &#34;&#34;&#34;Parse the XML element of TrafficSwarmAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A TrafficSwarmAction element (same as generated by the class
        itself).

    Returns
    -------
    TrafficSwarmAction
        A TrafficSwarmAction object.
    &#34;&#34;&#34;
    ta_element = find_mandatory_field(element, &#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]

    tsa_element = find_mandatory_field(ta_element, &#34;TrafficSwarmAction&#34;)

    innerradius = convert_float(tsa_element.attrib[&#34;innerRadius&#34;])
    numberofvehicles = convert_int(tsa_element.attrib[&#34;numberOfVehicles&#34;])
    offset = convert_float(tsa_element.attrib[&#34;offset&#34;])
    semimajoraxis = convert_float(tsa_element.attrib[&#34;semiMajorAxis&#34;])
    semiminoraxis = convert_float(tsa_element.attrib[&#34;semiMinorAxis&#34;])
    velocity = None
    if &#34;velocity&#34; in tsa_element.attrib:
        velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
    elif tsa_element.find(&#34;InitialSpeedRange&#34;) is not None:
        velocity = Range.parse(
            find_mandatory_field(tsa_element, &#34;InitialSpeedRange&#34;)
        )

    traffic = None
    if tsa_element.find(&#34;TrafficDefinition&#34;) is not None:
        traffic = TrafficDefinition.parse(
            find_mandatory_field(tsa_element, &#34;TrafficDefinition&#34;)
        )
    elif tsa_element.find(&#34;TrafficDistribution&#34;) is not None:
        traffic = TrafficDistribution.parse(
            find_mandatory_field(tsa_element, &#34;TrafficDistribution&#34;)
        )

    dot = None
    if tsa_element.find(&#34;DirectionOfTravelDistribution&#34;) is not None:
        dot = DirectionOfTravelDistribution.parse(
            find_mandatory_field(
                tsa_element, &#34;DirectionOfTravelDistribution&#34;
            )
        )
    central_element = find_mandatory_field(tsa_element, &#34;CentralObject&#34;)
    centralobject = central_element.attrib[&#34;entityRef&#34;]
    tsa_object = TrafficSwarmAction(
        semimajoraxis,
        semiminoraxis,
        innerradius,
        offset,
        numberofvehicles,
        centralobject,
        traffic,
        velocity,
        name,
        dot,
    )
    return tsa_object</code></pre>
</details>
<div class="desc"><p>Parse the XML element of TrafficSwarmAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A TrafficSwarmAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction" href="#scenariogeneration.xosc.actions.TrafficSwarmAction">TrafficSwarmAction</a></code></dt>
<dd>A TrafficSwarmAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the TrafficSwarmAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        TrafficSwarmAction.
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#34;semiMajorAxis&#34;] = str(self.semimajoraxis)
    retdict[&#34;semiMinorAxis&#34;] = str(self.semiminoraxis)
    retdict[&#34;innerRadius&#34;] = str(self.innerradius)
    retdict[&#34;offset&#34;] = str(self.offset)
    retdict[&#34;numberOfVehicles&#34;] = str(self.numberofvehicles)
    if self.velocity is not None and not isinstance(self.velocity, Range):
        retdict[&#34;velocity&#34;] = str(self.velocity)
    return retdict</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the TrafficSwarmAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
TrafficSwarmAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the TrafficSwarmAction.

    Returns
    -------
    ET.Element
        The XML element representing the TrafficSwarmAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}
    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=traffic_attrib
    )

    swarmaction = ET.SubElement(
        trafficaction, &#34;TrafficSwarmAction&#34;, attrib=self.get_attributes()
    )

    if isinstance(
        self.trafficdefinition, TrafficDefinition
    ) and self.isVersionEqLarger(minor=3):
        raise OpenSCENARIOVersionError(
            &#34;TrafficSourceAction with TrafficDefinition was depricated in OSC 1.3&#34;
        )
    if isinstance(
        self.trafficdefinition, TrafficDistribution
    ) and self.isVersionEqLess(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;TrafficSourceAction with TrafficDistribution was first introduced in OSC 1.3&#34;
        )
    swarmaction.append(self.trafficdefinition.get_element())
    ET.SubElement(
        swarmaction,
        &#34;CentralObject&#34;,
        attrib={&#34;entityRef&#34;: self.centralobject},
    )
    if self.velocity is not None:
        if self.version_minor &gt; 1:
            if isinstance(self.velocity, Range):
                swarmaction.append(
                    self.velocity.get_element(&#34;InitialSpeedRange&#34;)
                )
            else:
                raise OpenSCENARIOVersionError(
                    &#34;Range for TrafficSwarmAction was introduced in &#34;
                    &#34;OSC V1.2, velocity should not be used anymore.&#34;
                )

    if self.direction_of_travel is not None:
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;DirectionOfTravelDistribution was added in OSC V1.2&#34;
            )
        swarmaction.append(self.direction_of_travel.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the TrafficSwarmAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the TrafficSwarmAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction"><code class="flex name class">
<span>class <span class="ident">UserDefinedAction</span></span>
<span>(</span><span>custom_command_action: <a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedAction(_ActionType):
    &#34;&#34;&#34;The UserDefinedAction enables adding simulator-specific
    CustomCommandActions.

    Methods
    -------
    add_custom_command_action(custom_command_action)
        Adds a CustomCommandAction to the UserDefinedAction.
    get_element()
        Returns the full ElementTree of the class.
    &#34;&#34;&#34;

    def __init__(self, custom_command_action: CustomCommandAction):
        &#34;&#34;&#34;Initialize the UserDefinedAction.

        Parameters
        ----------
        custom_command_action : CustomCommandAction
            The custom command action to be added.
        &#34;&#34;&#34;
        self.custom_command_action = custom_command_action

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, UserDefinedAction):
            if self.custom_command_action == other.custom_command_action:
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;UserDefinedAction&#34;:
        &#34;&#34;&#34;Parses the XML element of a UserDefinedAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A UserDefinedAction element.

        Returns
        -------
        UserDefinedAction
            A UserDefinedAction object.
        &#34;&#34;&#34;
        custom_command_action = CustomCommandAction.parse(
            find_mandatory_field(element, &#34;CustomCommandAction&#34;)
        )
        user_defined_action = UserDefinedAction(custom_command_action)
        return user_defined_action

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Generate an ElementTree representation of the UserDefinedAction.

        Returns
        -------
        xml.etree.ElementTree.Element
            The root XML element representing the UserDefinedAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;UserDefinedAction&#34;)
        element.append(self.custom_command_action.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The UserDefinedAction enables adding simulator-specific
CustomCommandActions.</p>
<h2 id="methods">Methods</h2>
<p>add_custom_command_action(custom_command_action)
Adds a CustomCommandAction to the UserDefinedAction.
get_element()
Returns the full ElementTree of the class.</p>
<p>Initialize the UserDefinedAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>custom_command_action</code></strong> :&ensp;<code><a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></code></dt>
<dd>The custom command action to be added.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.UserDefinedAction" href="#scenariogeneration.xosc.actions.UserDefinedAction">UserDefinedAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;UserDefinedAction&#34;:
    &#34;&#34;&#34;Parses the XML element of a UserDefinedAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A UserDefinedAction element.

    Returns
    -------
    UserDefinedAction
        A UserDefinedAction object.
    &#34;&#34;&#34;
    custom_command_action = CustomCommandAction.parse(
        find_mandatory_field(element, &#34;CustomCommandAction&#34;)
    )
    user_defined_action = UserDefinedAction(custom_command_action)
    return user_defined_action</code></pre>
</details>
<div class="desc"><p>Parses the XML element of a UserDefinedAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A UserDefinedAction element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.UserDefinedAction" href="#scenariogeneration.xosc.actions.UserDefinedAction">UserDefinedAction</a></code></dt>
<dd>A UserDefinedAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Generate an ElementTree representation of the UserDefinedAction.

    Returns
    -------
    xml.etree.ElementTree.Element
        The root XML element representing the UserDefinedAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;UserDefinedAction&#34;)
    element.append(self.custom_command_action.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>Generate an ElementTree representation of the UserDefinedAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The root XML element representing the UserDefinedAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableAddAction"><code class="flex name class">
<span>class <span class="ident">VariableAddAction</span></span>
<span>(</span><span>variable_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableAddAction(_ActionType):
    &#34;&#34;&#34;The VariableAddAction class creates a VariableAction of type
    VariableModifyAction which adds a value to an existing Variable (valid from
    V1.2).

    Parameters
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be added to the variable.

    Attributes
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be added to the variable.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, variable_ref: str, value: float):
        &#34;&#34;&#34;Initialize the VariableAddAction.

        Parameters
        ----------
        variable_ref : str
            Name of the variable.
        value : float
            The value that should be added to the variable.
        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, VariableAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;VariableAddAction&#34;:
        &#34;&#34;&#34;Parses the XML element of VariableAddAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A VariableAddAction element (same as generated by the class
            itself).

        Returns
        -------
        VariableAddAction
            A VariableAddAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
        rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
        mbv_element = find_mandatory_field(rule_element, &#34;AddValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableAddAction(variableRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the AbsoluteSpeedAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            AbsoluteSpeedAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the AbsoluteSpeedAction.

        Returns
        -------
        ET.Element
            The XML element representing the AbsoluteSpeedAction.
        &#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;VariableActions were added in OSC 1.2&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The VariableAddAction class creates a VariableAction of type
VariableModifyAction which adds a value to an existing Variable (valid from
V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the variable.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the variable.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the VariableAddAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the variable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.VariableAddAction" href="#scenariogeneration.xosc.actions.VariableAddAction">VariableAddAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;VariableAddAction&#34;:
    &#34;&#34;&#34;Parses the XML element of VariableAddAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A VariableAddAction element (same as generated by the class
        itself).

    Returns
    -------
    VariableAddAction
        A VariableAddAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]

    ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
    rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
    mbv_element = find_mandatory_field(rule_element, &#34;AddValue&#34;)
    value = mbv_element.attrib[&#34;value&#34;]

    return VariableAddAction(variableRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of VariableAddAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A VariableAddAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.VariableAddAction" href="#scenariogeneration.xosc.actions.VariableAddAction">VariableAddAction</a></code></dt>
<dd>A VariableAddAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the AbsoluteSpeedAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        AbsoluteSpeedAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the AbsoluteSpeedAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
AbsoluteSpeedAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the AbsoluteSpeedAction.

    Returns
    -------
    ET.Element
        The XML element representing the AbsoluteSpeedAction.
    &#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(
            &#34;VariableActions were added in OSC 1.2&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the AbsoluteSpeedAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the AbsoluteSpeedAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction"><code class="flex name class">
<span>class <span class="ident">VariableMultiplyAction</span></span>
<span>(</span><span>variable_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableMultiplyAction(_ActionType):
    &#34;&#34;&#34;The VariableMultiplyAction class creates a VariableAction of type
    VariableModifyAction which multiplies a value to an existing Variable
    (valid from V1.2).

    Parameters
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be multiplied to the variable.

    Attributes
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be multiplied to the variable.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, variable_ref: str, value: float):
        &#34;&#34;&#34;Initialize the VariableMultiplyAction.

        Parameters
        ----------
        variable_ref : str
            Name of the variable.
        value : float
            The value that should be added to the variable.
        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, VariableMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;VariableMultiplyAction&#34;:
        &#34;&#34;&#34;Parses the XML element of VariableMultiplyAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A VariableMultiplyAction element (same as generated by the
            class itself).

        Returns
        -------
        VariableMultiplyAction
            A VariableMultiplyAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
        rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
        mbv_element = find_mandatory_field(rule_element, &#34;MultiplyByValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableMultiplyAction(variableRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the VariableMultiplyAction as a dict.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            VariableMultiplyAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the VariableMultiplyAction.&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;VariableActions were added in OSC 1.2&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The VariableMultiplyAction class creates a VariableAction of type
VariableModifyAction which multiplies a value to an existing Variable
(valid from V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be multiplied to the variable.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be multiplied to the variable.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the VariableMultiplyAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the variable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.VariableMultiplyAction" href="#scenariogeneration.xosc.actions.VariableMultiplyAction">VariableMultiplyAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;VariableMultiplyAction&#34;:
    &#34;&#34;&#34;Parses the XML element of VariableMultiplyAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A VariableMultiplyAction element (same as generated by the
        class itself).

    Returns
    -------
    VariableMultiplyAction
        A VariableMultiplyAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]

    ma_element = find_mandatory_field(pa_element, &#34;ModifyAction&#34;)
    rule_element = find_mandatory_field(ma_element, &#34;Rule&#34;)
    mbv_element = find_mandatory_field(rule_element, &#34;MultiplyByValue&#34;)
    value = mbv_element.attrib[&#34;value&#34;]

    return VariableMultiplyAction(variableRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of VariableMultiplyAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A VariableMultiplyAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction" href="#scenariogeneration.xosc.actions.VariableMultiplyAction">VariableMultiplyAction</a></code></dt>
<dd>A VariableMultiplyAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the VariableMultiplyAction as a dict.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        VariableMultiplyAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the VariableMultiplyAction as a dict.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
VariableMultiplyAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the VariableMultiplyAction.&#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(
            &#34;VariableActions were added in OSC 1.2&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the VariableMultiplyAction.</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableSetAction"><code class="flex name class">
<span>class <span class="ident">VariableSetAction</span></span>
<span>(</span><span>variable_ref: str, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableSetAction(_ActionType):
    &#34;&#34;&#34;The VariableSetAction class creates a VariableAction which sets a value
    to an existing Variable (valid from V1.2).

    Parameters
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be set to the variable.

    Attributes
    ----------
    variable_ref : str
        Name of the variable.
    value : float
        The value that should be set to the variable.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, variable_ref: str, value: float):
        &#34;&#34;&#34;Initialize the VariableSetAction.

        Parameters
        ----------
        variable_ref : str
            Name of the variable.
        value : float
            The value that should be added to the variable.
        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, VariableSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;VariableSetAction&#34;:
        &#34;&#34;&#34;Parses the XML element of VariableSetAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A VariableSetAction element (same as generated by the class
            itself).

        Returns
        -------
        VariableSetAction
            A VariableSetAction object.
        &#34;&#34;&#34;
        pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]
        psa_element = find_mandatory_field(pa_element, &#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        return VariableSetAction(variableRef, value)

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the VariableSetAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            VariableSetAction.
        &#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the VariableSetAction.

        Returns
        -------
        ET.Element
            The XML element representing the VariableSetAction.
        &#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;VariableActions were added in OSC 1.2&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>The VariableSetAction class creates a VariableAction which sets a value
to an existing Variable (valid from V1.2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be set to the variable.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be set to the variable.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element)
Parses an ElementTree created by the class and returns an
instance of the class.
get_element()
Returns the full ElementTree of the class.
get_attributes()
Returns a dictionary of all attributes of the class.</p>
<p>Initialize the VariableSetAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>variable_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that should be added to the variable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.VariableSetAction" href="#scenariogeneration.xosc.actions.VariableSetAction">VariableSetAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;VariableSetAction&#34;:
    &#34;&#34;&#34;Parses the XML element of VariableSetAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A VariableSetAction element (same as generated by the class
        itself).

    Returns
    -------
    VariableSetAction
        A VariableSetAction object.
    &#34;&#34;&#34;
    pa_element = find_mandatory_field(element, &#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]
    psa_element = find_mandatory_field(pa_element, &#34;SetAction&#34;)
    value = psa_element.attrib[&#34;value&#34;]
    return VariableSetAction(variableRef, value)</code></pre>
</details>
<div class="desc"><p>Parses the XML element of VariableSetAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A VariableSetAction element (same as generated by the class
itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.VariableSetAction" href="#scenariogeneration.xosc.actions.VariableSetAction">VariableSetAction</a></code></dt>
<dd>A VariableSetAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the VariableSetAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        VariableSetAction.
    &#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the VariableSetAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
VariableSetAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the VariableSetAction.

    Returns
    -------
    ET.Element
        The XML element representing the VariableSetAction.
    &#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(
            &#34;VariableActions were added in OSC 1.2&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the VariableSetAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the VariableSetAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction"><code class="flex name class">
<span>class <span class="ident">VisibilityAction</span></span>
<span>(</span><span>graphics: bool, traffic: bool, sensors: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisibilityAction(_PrivateActionType):
    &#34;&#34;&#34;Creates a VisibilityAction.

    Parameters
    ----------
    graphics : bool
        Visible for graphics or not.
    traffic : bool
        Visible for traffic.
    sensors : bool
        Visible to sensors or not.

    Attributes
    ----------
    graphics : bool
        Visible for graphics or not.
    traffic : bool
        Visible for traffic.
    sensors : bool
        Visible to sensors or not.
    sensor_refs : list of str
        All sensor references.

    Methods
    -------
    parse(element : xml.etree.ElementTree.Element) -&gt; VisibilityAction
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element() -&gt; xml.etree.ElementTree.Element
        Returns the full ElementTree of the class.
    get_attributes() -&gt; dict
        Returns the attributes of the class.
    &#34;&#34;&#34;

    def __init__(self, graphics: bool, traffic: bool, sensors: bool):
        &#34;&#34;&#34;Initializes the VisibilityAction.

        Parameters
        ----------
        graphics : bool
            Visible for graphics or not.
        traffic : bool
            Visible for traffic.
        sensors : bool
            Visible to sensors or not.
        &#34;&#34;&#34;
        self.graphics = convert_bool(graphics)
        self.traffic = convert_bool(traffic)
        self.sensors = convert_bool(sensors)
        self.sensor_refs = []

    def __eq__(self, other: object) -&gt; bool:
        if isinstance(other, VisibilityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.sensor_refs == other.sensor_refs
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -&gt; &#34;VisibilityAction&#34;:
        &#34;&#34;&#34;Parses the XML element of VisibilityAction.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A VisibilityAction element (same as generated by the
            class itself).

        Returns
        -------
        VisibilityAction
            A VisibilityAction object.
        &#34;&#34;&#34;
        va_element = find_mandatory_field(element, &#34;VisibilityAction&#34;)
        graphics = convert_bool(va_element.attrib[&#34;graphics&#34;])
        traffic = convert_bool(va_element.attrib[&#34;traffic&#34;])
        sensors = convert_bool(va_element.attrib[&#34;sensors&#34;])
        visibility_action = VisibilityAction(graphics, traffic, sensors)
        sensor_ref_element = va_element.find(&#34;SensorReferenceSet&#34;)
        if sensor_ref_element is not None:
            for sensor_element in sensor_ref_element.findall(
                &#34;SensorReference&#34;
            ):
                visibility_action.add_sensor_reference(
                    sensor_element.attrib[&#34;name&#34;]
                )
        return visibility_action

    def add_sensor_reference(self, sensor_ref: str):
        &#34;&#34;&#34;Adds a sensor reference to the visibility action.

        Parameters
        ----------
        sensor_ref : str
            Name of a sensor.

        Returns
        -------
        VisibilityAction
            The updated VisibilityAction instance.
        &#34;&#34;&#34;
        self.sensor_refs.append(sensor_ref)
        return self

    def get_attributes(self) -&gt; dict:
        &#34;&#34;&#34;Returns the attributes of the VisibilityAction as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the
            VisibilityAction.
        &#34;&#34;&#34;
        return {
            &#34;graphics&#34;: get_bool_string(self.graphics),
            &#34;traffic&#34;: get_bool_string(self.traffic),
            &#34;sensors&#34;: get_bool_string(self.sensors),
        }

    def get_element(self) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the elementTree of the VisibilityAction.

        Returns
        -------
        ET.Element
            The XML element representing the VisibilityAction.
        &#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        visibility_element = ET.SubElement(
            element, &#34;VisibilityAction&#34;, self.get_attributes()
        )
        if self.sensor_refs:
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(
                    &#34;SensorReference was added in OSC V1.2&#34;
                )
            sensor_ref_element = ET.SubElement(
                visibility_element, &#34;SensorReferenceSet&#34;
            )
            for sensor in self.sensor_refs:
                ET.SubElement(
                    sensor_ref_element,
                    &#34;SensorReference&#34;,
                    {&#34;name&#34;: str(sensor)},
                )
        return element</code></pre>
</details>
<div class="desc"><p>Creates a VisibilityAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graphics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for graphics or not.</dd>
<dt><strong><code>traffic</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for traffic.</dd>
<dt><strong><code>sensors</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible to sensors or not.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>graphics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for graphics or not.</dd>
<dt><strong><code>traffic</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for traffic.</dd>
<dt><strong><code>sensors</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible to sensors or not.</dd>
<dt><strong><code>sensor_refs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>All sensor references.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>parse(element : xml.etree.ElementTree.Element) -&gt; VisibilityAction
Parses an ElementTree created by the class and returns an
instance of the class.
get_element() -&gt; xml.etree.ElementTree.Element
Returns the full ElementTree of the class.
get_attributes() -&gt; dict
Returns the attributes of the class.</p>
<p>Initializes the VisibilityAction.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>graphics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for graphics or not.</dd>
<dt><strong><code>traffic</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible for traffic.</dd>
<dt><strong><code>sensors</code></strong> :&ensp;<code>bool</code></dt>
<dd>Visible to sensors or not.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element: xml.etree.ElementTree.Element) ‑> <a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element: ET.Element) -&gt; &#34;VisibilityAction&#34;:
    &#34;&#34;&#34;Parses the XML element of VisibilityAction.

    Parameters
    ----------
    element : xml.etree.ElementTree.Element
        A VisibilityAction element (same as generated by the
        class itself).

    Returns
    -------
    VisibilityAction
        A VisibilityAction object.
    &#34;&#34;&#34;
    va_element = find_mandatory_field(element, &#34;VisibilityAction&#34;)
    graphics = convert_bool(va_element.attrib[&#34;graphics&#34;])
    traffic = convert_bool(va_element.attrib[&#34;traffic&#34;])
    sensors = convert_bool(va_element.attrib[&#34;sensors&#34;])
    visibility_action = VisibilityAction(graphics, traffic, sensors)
    sensor_ref_element = va_element.find(&#34;SensorReferenceSet&#34;)
    if sensor_ref_element is not None:
        for sensor_element in sensor_ref_element.findall(
            &#34;SensorReference&#34;
        ):
            visibility_action.add_sensor_reference(
                sensor_element.attrib[&#34;name&#34;]
            )
    return visibility_action</code></pre>
</details>
<div class="desc"><p>Parses the XML element of VisibilityAction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element</code></strong> :&ensp;<code>xml.etree.ElementTree.Element</code></dt>
<dd>A VisibilityAction element (same as generated by the
class itself).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></code></dt>
<dd>A VisibilityAction object.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference"><code class="name flex">
<span>def <span class="ident">add_sensor_reference</span></span>(<span>self, sensor_ref: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sensor_reference(self, sensor_ref: str):
    &#34;&#34;&#34;Adds a sensor reference to the visibility action.

    Parameters
    ----------
    sensor_ref : str
        Name of a sensor.

    Returns
    -------
    VisibilityAction
        The updated VisibilityAction instance.
    &#34;&#34;&#34;
    self.sensor_refs.append(sensor_ref)
    return self</code></pre>
</details>
<div class="desc"><p>Adds a sensor reference to the visibility action.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sensor_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of a sensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></code></dt>
<dd>The updated VisibilityAction instance.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self) -&gt; dict:
    &#34;&#34;&#34;Returns the attributes of the VisibilityAction as a dictionary.

    Returns
    -------
    dict
        A dictionary containing the attributes of the
        VisibilityAction.
    &#34;&#34;&#34;
    return {
        &#34;graphics&#34;: get_bool_string(self.graphics),
        &#34;traffic&#34;: get_bool_string(self.traffic),
        &#34;sensors&#34;: get_bool_string(self.sensors),
    }</code></pre>
</details>
<div class="desc"><p>Returns the attributes of the VisibilityAction as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the
VisibilityAction.</dd>
</dl></div>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self) ‑> xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the elementTree of the VisibilityAction.

    Returns
    -------
    ET.Element
        The XML element representing the VisibilityAction.
    &#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    visibility_element = ET.SubElement(
        element, &#34;VisibilityAction&#34;, self.get_attributes()
    )
    if self.sensor_refs:
        if self.isVersionEqLess(minor=1):
            raise OpenSCENARIOVersionError(
                &#34;SensorReference was added in OSC V1.2&#34;
            )
        sensor_ref_element = ET.SubElement(
            visibility_element, &#34;SensorReferenceSet&#34;
        )
        for sensor in self.sensor_refs:
            ET.SubElement(
                sensor_ref_element,
                &#34;SensorReference&#34;,
                {&#34;name&#34;: str(sensor)},
            )
    return element</code></pre>
</details>
<div class="desc"><p>Returns the elementTree of the VisibilityAction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.Element</code></dt>
<dd>The XML element representing the VisibilityAction.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction">AbsoluteSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction" href="#scenariogeneration.xosc.actions.AcquirePositionAction">AcquirePositionAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction.get_element" href="#scenariogeneration.xosc.actions.AcquirePositionAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction.parse" href="#scenariogeneration.xosc.actions.AcquirePositionAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_element" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.parse" href="#scenariogeneration.xosc.actions.ActivateControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AddEntityAction" href="#scenariogeneration.xosc.actions.AddEntityAction">AddEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.AddEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_element" href="#scenariogeneration.xosc.actions.AddEntityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.parse" href="#scenariogeneration.xosc.actions.AddEntityAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AnimationAction" href="#scenariogeneration.xosc.actions.AnimationAction">AnimationAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.get_attributes" href="#scenariogeneration.xosc.actions.AnimationAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.get_element" href="#scenariogeneration.xosc.actions.AnimationAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.parse" href="#scenariogeneration.xosc.actions.AnimationAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_element" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.parse" href="#scenariogeneration.xosc.actions.AssignControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignRouteAction" href="#scenariogeneration.xosc.actions.AssignRouteAction">AssignRouteAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignRouteAction.get_element" href="#scenariogeneration.xosc.actions.AssignRouteAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignRouteAction.parse" href="#scenariogeneration.xosc.actions.AssignRouteAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ConnectTrailerAction" href="#scenariogeneration.xosc.actions.ConnectTrailerAction">ConnectTrailerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ConnectTrailerAction.get_attributes" href="#scenariogeneration.xosc.actions.ConnectTrailerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ConnectTrailerAction.get_element" href="#scenariogeneration.xosc.actions.ConnectTrailerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ConnectTrailerAction.parse" href="#scenariogeneration.xosc.actions.ConnectTrailerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ControllerAction" href="#scenariogeneration.xosc.actions.ControllerAction">ControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ControllerAction.get_element" href="#scenariogeneration.xosc.actions.ControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ControllerAction.parse" href="#scenariogeneration.xosc.actions.ControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.get_element" href="#scenariogeneration.xosc.actions.CustomCommandAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.parse" href="#scenariogeneration.xosc.actions.CustomCommandAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction" href="#scenariogeneration.xosc.actions.DeleteEntityAction">DeleteEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_element" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.parse" href="#scenariogeneration.xosc.actions.DeleteEntityAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.DisconnectTrailerAction" href="#scenariogeneration.xosc.actions.DisconnectTrailerAction">DisconnectTrailerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.DisconnectTrailerAction.get_element" href="#scenariogeneration.xosc.actions.DisconnectTrailerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DisconnectTrailerAction.parse" href="#scenariogeneration.xosc.actions.DisconnectTrailerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.EnvironmentAction" href="#scenariogeneration.xosc.actions.EnvironmentAction">EnvironmentAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.get_element" href="#scenariogeneration.xosc.actions.EnvironmentAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.parse" href="#scenariogeneration.xosc.actions.EnvironmentAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction">FollowTrajectoryAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.parse" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction" href="#scenariogeneration.xosc.actions.LateralDistanceAction">LateralDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.parse" href="#scenariogeneration.xosc.actions.LateralDistanceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LightStateAction" href="#scenariogeneration.xosc.actions.LightStateAction">LightStateAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.get_attributes" href="#scenariogeneration.xosc.actions.LightStateAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.get_element" href="#scenariogeneration.xosc.actions.LightStateAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.parse" href="#scenariogeneration.xosc.actions.LightStateAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction">LongitudinalDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ObjectController" href="#scenariogeneration.xosc.actions.ObjectController">ObjectController</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ObjectController.get_attributes" href="#scenariogeneration.xosc.actions.ObjectController.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ObjectController.get_element" href="#scenariogeneration.xosc.actions.ObjectController.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ObjectController.parse" href="#scenariogeneration.xosc.actions.ObjectController.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.parse" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.parse">parse</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake">set_brake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch">set_clutch</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear">set_gear</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake">set_parkingbrake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel">set_steeringwheel</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle">set_throttle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterAddAction" href="#scenariogeneration.xosc.actions.ParameterAddAction">ParameterAddAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_element" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.parse" href="#scenariogeneration.xosc.actions.ParameterAddAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction">ParameterMultiplyAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.parse" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterSetAction" href="#scenariogeneration.xosc.actions.ParameterSetAction">ParameterSetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_element" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.parse" href="#scenariogeneration.xosc.actions.ParameterSetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RandomRouteAction" href="#scenariogeneration.xosc.actions.RandomRouteAction">RandomRouteAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RandomRouteAction.get_element" href="#scenariogeneration.xosc.actions.RandomRouteAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RandomRouteAction.parse" href="#scenariogeneration.xosc.actions.RandomRouteAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction">RelativeLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction">RelativeLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction" href="#scenariogeneration.xosc.actions.RelativeSpeedAction">RelativeSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.parse" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SetMonitorAction" href="#scenariogeneration.xosc.actions.SetMonitorAction">SetMonitorAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SetMonitorAction.get_attributes" href="#scenariogeneration.xosc.actions.SetMonitorAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SetMonitorAction.get_element" href="#scenariogeneration.xosc.actions.SetMonitorAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SetMonitorAction.parse" href="#scenariogeneration.xosc.actions.SetMonitorAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction" href="#scenariogeneration.xosc.actions.SpeedProfileAction">SpeedProfileAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes" href="#scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.get_element" href="#scenariogeneration.xosc.actions.SpeedProfileAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.parse" href="#scenariogeneration.xosc.actions.SpeedProfileAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SynchronizeAction" href="#scenariogeneration.xosc.actions.SynchronizeAction">SynchronizeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_element" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.parse" href="#scenariogeneration.xosc.actions.SynchronizeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TeleportAction" href="#scenariogeneration.xosc.actions.TeleportAction">TeleportAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TeleportAction.get_element" href="#scenariogeneration.xosc.actions.TeleportAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TeleportAction.parse" href="#scenariogeneration.xosc.actions.TeleportAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficAreaAction" href="#scenariogeneration.xosc.actions.TrafficAreaAction">TrafficAreaAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficAreaAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficAreaAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficAreaAction.get_element" href="#scenariogeneration.xosc.actions.TrafficAreaAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficAreaAction.parse" href="#scenariogeneration.xosc.actions.TrafficAreaAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction">TrafficSignalControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction">TrafficSignalStateAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.parse" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction" href="#scenariogeneration.xosc.actions.TrafficSinkAction">TrafficSinkAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.parse" href="#scenariogeneration.xosc.actions.TrafficSinkAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction" href="#scenariogeneration.xosc.actions.TrafficSourceAction">TrafficSourceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.parse" href="#scenariogeneration.xosc.actions.TrafficSourceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficStopAction" href="#scenariogeneration.xosc.actions.TrafficStopAction">TrafficStopAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_element" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.parse" href="#scenariogeneration.xosc.actions.TrafficStopAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction" href="#scenariogeneration.xosc.actions.TrafficSwarmAction">TrafficSwarmAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.parse" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.UserDefinedAction" href="#scenariogeneration.xosc.actions.UserDefinedAction">UserDefinedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.UserDefinedAction.get_element" href="#scenariogeneration.xosc.actions.UserDefinedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.UserDefinedAction.parse" href="#scenariogeneration.xosc.actions.UserDefinedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableAddAction" href="#scenariogeneration.xosc.actions.VariableAddAction">VariableAddAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableAddAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.get_element" href="#scenariogeneration.xosc.actions.VariableAddAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.parse" href="#scenariogeneration.xosc.actions.VariableAddAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction" href="#scenariogeneration.xosc.actions.VariableMultiplyAction">VariableMultiplyAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.get_element" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.parse" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableSetAction" href="#scenariogeneration.xosc.actions.VariableSetAction">VariableSetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableSetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.get_element" href="#scenariogeneration.xosc.actions.VariableSetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.parse" href="#scenariogeneration.xosc.actions.VariableSetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference" href="#scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference">add_sensor_reference</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_attributes" href="#scenariogeneration.xosc.actions.VisibilityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_element" href="#scenariogeneration.xosc.actions.VisibilityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.parse" href="#scenariogeneration.xosc.actions.VisibilityAction.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
