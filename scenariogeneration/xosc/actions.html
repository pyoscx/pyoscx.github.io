<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>scenariogeneration.xosc.actions API documentation</title>
<meta name="description" content="the actions module contains the actions defined OpenSCENARIO" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.actions</code></h1>
</header>
<section id="section-intro">
<p>the actions module contains the actions defined OpenSCENARIO</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; the actions module contains the actions defined OpenSCENARIO

&#34;&#34;&#34;
import xml.etree.ElementTree as ET

from numpy.lib.function_base import disp

from .utils import DynamicsConstrains, TimeReference, convert_bool, TransitionDynamics, CatalogReference, Route, Trajectory, TrafficDefinition, Environment, AbsoluteSpeed, RelativeSpeedToMaster
from .utils import Controller
from .enumerations import CoordinateSystem, DynamicsShapes, LateralDisplacement, SpeedTargetValueType, FollowMode, ReferenceContext, VersionBase, LongitudinalDisplacement
from .exceptions import NoActionsDefinedError, OpenSCENARIOVersionError
from .position import _PositionType



class _ActionType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass
class _PrivateActionType(_ActionType):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass
class _Action(VersionBase):
    &#34;&#34;&#34; Private class used to define an action, should not be used by the user.
        Used as a wrapper to create the extra elements needed
        
        Parameters
        ----------
            name (str): name of the action

            action (*Action): any action

        Attributes
        ----------
            name (str): name of the action

            action (*Action): any action

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    
    &#34;&#34;&#34;

    def __init__(self,name,action):
        &#34;&#34;&#34; initalize _Action

        Parameters
        ----------
            name (str): name of the action

            action (*Action): any action

        &#34;&#34;&#34;
        self.name = name
        
        self.action = action

    def __eq__(self,other):
        if isinstance(other,_Action):
            if self.get_attributes() == other.get_attributes() and self.action == other.action:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the _Action as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name}
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the _Action

        &#34;&#34;&#34;
        element = ET.Element(&#39;Action&#39;,attrib=self.get_attributes())
        element.append(self.action.get_element())
        return element


#### Private Actions ####

#LongitudinalAction

class AbsoluteSpeedAction(_PrivateActionType):
    &#34;&#34;&#34; The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed
        
        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        Attributes
        ----------

            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,speed,transition_dynamics):
        &#34;&#34;&#34; initalize the AbsoluteSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        &#34;&#34;&#34;
        self.speed = speed
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,AbsoluteSpeedAction):
            if self.get_attributes() == other.get_attributes() and self.transition_dynamics == other.transition_dynamics:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
        speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)

        speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
        speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
        
        ET.SubElement(speedactiontarget,&#39;AbsoluteTargetSpeed&#39;,self.get_attributes())
        
        return element

class RelativeSpeedAction(_PrivateActionType):
    &#34;&#34;&#34; The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target
        
        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

        Attributes
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,speed,entity,transition_dynamics,valuetype=&#39;delta&#39;,continuous=True):
        &#34;&#34;&#34; initalizes RelativeSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

        &#34;&#34;&#34;
        self.speed = speed
        self.target = entity
        self.valuetype = valuetype
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics
        self.continuous = continuous

    def __eq__(self,other):
        if isinstance(other,RelativeSpeedAction):
            if self.get_attributes() == other.get_attributes() and self.transition_dynamics == other.transition_dynamics:
                return True
        return False
    
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.target,&#39;value&#39;:str(self.speed),&#39;speedTargetValueType&#39;:self.valuetype,&#39;continuous&#39;:convert_bool(self.continuous)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
        speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)
        speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
        speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
        
        ET.SubElement(speedactiontarget,&#39;RelativeTargetSpeed&#39;,self.get_attributes())
        
        return element
            
class LongitudinalDistanceAction(_PrivateActionType):
    &#34;&#34;&#34; The LongitudinalDistanceAction creates a LongitudinalAction of type LongitudinalDistanceAction with a distance target
        
        Parameters
        ----------
            distance (float): distance to the entity
            
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
                
        Attributes
        ----------
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            distance (float): the distance to the entity

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

            displacement (LongitudinalDisplacement): type of displacement wanted
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,distance,entity,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None, coordinate_system=CoordinateSystem.entity, displacement=LongitudinalDisplacement.any):
        &#34;&#34;&#34; initalize the LongitudinalDistanceAction
        
        Parameters
        ----------
            distance (float): distance to the entity
            
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
        &#34;&#34;&#34;
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)

        self.freespace = freespace
        self.continuous = continuous
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        self.distance = distance
        if not hasattr(CoordinateSystem,str(coordinate_system)):
            raise ValueError(coordinate_system + &#39;; is not a valid CoordinateSystem.&#39;)
        if not hasattr(LongitudinalDisplacement,str(displacement)):
            raise ValueError(displacement + &#39;; is not a valid LongitudinalDisplacement.&#39;)
        self.coordinate_system = coordinate_system
        self.displacement = displacement

    def __eq__(self,other):
        if isinstance(other,LongitudinalDistanceAction):
            if self.get_attributes() == other.get_attributes() and self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LongitudinalDistanceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        retdict[&#39;distance&#39;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
            retdict[&#39;displacement&#39;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LongitudinalDistanceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

        longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element

class LongitudinalTimegapAction(_PrivateActionType):
    &#34;&#34;&#34; The LongitudinalTimegapAction creates a LongitudinalAction of type LongitudinalDistanceAction with the timegap option
        
        Parameters
        ----------
            timegap (float): time to the target 

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

        Attributes
        ----------
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            timegap (float): timegap to the target

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,timegap,entity,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None):
        &#34;&#34;&#34; initalize the LongitudinalTimegapAction
        
        Parameters
        ----------
            timegap (float): time to the target 

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

        &#34;&#34;&#34;
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)


        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)


        self.freespace = freespace
        self.continuous = continuous
        self.timegap = timegap
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        
    def __eq__(self,other):
        if isinstance(other,LongitudinalTimegapAction):
            if self.get_attributes() == other.get_attributes() and self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LongitudinalTimegapAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        retdict[&#39;timeGap&#39;] = str(self.timegap)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LongitudinalTimegapAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

        longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element

# lateral actions

class AbsoluteLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34; the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target
        
        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        Attributes
        ----------
            lane (int): lane to change to

            target_lane_offset (float): offset in the target lane is wanted
                
            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lane,transition_dynamics,target_lane_offset=None):
        &#34;&#34;&#34; initalize AbsoluteLaneChangeAction

        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = lane
        self.target_lane_offset = target_lane_offset       
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,AbsoluteLaneChangeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.transition_dynamics == other.transition_dynamics and \
            self.target_lane_offset == other.target_lane_offset:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteLaneChangeAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.lane)
        return retdict
    
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneChangeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        laneoffset = {}
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        if self.target_lane_offset:
            laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)

        
        lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
        lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
        
        ET.SubElement(lanchangetarget,&#39;AbsoluteTargetLane&#39;,self.get_attributes())
        return element


class RelativeLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34; the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target
        
        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to
            
            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        Attributes
        ----------
            value (int): lane to change to

            target (str): target for relative lane change

            target_lane_offset (float): offset in the target lane is wanted
                
            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lane,entity,transition_dynamics,target_lane_offset=None):
        &#34;&#34;&#34; initalize RelativeLaneChangeAction

        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to
            
            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = lane
        self.target = entity
        self.target_lane_offset = target_lane_offset
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,RelativeLaneChangeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.transition_dynamics == other.transition_dynamics and \
            self.target_lane_offset == other.target_lane_offset:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeLaneChangeAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.lane)
        retdict[&#39;entityRef&#39;] = self.target
        return retdict
    
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeLaneChangeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        laneoffset = {}
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        if self.target_lane_offset is not None:
            laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)
        
        lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
        lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
        
        ET.SubElement(lanchangetarget,&#39;RelativeTargetLane&#39;,self.get_attributes())
        return element

class AbsoluteLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34; the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target
        
        Parameters
        ----------
            value (float): lateral offset of the lane

            shape (DynamicsShapes): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

        Attributes
        ----------
            continuous (bool): if the controller tries to keep the relative speed 

            value (float): lateral offset of the lane

            target (str): the name of the entity (relative only)

            dynshape (DynamicsShapes): the shape of the action

            maxlatacc (float): maximum allowed lateral acceleration

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,value,shape,maxlatacc,continuous = True):
        &#34;&#34;&#34; initalizes the AbsoluteLaneOffsetAction
            Parameters
            ----------
                value (float): lateral offset of the lane

                shape (DynamicsShapes): shape of the offset action

                maxlatacc (float): maximum allowed lateral acceleration

                continuous (bool): if the controller tries to keep the relative speed 
                    Default: True
        &#34;&#34;&#34;
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)

        self.continuous = continuous
        self.value = value
        if not hasattr(DynamicsShapes,str(shape)):
            raise ValueError(shape + &#39;; is not a valid shape.&#39;)
        self.dynshape = shape
        self.maxlatacc = maxlatacc

    def __eq__(self,other):
        if isinstance(other,AbsoluteLaneOffsetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynshape == other.dynshape and \
            self.maxlatacc == other.maxlatacc and \
            self.continuous == other.continuous:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteLaneOffsetAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.value)
        return retdict
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneOffsetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
        ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
        laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
        ET.SubElement(laneoftarget,&#39;AbsoluteTargetLaneOffset&#39;,self.get_attributes())

        return element

class RelativeLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34; the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target
        
        Parameters
        ----------
            value (float): relative lateral offset of the target

            entity (str): name of the entity

            shape (str): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

        Attributes
        ----------
            continuous (bool): if the controller tries to keep the relative speed 

            value (float): relative lateral offset of the arget

            target (str): the name of the entity

            dynshape (str): the shape of the action

            maxlatacc (float): maximum allowed lateral acceleration

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,value,entity,shape,maxlatacc,continuous = True):
        &#34;&#34;&#34; initalizes the RelativeLaneOffsetAction,

            Parameters
            ----------
                value (float): relative lateral offset of the target

                entity (str): name of the entity

                shape (str): shape of the offset action

                maxlatacc (float): maximum allowed lateral acceleration

                continuous (bool): if the controller tries to keep the relative speed 
                    Default: True
        &#34;&#34;&#34;
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        self.continuous = continuous
        self.value = value
        self.target = entity
        if not hasattr(DynamicsShapes,str(shape)):
            raise ValueError(shape + &#39;; is not a valid shape.&#39;)
        self.dynshape = shape
        self.maxlatacc = maxlatacc

    def __eq__(self,other):
        if isinstance(other,RelativeLaneOffsetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynshape == other.dynshape and \
            self.maxlatacc == other.maxlatacc and \
            self.continuous == other.continuous and \
            self.target == other.target:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeLaneOffsetAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.value)
        retdict[&#39;entityRef&#39;] = self.target
        return retdict
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeLaneOffsetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
        ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
        laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
        ET.SubElement(laneoftarget,&#39;RelativeTargetLaneOffset&#39;,attrib=self.get_attributes())

        return element


class LateralDistanceAction(_PrivateActionType):
    &#34;&#34;&#34; 
        
        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        Attributes
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            distance (float): if the distance metric is used

            timegap (float): if timegap metric is used

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

            displacement (LateralDisplacement): type of displacement wanted

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,entity,distance=None,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None,coordinate_system=CoordinateSystem.entity,displacement=LateralDisplacement.any):
        &#34;&#34;&#34; initalizes the LateralDistanceAction

        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None
            
            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        &#34;&#34;&#34;
        self.distance = distance
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)

        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)
        
        self.freespace = freespace
        self.continuous = continuous
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        if not hasattr(CoordinateSystem,str(coordinate_system)):
            raise ValueError(coordinate_system + &#39;; is not a valid CoordinateSystem.&#39;)
        if not hasattr(LateralDisplacement,str(displacement)):
            raise ValueError(displacement + &#39;; is not a valid LateralDisplacement.&#39;)
        self.coordinate_system = coordinate_system
        self.displacement = displacement

    def __eq__(self,other):
        if isinstance(other,LateralDistanceAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LateralDistanceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        if self.distance != None:
            retdict[&#39;distance&#39;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
            retdict[&#39;displacement&#39;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LateralDistanceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        lateraldistanceaction = ET.SubElement(lataction,&#39;LateralDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            lateraldistanceaction.append(self.dynamic_constraint.get_element())

        return element



# teleport
class TeleportAction(_PrivateActionType):
    &#34;&#34;&#34; the TeleportAction creates the Teleport action of OpenScenario
        
        Parameters
        ----------
            position (*Position): any position object

        Attributes
        ----------
            position (*Position): any position object


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,position):
        &#34;&#34;&#34; initalizes the TeleportAction

        Parameters
        ----------
            position (*Position): any position object

        &#34;&#34;&#34;
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input not a valid Position type&#39;)        

        self.position = position

    def __eq__(self,other):
        if isinstance(other,TeleportAction):
            if self.position == other.position:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TeleportAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        telact = ET.SubElement(element,&#39;TeleportAction&#39;)
        telact.append(self.position.get_element())
        return element



# Routing actions

class AssignRouteAction(_PrivateActionType):
    &#34;&#34;&#34; AssignRouteAction creates a RouteAction of type AssignRouteAction

        Parameters
        ----------
            route (Route, or CatalogReference): the route to follow

        Attributes
        ----------
            route (Route, or CatalogReference): the route to follow


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,route):
        &#34;&#34;&#34; initalizes the AssignRouteAction

            Parameters
            ----------
                route (Route, or CatalogReference): the route to follow

        &#34;&#34;&#34;
        if not ( isinstance(route,Route) or isinstance(route,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 

        self.route = route

    def __eq__(self,other):
        if isinstance(other,AssignRouteAction):
            if self.route == other.route:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AssignRouteAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        assignrouteaction = ET.SubElement(routeaction,&#39;AssignRouteAction&#39;)
        assignrouteaction.append(self.route.get_element())

        return element


class AcquirePositionAction(_PrivateActionType):
    &#34;&#34;&#34; AcquirePositionAction creates a RouteAction of type AcquirePositionAction
        
        Parameters
        ----------
            position (*Position): target position

        Attributes
        ----------
            position (*Position): target position

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,position):
        &#34;&#34;&#34; initalizes the AcquirePositionAction

            Parameters
            ----------
                position (*Position): target position

        &#34;&#34;&#34;
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input not a valid Position type&#39;)        

        self.position = position

    def __eq__(self,other):
        if isinstance(other,AcquirePositionAction):
            if self.position == other.position:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AcquirePositionAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        posaction = ET.SubElement(routeaction,&#39;AcquirePositionAction&#39;)
        posaction.append(self.position.get_element())

        return element



class FollowTrajectoryAction(_PrivateActionType):
    &#34;&#34;&#34; FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction

        Parameters
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (FollowMode): the following mode of the action

            reference_domain (ReferenceContext): how to follow
                Default: None
            scale (double): scalefactor of the timeings (must be combined with reference_domain and offset)
                Default: None
            offset (double): offset for time values (must be combined with reference_domain and scale)
                Default: None
            initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
                Default: None

        Attributes
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (str): the following mode of the action

            timeref (TimeReference): the time reference of the trajectory

            initialDistanceOffset (double): start at this offset into the trajectory (v1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,trajectory,following_mode,reference_domain=None,scale=None,offset=None,initialDistanceOffset=None):
        &#34;&#34;&#34; initalize the FollowTrajectoryAction 

            Parameters
            ----------
                trajectory (Trajectory, or CatalogReference): the trajectory to follow

                following_mode (FollowMode): the following mode of the action

                reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
                    Default: None
                scale (double): scalefactor of the timings (must be combined with reference_domain and offset)
                    Default: None
                offset (double): offset for time values (must be combined with reference_domain and scale)
                    Default: None
                initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
                    Default: None
                    
        &#34;&#34;&#34;
        # if following_mode not in FollowMode:
        #     ValueError(str(following_mode) + &#39; is not a valied following mode.&#39;)
        if not ( isinstance(trajectory,Trajectory) or isinstance(trajectory,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.trajectory = trajectory
        self.following_mode = following_mode
        # TODO: check reference_domain
        self.timeref = TimeReference(reference_domain,scale,offset)
        self.initialDistanceOffset = initialDistanceOffset

    def __eq__(self,other):
        if isinstance(other,FollowTrajectoryAction):
            if self.timeref == other.timeref and \
            self.get_attributes() == other.get_attributes() and \
            self.trajectory == other.trajectory and \
            self.following_mode == other.following_mode:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the FollowTrajectoryAction as a dict

        &#34;&#34;&#34;
        if self.initialDistanceOffset:
            return {&#39;initialDistanceOffset&#39;:str(self.initialDistanceOffset)}
        else:
            # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
            return {}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the FollowTrajectoryAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        trajaction = ET.SubElement(routeaction,&#39;FollowTrajectoryAction&#39;,attrib=self.get_attributes())
        if self.isVersion(minor=0):
            trajaction.append(self.trajectory.get_element())
        else:
            trajref = ET.SubElement(trajaction,&#39;TrajectoryRef&#39;)
            trajref.append(self.trajectory.get_element())
        trajaction.append(self.timeref.get_element())
        ET.SubElement(trajaction,&#39;TrajectoryFollowingMode&#39;,attrib={&#39;followingMode&#39;:self.following_mode.get_name()})

        return element





class ActivateControllerAction(_PrivateActionType):
    &#34;&#34;&#34; ActivateControllerAction creates a ActivateControllerAction of open scenario
        
        Parameters
        ----------
            lateral (boolean): activate or deactivate the controller

            longitudinal (boolean): activate or deactivate the controller

        Attributes
        ----------
            lateral (boolean): activate or deactivate the controller
            
            longitudinal (boolean): activate or deactivate the controller

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lateral, longitudinal):
        &#34;&#34;&#34; initalizes the ActivateControllerAction

            Parameters
            ----------
                lateral (boolean): activate or deactivate the controller
            
                longitudinal (boolean): activate or deactivate the controller

        &#34;&#34;&#34;
        if not isinstance(lateral,bool):
            raise TypeError(&#39;lateral input is not of type bool&#39;) 
        if not isinstance(longitudinal,bool):
            raise TypeError(&#39;longitudinal input is not of type bool&#39;) 
        self.lateral = lateral
        self.longitudinal = longitudinal

    def __eq__(self,other):
        if isinstance(other,ActivateControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ActivateControllerAction as a dict

        &#34;&#34;&#34;
        return {&#39;lateral&#39;:convert_bool(self.lateral),&#39;longitudinal&#39;:convert_bool(self.longitudinal)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ActivateControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        if self.isVersion(minor=0):
            ET.SubElement(element,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
        else:
            subelem = ET.SubElement(element,&#39;ControllerAction&#39;)
            ET.SubElement(subelem,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
        return element


class AssignControllerAction(_PrivateActionType):
    &#34;&#34;&#34; AssignControllerAction creates a ControllerAction of type AssignControllerAction
        
        Parameters
        ----------
            controller (Controller or Catalogreference): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                Default: True

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                Default: True
        Attributes
        ----------
            controller (boolController or Catalogreferenceean): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,controller,activateLateral=True,activateLongitudinal=True):
        &#34;&#34;&#34; initalizes the AssignControllerAction

            Parameters
            ----------
                controller (Controller or Catalogreference): a controller to assign

                activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                    Default: True

                activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                    Default: True
        &#34;&#34;&#34;
        if not ( isinstance(controller,Controller) or isinstance(controller,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.controller = controller
        self.activateLateral = activateLateral
        self.activateLongitudinal = activateLongitudinal

    def __eq__(self,other):
        if isinstance(other,AssignControllerAction):
            if self.controller == other.controller:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            return {}
        else:
            return {&#39;activateLateral&#39;:convert_bool(self.activateLateral),&#39;activateLongitudinal&#39;:convert_bool(self.activateLongitudinal)}


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AssignControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        controlleraction = ET.SubElement(element,&#39;ControllerActiton&#39;)
        controlleraction.append(self.controller.get_element())

        return element

class OverrideControllerValueAction(_PrivateActionType):
    &#34;&#34;&#34; OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
        NOTE: this implementation is compatible with osc v.1.1 where all attributes don&#39;t have to be set. 

        Attributes
        ----------
            throttle_active (bool): if the throttle is active
                Default: None (will not be written)

            throttle_value (double): value of the throttle

            brake_active (bool): if the brake is active
                Default: None (will not be written)

            brake_value (double): value of the brake

            clutch_active (bool): if the clutch is active
                Default: None (will not be written)

            clutch_value (double): value of the clutch

            steeringwheel_active (bool): if the steeringwheel is active
                Default: None (will not be written)

            steeringwheel_value (double): value of the steeringwheel

            gear_active (bool): if the gear is active
                Default: None (will not be written)

            gear_value (double): value of the gear

            parkingbrake_active (bool): if the parkingbrake is active
                Default: None (will not be written)

            parkingbrake_value (double): value of the parkingbrake

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class
            
            set_throttle(active,value)
                sets the throttle value

            set_brake(active,value)
                sets the brake value

            set_steeringwheel(active,value)
                sets the steeringwheel value

            set_clutch(active,value)
                sets the clutch value

            set_gear(active,value)
                sets the gear value

            set_parkingbrake(active,value)
                sets the parkingbrake value

    &#34;&#34;&#34;

    def __init__(self):
        self.throttle_active = None
        self.throttle_value = 0
        self.brake_active = None
        self.brake_value = 0
        self.clutch_active = None
        self.clutch_value = 0
        self.steeringwheel_active = None
        self.steeringwheel_value = 0
        self.gear_active = None
        self.gear_value = 0
        self.parkingbrake_active = None
        self.parkingbrake_value = 0

    def __eq__(self,other):
        if isinstance(other,OverrideControllerValueAction):
            if self.throttle_value == other.throttle_value and \
            self.throttle_value == other.throttle_value and \
            self.brake_active == other.brake_active and \
            self.brake_value == other.brake_value and \
            self.clutch_active == other.clutch_active and \
            self.clutch_value == other.clutch_value and \
            self.steeringwheel_active == other.steeringwheel_active and \
            self.steeringwheel_value == other.steeringwheel_value and \
            self.gear_active == other.gear_active and \
            self.gear_value == other.gear_value and \
            self.parkingbrake_active == other.parkingbrake_active and \
            self.parkingbrake_value == other.parkingbrake_value:
                return True
        return False

    def set_clutch(self,active,value=0):
        &#34;&#34;&#34; Sets the clutch value

            Parameters
            ----------
                active (bool): if the clutch should be overridden

                value (double): value of the clutch 
                    Default: 0
        &#34;&#34;&#34;
        self.clutch_active = active
        self.clutch_value = value
    
    def set_brake(self,active,value=0):
        &#34;&#34;&#34; Sets the brake value

            Parameters
            ----------
                active (bool): if the brake should be overridden

                value (double): value of the brake 
                    Default: 0
        &#34;&#34;&#34;
        self.brake_active = active
        self.brake_value = value

    def set_throttle(self,active,value=0):
        &#34;&#34;&#34; Sets the throttle value

            Parameters
            ----------
                active (bool): if the throttle should be overridden

                value (double): value of the throttle 
                    Default: 0
        &#34;&#34;&#34;
        self.throttle_active = active
        self.throttle_value = value

    def set_steeringwheel(self,active,value=0):
        &#34;&#34;&#34; Sets the steeringwheel value

            Parameters
            ----------
                active (bool): if the steeringwheel should be overridden

                value (double): value of the steeringwheel 
                    Default: 0

        &#34;&#34;&#34;
        self.steeringwheel_active = active
        self.steeringwheel_value = value

    def set_parkingbrake(self,active,value=0):
        &#34;&#34;&#34; Sets the parkingbrake value

            Parameters
            ----------
                active (bool): if the parkingbrake should be overridden

                value (double): value of the parkingbrake 
                    Default: 0

        &#34;&#34;&#34;
        self.parkingbrake_active = active
        self.parkingbrake_value = value

    def set_gear(self,active,value=0):
        &#34;&#34;&#34; Sets the gear value

            Parameters
            ----------
                active (bool): if the gear should be overridden

                value (double): value of the gear 
                    Default: 0
        &#34;&#34;&#34;
        self.gear_active = active
        self.gear_value = value

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the OverrideControllerValueAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        controlleraction = ET.SubElement(element,&#39;ControllerAction&#39;)
        overrideaction = ET.SubElement(controlleraction,&#39;OverrideControllerValueAction&#39;)
        

        if self.throttle_active == None and self.brake_active == None and self.clutch_active == None and self.parkingbrake_active == None and self.steeringwheel_active == None and self.gear_active == None:
            raise NoActionsDefinedError(&#39;No actions were added to the OverrideControllerValueAction&#39;)
        if self.throttle_active != None:
            ET.SubElement(overrideaction,&#39;Throttle&#39;,{&#39;active&#39;:convert_bool(self.throttle_active),&#39;value&#39;:str(self.throttle_value)})
        if self.brake_active != None:
            ET.SubElement(overrideaction,&#39;Brake&#39;,{&#39;active&#39;:convert_bool(self.brake_active),&#39;value&#39;:str(self.brake_value)})
        if self.clutch_active != None:
            ET.SubElement(overrideaction,&#39;Clutch&#39;,{&#39;active&#39;:convert_bool(self.clutch_active),&#39;value&#39;:str(self.clutch_value)})
        if self.parkingbrake_active != None:
            ET.SubElement(overrideaction,&#39;ParkingBrake&#39;,{&#39;active&#39;:convert_bool(self.parkingbrake_active),&#39;value&#39;:str(self.parkingbrake_value)})
        if self.steeringwheel_active != None:
            ET.SubElement(overrideaction,&#39;SteeringWheel&#39;,{&#39;active&#39;:convert_bool(self.steeringwheel_active),&#39;value&#39;:str(self.steeringwheel_value)})
        if self.gear_active != None:
            ET.SubElement(overrideaction,&#39;Gear&#39;,{&#39;active&#39;:convert_bool(self.gear_active),&#39;value&#39;:str(self.gear_value)})

        return element

class VisibilityAction(_PrivateActionType):
    &#34;&#34;&#34; creates a VisibilityAction
        
        Parameters
        ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        Attributes
        ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self,graphics, traffic, sensors):
        &#34;&#34;&#34; initalizes the VisibilityAction

            Parameters
            ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        &#34;&#34;&#34;
        if not isinstance(graphics,bool):
            raise TypeError(&#39;graphics input is not of type bool&#39;)
        if not isinstance(traffic,bool):
            raise TypeError(&#39;traffic input is not of type bool&#39;)
        if not isinstance(sensors,bool):
            raise TypeError(&#39;sensors input is not of type bool&#39;)
        self.graphics = graphics
        self.traffic = traffic
        self.sensors = sensors

    def __eq__(self,other):
        if isinstance(other,VisibilityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

        &#34;&#34;&#34;
        return {&#39;graphics&#39;:convert_bool(self.graphics),&#39;traffic&#39;:convert_bool(self.traffic),&#39;sensors&#39;:convert_bool(self.sensors)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the VisibilityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        ET.SubElement(element,&#39;VisibilityAction&#39;,self.get_attributes())
        return element


class SynchronizeAction(_PrivateActionType):
    &#34;&#34;&#34; Synchronizes an entity&#39;s arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.
        
        Parameters
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            speed (double): the absolute speed of the target that should syncronize

            target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
                Default: None
        Attributes
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            speed (double): the absolute speed of the target that should syncronize

            target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self, entity, entity_PositionType:_PositionType, target_PositionType:_PositionType,target_tolerance_master=None,target_tolerance=None,final_speed=None):
        &#34;&#34;&#34; initalize the SynchronizeAction

            Parameters
            ----------
                entity (str): entity to syncronize with

                entity_PositionType (*Position): the position of the entity to syncronize to

                target_PositionType (*Position): the position of the target that should syncronize

                speed (double): the absolute speed of the target that should syncronize

                target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

                target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

                final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
                Default: None
        &#34;&#34;&#34;
        
        self.entity = entity
        if not isinstance(entity_PositionType,_PositionType):
            raise TypeError(&#39;entity_PositionType input is not a valid Position&#39;)
        
        if not isinstance(target_PositionType,_PositionType):
            raise TypeError(&#39;target_PositionType input is not a valid Position&#39;)
        self.entity_PositionType = entity_PositionType
        self.target_PositionType = target_PositionType
        self.target_tolerance_master = target_tolerance_master
        self.target_tolerance = target_tolerance
        if final_speed and not (isinstance(final_speed,AbsoluteSpeed) or isinstance(final_speed,RelativeSpeedToMaster)):
            raise TypeError(&#39;final_speed input is not AbsoluteSpeed or RelativeSpeedToMaster type&#39;)
        else:
            self.final_speed = final_speed

    def __eq__(self,other):
        if isinstance(other,SynchronizeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.entity_PositionType == other.entity_PositionType and \
            self.target_PositionType == other.target_PositionType and \
            self.final_speed == other.final_speed:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSynchronizeAction as a dict

        &#34;&#34;&#34;
        attr = {&#39;masterEntityRef&#39;:self.entity}
        if self.isVersion(1, 0):
            return attr
        if self.target_tolerance_master is not None:
            attr.update({&#39;targetToleranceMaster&#39;: str(self.target_tolerance_master)})
        if self.target_tolerance is not None:
            attr.update({&#39;targetTolerance&#39;: str(self.target_tolerance)})
        return attr

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSynchronizeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        syncaction = ET.SubElement(element,&#39;SynchronizeAction&#39;,self.get_attributes())
        syncaction.append(self.entity_PositionType.get_element(&#39;TargetPositionMaster&#39;))
        syncaction.append(self.target_PositionType.get_element(&#39;TargetPosition&#39;))
        if self.final_speed is not None:
            syncaction.append(self.final_speed.get_element())
        return element


#### Global Actions ####
class ParameterAddAction(_ActionType):
    &#34;&#34;&#34; The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterAddAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterAddAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
        rule = ET.SubElement(modifaction,&#39;Rule&#39;)
        ET.SubElement(rule,&#39;AddValue&#39;,self.get_attributes())

        
        return element


class ParameterMultiplyAction(_ActionType):
    &#34;&#34;&#34; The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be multiplied to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be multiplied to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterMultiplyAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterMultiplyAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterMultiplyAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterMultiplyAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
        rule = ET.SubElement(modifaction,&#39;Rule&#39;)
        ET.SubElement(rule,&#39;MultiplyByValue&#39;,self.get_attributes())

        return element


class ParameterSetAction(_ActionType):
    &#34;&#34;&#34; The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be set to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be set to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterSetAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterSetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterSetAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterSetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        ET.SubElement(paramaction,&#39;SetAction&#39;,self.get_attributes())
        
        return element


class TrafficSignalStateAction(_ActionType):
    &#34;&#34;&#34; The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal
        
        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        Attributes
        ----------

            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,name,state):
        &#34;&#34;&#34; initalize the TrafficSignalStateAction

        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self,other):
        if isinstance(other,TrafficSignalStateAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalStateAction as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name,&#39;state&#39;:self.state}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalStateAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
        tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
        ET.SubElement(tsa,&#39;TrafficSignalStateAction&#39;,self.get_attributes())
        
        return element


class AddEntityAction(_ActionType):
    &#34;&#34;&#34; The AddEntityAction class creates a EntityAction which adds a entity to the scenario
        
        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        Attributes
        ----------

            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,entityref,position):
        &#34;&#34;&#34; initalize the AddEntityAction

        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        &#34;&#34;&#34;
        
        self.entityref = entityref
        self.position = position

    def __eq__(self,other):
        if isinstance(other,AddEntityAction):
            if self.get_attributes() == other.get_attributes() and self.position == other.position:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AddEntityAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entityref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AddEntityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
        addentity = ET.SubElement(entityact,&#39;AddEntityAction&#39;)
        addentity.append(self.position.get_element())
        
        
        return element



class DeleteEntityAction(_ActionType):
    &#34;&#34;&#34; The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario
        
        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        Attributes
        ----------

            entityref (str): reference name of the vehicle to remove


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,entityref):
        &#34;&#34;&#34; initalize the DeleteEntityAction

        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        &#34;&#34;&#34;
        
        self.entityref = entityref

    def __eq__(self,other):
        if isinstance(other,DeleteEntityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the DeleteEntityAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entityref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the DeleteEntityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
        ET.SubElement(entityact,&#39;DeleteEntityAction&#39;)

        
        
        return element



class TrafficSignalControllerAction(_ActionType):
    &#34;&#34;&#34; The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal
        
        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        Attributes
        ----------

            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,phase,traffic_signalcontroller_ref):
        &#34;&#34;&#34; initalize the TrafficSignalControllerAction

        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        &#34;&#34;&#34;
        self.phase = phase
        self.traffic_signalcontroller_ref = traffic_signalcontroller_ref

    def __eq__(self,other):
        if isinstance(other,TrafficSignalControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalControllerAction as a dict

        &#34;&#34;&#34;
        return {&#39;phase&#39;:self.phase,&#39;trafficSignalControllerRef&#39;:self.traffic_signalcontroller_ref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
        tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
        ET.SubElement(tsa,&#39;TrafficSignalControllerAction&#39;,self.get_attributes())
        
        return element


class TrafficSourceAction(_ActionType):
    &#34;&#34;&#34; The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction
        
        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

        Attributes
        ----------

            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,rate,radius,position,trafficdefinition,velocity = None,name=None):
        &#34;&#34;&#34; initalize the TrafficSourceAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.rate = rate
        self.radius = radius
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input is not a valid Position&#39;)
        
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.velocity = velocity
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSourceAction):
            if self.get_attributes() == other.get_attributes() and \
            self.position == other.position and \
            self.trafficdefinition == other.trafficdefinition and \
            self.name == other.name:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSourceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;rate&#39;] = str(self.rate)
        retdict[&#39;radius&#39;] = str(self.radius)
        if self.velocity is not None:
            retdict[&#39;velocity&#39;] = str(self.velocity)
        

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSourceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        sourceaction = ET.SubElement(trafficaction,&#39;TrafficSourceAction&#39;,attrib=self.get_attributes())
        sourceaction.append(self.position.get_element())
        sourceaction.append(self.trafficdefinition.get_element())

        
        
        return element


class TrafficSinkAction(_ActionType):
    &#34;&#34;&#34; The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction
        
        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the sink around the position

            position (*Position): any Position to define the sink

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

        Attributes
        ----------

            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,rate,radius,position,trafficdefinition,name=None):
        &#34;&#34;&#34; initalize the TrafficSinkAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        &#34;&#34;&#34;
        self.rate = rate
        self.radius = radius
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input is not a valid Position&#39;)
        
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSinkAction):
            if self.get_attributes() == other.get_attributes() and \
            self.position == other.position and \
            self.trafficdefinition == other.trafficdefinition:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSinkAction as a dict

        &#34;&#34;&#34;
        retdict = {}

        retdict[&#39;rate&#39;] = str(self.rate)
        retdict[&#39;radius&#39;] = str(self.radius)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSinkAction

        &#34;&#34;&#34;

        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        sinkaction = ET.SubElement(trafficaction,&#39;TrafficSinkAction&#39;,attrib=self.get_attributes())
        sinkaction.append(self.position.get_element())
        sinkaction.append(self.trafficdefinition.get_element())

        return element


class TrafficSwarmAction(_ActionType):
    &#34;&#34;&#34; The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction
        
        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner cirvle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None
            
            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        Attributes
        ----------

            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner cirvle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,semimajoraxis,semiminoraxis,innerradius,offset,numberofvehicles,centralobject,trafficdefinition,velocity = None,name = None):
        &#34;&#34;&#34; initalize the TrafficSwarmAction

        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner circle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None
            
            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.semimajoraxis = semimajoraxis
        self.semiminoraxis = semiminoraxis
        self.innerradius = innerradius
        self.offset = offset
        self.numberofvehicles = numberofvehicles
        self.centralobject = centralobject
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.trafficdefinition = trafficdefinition
        self.velocity = velocity
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSwarmAction):
            if self.get_attributes() == other.get_attributes() and \
            self.centralobject == other.centralobject and \
            self.trafficdefinition == other.trafficdefinition and \
            self.name == other.name:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSwarmAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;semiMajorAxis&#39;] = str(self.semimajoraxis)
        retdict[&#39;semiMinorAxis&#39;] = str(self.semiminoraxis)
        retdict[&#39;innerRadius&#39;] = str(self.innerradius)
        retdict[&#39;offset&#39;] = str(self.offset)
        retdict[&#39;numberOfVehicles&#39;] = str(self.numberofvehicles)
        if self.velocity is not None:
            retdict[&#39;velocity&#39;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSwarmAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        
        swarmaction = ET.SubElement(trafficaction,&#39;TrafficSwarmAction&#39;,attrib=self.get_attributes())
        swarmaction.append(self.trafficdefinition.get_element())
        ET.SubElement(swarmaction,&#39;CentralSwarmObject&#39;,attrib={&#39;entityRef&#39;:self.centralobject})

        return element



class TrafficStopAction(_ActionType):
    &#34;&#34;&#34; The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction 
        
        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None

        Attributes
        ----------

            name (str): name of the Traffic to stop

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,name = None):
        &#34;&#34;&#34; initalize the TrafficSwarmAction

        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None
        &#34;&#34;&#34;
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficStopAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficStopAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.name and not self.isVersion(minor=0):
            retdict[&#39;trafficName&#39;] = str(self.name)
        elif self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;TrafficStopAction was introduced in OpenSCENARIO V1.1&#39;)

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficStopAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=self.get_attributes())
        ET.SubElement(trafficaction,&#39;TrafficStopAction&#39;)      

        return element


class EnvironmentAction(_ActionType):
    &#34;&#34;&#34; The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction
        
        Parameters
        ----------
            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        Attributes
        ----------

            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;
    def __init__(self, name, environment):
        &#34;&#34;&#34; initalize the EnvironmentAction

            Parameters
            ----------
                name (str): name of the action

                environment (Environment or CatalogReference): the environment to change to

        &#34;&#34;&#34;
        self.name = name
        if not ( isinstance(environment,Environment) or isinstance(environment,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.environment = environment

    def __eq__(self,other):
        if isinstance(other,EnvironmentAction):
            if self.get_attributes() == other.get_attributes() and \
            self.environment == other.environment:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the EnvironmentAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the EnvironmentAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        envaction = ET.SubElement(element, &#39;EnvironmentAction&#39;)
        envaction.append(self.environment.get_element())
        
        return element


class CustomCommandAction(_ActionType):
    &#34;&#34;&#34; The CustomCommandAction creates a simulator defined action, can add any number of xml.etree.ElementTree to an Action

        NOTE: this is a very crude implementation, and the element has to be created by the user.
        
        Parameters
        ----------
            
        Attributes
        ----------

            elements (list of xml.etree.ElementTree): elements to add to the action

        Methods
        -------
            add_element(element)
                Adds an element to the action
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self,semimajoraxis,semiminoraxis,innerradius,offset,numberofvehicles,centralobject,trafficdefinition,velocity = None):
        &#34;&#34;&#34; initalize the CustomCommandAction

            Parameters
            ----------

        &#34;&#34;&#34;
        self.elements = []

    def add_element(self,element):
        &#34;&#34;&#34; adds an element to the CustomCommandAction

            Parameters
            ----------
                element (xml.etree.ElementTree): the element to add
        &#34;&#34;&#34;
        self.elements.append(element)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the CustomCommandAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;UserDefinedAction&#39;)
        for e in self.elements:
            element.append(e)

        return element</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneChangeAction</span></span>
<span>(</span><span>lane, transition_dynamics, target_lane_offset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (int): lane to change to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lane (int): lane to change to

target_lane_offset (float): offset in the target lane is wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize AbsoluteLaneChangeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane (int): lane to change to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34; the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target
        
        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        Attributes
        ----------
            lane (int): lane to change to

            target_lane_offset (float): offset in the target lane is wanted
                
            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lane,transition_dynamics,target_lane_offset=None):
        &#34;&#34;&#34; initalize AbsoluteLaneChangeAction

        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = lane
        self.target_lane_offset = target_lane_offset       
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,AbsoluteLaneChangeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.transition_dynamics == other.transition_dynamics and \
            self.target_lane_offset == other.target_lane_offset:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteLaneChangeAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.lane)
        return retdict
    
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneChangeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        laneoffset = {}
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        if self.target_lane_offset:
            laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)

        
        lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
        lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
        
        ET.SubElement(lanchangetarget,&#39;AbsoluteTargetLane&#39;,self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteLaneChangeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteLaneChangeAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;value&#39;] = str(self.lane)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteLaneChangeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneChangeAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    laneoffset = {}
    lataction = ET.SubElement(element,&#39;LateralAction&#39;)
    if self.target_lane_offset:
        laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)

    
    lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
    lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
    
    ET.SubElement(lanchangetarget,&#39;AbsoluteTargetLane&#39;,self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneOffsetAction</span></span>
<span>(</span><span>value, shape, maxlatacc, continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): lateral offset of the lane

shape (DynamicsShapes): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed 
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>continuous (bool): if the controller tries to keep the relative speed

value (float): lateral offset of the lane

target (str): the name of the entity (relative only)

dynshape (DynamicsShapes): the shape of the action

maxlatacc (float): maximum allowed lateral acceleration
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the AbsoluteLaneOffsetAction
Parameters</p>
<hr>
<pre><code>value (float): lateral offset of the lane

shape (DynamicsShapes): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed 
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34; the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target
        
        Parameters
        ----------
            value (float): lateral offset of the lane

            shape (DynamicsShapes): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

        Attributes
        ----------
            continuous (bool): if the controller tries to keep the relative speed 

            value (float): lateral offset of the lane

            target (str): the name of the entity (relative only)

            dynshape (DynamicsShapes): the shape of the action

            maxlatacc (float): maximum allowed lateral acceleration

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,value,shape,maxlatacc,continuous = True):
        &#34;&#34;&#34; initalizes the AbsoluteLaneOffsetAction
            Parameters
            ----------
                value (float): lateral offset of the lane

                shape (DynamicsShapes): shape of the offset action

                maxlatacc (float): maximum allowed lateral acceleration

                continuous (bool): if the controller tries to keep the relative speed 
                    Default: True
        &#34;&#34;&#34;
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)

        self.continuous = continuous
        self.value = value
        if not hasattr(DynamicsShapes,str(shape)):
            raise ValueError(shape + &#39;; is not a valid shape.&#39;)
        self.dynshape = shape
        self.maxlatacc = maxlatacc

    def __eq__(self,other):
        if isinstance(other,AbsoluteLaneOffsetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynshape == other.dynshape and \
            self.maxlatacc == other.maxlatacc and \
            self.continuous == other.continuous:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteLaneOffsetAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.value)
        return retdict
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneOffsetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
        ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
        laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
        ET.SubElement(laneoftarget,&#39;AbsoluteTargetLaneOffset&#39;,self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteLaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteLaneOffsetAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;value&#39;] = str(self.value)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteLaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteLaneOffsetAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    lataction = ET.SubElement(element,&#39;LateralAction&#39;)
    laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
    ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
    laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
    ET.SubElement(laneoftarget,&#39;AbsoluteTargetLaneOffset&#39;,self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteSpeedAction</span></span>
<span>(</span><span>speed, transition_dynamics)</span>
</code></dt>
<dd>
<div class="desc"><p>The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed</p>
<h2 id="parameters">Parameters</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the AbsoluteSpeedAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteSpeedAction(_PrivateActionType):
    &#34;&#34;&#34; The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed
        
        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        Attributes
        ----------

            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,speed,transition_dynamics):
        &#34;&#34;&#34; initalize the AbsoluteSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        &#34;&#34;&#34;
        self.speed = speed
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,AbsoluteSpeedAction):
            if self.get_attributes() == other.get_attributes() and self.transition_dynamics == other.transition_dynamics:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
        speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)

        speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
        speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
        
        ET.SubElement(speedactiontarget,&#39;AbsoluteTargetSpeed&#39;,self.get_attributes())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

    &#34;&#34;&#34;
    return {&#39;value&#39;:str(self.speed)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
    speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)

    speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
    speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
    
    ET.SubElement(speedactiontarget,&#39;AbsoluteTargetSpeed&#39;,self.get_attributes())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction"><code class="flex name class">
<span>class <span class="ident">AcquirePositionAction</span></span>
<span>(</span><span>position)</span>
</code></dt>
<dd>
<div class="desc"><p>AcquirePositionAction creates a RouteAction of type AcquirePositionAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): target position
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>position (*Position): target position
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AcquirePositionAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>position (*Position): target position
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcquirePositionAction(_PrivateActionType):
    &#34;&#34;&#34; AcquirePositionAction creates a RouteAction of type AcquirePositionAction
        
        Parameters
        ----------
            position (*Position): target position

        Attributes
        ----------
            position (*Position): target position

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,position):
        &#34;&#34;&#34; initalizes the AcquirePositionAction

            Parameters
            ----------
                position (*Position): target position

        &#34;&#34;&#34;
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input not a valid Position type&#39;)        

        self.position = position

    def __eq__(self,other):
        if isinstance(other,AcquirePositionAction):
            if self.position == other.position:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AcquirePositionAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        posaction = ET.SubElement(routeaction,&#39;AcquirePositionAction&#39;)
        posaction.append(self.position.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AcquirePositionAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AcquirePositionAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
    posaction = ET.SubElement(routeaction,&#39;AcquirePositionAction&#39;)
    posaction.append(self.position.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction"><code class="flex name class">
<span>class <span class="ident">ActivateControllerAction</span></span>
<span>(</span><span>lateral, longitudinal)</span>
</code></dt>
<dd>
<div class="desc"><p>ActivateControllerAction creates a ActivateControllerAction of open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lateral (boolean): activate or deactivate the controller

longitudinal (boolean): activate or deactivate the controller
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lateral (boolean): activate or deactivate the controller

longitudinal (boolean): activate or deactivate the controller
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalizes the ActivateControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lateral (boolean): activate or deactivate the controller

longitudinal (boolean): activate or deactivate the controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActivateControllerAction(_PrivateActionType):
    &#34;&#34;&#34; ActivateControllerAction creates a ActivateControllerAction of open scenario
        
        Parameters
        ----------
            lateral (boolean): activate or deactivate the controller

            longitudinal (boolean): activate or deactivate the controller

        Attributes
        ----------
            lateral (boolean): activate or deactivate the controller
            
            longitudinal (boolean): activate or deactivate the controller

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lateral, longitudinal):
        &#34;&#34;&#34; initalizes the ActivateControllerAction

            Parameters
            ----------
                lateral (boolean): activate or deactivate the controller
            
                longitudinal (boolean): activate or deactivate the controller

        &#34;&#34;&#34;
        if not isinstance(lateral,bool):
            raise TypeError(&#39;lateral input is not of type bool&#39;) 
        if not isinstance(longitudinal,bool):
            raise TypeError(&#39;longitudinal input is not of type bool&#39;) 
        self.lateral = lateral
        self.longitudinal = longitudinal

    def __eq__(self,other):
        if isinstance(other,ActivateControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ActivateControllerAction as a dict

        &#34;&#34;&#34;
        return {&#39;lateral&#39;:convert_bool(self.lateral),&#39;longitudinal&#39;:convert_bool(self.longitudinal)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ActivateControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        if self.isVersion(minor=0):
            ET.SubElement(element,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
        else:
            subelem = ET.SubElement(element,&#39;ControllerAction&#39;)
            ET.SubElement(subelem,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ActivateControllerAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the ActivateControllerAction as a dict

    &#34;&#34;&#34;
    return {&#39;lateral&#39;:convert_bool(self.lateral),&#39;longitudinal&#39;:convert_bool(self.longitudinal)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ActivateControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ActivateControllerAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    if self.isVersion(minor=0):
        ET.SubElement(element,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
    else:
        subelem = ET.SubElement(element,&#39;ControllerAction&#39;)
        ET.SubElement(subelem,&#39;ActivateControllerAction&#39;,attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction"><code class="flex name class">
<span>class <span class="ident">AddEntityAction</span></span>
<span>(</span><span>entityref, position)</span>
</code></dt>
<dd>
<div class="desc"><p>The AddEntityAction class creates a EntityAction which adds a entity to the scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the AddEntityAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AddEntityAction(_ActionType):
    &#34;&#34;&#34; The AddEntityAction class creates a EntityAction which adds a entity to the scenario
        
        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        Attributes
        ----------

            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,entityref,position):
        &#34;&#34;&#34; initalize the AddEntityAction

        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        &#34;&#34;&#34;
        
        self.entityref = entityref
        self.position = position

    def __eq__(self,other):
        if isinstance(other,AddEntityAction):
            if self.get_attributes() == other.get_attributes() and self.position == other.position:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AddEntityAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entityref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AddEntityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
        addentity = ET.SubElement(entityact,&#39;AddEntityAction&#39;)
        addentity.append(self.position.get_element())
        
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AddEntityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AddEntityAction as a dict

    &#34;&#34;&#34;
    return {&#39;entityRef&#39;:self.entityref}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AddEntityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AddEntityAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
    addentity = ET.SubElement(entityact,&#39;AddEntityAction&#39;)
    addentity.append(self.position.get_element())
    
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction"><code class="flex name class">
<span>class <span class="ident">AssignControllerAction</span></span>
<span>(</span><span>controller, activateLateral=True, activateLongitudinal=True)</span>
</code></dt>
<dd>
<div class="desc"><p>AssignControllerAction creates a ControllerAction of type AssignControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>controller (Controller or Catalogreference): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)
    Default: True

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>controller (boolController or Catalogreferenceean): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AssignControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>controller (Controller or Catalogreference): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)
    Default: True

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignControllerAction(_PrivateActionType):
    &#34;&#34;&#34; AssignControllerAction creates a ControllerAction of type AssignControllerAction
        
        Parameters
        ----------
            controller (Controller or Catalogreference): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                Default: True

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                Default: True
        Attributes
        ----------
            controller (boolController or Catalogreferenceean): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,controller,activateLateral=True,activateLongitudinal=True):
        &#34;&#34;&#34; initalizes the AssignControllerAction

            Parameters
            ----------
                controller (Controller or Catalogreference): a controller to assign

                activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                    Default: True

                activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                    Default: True
        &#34;&#34;&#34;
        if not ( isinstance(controller,Controller) or isinstance(controller,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.controller = controller
        self.activateLateral = activateLateral
        self.activateLongitudinal = activateLongitudinal

    def __eq__(self,other):
        if isinstance(other,AssignControllerAction):
            if self.controller == other.controller:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            return {}
        else:
            return {&#39;activateLateral&#39;:convert_bool(self.activateLateral),&#39;activateLongitudinal&#39;:convert_bool(self.activateLongitudinal)}


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AssignControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        controlleraction = ET.SubElement(element,&#39;ControllerActiton&#39;)
        controlleraction.append(self.controller.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the VisibilityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        return {}
    else:
        return {&#39;activateLateral&#39;:convert_bool(self.activateLateral),&#39;activateLongitudinal&#39;:convert_bool(self.activateLongitudinal)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AssignControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AssignControllerAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    controlleraction = ET.SubElement(element,&#39;ControllerActiton&#39;)
    controlleraction.append(self.controller.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction"><code class="flex name class">
<span>class <span class="ident">AssignRouteAction</span></span>
<span>(</span><span>route)</span>
</code></dt>
<dd>
<div class="desc"><p>AssignRouteAction creates a RouteAction of type AssignRouteAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AssignRouteAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignRouteAction(_PrivateActionType):
    &#34;&#34;&#34; AssignRouteAction creates a RouteAction of type AssignRouteAction

        Parameters
        ----------
            route (Route, or CatalogReference): the route to follow

        Attributes
        ----------
            route (Route, or CatalogReference): the route to follow


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,route):
        &#34;&#34;&#34; initalizes the AssignRouteAction

            Parameters
            ----------
                route (Route, or CatalogReference): the route to follow

        &#34;&#34;&#34;
        if not ( isinstance(route,Route) or isinstance(route,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 

        self.route = route

    def __eq__(self,other):
        if isinstance(other,AssignRouteAction):
            if self.route == other.route:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AssignRouteAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        assignrouteaction = ET.SubElement(routeaction,&#39;AssignRouteAction&#39;)
        assignrouteaction.append(self.route.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AssignRouteAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AssignRouteAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
    assignrouteaction = ET.SubElement(routeaction,&#39;AssignRouteAction&#39;)
    assignrouteaction.append(self.route.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction"><code class="flex name class">
<span>class <span class="ident">CustomCommandAction</span></span>
<span>(</span><span>semimajoraxis, semiminoraxis, innerradius, offset, numberofvehicles, centralobject, trafficdefinition, velocity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The CustomCommandAction creates a simulator defined action, can add any number of xml.etree.ElementTree to an Action</p>
<p>NOTE: this is a very crude implementation, and the element has to be created by the user.</p>
<h2 id="parameters">Parameters</h2>
<h2 id="attributes">Attributes</h2>
<pre><code>elements (list of xml.etree.ElementTree): elements to add to the action
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_element(element)
    Adds an element to the action
get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the CustomCommandAction</p>
<h2 id="parameters_1">Parameters</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomCommandAction(_ActionType):
    &#34;&#34;&#34; The CustomCommandAction creates a simulator defined action, can add any number of xml.etree.ElementTree to an Action

        NOTE: this is a very crude implementation, and the element has to be created by the user.
        
        Parameters
        ----------
            
        Attributes
        ----------

            elements (list of xml.etree.ElementTree): elements to add to the action

        Methods
        -------
            add_element(element)
                Adds an element to the action
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self,semimajoraxis,semiminoraxis,innerradius,offset,numberofvehicles,centralobject,trafficdefinition,velocity = None):
        &#34;&#34;&#34; initalize the CustomCommandAction

            Parameters
            ----------

        &#34;&#34;&#34;
        self.elements = []

    def add_element(self,element):
        &#34;&#34;&#34; adds an element to the CustomCommandAction

            Parameters
            ----------
                element (xml.etree.ElementTree): the element to add
        &#34;&#34;&#34;
        self.elements.append(element)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the CustomCommandAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;UserDefinedAction&#39;)
        for e in self.elements:
            element.append(e)

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.add_element"><code class="name flex">
<span>def <span class="ident">add_element</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"><p>adds an element to the CustomCommandAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree): the element to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_element(self,element):
    &#34;&#34;&#34; adds an element to the CustomCommandAction

        Parameters
        ----------
            element (xml.etree.ElementTree): the element to add
    &#34;&#34;&#34;
    self.elements.append(element)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the CustomCommandAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the CustomCommandAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;UserDefinedAction&#39;)
    for e in self.elements:
        element.append(e)

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction"><code class="flex name class">
<span>class <span class="ident">DeleteEntityAction</span></span>
<span>(</span><span>entityref)</span>
</code></dt>
<dd>
<div class="desc"><p>The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the DeleteEntityAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteEntityAction(_ActionType):
    &#34;&#34;&#34; The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario
        
        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        Attributes
        ----------

            entityref (str): reference name of the vehicle to remove


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,entityref):
        &#34;&#34;&#34; initalize the DeleteEntityAction

        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        &#34;&#34;&#34;
        
        self.entityref = entityref

    def __eq__(self,other):
        if isinstance(other,DeleteEntityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the DeleteEntityAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entityref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the DeleteEntityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
        ET.SubElement(entityact,&#39;DeleteEntityAction&#39;)

        
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the DeleteEntityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the DeleteEntityAction as a dict

    &#34;&#34;&#34;
    return {&#39;entityRef&#39;:self.entityref}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the DeleteEntityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the DeleteEntityAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    entityact = ET.SubElement(element,&#39;EntityAction&#39;,attrib=self.get_attributes())
    ET.SubElement(entityact,&#39;DeleteEntityAction&#39;)

    
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction"><code class="flex name class">
<span>class <span class="ident">EnvironmentAction</span></span>
<span>(</span><span>name, environment)</span>
</code></dt>
<dd>
<div class="desc"><p>The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the action

environment (Environment or CatalogReference): the environment to change to
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the action

environment (Environment or CatalogReference): the environment to change to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the EnvironmentAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the action

environment (Environment or CatalogReference): the environment to change to
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnvironmentAction(_ActionType):
    &#34;&#34;&#34; The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction
        
        Parameters
        ----------
            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        Attributes
        ----------

            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;
    def __init__(self, name, environment):
        &#34;&#34;&#34; initalize the EnvironmentAction

            Parameters
            ----------
                name (str): name of the action

                environment (Environment or CatalogReference): the environment to change to

        &#34;&#34;&#34;
        self.name = name
        if not ( isinstance(environment,Environment) or isinstance(environment,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.environment = environment

    def __eq__(self,other):
        if isinstance(other,EnvironmentAction):
            if self.get_attributes() == other.get_attributes() and \
            self.environment == other.environment:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the EnvironmentAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the EnvironmentAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        envaction = ET.SubElement(element, &#39;EnvironmentAction&#39;)
        envaction.append(self.environment.get_element())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the EnvironmentAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the EnvironmentAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;name&#39;] = self.name
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the EnvironmentAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the EnvironmentAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    envaction = ET.SubElement(element, &#39;EnvironmentAction&#39;)
    envaction.append(self.environment.get_element())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction"><code class="flex name class">
<span>class <span class="ident">FollowTrajectoryAction</span></span>
<span>(</span><span>trajectory, following_mode, reference_domain=None, scale=None, offset=None, initialDistanceOffset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (FollowMode): the following mode of the action

reference_domain (ReferenceContext): how to follow
    Default: None
scale (double): scalefactor of the timeings (must be combined with reference_domain and offset)
    Default: None
offset (double): offset for time values (must be combined with reference_domain and scale)
    Default: None
initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (str): the following mode of the action

timeref (TimeReference): the time reference of the trajectory

initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the FollowTrajectoryAction </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (FollowMode): the following mode of the action

reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
    Default: None
scale (double): scalefactor of the timings (must be combined with reference_domain and offset)
    Default: None
offset (double): offset for time values (must be combined with reference_domain and scale)
    Default: None
initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FollowTrajectoryAction(_PrivateActionType):
    &#34;&#34;&#34; FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction

        Parameters
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (FollowMode): the following mode of the action

            reference_domain (ReferenceContext): how to follow
                Default: None
            scale (double): scalefactor of the timeings (must be combined with reference_domain and offset)
                Default: None
            offset (double): offset for time values (must be combined with reference_domain and scale)
                Default: None
            initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
                Default: None

        Attributes
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (str): the following mode of the action

            timeref (TimeReference): the time reference of the trajectory

            initialDistanceOffset (double): start at this offset into the trajectory (v1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,trajectory,following_mode,reference_domain=None,scale=None,offset=None,initialDistanceOffset=None):
        &#34;&#34;&#34; initalize the FollowTrajectoryAction 

            Parameters
            ----------
                trajectory (Trajectory, or CatalogReference): the trajectory to follow

                following_mode (FollowMode): the following mode of the action

                reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
                    Default: None
                scale (double): scalefactor of the timings (must be combined with reference_domain and offset)
                    Default: None
                offset (double): offset for time values (must be combined with reference_domain and scale)
                    Default: None
                initialDistanceOffset (double): start at this offset into the trajectory (v1.1)
                    Default: None
                    
        &#34;&#34;&#34;
        # if following_mode not in FollowMode:
        #     ValueError(str(following_mode) + &#39; is not a valied following mode.&#39;)
        if not ( isinstance(trajectory,Trajectory) or isinstance(trajectory,CatalogReference)):
            raise TypeError(&#39;route input not of type Route or CatalogReference&#39;) 
        self.trajectory = trajectory
        self.following_mode = following_mode
        # TODO: check reference_domain
        self.timeref = TimeReference(reference_domain,scale,offset)
        self.initialDistanceOffset = initialDistanceOffset

    def __eq__(self,other):
        if isinstance(other,FollowTrajectoryAction):
            if self.timeref == other.timeref and \
            self.get_attributes() == other.get_attributes() and \
            self.trajectory == other.trajectory and \
            self.following_mode == other.following_mode:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the FollowTrajectoryAction as a dict

        &#34;&#34;&#34;
        if self.initialDistanceOffset:
            return {&#39;initialDistanceOffset&#39;:str(self.initialDistanceOffset)}
        else:
            # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
            return {}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the FollowTrajectoryAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
        trajaction = ET.SubElement(routeaction,&#39;FollowTrajectoryAction&#39;,attrib=self.get_attributes())
        if self.isVersion(minor=0):
            trajaction.append(self.trajectory.get_element())
        else:
            trajref = ET.SubElement(trajaction,&#39;TrajectoryRef&#39;)
            trajref.append(self.trajectory.get_element())
        trajaction.append(self.timeref.get_element())
        ET.SubElement(trajaction,&#39;TrajectoryFollowingMode&#39;,attrib={&#39;followingMode&#39;:self.following_mode.get_name()})

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the FollowTrajectoryAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the FollowTrajectoryAction as a dict

    &#34;&#34;&#34;
    if self.initialDistanceOffset:
        return {&#39;initialDistanceOffset&#39;:str(self.initialDistanceOffset)}
    else:
        # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
        return {}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the FollowTrajectoryAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the FollowTrajectoryAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    routeaction = ET.SubElement(element,&#39;RoutingAction&#39;)
    trajaction = ET.SubElement(routeaction,&#39;FollowTrajectoryAction&#39;,attrib=self.get_attributes())
    if self.isVersion(minor=0):
        trajaction.append(self.trajectory.get_element())
    else:
        trajref = ET.SubElement(trajaction,&#39;TrajectoryRef&#39;)
        trajref.append(self.trajectory.get_element())
    trajaction.append(self.timeref.get_element())
    ET.SubElement(trajaction,&#39;TrajectoryFollowingMode&#39;,attrib={&#39;followingMode&#39;:self.following_mode.get_name()})

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction"><code class="flex name class">
<span>class <span class="ident">LateralDistanceAction</span></span>
<span>(</span><span>entity, distance=None, freespace=True, continuous=True, max_acceleration=None, max_deceleration=None, max_speed=None, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, displacement=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LateralDisplacement): type of displacement wanted
    Default LateralDisplacement.any
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

continuous (bool): if the controller tries to keep the relative speed

distance (float): if the distance metric is used

timegap (float): if timegap metric is used

dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

displacement (LateralDisplacement): type of displacement wanted
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the LateralDistanceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LateralDisplacement): type of displacement wanted
    Default LateralDisplacement.any
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LateralDistanceAction(_PrivateActionType):
    &#34;&#34;&#34; 
        
        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        Attributes
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            distance (float): if the distance metric is used

            timegap (float): if timegap metric is used

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

            displacement (LateralDisplacement): type of displacement wanted

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,entity,distance=None,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None,coordinate_system=CoordinateSystem.entity,displacement=LateralDisplacement.any):
        &#34;&#34;&#34; initalizes the LateralDistanceAction

        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None
            
            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        &#34;&#34;&#34;
        self.distance = distance
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)

        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)
        
        self.freespace = freespace
        self.continuous = continuous
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        if not hasattr(CoordinateSystem,str(coordinate_system)):
            raise ValueError(coordinate_system + &#39;; is not a valid CoordinateSystem.&#39;)
        if not hasattr(LateralDisplacement,str(displacement)):
            raise ValueError(displacement + &#39;; is not a valid LateralDisplacement.&#39;)
        self.coordinate_system = coordinate_system
        self.displacement = displacement

    def __eq__(self,other):
        if isinstance(other,LateralDistanceAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LateralDistanceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        if self.distance != None:
            retdict[&#39;distance&#39;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
            retdict[&#39;displacement&#39;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LateralDistanceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        lateraldistanceaction = ET.SubElement(lataction,&#39;LateralDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            lateraldistanceaction.append(self.dynamic_constraint.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LateralDistanceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the LateralDistanceAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;entityRef&#39;] = self.target
    retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
    retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
    if self.distance != None:
        retdict[&#39;distance&#39;] = str(self.distance)
    if not self.isVersion(minor=0):
        retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
        retdict[&#39;displacement&#39;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LateralDistanceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the LateralDistanceAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    lataction = ET.SubElement(element,&#39;LateralAction&#39;)
    lateraldistanceaction = ET.SubElement(lataction,&#39;LateralDistanceAction&#39;,attrib=self.get_attributes())
    if self.dynamic_constraint.is_filled():
        lateraldistanceaction.append(self.dynamic_constraint.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction"><code class="flex name class">
<span>class <span class="ident">LongitudinalDistanceAction</span></span>
<span>(</span><span>distance, entity, freespace=True, continuous=True, max_acceleration=None, max_deceleration=None, max_speed=None, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, displacement=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>The LongitudinalDistanceAction creates a LongitudinalAction of type LongitudinalDistanceAction with a distance target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>distance (float): distance to the entity

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LongitudinalDisplacement): type of displacement wanted
    Default LongitudinalDisplacement.any
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

continuous (bool): if the controller tries to keep the relative speed

distance (float): the distance to the entity

dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

displacement (LongitudinalDisplacement): type of displacement wanted
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the LongitudinalDistanceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>distance (float): distance to the entity

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LongitudinalDisplacement): type of displacement wanted
    Default LongitudinalDisplacement.any
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LongitudinalDistanceAction(_PrivateActionType):
    &#34;&#34;&#34; The LongitudinalDistanceAction creates a LongitudinalAction of type LongitudinalDistanceAction with a distance target
        
        Parameters
        ----------
            distance (float): distance to the entity
            
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
                
        Attributes
        ----------
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            distance (float): the distance to the entity

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

            displacement (LongitudinalDisplacement): type of displacement wanted
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,distance,entity,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None, coordinate_system=CoordinateSystem.entity, displacement=LongitudinalDisplacement.any):
        &#34;&#34;&#34; initalize the LongitudinalDistanceAction
        
        Parameters
        ----------
            distance (float): distance to the entity
            
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
        &#34;&#34;&#34;
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)

        self.freespace = freespace
        self.continuous = continuous
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        self.distance = distance
        if not hasattr(CoordinateSystem,str(coordinate_system)):
            raise ValueError(coordinate_system + &#39;; is not a valid CoordinateSystem.&#39;)
        if not hasattr(LongitudinalDisplacement,str(displacement)):
            raise ValueError(displacement + &#39;; is not a valid LongitudinalDisplacement.&#39;)
        self.coordinate_system = coordinate_system
        self.displacement = displacement

    def __eq__(self,other):
        if isinstance(other,LongitudinalDistanceAction):
            if self.get_attributes() == other.get_attributes() and self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LongitudinalDistanceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        retdict[&#39;distance&#39;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
            retdict[&#39;displacement&#39;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LongitudinalDistanceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

        longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LongitudinalDistanceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the LongitudinalDistanceAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;entityRef&#39;] = self.target
    retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
    retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
    retdict[&#39;distance&#39;] = str(self.distance)
    if not self.isVersion(minor=0):
        retdict[&#39;coordinateSystem&#39;] = self.coordinate_system.get_name()
        retdict[&#39;displacement&#39;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LongitudinalDistanceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the LongitudinalDistanceAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

    longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
    if self.dynamic_constraint.is_filled():
        longdistaction.append(self.dynamic_constraint.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalTimegapAction"><code class="flex name class">
<span>class <span class="ident">LongitudinalTimegapAction</span></span>
<span>(</span><span>timegap, entity, freespace=True, continuous=True, max_acceleration=None, max_deceleration=None, max_speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The LongitudinalTimegapAction creates a LongitudinalAction of type LongitudinalDistanceAction with the timegap option</p>
<h2 id="parameters">Parameters</h2>
<pre><code>timegap (float): time to the target

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

continuous (bool): if the controller tries to keep the relative speed

timegap (float): timegap to the target

dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the LongitudinalTimegapAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>timegap (float): time to the target

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed 
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LongitudinalTimegapAction(_PrivateActionType):
    &#34;&#34;&#34; The LongitudinalTimegapAction creates a LongitudinalAction of type LongitudinalDistanceAction with the timegap option
        
        Parameters
        ----------
            timegap (float): time to the target 

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

        Attributes
        ----------
            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

            continuous (bool): if the controller tries to keep the relative speed 

            timegap (float): timegap to the target

            dynamic_constraint (DynamicsConstrains): Dynamics constraints of the action

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,timegap,entity,freespace=True,continuous=True,max_acceleration = None,max_deceleration = None,max_speed = None):
        &#34;&#34;&#34; initalize the LongitudinalTimegapAction
        
        Parameters
        ----------
            timegap (float): time to the target 

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

        &#34;&#34;&#34;
        self.target = entity
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)


        if not isinstance(freespace,bool):
            raise TypeError(&#39;freespace input not of type bool&#39;)


        self.freespace = freespace
        self.continuous = continuous
        self.timegap = timegap
        self.dynamic_constraint = DynamicsConstrains(max_acceleration,max_deceleration,max_speed)
        
    def __eq__(self,other):
        if isinstance(other,LongitudinalTimegapAction):
            if self.get_attributes() == other.get_attributes() and self.dynamic_constraint == other.dynamic_constraint:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the LongitudinalTimegapAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;entityRef&#39;] = self.target
        retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
        retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
        retdict[&#39;timeGap&#39;] = str(self.timegap)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the LongitudinalTimegapAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

        longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LongitudinalTimegapAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the LongitudinalTimegapAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;entityRef&#39;] = self.target
    retdict[&#39;freespace&#39;] = convert_bool(self.freespace)
    retdict[&#39;continuous&#39;] = convert_bool(self.continuous)
    retdict[&#39;timeGap&#39;] = str(self.timegap)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LongitudinalTimegapAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the LongitudinalTimegapAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    longact = ET.SubElement(element,&#39;LongitudinalAction&#39;)

    longdistaction = ET.SubElement(longact,&#39;LongitudinalDistanceAction&#39;,attrib=self.get_attributes())
    if self.dynamic_constraint.is_filled():
        longdistaction.append(self.dynamic_constraint.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction"><code class="flex name class">
<span>class <span class="ident">OverrideControllerValueAction</span></span>
</code></dt>
<dd>
<div class="desc"><p>OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
NOTE: this implementation is compatible with osc v.1.1 where all attributes don't have to be set. </p>
<h2 id="attributes">Attributes</h2>
<pre><code>throttle_active (bool): if the throttle is active
    Default: None (will not be written)

throttle_value (double): value of the throttle

brake_active (bool): if the brake is active
    Default: None (will not be written)

brake_value (double): value of the brake

clutch_active (bool): if the clutch is active
    Default: None (will not be written)

clutch_value (double): value of the clutch

steeringwheel_active (bool): if the steeringwheel is active
    Default: None (will not be written)

steeringwheel_value (double): value of the steeringwheel

gear_active (bool): if the gear is active
    Default: None (will not be written)

gear_value (double): value of the gear

parkingbrake_active (bool): if the parkingbrake is active
    Default: None (will not be written)

parkingbrake_value (double): value of the parkingbrake
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class

set_throttle(active,value)
    sets the throttle value

set_brake(active,value)
    sets the brake value

set_steeringwheel(active,value)
    sets the steeringwheel value

set_clutch(active,value)
    sets the clutch value

set_gear(active,value)
    sets the gear value

set_parkingbrake(active,value)
    sets the parkingbrake value
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OverrideControllerValueAction(_PrivateActionType):
    &#34;&#34;&#34; OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
        NOTE: this implementation is compatible with osc v.1.1 where all attributes don&#39;t have to be set. 

        Attributes
        ----------
            throttle_active (bool): if the throttle is active
                Default: None (will not be written)

            throttle_value (double): value of the throttle

            brake_active (bool): if the brake is active
                Default: None (will not be written)

            brake_value (double): value of the brake

            clutch_active (bool): if the clutch is active
                Default: None (will not be written)

            clutch_value (double): value of the clutch

            steeringwheel_active (bool): if the steeringwheel is active
                Default: None (will not be written)

            steeringwheel_value (double): value of the steeringwheel

            gear_active (bool): if the gear is active
                Default: None (will not be written)

            gear_value (double): value of the gear

            parkingbrake_active (bool): if the parkingbrake is active
                Default: None (will not be written)

            parkingbrake_value (double): value of the parkingbrake

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class
            
            set_throttle(active,value)
                sets the throttle value

            set_brake(active,value)
                sets the brake value

            set_steeringwheel(active,value)
                sets the steeringwheel value

            set_clutch(active,value)
                sets the clutch value

            set_gear(active,value)
                sets the gear value

            set_parkingbrake(active,value)
                sets the parkingbrake value

    &#34;&#34;&#34;

    def __init__(self):
        self.throttle_active = None
        self.throttle_value = 0
        self.brake_active = None
        self.brake_value = 0
        self.clutch_active = None
        self.clutch_value = 0
        self.steeringwheel_active = None
        self.steeringwheel_value = 0
        self.gear_active = None
        self.gear_value = 0
        self.parkingbrake_active = None
        self.parkingbrake_value = 0

    def __eq__(self,other):
        if isinstance(other,OverrideControllerValueAction):
            if self.throttle_value == other.throttle_value and \
            self.throttle_value == other.throttle_value and \
            self.brake_active == other.brake_active and \
            self.brake_value == other.brake_value and \
            self.clutch_active == other.clutch_active and \
            self.clutch_value == other.clutch_value and \
            self.steeringwheel_active == other.steeringwheel_active and \
            self.steeringwheel_value == other.steeringwheel_value and \
            self.gear_active == other.gear_active and \
            self.gear_value == other.gear_value and \
            self.parkingbrake_active == other.parkingbrake_active and \
            self.parkingbrake_value == other.parkingbrake_value:
                return True
        return False

    def set_clutch(self,active,value=0):
        &#34;&#34;&#34; Sets the clutch value

            Parameters
            ----------
                active (bool): if the clutch should be overridden

                value (double): value of the clutch 
                    Default: 0
        &#34;&#34;&#34;
        self.clutch_active = active
        self.clutch_value = value
    
    def set_brake(self,active,value=0):
        &#34;&#34;&#34; Sets the brake value

            Parameters
            ----------
                active (bool): if the brake should be overridden

                value (double): value of the brake 
                    Default: 0
        &#34;&#34;&#34;
        self.brake_active = active
        self.brake_value = value

    def set_throttle(self,active,value=0):
        &#34;&#34;&#34; Sets the throttle value

            Parameters
            ----------
                active (bool): if the throttle should be overridden

                value (double): value of the throttle 
                    Default: 0
        &#34;&#34;&#34;
        self.throttle_active = active
        self.throttle_value = value

    def set_steeringwheel(self,active,value=0):
        &#34;&#34;&#34; Sets the steeringwheel value

            Parameters
            ----------
                active (bool): if the steeringwheel should be overridden

                value (double): value of the steeringwheel 
                    Default: 0

        &#34;&#34;&#34;
        self.steeringwheel_active = active
        self.steeringwheel_value = value

    def set_parkingbrake(self,active,value=0):
        &#34;&#34;&#34; Sets the parkingbrake value

            Parameters
            ----------
                active (bool): if the parkingbrake should be overridden

                value (double): value of the parkingbrake 
                    Default: 0

        &#34;&#34;&#34;
        self.parkingbrake_active = active
        self.parkingbrake_value = value

    def set_gear(self,active,value=0):
        &#34;&#34;&#34; Sets the gear value

            Parameters
            ----------
                active (bool): if the gear should be overridden

                value (double): value of the gear 
                    Default: 0
        &#34;&#34;&#34;
        self.gear_active = active
        self.gear_value = value

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the OverrideControllerValueAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        controlleraction = ET.SubElement(element,&#39;ControllerAction&#39;)
        overrideaction = ET.SubElement(controlleraction,&#39;OverrideControllerValueAction&#39;)
        

        if self.throttle_active == None and self.brake_active == None and self.clutch_active == None and self.parkingbrake_active == None and self.steeringwheel_active == None and self.gear_active == None:
            raise NoActionsDefinedError(&#39;No actions were added to the OverrideControllerValueAction&#39;)
        if self.throttle_active != None:
            ET.SubElement(overrideaction,&#39;Throttle&#39;,{&#39;active&#39;:convert_bool(self.throttle_active),&#39;value&#39;:str(self.throttle_value)})
        if self.brake_active != None:
            ET.SubElement(overrideaction,&#39;Brake&#39;,{&#39;active&#39;:convert_bool(self.brake_active),&#39;value&#39;:str(self.brake_value)})
        if self.clutch_active != None:
            ET.SubElement(overrideaction,&#39;Clutch&#39;,{&#39;active&#39;:convert_bool(self.clutch_active),&#39;value&#39;:str(self.clutch_value)})
        if self.parkingbrake_active != None:
            ET.SubElement(overrideaction,&#39;ParkingBrake&#39;,{&#39;active&#39;:convert_bool(self.parkingbrake_active),&#39;value&#39;:str(self.parkingbrake_value)})
        if self.steeringwheel_active != None:
            ET.SubElement(overrideaction,&#39;SteeringWheel&#39;,{&#39;active&#39;:convert_bool(self.steeringwheel_active),&#39;value&#39;:str(self.steeringwheel_value)})
        if self.gear_active != None:
            ET.SubElement(overrideaction,&#39;Gear&#39;,{&#39;active&#39;:convert_bool(self.gear_active),&#39;value&#39;:str(self.gear_value)})

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the OverrideControllerValueAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the OverrideControllerValueAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    controlleraction = ET.SubElement(element,&#39;ControllerAction&#39;)
    overrideaction = ET.SubElement(controlleraction,&#39;OverrideControllerValueAction&#39;)
    

    if self.throttle_active == None and self.brake_active == None and self.clutch_active == None and self.parkingbrake_active == None and self.steeringwheel_active == None and self.gear_active == None:
        raise NoActionsDefinedError(&#39;No actions were added to the OverrideControllerValueAction&#39;)
    if self.throttle_active != None:
        ET.SubElement(overrideaction,&#39;Throttle&#39;,{&#39;active&#39;:convert_bool(self.throttle_active),&#39;value&#39;:str(self.throttle_value)})
    if self.brake_active != None:
        ET.SubElement(overrideaction,&#39;Brake&#39;,{&#39;active&#39;:convert_bool(self.brake_active),&#39;value&#39;:str(self.brake_value)})
    if self.clutch_active != None:
        ET.SubElement(overrideaction,&#39;Clutch&#39;,{&#39;active&#39;:convert_bool(self.clutch_active),&#39;value&#39;:str(self.clutch_value)})
    if self.parkingbrake_active != None:
        ET.SubElement(overrideaction,&#39;ParkingBrake&#39;,{&#39;active&#39;:convert_bool(self.parkingbrake_active),&#39;value&#39;:str(self.parkingbrake_value)})
    if self.steeringwheel_active != None:
        ET.SubElement(overrideaction,&#39;SteeringWheel&#39;,{&#39;active&#39;:convert_bool(self.steeringwheel_active),&#39;value&#39;:str(self.steeringwheel_value)})
    if self.gear_active != None:
        ET.SubElement(overrideaction,&#39;Gear&#39;,{&#39;active&#39;:convert_bool(self.gear_active),&#39;value&#39;:str(self.gear_value)})

    return element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake"><code class="name flex">
<span>def <span class="ident">set_brake</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the brake value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the brake should be overridden

value (double): value of the brake 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_brake(self,active,value=0):
    &#34;&#34;&#34; Sets the brake value

        Parameters
        ----------
            active (bool): if the brake should be overridden

            value (double): value of the brake 
                Default: 0
    &#34;&#34;&#34;
    self.brake_active = active
    self.brake_value = value</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch"><code class="name flex">
<span>def <span class="ident">set_clutch</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the clutch value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the clutch should be overridden

value (double): value of the clutch 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_clutch(self,active,value=0):
    &#34;&#34;&#34; Sets the clutch value

        Parameters
        ----------
            active (bool): if the clutch should be overridden

            value (double): value of the clutch 
                Default: 0
    &#34;&#34;&#34;
    self.clutch_active = active
    self.clutch_value = value</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear"><code class="name flex">
<span>def <span class="ident">set_gear</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the gear value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the gear should be overridden

value (double): value of the gear 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gear(self,active,value=0):
    &#34;&#34;&#34; Sets the gear value

        Parameters
        ----------
            active (bool): if the gear should be overridden

            value (double): value of the gear 
                Default: 0
    &#34;&#34;&#34;
    self.gear_active = active
    self.gear_value = value</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake"><code class="name flex">
<span>def <span class="ident">set_parkingbrake</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the parkingbrake value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the parkingbrake should be overridden

value (double): value of the parkingbrake 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parkingbrake(self,active,value=0):
    &#34;&#34;&#34; Sets the parkingbrake value

        Parameters
        ----------
            active (bool): if the parkingbrake should be overridden

            value (double): value of the parkingbrake 
                Default: 0

    &#34;&#34;&#34;
    self.parkingbrake_active = active
    self.parkingbrake_value = value</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel"><code class="name flex">
<span>def <span class="ident">set_steeringwheel</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the steeringwheel value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the steeringwheel should be overridden

value (double): value of the steeringwheel 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_steeringwheel(self,active,value=0):
    &#34;&#34;&#34; Sets the steeringwheel value

        Parameters
        ----------
            active (bool): if the steeringwheel should be overridden

            value (double): value of the steeringwheel 
                Default: 0

    &#34;&#34;&#34;
    self.steeringwheel_active = active
    self.steeringwheel_value = value</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle"><code class="name flex">
<span>def <span class="ident">set_throttle</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the throttle value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the throttle should be overridden

value (double): value of the throttle 
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_throttle(self,active,value=0):
    &#34;&#34;&#34; Sets the throttle value

        Parameters
        ----------
            active (bool): if the throttle should be overridden

            value (double): value of the throttle 
                Default: 0
    &#34;&#34;&#34;
    self.throttle_active = active
    self.throttle_value = value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction"><code class="flex name class">
<span>class <span class="ident">ParameterAddAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be added to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be added to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterAddAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterAddAction(_ActionType):
    &#34;&#34;&#34; The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterAddAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterAddAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
        rule = ET.SubElement(modifaction,&#39;Rule&#39;)
        ET.SubElement(rule,&#39;AddValue&#39;,self.get_attributes())

        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteSpeedAction as a dict

    &#34;&#34;&#34;
    return {&#39;value&#39;:str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeedAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
    modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
    rule = ET.SubElement(modifaction,&#39;Rule&#39;)
    ET.SubElement(rule,&#39;AddValue&#39;,self.get_attributes())

    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction"><code class="flex name class">
<span>class <span class="ident">ParameterMultiplyAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be multiplied to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be multiplied to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterMultiplyAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterMultiplyAction(_ActionType):
    &#34;&#34;&#34; The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be multiplied to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be multiplied to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterMultiplyAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterMultiplyAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterMultiplyAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterMultiplyAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
        rule = ET.SubElement(modifaction,&#39;Rule&#39;)
        ET.SubElement(rule,&#39;MultiplyByValue&#39;,self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterMultiplyAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the ParameterMultiplyAction as a dict

    &#34;&#34;&#34;
    return {&#39;value&#39;:str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterMultiplyAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ParameterMultiplyAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
    modifaction = ET.SubElement(paramaction,&#39;ModifyAction&#39;)
    rule = ET.SubElement(modifaction,&#39;Rule&#39;)
    ET.SubElement(rule,&#39;MultiplyByValue&#39;,self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction"><code class="flex name class">
<span>class <span class="ident">ParameterSetAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be set to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be set to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterSetAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (double): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterSetAction(_ActionType):
    &#34;&#34;&#34; The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter
        
        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be set to the parameter

        Attributes
        ----------

            parameter_ref (str): name of the parameter

            value (double): the value that should be set to the parameter

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,parameter_ref,value):
        &#34;&#34;&#34; initalize the ParameterSetAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (double): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterSetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.parameter_ref == other.parameter_ref:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterSetAction as a dict

        &#34;&#34;&#34;
        return {&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterSetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
        ET.SubElement(paramaction,&#39;SetAction&#39;,self.get_attributes())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterSetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the ParameterSetAction as a dict

    &#34;&#34;&#34;
    return {&#39;value&#39;:str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterSetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ParameterSetAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    paramaction = ET.SubElement(element,&#39;ParameterAction&#39;,{&#39;parameterRef&#39;:self.parameter_ref})
    ET.SubElement(paramaction,&#39;SetAction&#39;,self.get_attributes())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneChangeAction</span></span>
<span>(</span><span>lane, entity, transition_dynamics, target_lane_offset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (int): relative lane number

entity (str): the entity to run relative to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (int): lane to change to

target (str): target for relative lane change

target_lane_offset (float): offset in the target lane is wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize RelativeLaneChangeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane (int): relative lane number

entity (str): the entity to run relative to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34; the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target
        
        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to
            
            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        Attributes
        ----------
            value (int): lane to change to

            target (str): target for relative lane change

            target_lane_offset (float): offset in the target lane is wanted
                
            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,lane,entity,transition_dynamics,target_lane_offset=None):
        &#34;&#34;&#34; initalize RelativeLaneChangeAction

        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to
            
            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = lane
        self.target = entity
        self.target_lane_offset = target_lane_offset
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self,other):
        if isinstance(other,RelativeLaneChangeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.transition_dynamics == other.transition_dynamics and \
            self.target_lane_offset == other.target_lane_offset:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeLaneChangeAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.lane)
        retdict[&#39;entityRef&#39;] = self.target
        return retdict
    
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeLaneChangeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        laneoffset = {}
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        if self.target_lane_offset is not None:
            laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)
        
        lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
        lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
        
        ET.SubElement(lanchangetarget,&#39;RelativeTargetLane&#39;,self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeLaneChangeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the RelativeLaneChangeAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;value&#39;] = str(self.lane)
    retdict[&#39;entityRef&#39;] = self.target
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeLaneChangeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RelativeLaneChangeAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    laneoffset = {}
    lataction = ET.SubElement(element,&#39;LateralAction&#39;)
    if self.target_lane_offset is not None:
        laneoffset = {&#39;targetLaneOffset&#39;:str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(lataction,&#39;LaneChangeAction&#39;,attrib=laneoffset)
    
    lanechangeaction.append(self.transition_dynamics.get_element(&#39;LaneChangeActionDynamics&#39;))
    lanchangetarget = ET.SubElement(lanechangeaction,&#39;LaneChangeTarget&#39;)
    
    ET.SubElement(lanchangetarget,&#39;RelativeTargetLane&#39;,self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneOffsetAction</span></span>
<span>(</span><span>value, entity, shape, maxlatacc, continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): relative lateral offset of the target

entity (str): name of the entity

shape (str): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed 
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>continuous (bool): if the controller tries to keep the relative speed

value (float): relative lateral offset of the arget

target (str): the name of the entity

dynshape (str): the shape of the action

maxlatacc (float): maximum allowed lateral acceleration
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the RelativeLaneOffsetAction,</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): relative lateral offset of the target

entity (str): name of the entity

shape (str): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed 
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34; the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target
        
        Parameters
        ----------
            value (float): relative lateral offset of the target

            entity (str): name of the entity

            shape (str): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed 
                Default: True

        Attributes
        ----------
            continuous (bool): if the controller tries to keep the relative speed 

            value (float): relative lateral offset of the arget

            target (str): the name of the entity

            dynshape (str): the shape of the action

            maxlatacc (float): maximum allowed lateral acceleration

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,value,entity,shape,maxlatacc,continuous = True):
        &#34;&#34;&#34; initalizes the RelativeLaneOffsetAction,

            Parameters
            ----------
                value (float): relative lateral offset of the target

                entity (str): name of the entity

                shape (str): shape of the offset action

                maxlatacc (float): maximum allowed lateral acceleration

                continuous (bool): if the controller tries to keep the relative speed 
                    Default: True
        &#34;&#34;&#34;
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        self.continuous = continuous
        self.value = value
        self.target = entity
        if not hasattr(DynamicsShapes,str(shape)):
            raise ValueError(shape + &#39;; is not a valid shape.&#39;)
        self.dynshape = shape
        self.maxlatacc = maxlatacc

    def __eq__(self,other):
        if isinstance(other,RelativeLaneOffsetAction):
            if self.get_attributes() == other.get_attributes() and \
            self.dynshape == other.dynshape and \
            self.maxlatacc == other.maxlatacc and \
            self.continuous == other.continuous and \
            self.target == other.target:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeLaneOffsetAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;value&#39;] = str(self.value)
        retdict[&#39;entityRef&#39;] = self.target
        return retdict
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeLaneOffsetAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        lataction = ET.SubElement(element,&#39;LateralAction&#39;)
        laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
        ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
        laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
        ET.SubElement(laneoftarget,&#39;RelativeTargetLaneOffset&#39;,attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeLaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the RelativeLaneOffsetAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;value&#39;] = str(self.value)
    retdict[&#39;entityRef&#39;] = self.target
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeLaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RelativeLaneOffsetAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    lataction = ET.SubElement(element,&#39;LateralAction&#39;)
    laneoffsetaction = ET.SubElement(lataction,&#39;LaneOffsetAction&#39;,attrib={&#39;continuous&#39;:convert_bool(self.continuous)})
    ET.SubElement(laneoffsetaction,&#39;LaneOffsetActionDynamics&#39;,{&#39;maxLateralAcc&#39;:str(self.maxlatacc),&#39;dynamicsShape&#39;:self.dynshape.get_name()})
    laneoftarget = ET.SubElement(laneoffsetaction,&#39;LaneOffsetTarget&#39;)
    ET.SubElement(laneoftarget,&#39;RelativeTargetLaneOffset&#39;,attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedAction</span></span>
<span>(</span><span>speed, entity, transition_dynamics, valuetype='delta', continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target (used for relative speed)

transition_dynamics (TransitionDynamics): how the change should be made

valuetype (str): the type of relative speed wanted (used for relative speed)

continuous (bool): if the controller tries to keep the relative speed
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target (used for relative speed)

valuetype (str): the type of relative speed wanted (used for relative speed)

continuous (bool): if the controller tries to keep the relative speed

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes RelativeSpeedAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target (used for relative speed)

transition_dynamics (TransitionDynamics): how the change should be made

valuetype (str): the type of relative speed wanted (used for relative speed)

continuous (bool): if the controller tries to keep the relative speed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedAction(_PrivateActionType):
    &#34;&#34;&#34; The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target
        
        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

        Attributes
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

            transition_dynamics (TransitionDynamics): how the change should be made

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,speed,entity,transition_dynamics,valuetype=&#39;delta&#39;,continuous=True):
        &#34;&#34;&#34; initalizes RelativeSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target (used for relative speed)

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (str): the type of relative speed wanted (used for relative speed)

            continuous (bool): if the controller tries to keep the relative speed 

        &#34;&#34;&#34;
        self.speed = speed
        self.target = entity
        self.valuetype = valuetype
        if not isinstance(continuous,bool):
            raise TypeError(&#39;continuous input not of type bool&#39;)
        
        if not isinstance(transition_dynamics,TransitionDynamics):
            raise TypeError(&#39;transition_dynamics input not of type TransitionDynamics&#39;)
        self.transition_dynamics = transition_dynamics
        self.continuous = continuous

    def __eq__(self,other):
        if isinstance(other,RelativeSpeedAction):
            if self.get_attributes() == other.get_attributes() and self.transition_dynamics == other.transition_dynamics:
                return True
        return False
    
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeSpeedAction as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.target,&#39;value&#39;:str(self.speed),&#39;speedTargetValueType&#39;:self.valuetype,&#39;continuous&#39;:convert_bool(self.continuous)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeSpeedAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
        speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)
        speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
        speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
        
        ET.SubElement(speedactiontarget,&#39;RelativeTargetSpeed&#39;,self.get_attributes())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the RelativeSpeedAction as a dict

    &#34;&#34;&#34;
    return {&#39;entityRef&#39;:self.target,&#39;value&#39;:str(self.speed),&#39;speedTargetValueType&#39;:self.valuetype,&#39;continuous&#39;:convert_bool(self.continuous)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RelativeSpeedAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    longaction = ET.SubElement(element,&#39;LongitudinalAction&#39;)
    speedaction = ET.SubElement(longaction,&#39;SpeedAction&#39;)
    speedaction.append(self.transition_dynamics.get_element(&#39;SpeedActionDynamics&#39;))
    speedactiontarget = ET.SubElement(speedaction,&#39;SpeedActionTarget&#39;)
    
    ET.SubElement(speedactiontarget,&#39;RelativeTargetSpeed&#39;,self.get_attributes())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction"><code class="flex name class">
<span>class <span class="ident">SynchronizeAction</span></span>
<span>(</span><span>entity, entity_PositionType:scenariogeneration.xosc.utils._PositionType, target_PositionType:scenariogeneration.xosc.utils._PositionType, target_tolerance_master=None, target_tolerance=None, final_speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronizes an entity's arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

speed (double): the absolute speed of the target that should syncronize

target_tolerance_master (optional) (double): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (double): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

speed (double): the absolute speed of the target that should syncronize

target_tolerance_master (optional) (double): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (double): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalize the SynchronizeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

speed (double): the absolute speed of the target that should syncronize

target_tolerance_master (optional) (double): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (double): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynchronizeAction(_PrivateActionType):
    &#34;&#34;&#34; Synchronizes an entity&#39;s arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.
        
        Parameters
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            speed (double): the absolute speed of the target that should syncronize

            target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
                Default: None
        Attributes
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            speed (double): the absolute speed of the target that should syncronize

            target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self, entity, entity_PositionType:_PositionType, target_PositionType:_PositionType,target_tolerance_master=None,target_tolerance=None,final_speed=None):
        &#34;&#34;&#34; initalize the SynchronizeAction

            Parameters
            ----------
                entity (str): entity to syncronize with

                entity_PositionType (*Position): the position of the entity to syncronize to

                target_PositionType (*Position): the position of the target that should syncronize

                speed (double): the absolute speed of the target that should syncronize

                target_tolerance_master (optional) (double): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

                target_tolerance (optional) (double): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

                final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
                Default: None
        &#34;&#34;&#34;
        
        self.entity = entity
        if not isinstance(entity_PositionType,_PositionType):
            raise TypeError(&#39;entity_PositionType input is not a valid Position&#39;)
        
        if not isinstance(target_PositionType,_PositionType):
            raise TypeError(&#39;target_PositionType input is not a valid Position&#39;)
        self.entity_PositionType = entity_PositionType
        self.target_PositionType = target_PositionType
        self.target_tolerance_master = target_tolerance_master
        self.target_tolerance = target_tolerance
        if final_speed and not (isinstance(final_speed,AbsoluteSpeed) or isinstance(final_speed,RelativeSpeedToMaster)):
            raise TypeError(&#39;final_speed input is not AbsoluteSpeed or RelativeSpeedToMaster type&#39;)
        else:
            self.final_speed = final_speed

    def __eq__(self,other):
        if isinstance(other,SynchronizeAction):
            if self.get_attributes() == other.get_attributes() and \
            self.entity_PositionType == other.entity_PositionType and \
            self.target_PositionType == other.target_PositionType and \
            self.final_speed == other.final_speed:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSynchronizeAction as a dict

        &#34;&#34;&#34;
        attr = {&#39;masterEntityRef&#39;:self.entity}
        if self.isVersion(1, 0):
            return attr
        if self.target_tolerance_master is not None:
            attr.update({&#39;targetToleranceMaster&#39;: str(self.target_tolerance_master)})
        if self.target_tolerance is not None:
            attr.update({&#39;targetTolerance&#39;: str(self.target_tolerance)})
        return attr

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSynchronizeAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        syncaction = ET.SubElement(element,&#39;SynchronizeAction&#39;,self.get_attributes())
        syncaction.append(self.entity_PositionType.get_element(&#39;TargetPositionMaster&#39;))
        syncaction.append(self.target_PositionType.get_element(&#39;TargetPosition&#39;))
        if self.final_speed is not None:
            syncaction.append(self.final_speed.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSynchronizeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteSynchronizeAction as a dict

    &#34;&#34;&#34;
    attr = {&#39;masterEntityRef&#39;:self.entity}
    if self.isVersion(1, 0):
        return attr
    if self.target_tolerance_master is not None:
        attr.update({&#39;targetToleranceMaster&#39;: str(self.target_tolerance_master)})
    if self.target_tolerance is not None:
        attr.update({&#39;targetTolerance&#39;: str(self.target_tolerance)})
    return attr</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSynchronizeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteSynchronizeAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    syncaction = ET.SubElement(element,&#39;SynchronizeAction&#39;,self.get_attributes())
    syncaction.append(self.entity_PositionType.get_element(&#39;TargetPositionMaster&#39;))
    syncaction.append(self.target_PositionType.get_element(&#39;TargetPosition&#39;))
    if self.final_speed is not None:
        syncaction.append(self.final_speed.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TeleportAction"><code class="flex name class">
<span>class <span class="ident">TeleportAction</span></span>
<span>(</span><span>position)</span>
</code></dt>
<dd>
<div class="desc"><p>the TeleportAction creates the Teleport action of OpenScenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): any position object
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>position (*Position): any position object
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the TeleportAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>position (*Position): any position object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TeleportAction(_PrivateActionType):
    &#34;&#34;&#34; the TeleportAction creates the Teleport action of OpenScenario
        
        Parameters
        ----------
            position (*Position): any position object

        Attributes
        ----------
            position (*Position): any position object


        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,position):
        &#34;&#34;&#34; initalizes the TeleportAction

        Parameters
        ----------
            position (*Position): any position object

        &#34;&#34;&#34;
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input not a valid Position type&#39;)        

        self.position = position

    def __eq__(self,other):
        if isinstance(other,TeleportAction):
            if self.position == other.position:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TeleportAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        telact = ET.SubElement(element,&#39;TeleportAction&#39;)
        telact.append(self.position.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TeleportAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TeleportAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TeleportAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    telact = ET.SubElement(element,&#39;TeleportAction&#39;)
    telact.append(self.position.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalControllerAction</span></span>
<span>(</span><span>phase, traffic_signalcontroller_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalControllerAction(_ActionType):
    &#34;&#34;&#34; The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal
        
        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        Attributes
        ----------

            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,phase,traffic_signalcontroller_ref):
        &#34;&#34;&#34; initalize the TrafficSignalControllerAction

        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        &#34;&#34;&#34;
        self.phase = phase
        self.traffic_signalcontroller_ref = traffic_signalcontroller_ref

    def __eq__(self,other):
        if isinstance(other,TrafficSignalControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalControllerAction as a dict

        &#34;&#34;&#34;
        return {&#39;phase&#39;:self.phase,&#39;trafficSignalControllerRef&#39;:self.traffic_signalcontroller_ref}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalControllerAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
        tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
        ET.SubElement(tsa,&#39;TrafficSignalControllerAction&#39;,self.get_attributes())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalControllerAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSignalControllerAction as a dict

    &#34;&#34;&#34;
    return {&#39;phase&#39;:self.phase,&#39;trafficSignalControllerRef&#39;:self.traffic_signalcontroller_ref}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSignalControllerAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
    tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
    ET.SubElement(tsa,&#39;TrafficSignalControllerAction&#39;,self.get_attributes())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalStateAction</span></span>
<span>(</span><span>name, state)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalStateAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalStateAction(_ActionType):
    &#34;&#34;&#34; The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal
        
        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        Attributes
        ----------

            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,name,state):
        &#34;&#34;&#34; initalize the TrafficSignalStateAction

        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self,other):
        if isinstance(other,TrafficSignalStateAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalStateAction as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name,&#39;state&#39;:self.state}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalStateAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
        tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
        ET.SubElement(tsa,&#39;TrafficSignalStateAction&#39;,self.get_attributes())
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalStateAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSignalStateAction as a dict

    &#34;&#34;&#34;
    return {&#39;name&#39;:self.name,&#39;state&#39;:self.state}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalStateAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSignalStateAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    infra = ET.SubElement(element,&#39;InfrastructureAction&#39;)
    tsa = ET.SubElement(infra,&#39;TrafficSignalAction&#39;)
    ET.SubElement(tsa,&#39;TrafficSignalStateAction&#39;,self.get_attributes())
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction"><code class="flex name class">
<span>class <span class="ident">TrafficSinkAction</span></span>
<span>(</span><span>rate, radius, position, trafficdefinition, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the sink around the position

position (*Position): any Position to define the sink

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSinkAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSinkAction(_ActionType):
    &#34;&#34;&#34; The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction
        
        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the sink around the position

            position (*Position): any Position to define the sink

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

        Attributes
        ----------

            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,rate,radius,position,trafficdefinition,name=None):
        &#34;&#34;&#34; initalize the TrafficSinkAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        &#34;&#34;&#34;
        self.rate = rate
        self.radius = radius
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input is not a valid Position&#39;)
        
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSinkAction):
            if self.get_attributes() == other.get_attributes() and \
            self.position == other.position and \
            self.trafficdefinition == other.trafficdefinition:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSinkAction as a dict

        &#34;&#34;&#34;
        retdict = {}

        retdict[&#39;rate&#39;] = str(self.rate)
        retdict[&#39;radius&#39;] = str(self.radius)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSinkAction

        &#34;&#34;&#34;

        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        sinkaction = ET.SubElement(trafficaction,&#39;TrafficSinkAction&#39;,attrib=self.get_attributes())
        sinkaction.append(self.position.get_element())
        sinkaction.append(self.trafficdefinition.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSinkAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSinkAction as a dict

    &#34;&#34;&#34;
    retdict = {}

    retdict[&#39;rate&#39;] = str(self.rate)
    retdict[&#39;radius&#39;] = str(self.radius)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSinkAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSinkAction

    &#34;&#34;&#34;

    element = ET.Element(&#39;GlobalAction&#39;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#39;trafficName&#39;:self.name}
    trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
    sinkaction = ET.SubElement(trafficaction,&#39;TrafficSinkAction&#39;,attrib=self.get_attributes())
    sinkaction.append(self.position.get_element())
    sinkaction.append(self.trafficdefinition.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction"><code class="flex name class">
<span>class <span class="ident">TrafficSourceAction</span></span>
<span>(</span><span>rate, radius, position, trafficdefinition, velocity=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSourceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSourceAction(_ActionType):
    &#34;&#34;&#34; The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction
        
        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

        Attributes
        ----------

            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,rate,radius,position,trafficdefinition,velocity = None,name=None):
        &#34;&#34;&#34; initalize the TrafficSourceAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.rate = rate
        self.radius = radius
        if not isinstance(position,_PositionType):
            raise TypeError(&#39;position input is not a valid Position&#39;)
        
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.velocity = velocity
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSourceAction):
            if self.get_attributes() == other.get_attributes() and \
            self.position == other.position and \
            self.trafficdefinition == other.trafficdefinition and \
            self.name == other.name:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSourceAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;rate&#39;] = str(self.rate)
        retdict[&#39;radius&#39;] = str(self.radius)
        if self.velocity is not None:
            retdict[&#39;velocity&#39;] = str(self.velocity)
        

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSourceAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        sourceaction = ET.SubElement(trafficaction,&#39;TrafficSourceAction&#39;,attrib=self.get_attributes())
        sourceaction.append(self.position.get_element())
        sourceaction.append(self.trafficdefinition.get_element())

        
        
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSourceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSourceAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;rate&#39;] = str(self.rate)
    retdict[&#39;radius&#39;] = str(self.radius)
    if self.velocity is not None:
        retdict[&#39;velocity&#39;] = str(self.velocity)
    

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSourceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSourceAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#39;trafficName&#39;:self.name}
    
    trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
    sourceaction = ET.SubElement(trafficaction,&#39;TrafficSourceAction&#39;,attrib=self.get_attributes())
    sourceaction.append(self.position.get_element())
    sourceaction.append(self.trafficdefinition.get_element())

    
    
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction"><code class="flex name class">
<span>class <span class="ident">TrafficStopAction</span></span>
<span>(</span><span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction </p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the Traffic to stop
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the Traffic to stop
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSwarmAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the Traffic to stop
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficStopAction(_ActionType):
    &#34;&#34;&#34; The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction 
        
        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None

        Attributes
        ----------

            name (str): name of the Traffic to stop

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,name = None):
        &#34;&#34;&#34; initalize the TrafficSwarmAction

        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None
        &#34;&#34;&#34;
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficStopAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficStopAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.name and not self.isVersion(minor=0):
            retdict[&#39;trafficName&#39;] = str(self.name)
        elif self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;TrafficStopAction was introduced in OpenSCENARIO V1.1&#39;)

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficStopAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=self.get_attributes())
        ET.SubElement(trafficaction,&#39;TrafficStopAction&#39;)      

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficStopAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficStopAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    if self.name and not self.isVersion(minor=0):
        retdict[&#39;trafficName&#39;] = str(self.name)
    elif self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;TrafficStopAction was introduced in OpenSCENARIO V1.1&#39;)

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficStopAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficStopAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=self.get_attributes())
    ET.SubElement(trafficaction,&#39;TrafficStopAction&#39;)      

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction"><code class="flex name class">
<span>class <span class="ident">TrafficSwarmAction</span></span>
<span>(</span><span>semimajoraxis, semiminoraxis, innerradius, offset, numberofvehicles, centralobject, trafficdefinition, velocity=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner cirvle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner cirvle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSwarmAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner circle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSwarmAction(_ActionType):
    &#34;&#34;&#34; The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction
        
        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner cirvle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None
            
            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        Attributes
        ----------

            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner cirvle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                
        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self,semimajoraxis,semiminoraxis,innerradius,offset,numberofvehicles,centralobject,trafficdefinition,velocity = None,name = None):
        &#34;&#34;&#34; initalize the TrafficSwarmAction

        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner circle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None
            
            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.semimajoraxis = semimajoraxis
        self.semiminoraxis = semiminoraxis
        self.innerradius = innerradius
        self.offset = offset
        self.numberofvehicles = numberofvehicles
        self.centralobject = centralobject
        if not isinstance(trafficdefinition,TrafficDefinition):
            raise TypeError(&#39;trafficdefinition input is not of type TrafficDefinition&#39;)
        self.trafficdefinition = trafficdefinition
        self.velocity = velocity
        self.name = name

    def __eq__(self,other):
        if isinstance(other,TrafficSwarmAction):
            if self.get_attributes() == other.get_attributes() and \
            self.centralobject == other.centralobject and \
            self.trafficdefinition == other.trafficdefinition and \
            self.name == other.name:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSwarmAction as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;semiMajorAxis&#39;] = str(self.semimajoraxis)
        retdict[&#39;semiMinorAxis&#39;] = str(self.semiminoraxis)
        retdict[&#39;innerRadius&#39;] = str(self.innerradius)
        retdict[&#39;offset&#39;] = str(self.offset)
        retdict[&#39;numberOfVehicles&#39;] = str(self.numberofvehicles)
        if self.velocity is not None:
            retdict[&#39;velocity&#39;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSwarmAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;GlobalAction&#39;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#39;trafficName&#39;:self.name}
        trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
        
        swarmaction = ET.SubElement(trafficaction,&#39;TrafficSwarmAction&#39;,attrib=self.get_attributes())
        swarmaction.append(self.trafficdefinition.get_element())
        ET.SubElement(swarmaction,&#39;CentralSwarmObject&#39;,attrib={&#39;entityRef&#39;:self.centralobject})

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSwarmAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSwarmAction as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;semiMajorAxis&#39;] = str(self.semimajoraxis)
    retdict[&#39;semiMinorAxis&#39;] = str(self.semiminoraxis)
    retdict[&#39;innerRadius&#39;] = str(self.innerradius)
    retdict[&#39;offset&#39;] = str(self.offset)
    retdict[&#39;numberOfVehicles&#39;] = str(self.numberofvehicles)
    if self.velocity is not None:
        retdict[&#39;velocity&#39;] = str(self.velocity)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSwarmAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSwarmAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;GlobalAction&#39;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#39;trafficName&#39;:self.name}
    trafficaction = ET.SubElement(element, &#39;TrafficAction&#39;,attrib=traffic_attrib)
    
    swarmaction = ET.SubElement(trafficaction,&#39;TrafficSwarmAction&#39;,attrib=self.get_attributes())
    swarmaction.append(self.trafficdefinition.get_element())
    ET.SubElement(swarmaction,&#39;CentralSwarmObject&#39;,attrib={&#39;entityRef&#39;:self.centralobject})

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction"><code class="flex name class">
<span>class <span class="ident">VisibilityAction</span></span>
<span>(</span><span>graphics, traffic, sensors)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a VisibilityAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>graphics (boolean): visible for graphics or not

traffic (boolean): visible for traffic

sensors (boolean): visible to sensors or not
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>graphics (boolean): visible for graphics or not

traffic (boolean): visible for traffic

sensors (boolean): visible to sensors or not
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalizes the VisibilityAction</p>
<h2 id="parameters_1">Parameters</h2>
<p>graphics (boolean): visible for graphics or not</p>
<p>traffic (boolean): visible for traffic</p>
<p>sensors (boolean): visible to sensors or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisibilityAction(_PrivateActionType):
    &#34;&#34;&#34; creates a VisibilityAction
        
        Parameters
        ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        Attributes
        ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the the attributes of the class

    &#34;&#34;&#34;
    def __init__(self,graphics, traffic, sensors):
        &#34;&#34;&#34; initalizes the VisibilityAction

            Parameters
            ----------
            graphics (boolean): visible for graphics or not

            traffic (boolean): visible for traffic

            sensors (boolean): visible to sensors or not

        &#34;&#34;&#34;
        if not isinstance(graphics,bool):
            raise TypeError(&#39;graphics input is not of type bool&#39;)
        if not isinstance(traffic,bool):
            raise TypeError(&#39;traffic input is not of type bool&#39;)
        if not isinstance(sensors,bool):
            raise TypeError(&#39;sensors input is not of type bool&#39;)
        self.graphics = graphics
        self.traffic = traffic
        self.sensors = sensors

    def __eq__(self,other):
        if isinstance(other,VisibilityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

        &#34;&#34;&#34;
        return {&#39;graphics&#39;:convert_bool(self.graphics),&#39;traffic&#39;:convert_bool(self.traffic),&#39;sensors&#39;:convert_bool(self.sensors)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the VisibilityAction

        &#34;&#34;&#34;
        element = ET.Element(&#39;PrivateAction&#39;)
        ET.SubElement(element,&#39;VisibilityAction&#39;,self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the VisibilityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the VisibilityAction as a dict

    &#34;&#34;&#34;
    return {&#39;graphics&#39;:convert_bool(self.graphics),&#39;traffic&#39;:convert_bool(self.traffic),&#39;sensors&#39;:convert_bool(self.sensors)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the VisibilityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the VisibilityAction

    &#34;&#34;&#34;
    element = ET.Element(&#39;PrivateAction&#39;)
    ET.SubElement(element,&#39;VisibilityAction&#39;,self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction">AbsoluteSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction" href="#scenariogeneration.xosc.actions.AcquirePositionAction">AcquirePositionAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction.get_element" href="#scenariogeneration.xosc.actions.AcquirePositionAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_element" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AddEntityAction" href="#scenariogeneration.xosc.actions.AddEntityAction">AddEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.AddEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_element" href="#scenariogeneration.xosc.actions.AddEntityAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_element" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignRouteAction" href="#scenariogeneration.xosc.actions.AssignRouteAction">AssignRouteAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignRouteAction.get_element" href="#scenariogeneration.xosc.actions.AssignRouteAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.add_element" href="#scenariogeneration.xosc.actions.CustomCommandAction.add_element">add_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.get_element" href="#scenariogeneration.xosc.actions.CustomCommandAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction" href="#scenariogeneration.xosc.actions.DeleteEntityAction">DeleteEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_element" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.EnvironmentAction" href="#scenariogeneration.xosc.actions.EnvironmentAction">EnvironmentAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.get_attributes" href="#scenariogeneration.xosc.actions.EnvironmentAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.get_element" href="#scenariogeneration.xosc.actions.EnvironmentAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction">FollowTrajectoryAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction" href="#scenariogeneration.xosc.actions.LateralDistanceAction">LateralDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction">LongitudinalDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LongitudinalTimegapAction" href="#scenariogeneration.xosc.actions.LongitudinalTimegapAction">LongitudinalTimegapAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_attributes" href="#scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_element" href="#scenariogeneration.xosc.actions.LongitudinalTimegapAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake">set_brake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch">set_clutch</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear">set_gear</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake">set_parkingbrake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel">set_steeringwheel</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle">set_throttle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterAddAction" href="#scenariogeneration.xosc.actions.ParameterAddAction">ParameterAddAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_element" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction">ParameterMultiplyAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterSetAction" href="#scenariogeneration.xosc.actions.ParameterSetAction">ParameterSetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_element" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction">RelativeLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction">RelativeLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction" href="#scenariogeneration.xosc.actions.RelativeSpeedAction">RelativeSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SynchronizeAction" href="#scenariogeneration.xosc.actions.SynchronizeAction">SynchronizeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_element" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TeleportAction" href="#scenariogeneration.xosc.actions.TeleportAction">TeleportAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TeleportAction.get_element" href="#scenariogeneration.xosc.actions.TeleportAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction">TrafficSignalControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction">TrafficSignalStateAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction" href="#scenariogeneration.xosc.actions.TrafficSinkAction">TrafficSinkAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction" href="#scenariogeneration.xosc.actions.TrafficSourceAction">TrafficSourceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficStopAction" href="#scenariogeneration.xosc.actions.TrafficStopAction">TrafficStopAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_element" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction" href="#scenariogeneration.xosc.actions.TrafficSwarmAction">TrafficSwarmAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_attributes" href="#scenariogeneration.xosc.actions.VisibilityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_element" href="#scenariogeneration.xosc.actions.VisibilityAction.get_element">get_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>