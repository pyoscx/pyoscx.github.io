<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scenariogeneration.xosc.actions API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.actions</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  scenariogeneration
  https://github.com/pyoscx/scenariogeneration

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  Copyright (c) 2022 The scenariogeneration Authors.

&#34;&#34;&#34;

import xml.etree.ElementTree as ET


from .utils import (
    DynamicsConstraints,
    EntityRef,
    TimeReference,
    TrafficSignalController,
    convert_bool,
    TransitionDynamics,
    CatalogReference,
    TrafficDefinition,
    Environment,
    AbsoluteSpeed,
    RelativeSpeedToMaster,
    convert_float,
    convert_int,
    get_bool_string,
    convert_enum,
    _AnimationType,
    _VehicleComponent,
    _ComponentAnimation,
    UserDefinedComponent,
    _AnimationTypeFactory,
)
from .utils import (
    Controller,
    _PositionType,
    Color,
    UserDefinedLight,
    _LightState,
    DirectionOfTravelDistribution,
)

from .enumerations import (
    CoordinateSystem,
    DynamicsShapes,
    LateralDisplacement,
    SpeedTargetValueType,
    FollowingMode,
    VersionBase,
    LongitudinalDisplacement,
    DynamicsShapes,
    VehicleLightType,
    LightMode,
    AutomaticGearType,
    VehicleComponentType,
)
from .exceptions import (
    NoActionsDefinedError,
    NotAValidElement,
    OpenSCENARIOVersionError,
    NotEnoughInputArguments,
    ToManyOptionalArguments,
)
from .position import _PositionFactory, Route, Trajectory

from .parameters import Range


class _GlobalActionFactory:
    @staticmethod
    def parse_globalaction(element):
        if element.findall(&#34;EnvironmentAction&#34;):
            return EnvironmentAction.parse(element)
        elif element.findall(&#34;EntityAction/AddEntityAction&#34;):
            return AddEntityAction.parse(element)
        elif element.findall(&#34;EntityAction/DeleteEntityAction&#34;):
            return DeleteEntityAction.parse(element)
        elif element.findall(&#34;ParameterAction/ModifyAction/Rule/AddValue&#34;):
            return ParameterAddAction.parse(element)
        elif element.findall(&#34;ParameterAction/ModifyAction/Rule/MultiplyByValue&#34;):
            return ParameterMultiplyAction.parse(element)
        elif element.findall(&#34;ParameterAction/SetAction&#34;):
            return ParameterSetAction.parse(element)
        elif element.findall(&#34;VariableAction/ModifyAction/Rule/AddValue&#34;):
            return VariableAddAction.parse(element)
        elif element.findall(&#34;VariableAction/ModifyAction/Rule/MultiplyByValue&#34;):
            return VariableMultiplyAction.parse(element)
        elif element.findall(&#34;VariableAction/SetAction&#34;):
            return VariableSetAction.parse(element)
        elif element.findall(
            &#34;InfrastructureAction/TrafficSignalAction/TrafficSignalStateAction&#34;
        ):
            return TrafficSignalStateAction.parse(element)
        elif element.findall(
            &#34;InfrastructureAction/TrafficSignalAction/TrafficSignalControllerAction&#34;
        ):
            return TrafficSignalControllerAction.parse(element)
        elif element.findall(&#34;TrafficAction/TrafficSourceAction&#34;):
            return TrafficSourceAction.parse(element)
        elif element.findall(&#34;TrafficAction/TrafficSinkAction&#34;):
            return TrafficSinkAction.parse(element)
        elif element.findall(&#34;TrafficAction/TrafficSwarmAction&#34;):
            return TrafficSwarmAction.parse(element)
        elif element.findall(&#34;TrafficAction/TrafficStopAction&#34;):
            return TrafficStopAction.parse(element)
        else:
            raise NotAValidElement(&#34;element &#34;, element, &#34;is not a valid GlobalAction&#34;)


class _PrivateActionFactory:
    @staticmethod
    def parse_privateaction(element):
        if element.findall(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;
        ):
            return AbsoluteSpeedAction.parse(element)
        elif element.findall(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;
        ):
            return RelativeSpeedAction.parse(element)
        elif element.findall(&#34;LongitudinalAction/LongitudinalDistanceAction&#34;):
            return LongitudinalDistanceAction.parse(element)
        elif element.findall(
            &#34;LateralAction/LaneChangeAction/LaneChangeTarget/AbsoluteTargetLane&#34;
        ):
            return AbsoluteLaneChangeAction.parse(element)
        elif element.findall(
            &#34;LateralAction/LaneChangeAction/LaneChangeTarget/RelativeTargetLane&#34;
        ):
            return RelativeLaneChangeAction.parse(element)
        elif element.findall(
            &#34;LateralAction/LaneOffsetAction/LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;
        ):
            return AbsoluteLaneOffsetAction.parse(element)
        elif element.findall(
            &#34;LateralAction/LaneOffsetAction/LaneOffsetTarget/RelativeTargetLaneOffset&#34;
        ):
            return RelativeLaneOffsetAction.parse(element)
        elif element.findall(&#34;LateralAction/LateralDistanceAction&#34;):
            return LateralDistanceAction.parse(element)
        elif element.findall(&#34;VisibilityAction&#34;):
            return VisibilityAction.parse(element)
        elif element.findall(&#34;SynchronizeAction&#34;):
            return SynchronizeAction.parse(element)
        elif element.findall(&#34;ActivateControllerAction&#34;):
            return ActivateControllerAction.parse(element)
        elif element.findall(&#34;ControllerAction&#34;):
            return ControllerAction.parse(element)
        elif element.findall(&#34;TeleportAction&#34;):
            return TeleportAction.parse(element)
        elif element.findall(&#34;RoutingAction/AssignRouteAction&#34;):
            return AssignRouteAction.parse(element)
        elif element.findall(&#34;RoutingAction/FollowTrajectoryAction&#34;):
            return FollowTrajectoryAction.parse(element)
        elif element.findall(&#34;RoutingAction/AcquirePositionAction&#34;):
            return AcquirePositionAction.parse(element)
        elif element.findall(&#34;AppearanceAction/AnimationAction&#34;):
            return AnimationAction.parse(element)
        elif element.findall(&#34;LongitudinalAction/SpeedProfileAction&#34;):
            return SpeedProfileAction.parse(element)
        elif element.findall(&#34;AppearanceAction/LightStateAction&#34;):
            return LightStateAction.parse(element)
        else:
            raise NotAValidElement(&#34;element &#34;, element, &#34;is not a valid PrivateAction&#34;)


class _ActionType(VersionBase):
    &#34;&#34;&#34;helper class for typesetting&#34;&#34;&#34;

    pass


class _PrivateActionType(_ActionType):
    &#34;&#34;&#34;helper class for typesetting&#34;&#34;&#34;

    pass


class _Action(VersionBase):
    &#34;&#34;&#34;Private class used to define an action, should not be used by the user.
    Used as a wrapper to create the extra elements needed

    Parameters
    ----------
        name (str): name of the action

        action (*Action): any action

    Attributes
    ----------
        name (str): name of the action

        action (*Action): any action

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, action):
        &#34;&#34;&#34;initalize _Action

        Parameters
        ----------
            name (str): name of the action

            action (*Action): any action

        &#34;&#34;&#34;
        self.name = name

        self.action = action

    def __eq__(self, other):
        if isinstance(other, _Action):
            if (
                self.get_attributes() == other.get_attributes()
                and self.action == other.action
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of _Action

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A _Action element (same as generated by the class itself)

        Returns
        -------
            action (_Action): a _Action object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        if element.find(&#34;PrivateAction&#34;) is not None:
            action = _PrivateActionFactory.parse_privateaction(
                element.find(&#34;PrivateAction&#34;)
            )
        elif element.find(&#34;GlobalAction&#34;) is not None:
            action = _GlobalActionFactory.parse_globalaction(
                element.find(&#34;GlobalAction&#34;)
            )
        elif element.find(&#34;UserDefinedAction&#34;) is not None:
            action = UserDefinedAction.parse(element)
        else:
            raise NotAValidElement(element.tag, &#34;is not a valid action&#34;)
        return _Action(name, action)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the _Action as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: self.name}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the _Action&#34;&#34;&#34;
        element = ET.Element(&#34;Action&#34;, attrib=self.get_attributes())
        element.append(self.action.get_element())
        return element


#### Private Actions ####

# LongitudinalAction


class AbsoluteSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed

    Parameters
    ----------
        speed (float): the speed wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Attributes
    ----------

        speed (float): the speed wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, speed: float, transition_dynamics):
        &#34;&#34;&#34;initalize the AbsoluteSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, AbsoluteSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of WorldPosition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            position (WorldPosition): a world position object

        &#34;&#34;&#34;
        speed_element = element.find(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;
        )
        td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
        speed = speed_element.attrib[&#34;value&#34;]
        transition_dynamics = TransitionDynamics.parse(td_element)
        return AbsoluteSpeedAction(speed, transition_dynamics)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)

        speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(speedactiontarget, &#34;AbsoluteTargetSpeed&#34;, self.get_attributes())

        return element


class RelativeSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target

    Parameters
    ----------
        speed (float): the speed wanted

        target (str): the name of the relative target (used for relative speed)

        transition_dynamics (TransitionDynamics): how the change should be made

        valuetype (str): the type of relative speed wanted (used for relative speed)

        continuous (bool): if the controller tries to keep the relative speed

    Attributes
    ----------
        speed (float): the speed wanted

        target (str): the name of the relative target (used for relative speed)

        valuetype (str): the type of relative speed wanted (used for relative speed)

        continuous (bool): if the controller tries to keep the relative speed

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        speed,
        entity,
        transition_dynamics,
        valuetype=SpeedTargetValueType.delta,
        continuous=True,
    ):
        &#34;&#34;&#34;initalizes RelativeSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (SpeedTargetValueType): the type of relative speed wanted

            continuous (bool): if the controller tries to keep the relative speed

        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        self.target = entity
        if not hasattr(SpeedTargetValueType, str(valuetype)):
            raise TypeError(&#34;valuetype input not of type SpeedTargetValueType&#34;)
        self.valuetype = valuetype

        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics
        self.continuous = convert_bool(continuous)

    def __eq__(self, other):
        if isinstance(other, RelativeSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeSpeedAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            action (RelativeSpeedAction): the RelativeSpeedAction

        &#34;&#34;&#34;
        speed_element = element.find(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;
        )
        td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
        speed = speed_element.attrib[&#34;value&#34;]
        entity = speed_element.attrib[&#34;entityRef&#34;]
        continuous = convert_bool(speed_element.attrib[&#34;continuous&#34;])
        valuetype = getattr(
            SpeedTargetValueType, speed_element.attrib[&#34;speedTargetValueType&#34;]
        )
        transition_dynamics = TransitionDynamics.parse(td_element)
        return RelativeSpeedAction(
            speed, entity, transition_dynamics, valuetype, continuous
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeSpeedAction as a dict&#34;&#34;&#34;
        return {
            &#34;entityRef&#34;: self.target,
            &#34;value&#34;: str(self.speed),
            &#34;speedTargetValueType&#34;: self.valuetype.get_name(),
            &#34;continuous&#34;: get_bool_string(self.continuous),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeSpeedAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)
        speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(speedactiontarget, &#34;RelativeTargetSpeed&#34;, self.get_attributes())

        return element


class LongitudinalDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;The LongitudinalAction creates a LongitudinalAction of type LongitudinalAction with a distance target

    Parameters
    ----------
        distance (float): distance to the entity

        entity (str): the target name

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

        max_acceleration (float): maximum acceleration allowed
            Default: None

        max_deceleration (float): maximum deceleration allowed
            Default: None

        max_speed (float): maximum speed allowed
            Default: None

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
            Default CoordinateSystem.entity

        displacement (LongitudinalDisplacement): type of displacement wanted
            Default LongitudinalDisplacement.any

    Attributes
    ----------
        entity (str): the target name

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        continuous (bool): if the controller tries to keep the relative speed

        distance (float): the distance to the entity

        dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

        displacement (LongitudinalDisplacement): type of displacement wanted

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        freespace=True,
        continuous=True,
        max_acceleration=None,
        max_deceleration=None,
        max_speed=None,
        distance=None,
        timeGap=None,
        coordinate_system=CoordinateSystem.entity,
        displacement=LongitudinalDisplacement.any,
    ):
        &#34;&#34;&#34;initalize the LongitudinalDistanceAction

        Parameters
        ----------
            distance (float): distance to the entity

            timegap (float): time to the target

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
        &#34;&#34;&#34;
        self.target = entity
        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration, max_deceleration, max_speed
        )

        if distance is not None and timeGap is not None:
            raise ToManyOptionalArguments(
                &#34;Not both of distance and timeGap can be used.&#34;
            )
        if distance is None and timeGap is None:
            raise NotEnoughInputArguments(&#34;Either ds or dsLane is needed as input.&#34;)
        self.distance = convert_float(distance)
        self.timeGap = convert_float(timeGap)

        self.coordinate_system = convert_enum(coordinate_system, CoordinateSystem)
        self.displacement = convert_enum(displacement, LongitudinalDisplacement)

    def __eq__(self, other):
        if isinstance(other, LongitudinalDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LongitudinalAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LongitudinalDistanceAction element (same as generated by the class itself)

        Returns
        -------
            ld_action (LongitudinalDistanceAction): a LongitudinalDistanceAction object

        &#34;&#34;&#34;
        lda_element = element.find(&#34;LongitudinalAction/LongitudinalDistanceAction&#34;)
        entity = lda_element.attrib[&#34;entityRef&#34;]
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        distance = None
        timeGap = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = convert_float(lda_element.attrib[&#34;distance&#34;])
        if &#34;timeGap&#34; in lda_element.attrib:
            timeGap = convert_float(lda_element.attrib[&#34;timeGap&#34;])

        coordinate_system = CoordinateSystem.entity
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate_system = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem, False
            )
        displacement = LongitudinalDisplacement.any
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;], LongitudinalDisplacement, False
            )
        max_acceleration = None
        max_deceleration = None
        max_speed = None
        constraints = None
        if lda_element.find(&#34;DynamicConstraints&#34;) != None:
            constraints = DynamicsConstraints.parse(
                lda_element.find(&#34;DynamicConstraints&#34;)
            )
            max_acceleration = constraints.max_acceleration
            max_deceleration = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LongitudinalDistanceAction(
            entity,
            freespace,
            continuous,
            max_acceleration,
            max_deceleration,
            max_speed,
            distance,
            timeGap,
            coordinate_system,
            displacement,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LongitudinalDistanceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance != None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if self.timeGap != None:
            retdict[&#34;timeGap&#34;] = str(self.timeGap)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LongitudinalDistanceAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longact = ET.SubElement(element, &#34;LongitudinalAction&#34;)

        longdistaction = ET.SubElement(
            longact, &#34;LongitudinalDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element


class SpeedProfileAction(_PrivateActionType):
    &#34;&#34;&#34;The SpeedProfileAction class specifies a LongitudinalAction of type SpeedProfileAction

    Parameters
    ----------
        speeds (list of float): the different speed entries wanted

        following_mode (FollowingMode): how to follow the speed changes

        times (list of float): optional time entries when the speed entries should be achieved
            Default: None

        dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
            Default: None

        entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
            Default: None

    Attributes
    ----------

        speeds (list of float): the different speed entries wanted

        following_mode (FollowingMode): how to follow the speed changes

        times (list of float): optional time entries when the speed entries should be achieved

        dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile

        entity (str): name of an entity, the speeds will then be interpreted as relative to that entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self, speeds, following_mode, times=None, dynamics_constraint=None, entity=None
    ):
        &#34;&#34;&#34;initalize the SpeedProfileAction

        Parameters
        ----------
            speeds (list of float): the different speed entries wanted

            following_mode (FollowingMode): how to follow the speed changes

            times (list of float): optional time entries when the speed entries should be achieved
                Default: None

            dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
                Default: None

            entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
                Default: None

        &#34;&#34;&#34;
        if times and (len(times) != len(speeds)):
            raise ValueError(&#34;times and speeds are not the same lenght&#34;)
        self.speeds = [convert_float(x) for x in speeds]
        if dynamics_constraint and not isinstance(
            dynamics_constraint, DynamicsConstraints
        ):
            raise TypeError(&#34;dynamics_constraint input not of type DynamicsConstraints&#34;)
        self.dynamics_constraint = dynamics_constraint
        self.following_mode = convert_enum(following_mode, FollowingMode)
        if times:
            self.times = [convert_float(x) for x in times]
        else:
            self.times = times
        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, SpeedProfileAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamics_constraint == other.dynamics_constraint
                and self.entity == other.entity
                and self.speeds == other.speeds
                and self.times == other.times
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SpeedProfileAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A SpeedProfileAction element (same as generated by the class itself)

        Returns
        -------
            action (SpeedProfileAction): a SpeedProfileAction object

        &#34;&#34;&#34;
        speed_profile_element = element.find(&#34;LongitudinalAction/SpeedProfileAction&#34;)
        following_mode = convert_enum(
            speed_profile_element.attrib[&#34;followingMode&#34;], FollowingMode
        )
        dynamics_constraint = None
        entity = None

        if &#34;entityRef&#34; in speed_profile_element.attrib:
            entity = speed_profile_element.attrib[&#34;entityRef&#34;]
        if speed_profile_element.find(&#34;DynamicConstraints&#34;) is not None:
            dynamics_constraint = DynamicsConstraints.parse(
                speed_profile_element.find(&#34;DynamicConstraints&#34;)
            )

        entires = speed_profile_element.findall(&#34;SpeedProfileEntry&#34;)
        speeds = []
        times = []
        for i in entires:
            if &#34;time&#34; in i.attrib:
                times.append(convert_float(i.attrib[&#34;time&#34;]))
            speeds.append(convert_float(i.attrib[&#34;speed&#34;]))

        return SpeedProfileAction(
            speeds, following_mode, times, dynamics_constraint, entity
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SpeedProfileAction as a dict&#34;&#34;&#34;
        retdict = {&#34;followingMode&#34;: self.following_mode.get_name()}
        if self.entity:
            retdict[&#34;entityRef&#34;] = self.entity
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SpeedProfileAction&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;SpeedProfileAction was introduced in OpenSCENARIO V1.2&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(
            longaction, &#34;SpeedProfileAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamics_constraint is not None:
            speedaction.append(self.dynamics_constraint.get_element())

        for i in range(len(self.speeds)):
            tmp_dict = {&#34;speed&#34;: str(self.speeds[i])}
            if self.times:
                tmp_dict[&#34;time&#34;] = str(self.times[i])
            ET.SubElement(speedaction, &#34;SpeedProfileEntry&#34;, attrib=tmp_dict)

        return element


class AbsoluteLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target

    Parameters
    ----------
        lane (int): lane to change to

        transition_dynamics (TransitionDynamics): how the change should be made

        target_lane_offset (float): if a offset in the target lane is wanted
            Default: None

    Attributes
    ----------
        lane (int): lane to change to

        target_lane_offset (float): offset in the target lane is wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, lane, transition_dynamics, target_lane_offset=None):
        &#34;&#34;&#34;initalize AbsoluteLaneChangeAction

        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = convert_int(lane)
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, AbsoluteLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

        Returns
        -------
            alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

        &#34;&#34;&#34;
        lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
        dynamics = TransitionDynamics.parse(
            lca_element.find(&#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = lca_element.find(&#34;LaneChangeTarget/AbsoluteTargetLane&#34;)
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])

        return AbsoluteLaneChangeAction(lane, dynamics, target_lane_offset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteLaneChangeAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneChangeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(lanchangetarget, &#34;AbsoluteTargetLane&#34;, self.get_attributes())
        return element


class RelativeLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target

    Parameters
    ----------
        lane (int): relative lane number

        entity (str): the entity to run relative to

        transition_dynamics (TransitionDynamics): how the change should be made

        target_lane_offset (float): if a offset in the target lane is wanted
            Default: None

    Attributes
    ----------
        value (int): lane to change to

        target (str): target for relative lane change

        target_lane_offset (float): offset in the target lane is wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, lane, entity, transition_dynamics, target_lane_offset=None):
        &#34;&#34;&#34;initalize RelativeLaneChangeAction

        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = convert_int(lane)
        self.target = entity
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, RelativeLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

        Returns
        -------
            alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

        &#34;&#34;&#34;
        lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
        dynamics = TransitionDynamics.parse(
            lca_element.find(&#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = lca_element.find(&#34;LaneChangeTarget/RelativeTargetLane&#34;)
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])
        target = targetlane_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneChangeAction(lane, target, dynamics, target_lane_offset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeLaneChangeAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeLaneChangeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset is not None:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(lanchangetarget, &#34;RelativeTargetLane&#34;, self.get_attributes())
        return element


class AbsoluteLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target

    Parameters
    ----------
        value (float): lateral offset of the lane

        shape (DynamicsShapes): shape of the offset action

        maxlatacc (float): maximum allowed lateral acceleration

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

    Attributes
    ----------
        continuous (bool): if the controller tries to keep the relative speed

        value (float): lateral offset of the lane

        target (str): the name of the entity (relative only)

        dynshape (DynamicsShapes): the shape of the action

        maxlatacc (float): maximum allowed lateral acceleration

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, shape, maxlatacc=None, continuous=True):
        &#34;&#34;&#34;initalizes the AbsoluteLaneOffsetAction
        Parameters
        ----------
            value (float): lateral offset of the lane

            shape (DynamicsShapes): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed
                Default: True
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.dynshape = convert_enum(shape, DynamicsShapes)
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other):
        if isinstance(other, AbsoluteLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

        Returns
        -------
            alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

        &#34;&#34;&#34;
        loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

        continuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = convert_enum(load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes)

        atlo_element = loa_element.find(&#34;LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;)
        value = atlo_element.attrib[&#34;value&#34;]

        return AbsoluteLaneOffsetAction(value, dynamics, maxacc, continuous)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteLaneOffsetAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(laneoftarget, &#34;AbsoluteTargetLaneOffset&#34;, self.get_attributes())

        return element


class RelativeLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target

    Parameters
    ----------
        value (float): relative lateral offset of the target

        entity (str): name of the entity

        shape (str): shape of the offset action

        maxlatacc (float): maximum allowed lateral acceleration

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

    Attributes
    ----------
        continuous (bool): if the controller tries to keep the relative speed

        value (float): relative lateral offset of the arget

        target (str): the name of the entity

        dynshape (str): the shape of the action

        maxlatacc (float): maximum allowed lateral acceleration

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, entity, shape, maxlatacc, continuous=True):
        &#34;&#34;&#34;initalizes the RelativeLaneOffsetAction,

        Parameters
        ----------
            value (float): relative lateral offset of the target

            entity (str): name of the entity

            shape (str): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed
                Default: True
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.target = entity
        if not hasattr(DynamicsShapes, str(shape)):
            raise ValueError(shape + &#34;; is not a valid shape.&#34;)
        self.dynshape = shape
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other):
        if isinstance(other, RelativeLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
                and self.target == other.target
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

        Returns
        -------
            alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

        &#34;&#34;&#34;
        loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

        contiuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = getattr(DynamicsShapes, load_element.attrib[&#34;dynamicsShape&#34;])

        rtlo_element = loa_element.find(&#34;LaneOffsetTarget/RelativeTargetLaneOffset&#34;)
        value = convert_float(rtlo_element.attrib[&#34;value&#34;])
        entity = rtlo_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneOffsetAction(value, entity, dynamics, maxacc, contiuous)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeLaneOffsetAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeLaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(
            laneoftarget, &#34;RelativeTargetLaneOffset&#34;, attrib=self.get_attributes()
        )

        return element


class LateralDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;

    Parameters
    ----------
        entity (str): the target name

        distance (float): the lateral distance to the entity

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

        max_acceleration (float): maximum acceleration allowed
            Default: None

        max_deceleration (float): maximum deceleration allowed
            Default: None

        max_speed (float): maximum speed allowed
            Default: None

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
            Default CoordinateSystem.entity

        displacement (LateralDisplacement): type of displacement wanted
            Default LateralDisplacement.any
    Attributes
    ----------
        entity (str): the target name

        distance (float): the lateral distance to the entity

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        continuous (bool): if the controller tries to keep the relative speed

        distance (float): if the distance metric is used

        timegap (float): if timegap metric is used

        dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

        displacement (LateralDisplacement): type of displacement wanted

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        distance=None,
        freespace=True,
        continuous=True,
        max_acceleration=None,
        max_deceleration=None,
        max_speed=None,
        coordinate_system=CoordinateSystem.entity,
        displacement=LateralDisplacement.any,
    ):
        &#34;&#34;&#34;initalizes the LateralDistanceAction

        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        &#34;&#34;&#34;
        self.distance = distance
        self.target = entity

        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration, max_deceleration, max_speed
        )
        self.coordinate_system = convert_enum(coordinate_system, CoordinateSystem)
        self.displacement = convert_enum(displacement, LateralDisplacement)

    def __eq__(self, other):
        if isinstance(other, LateralDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LateralDistanceAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LateralDistanceAction element (same as generated by the class itself)

        Returns
        -------
            ld_action (LateralDistanceAction): a LateralDistanceActionobject

        &#34;&#34;&#34;
        lda_element = element.find(&#34;LateralAction/LateralDistanceAction&#34;)
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        entity = lda_element.attrib[&#34;entityRef&#34;]
        distance = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = lda_element.attrib[&#34;distance&#34;]
        coordinate = None
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem
            )
        displacement = None
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;], LateralDisplacement
            )
        constraints = None
        max_acc = None
        max_dec = None
        max_speed = None
        if lda_element.find(&#34;DynamicConstraints&#34;) != None:
            constraints = DynamicsConstraints.parse(
                lda_element.find(&#34;DynamicConstraints&#34;)
            )
            max_acc = constraints.max_acceleration
            max_dec = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LateralDistanceAction(
            entity,
            distance,
            freespace,
            continuous,
            max_acc,
            max_dec,
            max_speed,
            coordinate,
            displacement,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LateralDistanceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance != None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LateralDistanceAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        lateraldistanceaction = ET.SubElement(
            lataction, &#34;LateralDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            lateraldistanceaction.append(self.dynamic_constraint.get_element())

        return element


# teleport
class TeleportAction(_PrivateActionType):
    &#34;&#34;&#34;the TeleportAction creates the Teleport action of OpenScenario

    Parameters
    ----------
        position (*Position): any position object

    Attributes
    ----------
        position (*Position): any position object


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34;initalizes the TeleportAction

        Parameters
        ----------
            position (*Position): any position object

        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other):
        if isinstance(other, TeleportAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of WorldPosition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            position (WorldPosition): a world position object

        &#34;&#34;&#34;
        position_element = element.find(&#34;TeleportAction/Position&#34;)

        position = _PositionFactory.parse_position(position_element)
        return TeleportAction(position)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TeleportAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        telact = ET.SubElement(element, &#34;TeleportAction&#34;)
        telact.append(self.position.get_element())
        return element


# Routing actions


class AssignRouteAction(_PrivateActionType):
    &#34;&#34;&#34;AssignRouteAction creates a RouteAction of type AssignRouteAction

    Parameters
    ----------
        route (Route, or CatalogReference): the route to follow

    Attributes
    ----------
        route (Route, or CatalogReference): the route to follow


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, route):
        &#34;&#34;&#34;initalizes the AssignRouteAction

        Parameters
        ----------
            route (Route, or CatalogReference): the route to follow

        &#34;&#34;&#34;
        if not (isinstance(route, Route) or isinstance(route, CatalogReference)):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)

        self.route = route

    def __eq__(self, other):
        if isinstance(other, AssignRouteAction):
            if self.route == other.route:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AssignRouteAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AssignRouteAction element (same as generated by the class itself)

        Returns
        -------
            ar_action (AssignRouteAction): a AssignRouteAction object

        &#34;&#34;&#34;
        ara_element = element.find(&#34;RoutingAction/AssignRouteAction&#34;)
        route = None
        if ara_element.find(&#34;Route&#34;) != None:
            route = Route.parse(ara_element.find(&#34;Route&#34;))
        elif ara_element.find(&#34;CatalogReference&#34;) != None:
            route = CatalogReference.parse(ara_element.find(&#34;CatalogReference&#34;))

        return AssignRouteAction(route)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AssignRouteAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        assignrouteaction = ET.SubElement(routeaction, &#34;AssignRouteAction&#34;)
        assignrouteaction.append(self.route.get_element())

        return element


class AcquirePositionAction(_PrivateActionType):
    &#34;&#34;&#34;AcquirePositionAction creates a RouteAction of type AcquirePositionAction

    Parameters
    ----------
        position (*Position): target position

    Attributes
    ----------
        position (*Position): target position

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34;initalizes the AcquirePositionAction

        Parameters
        ----------
            position (*Position): target position

        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other):
        if isinstance(other, AcquirePositionAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AcquirePositionAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AcquirePositionAction element (same as generated by the class itself)

        Returns
        -------
            ap_action (AcquirePositionAction): a AcquirePositionAction object

        &#34;&#34;&#34;
        pos_element = element.find(&#34;RoutingAction/AcquirePositionAction/Position&#34;)

        position = _PositionFactory.parse_position(pos_element)

        return AcquirePositionAction(position)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AcquirePositionAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        posaction = ET.SubElement(routeaction, &#34;AcquirePositionAction&#34;)
        posaction.append(self.position.get_element())

        return element


class FollowTrajectoryAction(_PrivateActionType):
    &#34;&#34;&#34;FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction

    Parameters
    ----------
        trajectory (Trajectory, or CatalogReference): the trajectory to follow

        following_mode (FollowingMode): the following mode of the action

        reference_domain (ReferenceContext): how to follow
            Default: None
        scale (float): scalefactor of the timeings (must be combined with reference_domain and offset)
            Default: None
        offset (float): offset for time values (must be combined with reference_domain and scale)
            Default: None
        initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
            Default: None

    Attributes
    ----------
        trajectory (Trajectory, or CatalogReference): the trajectory to follow

        following_mode (str): the following mode of the action

        timeref (TimeReference): the time reference of the trajectory

        initialDistanceOffset (float): start at this offset into the trajectory (v1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        trajectory,
        following_mode,
        reference_domain=None,
        scale=None,
        offset=None,
        initialDistanceOffset=None,
    ):
        &#34;&#34;&#34;initalize the FollowTrajectoryAction

        Parameters
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (FollowingMode): the following mode of the action

            reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
                Default: None
            scale (float): scalefactor of the timings (must be combined with reference_domain and offset)
                Default: None
            offset (float): offset for time values (must be combined with reference_domain and scale)
                Default: None
            initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
                Default: None

        &#34;&#34;&#34;
        # if following_mode not in FollowingMode:
        #     ValueError(str(following_mode) + &#39; is not a valied following mode.&#39;)
        if not (
            isinstance(trajectory, Trajectory)
            or isinstance(trajectory, CatalogReference)
        ):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)
        self.trajectory = trajectory
        self.following_mode = convert_enum(following_mode, FollowingMode)
        # TODO: check reference_domain
        self.timeref = TimeReference(reference_domain, scale, offset)
        self.initialDistanceOffset = convert_float(initialDistanceOffset)

    def __eq__(self, other):
        if isinstance(other, FollowTrajectoryAction):
            if (
                self.timeref == other.timeref
                and self.get_attributes() == other.get_attributes()
                and self.trajectory == other.trajectory
                and self.following_mode == other.following_mode
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of FollowTrajectoryAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A FollowTrajectoryAction element (same as generated by the class itself)

        Returns
        -------
            ft_action (FollowTrajectoryAction): a FollowTrajectoryAction object

        &#34;&#34;&#34;
        fta_element = element.find(&#34;RoutingAction/FollowTrajectoryAction&#34;)
        initial_distance_offset = None
        if &#34;initialDistanceOffset&#34; in fta_element.attrib:
            initial_distance_offset = convert_float(
                fta_element.attrib[&#34;initialDistanceOffset&#34;]
            )

        timeref = TimeReference.parse(fta_element.find(&#34;TimeReference&#34;))
        reference_domain = timeref.reference_domain
        offset = timeref.offset
        scale = timeref.scale

        tfm_element = fta_element.find(&#34;TrajectoryFollowingMode&#34;)
        following_mode = convert_enum(
            tfm_element.attrib[&#34;followingMode&#34;], FollowingMode
        )

        if fta_element.find(&#34;TrajectoryRef&#34;) != None:
            fta_element = fta_element.find(&#34;TrajectoryRef&#34;)
        trajectory = None
        if fta_element.find(&#34;Trajectory&#34;) != None:
            trajectory = Trajectory.parse(fta_element.find(&#34;Trajectory&#34;))
        if fta_element.find(&#34;CatalogReference&#34;) != None:
            trajectory = CatalogReference.parse(fta_element.find(&#34;CatalogReference&#34;))

        return FollowTrajectoryAction(
            trajectory,
            following_mode,
            reference_domain,
            scale,
            offset,
            initial_distance_offset,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the FollowTrajectoryAction as a dict&#34;&#34;&#34;
        if self.initialDistanceOffset:
            return {&#34;initialDistanceOffset&#34;: str(self.initialDistanceOffset)}
        else:
            # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
            return {}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the FollowTrajectoryAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        trajaction = ET.SubElement(
            routeaction, &#34;FollowTrajectoryAction&#34;, attrib=self.get_attributes()
        )
        if self.isVersion(minor=0):
            trajaction.append(self.trajectory.get_element())
        else:
            trajref = ET.SubElement(trajaction, &#34;TrajectoryRef&#34;)
            trajref.append(self.trajectory.get_element())
        trajaction.append(self.timeref.get_element())
        ET.SubElement(
            trajaction,
            &#34;TrajectoryFollowingMode&#34;,
            attrib={&#34;followingMode&#34;: self.following_mode.get_name()},
        )

        return element


class ControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ControllerAction creates a ControllerAction of open scenario

    Parameters
    ----------
        assignControllerAction (AssignControllerAction): assign a controller to an entity

        overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

        activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                                element in PrivateAction in 1.1


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class


    &#34;&#34;&#34;

    def __init__(
        self,
        assignControllerAction=None,
        overrideControllerValueAction=None,
        activateControllerAction=None,
    ):
        &#34;&#34;&#34;initalizes the ControllerAction

        Parameters
        ----------
            assignControllerAction (AssignControllerAction): assign a controller to an entity

            overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

            activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                                element in PrivateAction in 1.1

        &#34;&#34;&#34;
        if assignControllerAction is not None and not isinstance(
            assignControllerAction, AssignControllerAction
        ):
            raise TypeError(
                &#34;assignControllerAction is not of type AssignControllerAction&#34;
            )
        if overrideControllerValueAction is not None and not isinstance(
            overrideControllerValueAction, OverrideControllerValueAction
        ):
            raise TypeError(
                &#34;overrideControllerValueAction is not of type OverrideControllerValueAction&#34;
            )
        if activateControllerAction is not None and not isinstance(
            activateControllerAction, ActivateControllerAction
        ):
            raise TypeError(
                &#34;activateControllerAction is not of type ActivateControllerAction&#34;
            )
        self.assignControllerAction = assignControllerAction
        self.overrideControllerValueAction = overrideControllerValueAction
        self.activateControllerAction = activateControllerAction
        if self.assignControllerAction is not None:
            self.assignControllerAction._used_by_parent = True
        if self.overrideControllerValueAction is not None:
            self.overrideControllerValueAction._used_by_parent = True

    def __eq__(self, other):
        if isinstance(other, ControllerAction):
            if (
                self.activateControllerAction == other.activateControllerAction
                and self.overrideControllerValueAction
                == other.overrideControllerValueAction
                and self.assignControllerAction == other.assignControllerAction
            ):
                return True
        if isinstance(other, AssignControllerAction):
            if self.assignControllerAction == other:
                return True
        if isinstance(other, OverrideControllerValueAction):
            if self.overrideControllerValueAction == other:
                return True
        if isinstance(other, ActivateControllerAction):
            if self.activateControllerAction == other:
                return True

        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ControllerAction element (same as generated by the class itself)

        Returns
        -------
            (ControllerAction): a ActivateControllerAction object

        &#34;&#34;&#34;

        activateControllerAction = None
        overrideControllerValueAction = None
        assignControllerAction = None

        ca_element = element.find(&#34;ControllerAction&#34;)

        if ca_element.find(&#34;ActivateControllerAction&#34;) != None:
            activateControllerAction = ActivateControllerAction.parse(element)
        if ca_element.find(&#34;OverrideControllerValueAction&#34;) != None:
            overrideControllerValueAction = OverrideControllerValueAction.parse(element)
        if ca_element.find(&#34;AssignControllerAction&#34;) != None:
            assignControllerAction = AssignControllerAction.parse(element)

        return ControllerAction(
            assignControllerAction,
            overrideControllerValueAction,
            activateControllerAction,
        )

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ControllerAction&#34;&#34;&#34;
        if self.isVersion(minor=0):
            if (
                self.assignControllerAction is None
                or self.overrideControllerValueAction is None
            ):
                raise NotEnoughInputArguments(
                    &#34;Both assignControllerAction and overrideControllerValueAction are required in version 1.0.&#34;
                )
            if self.activateControllerAction is not None:
                raise OpenSCENARIOVersionError(
                    &#34;activateControllerAction is not parameter in version 1.0.&#34;
                )

        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)

        if self.activateControllerAction != None:
            pa_element = self.activateControllerAction.get_element()
            aca_element = pa_element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
            controlleraction.append(aca_element)

        if self.overrideControllerValueAction != None:
            pa_element = self.overrideControllerValueAction.get_element()
            ocva_element = pa_element.find(
                &#34;ControllerAction/OverrideControllerValueAction&#34;
            )
            controlleraction.append(ocva_element)

        if self.assignControllerAction != None:
            pa_element = self.assignControllerAction.get_element()
            aca_element = pa_element.find(&#34;ControllerAction/AssignControllerAction&#34;)
            controlleraction.append(aca_element)

        return element


class ActivateControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ActivateControllerAction creates a ActivateControllerAction of open scenario

    Parameters
    ----------
        lateral (boolean): activate or deactivate the controller

        longitudinal (boolean): activate or deactivate the controller

        animation (boolean): activate or deactivate an animation

        lighting (boolean): activate or deactivate lights

        controllerRef (Controller): reference to a controller assigned to the entity

    Attributes
    ----------
        lateral (boolean): activate or deactivate the controller

        longitudinal (boolean): activate or deactivate the controller

        animation (boolean): activate or deactivate an animation

        lighting (boolean): activate or deactivate lights

        controllerRef (Controller): reference to a controller assigned to the entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        lateral=None,
        longitudinal=None,
        animation=None,
        lighting=None,
        controllerRef=None,
    ):
        &#34;&#34;&#34;initalizes the ActivateControllerAction

        Parameters
        ----------
            lateral (boolean): activate or deactivate the controller
                Default: None

            longitudinal (boolean): activate or deactivate the controller

            animation (boolean): activate or deactivate an animation

            lighting (boolean): activate or deactivate lights

            controllerRef (Controller): reference to a controller assigned to the entity

        &#34;&#34;&#34;
        self.lateral = convert_bool(lateral)
        self.longitudinal = convert_bool(longitudinal)
        self.animation = convert_bool(animation)
        self.lighting = convert_bool(lighting)
        self.controllerRef = controllerRef

    def __eq__(self, other):
        if isinstance(other, ActivateControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        elif isinstance(other, ControllerAction):
            if self.get_attributes() == other.activateControllerAction.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ActivateControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ActivateControllerAction element (same as generated by the class itself)

        Returns
        -------
            ac_action (ActivateControllerAction): a ActivateControllerAction object

        &#34;&#34;&#34;
        lateral = None
        longitudinal = None
        animation = None
        lighting = None
        controllerRef = None
        aca_element = element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
        if &#34;lateral&#34; in aca_element.attrib:
            lateral = convert_bool(aca_element.attrib[&#34;lateral&#34;])
        if &#34;longitudinal&#34; in aca_element.attrib:
            longitudinal = convert_bool(aca_element.attrib[&#34;longitudinal&#34;])
        if &#34;animation&#34; in aca_element.attrib:
            animation = convert_bool(aca_element.attrib[&#34;animation&#34;])
        if &#34;lighting&#34; in aca_element.attrib:
            lighting = convert_bool(aca_element.attrib[&#34;lighting&#34;])
        if &#34;controllerRef&#34; in aca_element.attrib:
            controllerRef = aca_element.attrib[&#34;controllerRef&#34;]

        return ActivateControllerAction(
            lateral, longitudinal, animation, lighting, controllerRef
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ActivateControllerAction as a dict&#34;&#34;&#34;
        retdict = {}
        if self.lateral is not None:
            retdict[&#34;lateral&#34;] = get_bool_string(self.lateral)
        if self.longitudinal is not None:
            retdict[&#34;longitudinal&#34;] = get_bool_string(self.longitudinal)
        if self.animation is not None and self.isVersion(minor=2):
            retdict[&#34;animation&#34;] = get_bool_string(self.animation)
        if self.lighting is not None and self.isVersion(minor=2):
            retdict[&#34;lighting&#34;] = get_bool_string(self.lighting)
        if self.controllerRef is not None and self.isVersion(minor=2):
            retdict[&#34;controllerRef&#34;] = self.controllerRef
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ActivateControllerAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        if self.isVersion(minor=0):
            ET.SubElement(
                element, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
            )
        else:
            subelem = ET.SubElement(element, &#34;ControllerAction&#34;)
            ET.SubElement(
                subelem, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
            )
        return element


class AssignControllerAction(_PrivateActionType):
    &#34;&#34;&#34;AssignControllerAction creates a ControllerAction of type AssignControllerAction

    Parameters
    ----------
        controller (Controller or Catalogreference): a controller to assign

        activateLateral (bool): if the lateral control should be activated (valid from V1.1)
            Default: True

        activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
            Default: True

        activateLighting (bool): if the lighting control should be activated (valid from V1.2)
            Default: False

        activateAnimation (bool): if the lighting control should be activated (valid from V1.2)
            Default: False

    Attributes
    ----------
        controller (boolController or Catalogreferenceean): a controller to assign

        activateLateral (bool): if the lateral control should be activated (valid from V1.1)

        activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)

        activateLighting (bool): if the lighting control should be activated (valid from V1.2)

        activateAnimation (bool): if the lighting control should be activated (valid from V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        controller,
        activateLateral=True,
        activateLongitudinal=True,
        activateLighting=False,
        activateAnimation=False,
    ):
        &#34;&#34;&#34;initalizes the AssignControllerAction

        Parameters
        ----------
            controller (Controller or Catalogreference): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                Default: True

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                Default: True
        &#34;&#34;&#34;
        if not (
            isinstance(controller, Controller)
            or isinstance(controller, CatalogReference)
        ):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)
        self.controller = controller
        self.activateLateral = convert_bool(activateLateral)
        self.activateLongitudinal = convert_bool(activateLongitudinal)
        self.activateLighting = convert_bool(activateLighting)
        self.activateAnimation = convert_bool(activateAnimation)
        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, AssignControllerAction):
            if self.controller == other.controller:
                return True
        elif isinstance(other, ControllerAction):
            if self.controller == other.assignControllerAction.controller:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AssignControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AssignControllerAction element (same as generated by the class itself)

        Returns
        -------
            ac_action (AssignControllerAction): a AssignControllerAction object

        &#34;&#34;&#34;
        ca_element = element.find(&#34;ControllerAction&#34;)
        aca_element = ca_element.find(&#34;AssignControllerAction&#34;)
        activate_lateral = True
        if &#34;activateLateral&#34; in aca_element.attrib:
            activate_lateral = convert_bool(aca_element.attrib[&#34;activateLateral&#34;])

        activate_longitudinal = True
        if &#34;activateLongitudinal&#34; in aca_element.attrib:
            activate_longitudinal = convert_bool(
                aca_element.attrib[&#34;activateLongitudinal&#34;]
            )
        activate_lighting = False
        if &#34;activateLighting&#34; in aca_element.attrib:
            activate_lighting = convert_bool(aca_element.attrib[&#34;activateLighting&#34;])
        activate_animation = False
        if &#34;activateAnimation&#34; in aca_element.attrib:
            activate_animation = convert_bool(aca_element.attrib[&#34;activateAnimation&#34;])
        controller = None
        if aca_element.find(&#34;Controller&#34;) != None:
            controller = Controller.parse(aca_element.find(&#34;Controller&#34;))
        elif aca_element.find(&#34;CatalogReference&#34;) != None:
            controller = CatalogReference.parse(aca_element.find(&#34;CatalogReference&#34;))
        else:
            raise NotAValidElement(&#34;No Controller found for AssignControllerAction&#34;)

        return AssignControllerAction(
            controller,
            activate_lateral,
            activate_longitudinal,
            activate_lighting,
            activate_animation,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AssignControllerAction as a dict&#34;&#34;&#34;
        retdict = {}

        if self.isVersionEqLarger(minor=1):
            retdict = {
                &#34;activateLateral&#34;: get_bool_string(self.activateLateral),
                &#34;activateLongitudinal&#34;: get_bool_string(self.activateLongitudinal),
            }
        if self.isVersionEqLarger(minor=2):
            retdict[&#34;activateLighting&#34;] = get_bool_string(self.activateLighting)
            retdict[&#34;activateAnimation&#34;] = get_bool_string(self.activateAnimation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AssignControllerAction&#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;AssignControllerAction cannot be used alone in OSC 1.0, please add it to a ControllerAction.&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        assigncontrolleraction = ET.SubElement(
            controlleraction, &#34;AssignControllerAction&#34;, self.get_attributes()
        )
        assigncontrolleraction.append(self.controller.get_element())

        return element


class OverrideControllerValueAction(_PrivateActionType):
    &#34;&#34;&#34;OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
    NOTE: this implementation is compatible with osc v.1.1 where all attributes don&#39;t have to be set.

    Attributes
    ----------
        throttle_active (bool): if the throttle is active
            Default: None (will not be written)

        throttle_value (float): value of the throttle

        brake_active (bool): if the brake is active
            Default: None (will not be written)

        brake_value (float): value of the brake

        clutch_active (bool): if the clutch is active
            Default: None (will not be written)

        clutch_value (float): value of the clutch

        steeringwheel_active (bool): if the steeringwheel is active
            Default: None (will not be written)

        steeringwheel_value (float): value of the steeringwheel

        gear_active (bool): if the gear is active
            Default: None (will not be written)

        gear_value (float): value of the gear

        parkingbrake_active (bool): if the parkingbrake is active
            Default: None (will not be written)

        parkingbrake_value (float): value of the parkingbrake

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

        set_throttle(active,value)
            sets the throttle value

        set_brake(active,value)
            sets the brake value

        set_steeringwheel(active,value)
            sets the steeringwheel value

        set_clutch(active,value)
            sets the clutch value

        set_gear(active,value)
            sets the gear value

        set_parkingbrake(active,value)
            sets the parkingbrake value

    &#34;&#34;&#34;

    def __init__(self):
        self.throttle_active = None
        self.throttle_value = convert_float(0)
        self.throttle_rate = None
        self.brake_active = None
        self.brake_value = convert_float(0)
        self.brake_rate = None
        self.brake_force = False
        self.clutch_active = None
        self.clutch_value = convert_float(0)
        self.clutch_rate = None
        self.steeringwheel_active = None
        self.steeringwheel_value = convert_float(0)
        self.steeringwheel_rate = None
        self.steeringwheel_torque = None
        self.gear_active = None
        self.gear_value = convert_float(0)
        self._gear_maunal = True
        self.parkingbrake_active = None
        self.parkingbrake_value = convert_float(0)
        self.parkingbrake_rate = None
        self.parkingbrake_force = False

        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, OverrideControllerValueAction):
            if (
                self.throttle_value == other.throttle_value
                and self.throttle_value == other.throttle_value
                and self.throttle_rate == other.throttle_rate
                and self.brake_active == other.brake_active
                and self.brake_value == other.brake_value
                and self.brake_rate == other.brake_rate
                and self.brake_force == other.brake_force
                and self.clutch_active == other.clutch_active
                and self.clutch_value == other.clutch_value
                and self.clutch_rate == other.clutch_rate
                and self.steeringwheel_active == other.steeringwheel_active
                and self.steeringwheel_value == other.steeringwheel_value
                and self.steeringwheel_rate == other.steeringwheel_rate
                and self.steeringwheel_torque == other.steeringwheel_torque
                and self.gear_active == other.gear_active
                and self.gear_value == other.gear_value
                and self.parkingbrake_active == other.parkingbrake_active
                and self.parkingbrake_value == other.parkingbrake_value
                and self.parkingbrake_force == other.parkingbrake_force
                and self.parkingbrake_rate == other.parkingbrake_rate
            ):
                return True
        elif isinstance(other, ControllerAction):
            if (
                self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_rate
                == other.overrideControllerValueAction.throttle_rate
                and self.brake_active
                == other.overrideControllerValueAction.brake_active
                and self.brake_value == other.overrideControllerValueAction.brake_value
                and self.brake_rate == other.overrideControllerValueAction.brake_rate
                and self.brake_force == other.overrideControllerValueAction.brake_force
                and self.clutch_active
                == other.overrideControllerValueAction.clutch_active
                and self.clutch_value
                == other.overrideControllerValueAction.clutch_value
                and self.clutch_rate == other.overrideControllerValueAction.clutch_rate
                and self.steeringwheel_active
                == other.overrideControllerValueAction.steeringwheel_active
                and self.steeringwheel_value
                == other.overrideControllerValueAction.steeringwheel_value
                and self.steeringwheel_rate
                == other.overrideControllerValueAction.steeringwheel_rate
                and self.steeringwheel_torque
                == other.overrideControllerValueAction.steeringwheel_torque
                and self.gear_active == other.overrideControllerValueAction.gear_active
                and self.gear_value == other.overrideControllerValueAction.gear_value
                and self.parkingbrake_active
                == other.overrideControllerValueAction.parkingbrake_active
                and self.parkingbrake_value
                == other.overrideControllerValueAction.parkingbrake_value
                and self.parkingbrake_force
                == other.overrideControllerValueAction.parkingbrake_force
                and self.parkingbrake_rate
                == other.overrideControllerValueAction.parkingbrake_rate
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of OverrideControllerValueAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A OverrideControllerValueAction element (same as generated by the class itself)

        Returns
        -------
            ocv_action (OverrideControllerValueAction): a OverrideControllerValueAction object

        &#34;&#34;&#34;
        ocv_action = OverrideControllerValueAction()
        ocva_element = element.find(&#34;ControllerAction/OverrideControllerValueAction&#34;)

        ocv_action.throttle_active = None
        ocv_action.throttle_value = convert_float(0)
        if ocva_element.find(&#34;Throttle&#34;) != None:
            throttle_element = ocva_element.find(&#34;Throttle&#34;)
            ocv_action.throttle_active = convert_bool(throttle_element.attrib[&#34;active&#34;])
            ocv_action.throttle_value = convert_float(throttle_element.attrib[&#34;value&#34;])
            if &#34;maxRate&#34; in throttle_element.attrib:
                ocv_action.throttle_rate = convert_float(
                    throttle_element.attrib[&#34;maxRate&#34;]
                )

        ocv_action.brake_active = None
        ocv_action.brake_value = convert_float(0)
        if ocva_element.find(&#34;Brake&#34;) != None:
            brake_element = ocva_element.find(&#34;Brake&#34;)
            ocv_action.brake_active = convert_bool(brake_element.attrib[&#34;active&#34;])
            if &#34;value&#34; in brake_element.attrib:
                ocv_action.brake_value = convert_float(brake_element.attrib[&#34;value&#34;])
            else:
                if brake_element.find(&#34;BrakePercent&#34;) is not None:
                    brake_input_element = brake_element.find(&#34;BrakePercent&#34;)
                    ocv_action.brake_force = False

                elif brake_element.find(&#34;BrakeForce&#34;) is not None:
                    brake_input_element = brake_element.find(&#34;BrakeForce&#34;)
                    ocv_action.brake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.brake_value = convert_float(
                    brake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in brake_input_element.attrib:
                    ocv_action.brake_rate = brake_input_element.attrib[&#34;maxRate&#34;]

        ocv_action.clutch_active = None
        ocv_action.clutch_value = convert_float(0)
        if ocva_element.find(&#34;Clutch&#34;) != None:
            cluth_element = ocva_element.find(&#34;Clutch&#34;)
            ocv_action.clutch_active = convert_bool(cluth_element.attrib[&#34;active&#34;])
            ocv_action.clutch_value = convert_float(cluth_element.attrib[&#34;value&#34;])
            if &#34;maxRate&#34; in cluth_element.attrib:
                ocv_action.clutch_rate = convert_float(cluth_element.attrib[&#34;maxRate&#34;])

        ocv_action.parkingbrake_active = None
        ocv_action.parkingbrake_value = convert_float(0)
        if ocva_element.find(&#34;ParkingBrake&#34;) != None:
            parkingbrake_element = ocva_element.find(&#34;ParkingBrake&#34;)
            ocv_action.parkingbrake_active = convert_bool(
                parkingbrake_element.attrib[&#34;active&#34;]
            )

            if &#34;value&#34; in parkingbrake_element.attrib:
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_element.attrib[&#34;value&#34;]
                )
            else:
                if parkingbrake_element.find(&#34;BrakePercent&#34;) is not None:
                    parkingbrake_input_element = parkingbrake_element.find(
                        &#34;BrakePercent&#34;
                    )
                    ocv_action.parkingbrake_force = False

                elif parkingbrake_element.find(&#34;BrakeForce&#34;) is not None:
                    parkingbrake_input_element = parkingbrake_element.find(&#34;BrakeForce&#34;)
                    ocv_action.parkingbrake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in parkingbrake_input_element.attrib:
                    ocv_action.parkingbrake_rate = convert_float(
                        parkingbrake_input_element.attrib[&#34;maxRate&#34;]
                    )

        ocv_action.steeringwheel_active = None
        ocv_action.steeringwheel_value = convert_float(0)
        if ocva_element.find(&#34;SteeringWheel&#34;) != None:
            steeringwheel_element = ocva_element.find(&#34;SteeringWheel&#34;)
            ocv_action.steeringwheel_active = convert_bool(
                steeringwheel_element.attrib[&#34;active&#34;]
            )
            ocv_action.steeringwheel_value = convert_float(
                steeringwheel_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_rate = convert_float(
                    steeringwheel_element.attrib[&#34;maxRate&#34;]
                )
            if &#34;maxTorque&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_torque = convert_float(
                    steeringwheel_element.attrib[&#34;maxTorque&#34;]
                )

        ocv_action.gear_active = None
        ocv_action.gear_value = convert_float(0)
        if ocva_element.find(&#34;Gear&#34;) != None:
            gear_element = ocva_element.find(&#34;Gear&#34;)
            ocv_action.gear_active = convert_bool(gear_element.attrib[&#34;active&#34;])
            if &#34;number&#34; in gear_element.attrib:
                ocv_action.gear_value = convert_float(gear_element.attrib[&#34;number&#34;])
            elif gear_element.find(&#34;AutomaticGear&#34;) is not None:
                ocv_action.gear_value = getattr(
                    AutomaticGearType,
                    gear_element.find(&#34;AutomaticGear&#34;).attrib[&#34;gear&#34;],
                )

            elif gear_element.find(&#34;ManualGear&#34;) is not None:
                ocv_action.gear_value = convert_float(
                    gear_element.find(&#34;ManualGear&#34;).attrib[&#34;number&#34;]
                )
            else:
                raise ValueError(&#34;no gear number found in OverrideGearAction&#34;)

        return ocv_action

    def set_clutch(self, active, value=0, rate=None):
        &#34;&#34;&#34;Sets the clutch value

        Parameters
        ----------
            active (bool): if the clutch should be overridden

            value (float): value of the clutch
                Default: 0

            rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.clutch_active = convert_bool(active)
        self.clutch_value = convert_float(value)
        self.clutch_rate = rate

    def set_brake(self, active, value=0, rate=None, interpret_as_force=False):
        &#34;&#34;&#34;Sets the brake value

        Parameters
        ----------
            active (bool): if the brake should be overridden

            value (float): value of the brake
                Default: 0

            rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
                Default: None

        &#34;&#34;&#34;
        self.brake_active = convert_bool(active)
        self.brake_value = convert_float(value)
        self.brake_rate = rate
        self.brake_force = interpret_as_force

    def set_throttle(self, active, value=0, rate=None):
        &#34;&#34;&#34;Sets the throttle value

        Parameters
        ----------
            active (bool): if the throttle should be overridden

            value (float): value of the throttle
                Default: 0

            rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.throttle_active = convert_bool(active)
        self.throttle_value = convert_float(value)
        self.throttle_rate = rate

    def set_steeringwheel(self, active, value=0, rate=None, torque=None):
        &#34;&#34;&#34;Sets the steeringwheel value

        Parameters
        ----------
            active (bool): if the steeringwheel should be overridden

            value (float): value of the steeringwheel
                Default: 0

            rate (float): the Max Rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            torque (float): the Max Torque of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.steeringwheel_active = convert_bool(active)
        self.steeringwheel_value = convert_float(value)
        self.steeringwheel_rate = convert_float(rate)
        self.steeringwheel_torque = convert_float(torque)

    def set_parkingbrake(self, active, value=0, rate=None, interpret_as_force=False):
        &#34;&#34;&#34;Sets the parkingbrake value

        Parameters
        ----------
            active (bool): if the parkingbrake should be overridden

            value (float): value of the parkingbrake
                Default: 0

            rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.parkingbrake_active = convert_bool(active)
        self.parkingbrake_value = convert_float(value)
        self.parkingbrake_rate = rate
        self.parkingbrake_force = interpret_as_force

    def set_gear(self, active, value=0):
        &#34;&#34;&#34;Sets the gear value

        Parameters
        ----------
            active (bool): if the gear should be overridden

            value (float/AutomaticGearType): value of the gear
                Default: 0
        &#34;&#34;&#34;
        self.gear_active = convert_bool(active)
        if hasattr(AutomaticGearType, str(value)):
            self.gear_value = value
            self._gear_maunal = False
        else:
            self.gear_value = convert_float(value)
            self._gear_maunal = True

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the OverrideControllerValueAction&#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;OverrideControllerValueAction cannot be used alone in OSC 1.0, please add it to a ControllerAction&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        overrideaction = ET.SubElement(
            controlleraction, &#34;OverrideControllerValueAction&#34;
        )

        if (
            self.throttle_active == None
            and self.brake_active == None
            and self.clutch_active == None
            and self.parkingbrake_active == None
            and self.steeringwheel_active == None
            and self.gear_active == None
        ):
            raise NoActionsDefinedError(
                &#34;No actions were added to the OverrideControllerValueAction&#34;
            )
        if self.throttle_active != None:
            throttle_dict = {
                &#34;active&#34;: get_bool_string(self.throttle_active),
                &#34;value&#34;: str(self.throttle_value),
            }
            if self.throttle_rate is not None and self.isVersion(minor=2):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Throttle&#34;,
                throttle_dict,
            )
        if self.brake_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.brake_active),
                        &#34;value&#34;: str(self.brake_value),
                    },
                )
            else:
                override_brake = ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {&#34;active&#34;: get_bool_string(self.brake_active)},
                )
                brake_dict = {&#34;value&#34;: str(self.brake_value)}
                if self.brake_rate is not None:
                    brake_dict[&#34;maxRate&#34;] = str(self.brake_rate)
                if self.brake_force:
                    ET.SubElement(override_brake, &#34;BrakeForce&#34;, attrib=brake_dict)
                else:
                    ET.SubElement(override_brake, &#34;BrakePercent&#34;, attrib=brake_dict)

        if self.clutch_active != None:
            if self.throttle_rate is not None and self.isVersion(minor=2):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            clutch_dict = {
                &#34;active&#34;: get_bool_string(self.clutch_active),
                &#34;value&#34;: str(self.clutch_value),
            }
            if self.clutch_rate is not None and self.isVersion(minor=2):
                clutch_dict[&#34;maxRate&#34;] = str(self.clutch_rate)
            elif self.clutch_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Clutch&#34;,
                clutch_dict,
            )
        if self.parkingbrake_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.parkingbrake_active),
                        &#34;value&#34;: str(self.parkingbrake_value),
                    },
                )
            else:
                override_parking = ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {&#34;active&#34;: get_bool_string(self.parkingbrake_active)},
                )
                parkingbrake_dict = {&#34;value&#34;: str(self.parkingbrake_value)}
                if self.parkingbrake_rate is not None:
                    parkingbrake_dict[&#34;maxRate&#34;] = str(self.parkingbrake_rate)
                if self.parkingbrake_force:
                    ET.SubElement(
                        override_parking, &#34;BrakeForce&#34;, attrib=parkingbrake_dict
                    )
                else:
                    ET.SubElement(
                        override_parking, &#34;BrakePercent&#34;, attrib=parkingbrake_dict
                    )
        if self.steeringwheel_active != None:
            steering_dict = {
                &#34;active&#34;: get_bool_string(self.steeringwheel_active),
                &#34;value&#34;: str(self.steeringwheel_value),
            }
            if self.steeringwheel_torque is not None:
                if self.isVersion(minor=2):
                    steering_dict[&#34;maxTorque&#34;] = str(self.steeringwheel_torque)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxTorque was introduced in OpenSCENARIO v1.2&#34;
                    )
            if self.steeringwheel_rate is not None:
                if self.isVersion(minor=2):
                    steering_dict[&#34;maxRate&#34;] = str(self.steeringwheel_rate)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                    )
            ET.SubElement(
                overrideaction,
                &#34;SteeringWheel&#34;,
                steering_dict,
            )

        if self.gear_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                        &#34;number&#34;: str(self.gear_value),
                    },
                )
            else:
                override_gear_action = ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                    },
                )
                if self._gear_maunal:
                    ET.SubElement(
                        override_gear_action,
                        &#34;ManualGear&#34;,
                        {&#34;number&#34;: str(int(self.gear_value))},
                    )
                else:
                    ET.SubElement(
                        override_gear_action,
                        &#34;AutomaticGear&#34;,
                        {&#34;gear&#34;: self.gear_value.get_name()},
                    )

        return element


class VisibilityAction(_PrivateActionType):
    &#34;&#34;&#34;creates a VisibilityAction

    Parameters
    ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

    Attributes
    ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

        sensor_refs (list of str): all sensor references

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(self, graphics, traffic, sensors):
        &#34;&#34;&#34;initalizes the VisibilityAction

        Parameters
        ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

        &#34;&#34;&#34;
        self.graphics = convert_bool(graphics)
        self.traffic = convert_bool(traffic)
        self.sensors = convert_bool(sensors)
        self.sensor_refs = []

    def __eq__(self, other):
        if isinstance(other, VisibilityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.sensor_refs == other.sensor_refs
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VisibilityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VisibilityAction element (same as generated by the class itself)

        Returns
        -------
            v_action (VisibilityAction): a VisibilityAction object

        &#34;&#34;&#34;
        va_element = element.find(&#34;VisibilityAction&#34;)
        graphics = convert_bool(va_element.attrib[&#34;graphics&#34;])
        traffic = convert_bool(va_element.attrib[&#34;traffic&#34;])
        sensors = convert_bool(va_element.attrib[&#34;sensors&#34;])
        visibility_action = VisibilityAction(graphics, traffic, sensors)
        sensor_ref_element = va_element.find(&#34;SensorReferenceSet&#34;)
        if sensor_ref_element is not None:
            for sensor_element in sensor_ref_element.findall(&#34;SensorReference&#34;):
                visibility_action.add_sensor_reference(sensor_element.attrib[&#34;name&#34;])
        return visibility_action

    def add_sensor_reference(self, sensor_ref):
        &#34;&#34;&#34;adds a sensor reference to the visibility action (Valid since OSC V1.2)

        Parameters
        ----------
            sensor_ref (str): name of a sensor
        &#34;&#34;&#34;
        self.sensor_refs.append(sensor_ref)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VisibilityAction as a dict&#34;&#34;&#34;
        return {
            &#34;graphics&#34;: get_bool_string(self.graphics),
            &#34;traffic&#34;: get_bool_string(self.traffic),
            &#34;sensors&#34;: get_bool_string(self.sensors),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VisibilityAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        visibility_element = ET.SubElement(
            element, &#34;VisibilityAction&#34;, self.get_attributes()
        )
        if self.sensor_refs:
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(&#34;SensorReference was added in OSC V1.2&#34;)
            sensor_ref_element = ET.SubElement(visibility_element, &#34;SensorReferenceSet&#34;)
            for sensor in self.sensor_refs:
                ET.SubElement(
                    sensor_ref_element, &#34;SensorReference&#34;, {&#34;name&#34;: str(sensor)}
                )
        return element


class SynchronizeAction(_PrivateActionType):
    &#34;&#34;&#34;Synchronizes an entity&#39;s arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.

    Parameters
    ----------
        entity (str): entity to syncronize with

        entity_PositionType (*Position): the position of the entity to syncronize to

        target_PositionType (*Position): the position of the target that should syncronize

        speed (float): the absolute speed of the target that should syncronize

        target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
            Default: None
    Attributes
    ----------
        entity (str): entity to syncronize with

        entity_PositionType (*Position): the position of the entity to syncronize to

        target_PositionType (*Position): the position of the target that should syncronize

        speed (float): the absolute speed of the target that should syncronize

        target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        entity_PositionType: _PositionType,
        target_PositionType: _PositionType,
        target_tolerance_master=None,
        target_tolerance=None,
        final_speed=None,
    ):
        &#34;&#34;&#34;initalize the SynchronizeAction

        Parameters
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
            Default: None
        &#34;&#34;&#34;

        self.entity = entity
        if not isinstance(entity_PositionType, _PositionType):
            raise TypeError(&#34;entity_PositionType input is not a valid Position&#34;)

        if not isinstance(target_PositionType, _PositionType):
            raise TypeError(&#34;target_PositionType input is not a valid Position&#34;)
        self.entity_PositionType = entity_PositionType
        self.target_PositionType = target_PositionType
        self.target_tolerance_master = convert_float(target_tolerance_master)
        self.target_tolerance = convert_float(target_tolerance)
        if final_speed and not (
            isinstance(final_speed, AbsoluteSpeed)
            or isinstance(final_speed, RelativeSpeedToMaster)
        ):
            raise TypeError(
                &#34;final_speed input is not AbsoluteSpeed or RelativeSpeedToMaster type&#34;
            )
        else:
            self.final_speed = final_speed

    def __eq__(self, other):
        if isinstance(other, SynchronizeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.entity_PositionType == other.entity_PositionType
                and self.target_PositionType == other.target_PositionType
                and self.final_speed == other.final_speed
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SynchronizeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A SynchronizeAction element (same as generated by the class itself)

        Returns
        -------
            sync_action (SynchronizeAction): a SynchronizeAction object

        &#34;&#34;&#34;
        sa_element = element.find(&#34;SynchronizeAction&#34;)
        entity = sa_element.attrib[&#34;masterEntityRef&#34;]

        target_tolerance = None
        if &#34;targetTolerance&#34; in sa_element.attrib:
            target_tolerance = convert_float(sa_element.attrib[&#34;targetTolerance&#34;])

        target_tolerance_master = None
        if &#34;targetToleranceMaster&#34; in sa_element.attrib:
            target_tolerance_master = convert_float(
                sa_element.attrib[&#34;targetToleranceMaster&#34;]
            )

        targetPositionMaster = _PositionFactory.parse_position(
            sa_element.find(&#34;TargetPositionMaster&#34;)
        )
        targetPosition = _PositionFactory.parse_position(
            sa_element.find(&#34;TargetPosition&#34;)
        )

        finalSpeed = None
        if sa_element.find(&#34;FinalSpeed&#34;) != None:
            sa_element = sa_element.find(&#34;FinalSpeed&#34;)
            if sa_element.find(&#34;AbsoluteSpeed&#34;) != None:
                finalSpeed = AbsoluteSpeed.parse(sa_element)
            if sa_element.find(&#34;RelativeSpeedToMaster&#34;) != None:
                finalSpeed = RelativeSpeedToMaster.parse(sa_element)

        return SynchronizeAction(
            entity,
            targetPositionMaster,
            targetPosition,
            target_tolerance_master,
            target_tolerance,
            finalSpeed,
        )
        _

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSynchronizeAction as a dict&#34;&#34;&#34;
        attr = {&#34;masterEntityRef&#34;: self.entity}
        if self.isVersion(1, 0):
            return attr
        if self.target_tolerance_master is not None:
            attr.update({&#34;targetToleranceMaster&#34;: str(self.target_tolerance_master)})
        if self.target_tolerance is not None:
            attr.update({&#34;targetTolerance&#34;: str(self.target_tolerance)})
        return attr

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSynchronizeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        syncaction = ET.SubElement(element, &#34;SynchronizeAction&#34;, self.get_attributes())
        syncaction.append(self.entity_PositionType.get_element(&#34;TargetPositionMaster&#34;))
        syncaction.append(self.target_PositionType.get_element(&#34;TargetPosition&#34;))
        if self.final_speed is not None:
            syncaction.append(self.final_speed.get_element())
        return element


class LightStateAction(_PrivateActionType):
    &#34;&#34;&#34;LightStateAction creates an AppearanceAction of of the Type LightStateAction

    Parameters
    ----------
        light_type (VehicleLightType or UserDefinedLight):

        mode (LightMode): the new mode of the light

        transition_time (float): the transition time of the light
            Default: 0

        flashing_off_duration (float): how long the light should be off when LightMode is set to &#34;flashing&#34;

        flashing_on_duration (float): how long the light should be on when when LightMode is set to &#34;flashing&#34;

        intensity (float): the luminous intensity of the light

        color (Color): the color of the light

    Attributes
    ----------


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        light_type,
        mode,
        transition_time=0,
        flashing_off_duration=None,
        flashing_on_duration=None,
        intensity=None,
        color=None,
    ):
        &#34;&#34;&#34;initalize the LightStateAction

        Parameters
        ----------
            light_type (VehicleLightType or UserDefinedLight):

            mode (LightMode): the new mode of the light

            transition_time (float): the transition time of the light
                Default: 0

            flashing_off_duration (float): how long the light should be off when LightMode is set to &#34;flashing&#34;

            flashing_on_duration (float): how long the light should be on when when LightMode is set to &#34;flashing&#34;

            intensity (float): the luminous intensity of the light

            color (Color): the color of the light
        &#34;&#34;&#34;
        try:
            self.light_type = convert_enum(light_type, VehicleLightType)
        except Exception as e:
            if not isinstance(light_type, UserDefinedLight):
                raise TypeError(
                    &#34;light_type input is not of type VehicleLightType or UserDefinedLight&#34;
                )
            else:
                self.light_type = light_type

        self.lightstate = _LightState(
            mode, color, intensity, flashing_off_duration, flashing_on_duration
        )

        self.transition_time = convert_float(transition_time)

    def __eq__(self, other):
        if isinstance(other, LightStateAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.light_type == other.light_type
                and self.lightstate == other.lightstate
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LightStateAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LightStateAction element (same as generated by the class itself)

        Returns
        -------
            light_state_action (LightStateAction): a LightStateAction object

        &#34;&#34;&#34;
        light_element = element.find(&#34;AppearanceAction/LightStateAction&#34;)
        transition_time = None
        if &#34;transitionTime&#34; in light_element.attrib:
            transition_time = convert_float(light_element.attrib[&#34;transitionTime&#34;])
        light_state = _LightState.parse(light_element.find(&#34;LightState&#34;))
        type_element = light_element.find(&#34;LightType&#34;)
        if type_element.find(&#34;UserDefinedLight&#34;) is not None:
            light_type = UserDefinedLight.parse(type_element.find(&#34;UserDefinedLight&#34;))
        else:
            light_type = convert_enum(
                type_element.find(&#34;VehicleLight&#34;).attrib[&#34;vehicleLightType&#34;],
                VehicleLightType,
            )
        # create with dummy mode
        light_state_action = LightStateAction(light_type, LightMode.on, transition_time)
        light_state_action.lightstate = light_state
        return light_state_action

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LightStateAction as a dict&#34;&#34;&#34;
        attr = {&#34;transitionTime&#34;: str(self.transition_time)}
        return attr

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LightStateAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        light_element = ET.SubElement(
            appear_element, &#34;LightStateAction&#34;, self.get_attributes()
        )
        light_element.append(self.lightstate.get_element())

        light_type_element = ET.SubElement(light_element, &#34;LightType&#34;)
        if hasattr(VehicleLightType, str(self.light_type)):
            ET.SubElement(
                light_type_element,
                &#34;VehicleLight&#34;,
                attrib={&#34;vehicleLightType&#34;: self.light_type.get_name()},
            )
        else:
            light_type_element.append(self.light_type.get_element())

        return element


class AnimationAction(_PrivateActionType):
    &#34;&#34;&#34;AnimationAction creates an AppearanceAction of of the Type AnimationAction

    Parameters
    ----------
        animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

        duration (float): the duraton of the animation
            Default: None

        loop (bool): if the animation should be looped
            Default: None

        state (float): what state the animation should be put to
            Default: None

    Attributes
    ----------

        animation_type (_ComponentAnimation, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

        duration (float): the duraton of the animation

        loop (bool): if the animation should be looped

        state (float): what state the animation should be put to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        animation_type,
        duration=None,
        loop=None,
        state=None,
    ):
        &#34;&#34;&#34;initalize the AnimationAction

        Parameters
        ----------
            animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

            duration (float): the duraton of the animation
                Default: None

            loop (bool): if the animation should be looped
                Default: None

            state (float): what state the animation should be put to
                Default: None
        &#34;&#34;&#34;

        try:
            self.animation_type = _ComponentAnimation(_VehicleComponent(animation_type))
        except Exception as e:
            self.animation_type = None
        if self.animation_type:
            pass
        elif isinstance(animation_type, UserDefinedComponent):
            self.animation_type = _ComponentAnimation(animation_type)
        else:
            self.animation_type = animation_type
        self.duration = convert_float(duration)
        if loop is not None and not isinstance(loop, bool):
            raise TypeError(&#34;loop input is not of type bool&#34;)
        self.loop = loop
        self.state = convert_float(state)

    def __eq__(self, other):
        if isinstance(other, AnimationAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.animation_type == other.animation_type
                and self.state == other.state
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AnimationAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AnimationAction element (same as generated by the class itself)

        Returns
        -------
            animation_action (AnimationAction): a AnimationAction object

        &#34;&#34;&#34;
        animation_element = element.find(&#34;AppearanceAction/AnimationAction&#34;)
        duration = None
        if &#34;animationDuration&#34; in animation_element.attrib:
            duration = convert_float(animation_element.attrib[&#34;animationDuration&#34;])
        loop = None
        if &#34;loop&#34; in animation_element.attrib:
            loop = convert_bool(animation_element.attrib[&#34;loop&#34;])
        animation_state = animation_element.find(&#34;AnimationState&#34;)
        state = None
        if animation_state is not None:
            state = convert_float(animation_state.attrib[&#34;state&#34;])
        animation_type = _AnimationTypeFactory.parse_animationtype(
            animation_element.find(&#34;AnimationType&#34;)
        )
        return AnimationAction(animation_type, duration, loop, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AnimationAction as a dict&#34;&#34;&#34;
        retdict = {}

        if self.duration is not None:
            retdict[&#34;animationDuration&#34;] = str(self.duration)
        if self.loop is not None:
            retdict[&#34;loop&#34;] = get_bool_string(self.loop)

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AnimationAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        animation_element = ET.SubElement(
            appear_element, &#34;AnimationAction&#34;, self.get_attributes()
        )

        animation_type_element = ET.SubElement(animation_element, &#34;AnimationType&#34;)
        animation_type_element.append(self.animation_type.get_element())
        if self.state is not None:
            ET.SubElement(
                animation_element, &#34;AnimationState&#34;, attrib={&#34;state&#34;: str(self.state)}
            )

        return element


#### Global Actions ####
class ParameterAddAction(_ActionType):
    &#34;&#34;&#34;The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be added to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be added to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterAddAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other):
        if isinstance(other, ParameterAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterAddAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterAddAction element (same as generated by the class itself)

        Returns
        -------
            paa_action (ParameterAddAction): a ParameterAddAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;AddValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterAddAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterAddAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterAddAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterAddAction was deprecated in OSC 1.2, please use VariableAddAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element


class ParameterMultiplyAction(_ActionType):
    &#34;&#34;&#34;The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be multiplied to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be multiplied to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterMultiplyAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other):
        if isinstance(other, ParameterMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterMultiplyAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterMultiplyAction element (same as generated by the class itself)

        Returns
        -------
            pma_action (ParameterMultiplyAction): a ParameterMultiplyAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterMultiplyAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterMultiplyAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterMultiplyAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterMultiplyAction was deprecated in OSC 1.2, please use VariableMultiplyAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element


class ParameterSetAction(_ActionType):
    &#34;&#34;&#34;The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be set to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be set to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterSetAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, ParameterSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterSetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterSetAction element (same as generated by the class itself)

        Returns
        -------
            psa_action (ParameterSetAction): a ParameterSetAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]
        psa_element = pa_element.find(&#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        psa = ParameterSetAction(parameterRef, value)
        psa.setVersion(minor=1)
        return psa  # ParameterSetAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterSetAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterSetAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterSetAction was deprecated in OSC 1.2, please use VariableSetAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element


class VariableAddAction(_ActionType):
    &#34;&#34;&#34;The VariableAddAction class creates a VariableAction of type VariableModifyAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be added to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be added to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableAddAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableAddAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableAddAction element (same as generated by the class itself)

        Returns
        -------
            paa_action (VariableAddAction): a VariableAddAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;AddValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableAddAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element


class VariableMultiplyAction(_ActionType):
    &#34;&#34;&#34;The VariableMultiplyAction class creates a VariableAction of tyoe VariableModifyAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be multiplied to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be multiplied to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableMultiplyAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableMultiplyAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableMultiplyAction element (same as generated by the class itself)

        Returns
        -------
            pma_action (VariableMultiplyAction): a VariableMultiplyAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableMultiplyAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VariableMultiplyAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VariableMultiplyAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element


class VariableSetAction(_ActionType):
    &#34;&#34;&#34;The VariableSetAction class creates a VariableAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be set to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be set to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableSetAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableSetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableSetAction element (same as generated by the class itself)

        Returns
        -------
            psa_action (VariableSetAction): a VariableSetAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]
        psa_element = pa_element.find(&#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        return VariableSetAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VariableSetAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VariableSetAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element


class TrafficSignalStateAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal

    Parameters
    ----------
        name (str): id of the signal in the road network

        state (str): the state to set to the traffic light

    Attributes
    ----------

        name (str): id of the signal in the road network

        state (str): the state to set to the traffic light

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, name, state):
        &#34;&#34;&#34;initalize the TrafficSignalStateAction

        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self, other):
        if isinstance(other, TrafficSignalStateAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalStateAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSignalStateAction element (same as generated by the class itself)

        Returns
        -------
            tss_action (TrafficSignalStateAction): a TrafficSignalStateAction object

        &#34;&#34;&#34;
        isa_element = element.find(&#34;InfrastructureAction&#34;)
        tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
        tss_element = tsa_element.find(&#34;TrafficSignalStateAction&#34;)
        name = tss_element.attrib[&#34;name&#34;]
        state = tss_element.attrib[&#34;state&#34;]
        return TrafficSignalStateAction(name, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalStateAction as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalStateAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(tsa, &#34;TrafficSignalStateAction&#34;, self.get_attributes())

        return element


class AddEntityAction(_ActionType):
    &#34;&#34;&#34;The AddEntityAction class creates a EntityAction which adds a entity to the scenario

    Parameters
    ----------
        entityref (str): reference name of the newly added vehicle

        position (*Position): position where the vehicle should be added

    Attributes
    ----------

        entityref (str): reference name of the newly added vehicle

        position (*Position): position where the vehicle should be added

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, entityref, position):
        &#34;&#34;&#34;initalize the AddEntityAction

        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        &#34;&#34;&#34;

        self.entityref = entityref
        self.position = position

    def __eq__(self, other):
        if isinstance(other, AddEntityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AddEntityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AddEntityAction element (same as generated by the class itself)

        Returns
        -------
            ae_action (AddEntityAction): a AddEntityAction object

        &#34;&#34;&#34;
        ea_element = element.find(&#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        aea_element = ea_element.find(&#34;AddEntityAction&#34;)
        position = _PositionFactory.parse_position(aea_element.find(&#34;Position&#34;))
        return AddEntityAction(entityref, position)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AddEntityAction as a dict&#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AddEntityAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
        addentity = ET.SubElement(entityact, &#34;AddEntityAction&#34;)
        addentity.append(self.position.get_element())

        return element


class DeleteEntityAction(_ActionType):
    &#34;&#34;&#34;The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario

    Parameters
    ----------
        entityref (str): reference name of the vehicle to remove

    Attributes
    ----------

        entityref (str): reference name of the vehicle to remove


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, entityref):
        &#34;&#34;&#34;initalize the DeleteEntityAction

        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        &#34;&#34;&#34;

        self.entityref = entityref

    def __eq__(self, other):
        if isinstance(other, DeleteEntityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of DeleteEntityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A DeleteEntityAction element (same as generated by the class itself)

        Returns
        -------
            de_action (DeleteEntityAction): a DeleteEntityAction object

        &#34;&#34;&#34;
        ea_element = element.find(&#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        return DeleteEntityAction(entityref)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DeleteEntityAction as a dict&#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the DeleteEntityAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
        ET.SubElement(entityact, &#34;DeleteEntityAction&#34;)

        return element


class TrafficSignalControllerAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal

    Parameters
    ----------
        phase (str): phase of the signal

        traffic_signalcontroller_ref (str): reference to traffic signal controller

    Attributes
    ----------

        phase (str): phase of the signal

        traffic_signalcontroller_ref (str): reference to traffic signal controller

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, phase, traffic_signalcontroller_ref):
        &#34;&#34;&#34;initalize the TrafficSignalControllerAction

        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        &#34;&#34;&#34;
        self.phase = phase
        self.traffic_signalcontroller_ref = traffic_signalcontroller_ref

    def __eq__(self, other):
        if isinstance(other, TrafficSignalControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSignalControllerAction element (same as generated by the class itself)

        Returns
        -------
            tsc_action (TrafficSignalControllerAction): a TrafficSignalControllerAction object

        &#34;&#34;&#34;
        isa_element = element.find(&#34;InfrastructureAction&#34;)
        tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
        tsc_element = tsa_element.find(&#34;TrafficSignalControllerAction&#34;)

        phase = tsc_element.attrib[&#34;phase&#34;]
        tsc_ref = tsc_element.attrib[&#34;trafficSignalControllerRef&#34;]

        return TrafficSignalControllerAction(phase, tsc_ref)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerAction as a dict&#34;&#34;&#34;
        return {
            &#34;phase&#34;: self.phase,
            &#34;trafficSignalControllerRef&#34;: self.traffic_signalcontroller_ref,
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(tsa, &#34;TrafficSignalControllerAction&#34;, self.get_attributes())

        return element


class TrafficSourceAction(_ActionType):
    &#34;&#34;&#34;The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction

    Parameters
    ----------
        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity of the traffic
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

    Attributes
    ----------

        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity of the traffic
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self, rate, radius, position, trafficdefinition, velocity=None, name=None
    ):
        &#34;&#34;&#34;initalize the TrafficSourceAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.velocity = convert_float(velocity)
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficSourceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
                and self.trafficdefinition == other.trafficdefinition
                and self.name == other.name
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSourceAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSourceAction element (same as generated by the class itself)

        Returns
        -------
            tsa_action (TrafficSourceAction): a TrafficSourceAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]
        tsa_element = ta_element.find(&#34;TrafficSourceAction&#34;)

        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif &#34;speed&#34; in tsa_element.attrib:
            velocity = tsa_element.attrib[&#34;speed&#34;]
        position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))
        trafficdefinition = TrafficDefinition.parse(
            tsa_element.find(&#34;TrafficDefinition&#34;)
        )

        return TrafficSourceAction(
            rate, radius, position, trafficdefinition, velocity, name
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSourceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        if self.velocity is not None:
            if self.version_minor &lt; 2:
                retdict[&#34;velocity&#34;] = str(self.velocity)
            else:
                retdict[&#34;speed&#34;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSourceAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}

        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
        sourceaction = ET.SubElement(
            trafficaction, &#34;TrafficSourceAction&#34;, attrib=self.get_attributes()
        )
        sourceaction.append(self.position.get_element())
        sourceaction.append(self.trafficdefinition.get_element())

        return element


class TrafficSinkAction(_ActionType):
    &#34;&#34;&#34;The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction

    Parameters
    ----------
        rate (float): rate of appearing traffic

        radius (float): the radius of the sink around the position

        position (*Position): any Position to define the sink

        trafficdefinition (TrafficDefinition): definition of the traffic

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

    Attributes
    ----------

        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, radius, position, trafficdefinition, rate=None, name=None):
        &#34;&#34;&#34;initalize the TrafficSinkAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficSinkAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
                and self.trafficdefinition == other.trafficdefinition
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSinkAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSinkAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficSinkAction): a TrafficSinkAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = ta_element.find(&#34;TrafficSinkAction&#34;)
        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = None
        if &#34;rate&#34; in tsa_element.attrib:
            rate = convert_float(tsa_element.attrib[&#34;rate&#34;])

        if tsa_element.find(&#34;TrafficDefinition&#34;) != None:
            trafficdefinition = TrafficDefinition.parse(
                tsa_element.find(&#34;TrafficDefinition&#34;)
            )

        position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))

        return TrafficSinkAction(radius, position, trafficdefinition, rate, name)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSinkAction as a dict&#34;&#34;&#34;
        retdict = {}

        retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSinkAction&#34;&#34;&#34;

        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
        sinkaction = ET.SubElement(
            trafficaction, &#34;TrafficSinkAction&#34;, attrib=self.get_attributes()
        )
        sinkaction.append(self.position.get_element())
        sinkaction.append(self.trafficdefinition.get_element())

        return element


class TrafficSwarmAction(_ActionType):
    &#34;&#34;&#34;The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction

    Parameters
    ----------
        semimajoraxis (float): half length of major axis of ellipsis around target

        semiminoraxis (float): half length of minor axis of ellipsis around target

        innerradius (float): radius of inner circle

        offset (float): longitudinal offset from central entity

        numberofvehicles (int): maximum number of vehicles around entity

        centralobject (str): entity to swarm around

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float or Range): optional starting velocity (range is replacing velocity in OSC V1.2)
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

        direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
            Default: None

    Attributes
    ----------

        semimajoraxis (float): half length of major axis of ellipsis around target

        semiminoraxis (float): half length of minor axis of ellipsis around target

        innerradius (float): radius of inner cirvle

        offset (float): longitudinal offset from central entity

        numberofvehicles (int): maximum number of vehicles around entity

        centralobject (str): entity to swarm around

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self,
        semimajoraxis,
        semiminoraxis,
        innerradius,
        offset,
        numberofvehicles,
        centralobject,
        trafficdefinition,
        velocity=None,
        name=None,
        direction_of_travel=None,
    ):
        &#34;&#34;&#34;initalize the TrafficSwarmAction

        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner circle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

            direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
                Default: None
        &#34;&#34;&#34;
        self.semimajoraxis = convert_float(semimajoraxis)
        self.semiminoraxis = convert_float(semiminoraxis)
        self.innerradius = convert_float(innerradius)
        self.offset = convert_float(offset)
        self.numberofvehicles = convert_int(numberofvehicles)
        self.centralobject = centralobject
        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.trafficdefinition = trafficdefinition
        if velocity is not None:
            if isinstance(velocity, Range):
                self.velocity = velocity
            else:
                self.velocity = convert_float(velocity)
        else:
            self.velocity = None
        self.name = name
        if direction_of_travel is not None and not isinstance(
            direction_of_travel, DirectionOfTravelDistribution
        ):
            raise TypeError(
                &#34;direction_of_travel is not of type DirectionOfTravelDistribution&#34;
            )
        self.direction_of_travel = direction_of_travel

    def __eq__(self, other):
        if isinstance(other, TrafficSwarmAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.centralobject == other.centralobject
                and self.trafficdefinition == other.trafficdefinition
                and self.name == other.name
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSwarmAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSwarmAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficSwarmAction): a TrafficSwarmAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = ta_element.find(&#34;TrafficSwarmAction&#34;)

        innerradius = convert_float(tsa_element.attrib[&#34;innerRadius&#34;])
        numberofvehicles = convert_int(tsa_element.attrib[&#34;numberOfVehicles&#34;])
        offset = convert_float(tsa_element.attrib[&#34;offset&#34;])
        semimajoraxis = convert_float(tsa_element.attrib[&#34;semiMajorAxis&#34;])
        semiminoraxis = convert_float(tsa_element.attrib[&#34;semiMinorAxis&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif tsa_element.find(&#34;InitalSpeedRange&#34;) is not None:
            velocity = Range.parse(tsa_element.find(&#34;InitalSpeedRange&#34;))

        trafficdefinition = TrafficDefinition.parse(
            tsa_element.find(&#34;TrafficDefinition&#34;)
        )
        dot = None
        if tsa_element.find(&#34;DirectionOfTravelDistribution&#34;):
            dot = DirectionOfTravelDistribution.parse(
                tsa_element.find(&#34;DirectionOfTravelDistribution&#34;)
            )
        central_element = tsa_element.find(&#34;CentralObject&#34;)
        centralobject = central_element.attrib[&#34;entityRef&#34;]

        tsa_object = TrafficSwarmAction(
            semimajoraxis,
            semiminoraxis,
            innerradius,
            offset,
            numberofvehicles,
            centralobject,
            trafficdefinition,
            velocity,
            name,
            dot,
        )
        return tsa_object

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSwarmAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;semiMajorAxis&#34;] = str(self.semimajoraxis)
        retdict[&#34;semiMinorAxis&#34;] = str(self.semiminoraxis)
        retdict[&#34;innerRadius&#34;] = str(self.innerradius)
        retdict[&#34;offset&#34;] = str(self.offset)
        retdict[&#34;numberOfVehicles&#34;] = str(self.numberofvehicles)
        if self.velocity is not None and not isinstance(self.velocity, Range):
            retdict[&#34;velocity&#34;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSwarmAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)

        swarmaction = ET.SubElement(
            trafficaction, &#34;TrafficSwarmAction&#34;, attrib=self.get_attributes()
        )
        swarmaction.append(self.trafficdefinition.get_element())
        ET.SubElement(
            swarmaction, &#34;CentralObject&#34;, attrib={&#34;entityRef&#34;: self.centralobject}
        )
        if self.velocity is not None:
            if self.version_minor &gt; 1:
                if isinstance(self.velocity, Range):
                    swarmaction.append(self.velocity.get_element(&#34;InitialSpeedRange&#34;))
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;Range for TrafficSwarmAction was introduced in OSC V1.2, velocity should not be used anymore.&#34;
                    )

        if self.direction_of_travel is not None:
            if self.version_minor &lt; 2:
                raise OpenSCENARIOVersionError(
                    &#34;DirectionOfTravelDistribution was added in OSC V1.2&#34;
                )
            swarmaction.append(self.direction_of_travel.get_element())

        return element


class TrafficStopAction(_ActionType):
    &#34;&#34;&#34;The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction

    Parameters
    ----------
        name (str): name of the Traffic to stop
            Default: None

    Attributes
    ----------

        name (str): name of the Traffic to stop

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, name=None):
        &#34;&#34;&#34;initalize the TrafficSwarmAction

        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None
        &#34;&#34;&#34;
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficStopAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficStopAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficStopAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficStopAction): a TrafficStopAction object

        &#34;&#34;&#34;
        trafficaction_element = element.find(&#34;TrafficAction&#34;)
        name = trafficaction_element.attrib[&#34;trafficName&#34;]
        return TrafficStopAction(name)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficStopAction as a dict&#34;&#34;&#34;
        retdict = {}
        if self.name and not self.isVersion(minor=0):
            retdict[&#34;trafficName&#34;] = str(self.name)
        elif self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;TrafficStopAction was introduced in OpenSCENARIO V1.1&#34;
            )

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficStopAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=self.get_attributes()
        )
        ET.SubElement(trafficaction, &#34;TrafficStopAction&#34;)

        return element


class EnvironmentAction(_ActionType):
    &#34;&#34;&#34;The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction

    Parameters
    ----------
        environment (Environment or CatalogReference): the environment to change to

    Attributes
    ----------

        environment (Environment or CatalogReference): the environment to change to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, environment):
        &#34;&#34;&#34;initalize the EnvironmentAction

        Parameters
        ----------
            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        &#34;&#34;&#34;
        if not (
            isinstance(environment, Environment)
            or isinstance(environment, CatalogReference)
        ):
            raise TypeError(
                &#34;environment input not of type Environment or CatalogReference&#34;
            )
        self.environment = environment

    def __eq__(self, other):
        if isinstance(other, EnvironmentAction):
            if self.environment == other.environment:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of BoundingBox

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            boundingBox (BoundingBox): a BoundingBox object

        &#34;&#34;&#34;
        action_element = element.find(&#34;EnvironmentAction&#34;)
        if action_element.find(&#34;Environment&#34;) != None:
            environment = Environment.parse(action_element.find(&#34;Environment&#34;))
        elif action_element.find(&#34;CatalogReference&#34;) != None:
            environment = CatalogReference.parse(
                action_element.find(&#34;CatalogReference&#34;)
            )

        return EnvironmentAction(environment)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the EnvironmentAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        envaction = ET.SubElement(element, &#34;EnvironmentAction&#34;)
        envaction.append(self.environment.get_element())

        return element


class UserDefinedAction(_ActionType):
    &#34;&#34;&#34;The UserDefinedAction enables adding simulator-specific CustomCommandActions.

    Parameters
    ----------

    Attributes
    ----------

    Methods
    -------
        add_custom_command_action(custom_command_action)
            Adds a CustomCommandAction to the UserDefinedAction

        get_element()
            Returns the full ElementTree of the class
    &#34;&#34;&#34;

    def __init__(self, custom_command_action):
        &#34;&#34;&#34;initalize the UserDefinedAction

        Parameters
        ----------

        &#34;&#34;&#34;
        self.custom_command_action = custom_command_action

    def __eq__(self, other):
        if isinstance(other, UserDefinedAction):
            if self.custom_command_action == other.custom_command_action:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parsese the xml element of a UserDefinedAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedAction element

        Returns
        -------
            userDefinedAction (UserDefinedAction): a UserDefinedAction object

        &#34;&#34;&#34;
        custom_command_action = CustomCommandAction.parse(
            element.find(&#34;CustomCommandAction&#34;)
        )
        user_defined_action = UserDefinedAction(custom_command_action)
        return user_defined_action

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedAction&#34;&#34;&#34;
        element = ET.Element(&#34;UserDefinedAction&#34;)
        element.append(self.custom_command_action.get_element())
        return element


class CustomCommandAction(_ActionType):
    &#34;&#34;&#34;The CustomCommandAction creates a simulator defined action


    Parameters
    ----------

    Attributes
    ----------

        type (str): type of the custom command

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, type, content):
        &#34;&#34;&#34;initalize the CustomCommandAction

        Parameters
        ----------
            type (str): type of the custom command

            content (str): content of the custom command
        &#34;&#34;&#34;
        self.type = type
        self.content = content

    def __eq__(self, other):
        if isinstance(other, CustomCommandAction):
            if other.type == self.type:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parsese the xml element of a CustomCommandAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a CustomCommandAction element

        Returns
        -------
            customCommandAction (CustomCommandAction): a CustomCommandAction object

        &#34;&#34;&#34;
        if element.tag != &#34;CustomCommandAction&#34;:
            raise NotAValidElement(
                f&#39;Expected &#34;CustomCommandAction&#34; element, received &#34;{element.tag}&#34;.&#39;
            )
        action_type = element.attrib.get(&#34;type&#34;, None)
        if action_type == None:
            raise NotAValidElement(
                &#39;CustomCommandAction is missing required argument &#34;type&#34;.&#39;
            )

        return CustomCommandAction(action_type, element.text)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the CustomCommandAction&#34;&#34;&#34;
        element = ET.Element(&#34;CustomCommandAction&#34;, attrib={&#34;type&#34;: self.type})
        element.text = self.content
        return element</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneChangeAction</span></span>
<span>(</span><span>lane, transition_dynamics, target_lane_offset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (int): lane to change to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lane (int): lane to change to

target_lane_offset (float): offset in the target lane is wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize AbsoluteLaneChangeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane (int): lane to change to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;the AbsoluteLaneChangeAction creates a LateralAction of type LaneChangeAction with an absolute target

    Parameters
    ----------
        lane (int): lane to change to

        transition_dynamics (TransitionDynamics): how the change should be made

        target_lane_offset (float): if a offset in the target lane is wanted
            Default: None

    Attributes
    ----------
        lane (int): lane to change to

        target_lane_offset (float): offset in the target lane is wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, lane, transition_dynamics, target_lane_offset=None):
        &#34;&#34;&#34;initalize AbsoluteLaneChangeAction

        Parameters
        ----------
            lane (int): lane to change to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = convert_int(lane)
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, AbsoluteLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

        Returns
        -------
            alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

        &#34;&#34;&#34;
        lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
        dynamics = TransitionDynamics.parse(
            lca_element.find(&#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = lca_element.find(&#34;LaneChangeTarget/AbsoluteTargetLane&#34;)
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])

        return AbsoluteLaneChangeAction(lane, dynamics, target_lane_offset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteLaneChangeAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneChangeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(lanchangetarget, &#34;AbsoluteTargetLane&#34;, self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AbsoluteLaneChangeAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

    Returns
    -------
        alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

    &#34;&#34;&#34;
    lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
    target_lane_offset = None
    if &#34;targetLaneOffset&#34; in lca_element.attrib:
        target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
    dynamics = TransitionDynamics.parse(
        lca_element.find(&#34;LaneChangeActionDynamics&#34;)
    )
    targetlane_element = lca_element.find(&#34;LaneChangeTarget/AbsoluteTargetLane&#34;)
    lane = convert_int(targetlane_element.attrib[&#34;value&#34;])

    return AbsoluteLaneChangeAction(lane, dynamics, target_lane_offset)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteLaneChangeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteLaneChangeAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.lane)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteLaneChangeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneChangeAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    laneoffset = {}
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    if self.target_lane_offset:
        laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(
        lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
    )

    lanechangeaction.append(
        self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
    )
    lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

    ET.SubElement(lanchangetarget, &#34;AbsoluteTargetLane&#34;, self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteLaneOffsetAction</span></span>
<span>(</span><span>value, shape, maxlatacc=None, continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): lateral offset of the lane

shape (DynamicsShapes): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>continuous (bool): if the controller tries to keep the relative speed

value (float): lateral offset of the lane

target (str): the name of the entity (relative only)

dynshape (DynamicsShapes): the shape of the action

maxlatacc (float): maximum allowed lateral acceleration
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the AbsoluteLaneOffsetAction
Parameters</p>
<hr>
<pre><code>value (float): lateral offset of the lane

shape (DynamicsShapes): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;the AbsoluteLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with an absolute target

    Parameters
    ----------
        value (float): lateral offset of the lane

        shape (DynamicsShapes): shape of the offset action

        maxlatacc (float): maximum allowed lateral acceleration

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

    Attributes
    ----------
        continuous (bool): if the controller tries to keep the relative speed

        value (float): lateral offset of the lane

        target (str): the name of the entity (relative only)

        dynshape (DynamicsShapes): the shape of the action

        maxlatacc (float): maximum allowed lateral acceleration

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, shape, maxlatacc=None, continuous=True):
        &#34;&#34;&#34;initalizes the AbsoluteLaneOffsetAction
        Parameters
        ----------
            value (float): lateral offset of the lane

            shape (DynamicsShapes): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed
                Default: True
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.dynshape = convert_enum(shape, DynamicsShapes)
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other):
        if isinstance(other, AbsoluteLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

        Returns
        -------
            alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

        &#34;&#34;&#34;
        loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

        continuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = convert_enum(load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes)

        atlo_element = loa_element.find(&#34;LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;)
        value = atlo_element.attrib[&#34;value&#34;]

        return AbsoluteLaneOffsetAction(value, dynamics, maxacc, continuous)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteLaneOffsetAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(laneoftarget, &#34;AbsoluteTargetLaneOffset&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AbsoluteLaneOffsetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

    Returns
    -------
        alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

    &#34;&#34;&#34;
    loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

    continuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
    load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
    maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
    dynamics = convert_enum(load_element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes)

    atlo_element = loa_element.find(&#34;LaneOffsetTarget/AbsoluteTargetLaneOffset&#34;)
    value = atlo_element.attrib[&#34;value&#34;]

    return AbsoluteLaneOffsetAction(value, dynamics, maxacc, continuous)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteLaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteLaneOffsetAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.value)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteLaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteLaneOffsetAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    laneoffsetaction = ET.SubElement(
        lataction,
        &#34;LaneOffsetAction&#34;,
        attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
    )
    ET.SubElement(
        laneoffsetaction,
        &#34;LaneOffsetActionDynamics&#34;,
        {
            &#34;maxLateralAcc&#34;: str(self.maxlatacc),
            &#34;dynamicsShape&#34;: self.dynshape.get_name(),
        },
    )
    laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
    ET.SubElement(laneoftarget, &#34;AbsoluteTargetLaneOffset&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction"><code class="flex name class">
<span>class <span class="ident">AbsoluteSpeedAction</span></span>
<span>(</span><span>speed:Â float, transition_dynamics)</span>
</code></dt>
<dd>
<div class="desc"><p>The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed</p>
<h2 id="parameters">Parameters</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the AbsoluteSpeedAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speed (float): the speed wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;The AbsoluteSpeedAction class specifies a LongitudinalAction of type SpeedAction with an abosulte target speed

    Parameters
    ----------
        speed (float): the speed wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Attributes
    ----------

        speed (float): the speed wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, speed: float, transition_dynamics):
        &#34;&#34;&#34;initalize the AbsoluteSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            transition_dynamics (TransitionDynamics): how the change should be made

        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, AbsoluteSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of WorldPosition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            position (WorldPosition): a world position object

        &#34;&#34;&#34;
        speed_element = element.find(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;
        )
        td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
        speed = speed_element.attrib[&#34;value&#34;]
        transition_dynamics = TransitionDynamics.parse(td_element)
        return AbsoluteSpeedAction(speed, transition_dynamics)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)

        speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(speedactiontarget, &#34;AbsoluteTargetSpeed&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of WorldPosition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>position (WorldPosition): a world position object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of WorldPosition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        position (WorldPosition): a world position object

    &#34;&#34;&#34;
    speed_element = element.find(
        &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/AbsoluteTargetSpeed&#34;
    )
    td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
    speed = speed_element.attrib[&#34;value&#34;]
    transition_dynamics = TransitionDynamics.parse(td_element)
    return AbsoluteSpeedAction(speed, transition_dynamics)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.speed)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)

    speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
    speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

    ET.SubElement(speedactiontarget, &#34;AbsoluteTargetSpeed&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction"><code class="flex name class">
<span>class <span class="ident">AcquirePositionAction</span></span>
<span>(</span><span>position)</span>
</code></dt>
<dd>
<div class="desc"><p>AcquirePositionAction creates a RouteAction of type AcquirePositionAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): target position
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>position (*Position): target position
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AcquirePositionAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>position (*Position): target position
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcquirePositionAction(_PrivateActionType):
    &#34;&#34;&#34;AcquirePositionAction creates a RouteAction of type AcquirePositionAction

    Parameters
    ----------
        position (*Position): target position

    Attributes
    ----------
        position (*Position): target position

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34;initalizes the AcquirePositionAction

        Parameters
        ----------
            position (*Position): target position

        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other):
        if isinstance(other, AcquirePositionAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AcquirePositionAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AcquirePositionAction element (same as generated by the class itself)

        Returns
        -------
            ap_action (AcquirePositionAction): a AcquirePositionAction object

        &#34;&#34;&#34;
        pos_element = element.find(&#34;RoutingAction/AcquirePositionAction/Position&#34;)

        position = _PositionFactory.parse_position(pos_element)

        return AcquirePositionAction(position)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AcquirePositionAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        posaction = ET.SubElement(routeaction, &#34;AcquirePositionAction&#34;)
        posaction.append(self.position.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AcquirePositionAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AcquirePositionAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ap_action (AcquirePositionAction): a AcquirePositionAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AcquirePositionAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AcquirePositionAction element (same as generated by the class itself)

    Returns
    -------
        ap_action (AcquirePositionAction): a AcquirePositionAction object

    &#34;&#34;&#34;
    pos_element = element.find(&#34;RoutingAction/AcquirePositionAction/Position&#34;)

    position = _PositionFactory.parse_position(pos_element)

    return AcquirePositionAction(position)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AcquirePositionAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AcquirePositionAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AcquirePositionAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    posaction = ET.SubElement(routeaction, &#34;AcquirePositionAction&#34;)
    posaction.append(self.position.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction"><code class="flex name class">
<span>class <span class="ident">ActivateControllerAction</span></span>
<span>(</span><span>lateral=None, longitudinal=None, animation=None, lighting=None, controllerRef=None)</span>
</code></dt>
<dd>
<div class="desc"><p>ActivateControllerAction creates a ActivateControllerAction of open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lateral (boolean): activate or deactivate the controller

longitudinal (boolean): activate or deactivate the controller

animation (boolean): activate or deactivate an animation

lighting (boolean): activate or deactivate lights

controllerRef (Controller): reference to a controller assigned to the entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lateral (boolean): activate or deactivate the controller

longitudinal (boolean): activate or deactivate the controller

animation (boolean): activate or deactivate an animation

lighting (boolean): activate or deactivate lights

controllerRef (Controller): reference to a controller assigned to the entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalizes the ActivateControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lateral (boolean): activate or deactivate the controller
    Default: None

longitudinal (boolean): activate or deactivate the controller

animation (boolean): activate or deactivate an animation

lighting (boolean): activate or deactivate lights

controllerRef (Controller): reference to a controller assigned to the entity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActivateControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ActivateControllerAction creates a ActivateControllerAction of open scenario

    Parameters
    ----------
        lateral (boolean): activate or deactivate the controller

        longitudinal (boolean): activate or deactivate the controller

        animation (boolean): activate or deactivate an animation

        lighting (boolean): activate or deactivate lights

        controllerRef (Controller): reference to a controller assigned to the entity

    Attributes
    ----------
        lateral (boolean): activate or deactivate the controller

        longitudinal (boolean): activate or deactivate the controller

        animation (boolean): activate or deactivate an animation

        lighting (boolean): activate or deactivate lights

        controllerRef (Controller): reference to a controller assigned to the entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        lateral=None,
        longitudinal=None,
        animation=None,
        lighting=None,
        controllerRef=None,
    ):
        &#34;&#34;&#34;initalizes the ActivateControllerAction

        Parameters
        ----------
            lateral (boolean): activate or deactivate the controller
                Default: None

            longitudinal (boolean): activate or deactivate the controller

            animation (boolean): activate or deactivate an animation

            lighting (boolean): activate or deactivate lights

            controllerRef (Controller): reference to a controller assigned to the entity

        &#34;&#34;&#34;
        self.lateral = convert_bool(lateral)
        self.longitudinal = convert_bool(longitudinal)
        self.animation = convert_bool(animation)
        self.lighting = convert_bool(lighting)
        self.controllerRef = controllerRef

    def __eq__(self, other):
        if isinstance(other, ActivateControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        elif isinstance(other, ControllerAction):
            if self.get_attributes() == other.activateControllerAction.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ActivateControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ActivateControllerAction element (same as generated by the class itself)

        Returns
        -------
            ac_action (ActivateControllerAction): a ActivateControllerAction object

        &#34;&#34;&#34;
        lateral = None
        longitudinal = None
        animation = None
        lighting = None
        controllerRef = None
        aca_element = element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
        if &#34;lateral&#34; in aca_element.attrib:
            lateral = convert_bool(aca_element.attrib[&#34;lateral&#34;])
        if &#34;longitudinal&#34; in aca_element.attrib:
            longitudinal = convert_bool(aca_element.attrib[&#34;longitudinal&#34;])
        if &#34;animation&#34; in aca_element.attrib:
            animation = convert_bool(aca_element.attrib[&#34;animation&#34;])
        if &#34;lighting&#34; in aca_element.attrib:
            lighting = convert_bool(aca_element.attrib[&#34;lighting&#34;])
        if &#34;controllerRef&#34; in aca_element.attrib:
            controllerRef = aca_element.attrib[&#34;controllerRef&#34;]

        return ActivateControllerAction(
            lateral, longitudinal, animation, lighting, controllerRef
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ActivateControllerAction as a dict&#34;&#34;&#34;
        retdict = {}
        if self.lateral is not None:
            retdict[&#34;lateral&#34;] = get_bool_string(self.lateral)
        if self.longitudinal is not None:
            retdict[&#34;longitudinal&#34;] = get_bool_string(self.longitudinal)
        if self.animation is not None and self.isVersion(minor=2):
            retdict[&#34;animation&#34;] = get_bool_string(self.animation)
        if self.lighting is not None and self.isVersion(minor=2):
            retdict[&#34;lighting&#34;] = get_bool_string(self.lighting)
        if self.controllerRef is not None and self.isVersion(minor=2):
            retdict[&#34;controllerRef&#34;] = self.controllerRef
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ActivateControllerAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        if self.isVersion(minor=0):
            ET.SubElement(
                element, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
            )
        else:
            subelem = ET.SubElement(element, &#34;ControllerAction&#34;)
            ET.SubElement(
                subelem, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
            )
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ActivateControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ActivateControllerAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ac_action (ActivateControllerAction): a ActivateControllerAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ActivateControllerAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ActivateControllerAction element (same as generated by the class itself)

    Returns
    -------
        ac_action (ActivateControllerAction): a ActivateControllerAction object

    &#34;&#34;&#34;
    lateral = None
    longitudinal = None
    animation = None
    lighting = None
    controllerRef = None
    aca_element = element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
    if &#34;lateral&#34; in aca_element.attrib:
        lateral = convert_bool(aca_element.attrib[&#34;lateral&#34;])
    if &#34;longitudinal&#34; in aca_element.attrib:
        longitudinal = convert_bool(aca_element.attrib[&#34;longitudinal&#34;])
    if &#34;animation&#34; in aca_element.attrib:
        animation = convert_bool(aca_element.attrib[&#34;animation&#34;])
    if &#34;lighting&#34; in aca_element.attrib:
        lighting = convert_bool(aca_element.attrib[&#34;lighting&#34;])
    if &#34;controllerRef&#34; in aca_element.attrib:
        controllerRef = aca_element.attrib[&#34;controllerRef&#34;]

    return ActivateControllerAction(
        lateral, longitudinal, animation, lighting, controllerRef
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ActivateControllerAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ActivateControllerAction as a dict&#34;&#34;&#34;
    retdict = {}
    if self.lateral is not None:
        retdict[&#34;lateral&#34;] = get_bool_string(self.lateral)
    if self.longitudinal is not None:
        retdict[&#34;longitudinal&#34;] = get_bool_string(self.longitudinal)
    if self.animation is not None and self.isVersion(minor=2):
        retdict[&#34;animation&#34;] = get_bool_string(self.animation)
    if self.lighting is not None and self.isVersion(minor=2):
        retdict[&#34;lighting&#34;] = get_bool_string(self.lighting)
    if self.controllerRef is not None and self.isVersion(minor=2):
        retdict[&#34;controllerRef&#34;] = self.controllerRef
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ActivateControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ActivateControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ActivateControllerAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    if self.isVersion(minor=0):
        ET.SubElement(
            element, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
        )
    else:
        subelem = ET.SubElement(element, &#34;ControllerAction&#34;)
        ET.SubElement(
            subelem, &#34;ActivateControllerAction&#34;, attrib=self.get_attributes()
        )
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction"><code class="flex name class">
<span>class <span class="ident">AddEntityAction</span></span>
<span>(</span><span>entityref, position)</span>
</code></dt>
<dd>
<div class="desc"><p>The AddEntityAction class creates a EntityAction which adds a entity to the scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the AddEntityAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entityref (str): reference name of the newly added vehicle

position (*Position): position where the vehicle should be added
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AddEntityAction(_ActionType):
    &#34;&#34;&#34;The AddEntityAction class creates a EntityAction which adds a entity to the scenario

    Parameters
    ----------
        entityref (str): reference name of the newly added vehicle

        position (*Position): position where the vehicle should be added

    Attributes
    ----------

        entityref (str): reference name of the newly added vehicle

        position (*Position): position where the vehicle should be added

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, entityref, position):
        &#34;&#34;&#34;initalize the AddEntityAction

        Parameters
        ----------
            entityref (str): reference name of the newly added vehicle

            position (*Position): position where the vehicle should be added

        &#34;&#34;&#34;

        self.entityref = entityref
        self.position = position

    def __eq__(self, other):
        if isinstance(other, AddEntityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AddEntityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AddEntityAction element (same as generated by the class itself)

        Returns
        -------
            ae_action (AddEntityAction): a AddEntityAction object

        &#34;&#34;&#34;
        ea_element = element.find(&#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        aea_element = ea_element.find(&#34;AddEntityAction&#34;)
        position = _PositionFactory.parse_position(aea_element.find(&#34;Position&#34;))
        return AddEntityAction(entityref, position)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AddEntityAction as a dict&#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AddEntityAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
        addentity = ET.SubElement(entityact, &#34;AddEntityAction&#34;)
        addentity.append(self.position.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AddEntityAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AddEntityAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ae_action (AddEntityAction): a AddEntityAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AddEntityAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AddEntityAction element (same as generated by the class itself)

    Returns
    -------
        ae_action (AddEntityAction): a AddEntityAction object

    &#34;&#34;&#34;
    ea_element = element.find(&#34;EntityAction&#34;)
    entityref = ea_element.attrib[&#34;entityRef&#34;]
    aea_element = ea_element.find(&#34;AddEntityAction&#34;)
    position = _PositionFactory.parse_position(aea_element.find(&#34;Position&#34;))
    return AddEntityAction(entityref, position)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AddEntityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AddEntityAction as a dict&#34;&#34;&#34;
    return {&#34;entityRef&#34;: self.entityref}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AddEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AddEntityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AddEntityAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
    addentity = ET.SubElement(entityact, &#34;AddEntityAction&#34;)
    addentity.append(self.position.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AnimationAction"><code class="flex name class">
<span>class <span class="ident">AnimationAction</span></span>
<span>(</span><span>animation_type, duration=None, loop=None, state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>AnimationAction creates an AppearanceAction of of the Type AnimationAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

duration (float): the duraton of the animation
    Default: None

loop (bool): if the animation should be looped
    Default: None

state (float): what state the animation should be put to
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>animation_type (_ComponentAnimation, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

duration (float): the duraton of the animation

loop (bool): if the animation should be looped

state (float): what state the animation should be put to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalize the AnimationAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

duration (float): the duraton of the animation
    Default: None

loop (bool): if the animation should be looped
    Default: None

state (float): what state the animation should be put to
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnimationAction(_PrivateActionType):
    &#34;&#34;&#34;AnimationAction creates an AppearanceAction of of the Type AnimationAction

    Parameters
    ----------
        animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

        duration (float): the duraton of the animation
            Default: None

        loop (bool): if the animation should be looped
            Default: None

        state (float): what state the animation should be put to
            Default: None

    Attributes
    ----------

        animation_type (_ComponentAnimation, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

        duration (float): the duraton of the animation

        loop (bool): if the animation should be looped

        state (float): what state the animation should be put to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        animation_type,
        duration=None,
        loop=None,
        state=None,
    ):
        &#34;&#34;&#34;initalize the AnimationAction

        Parameters
        ----------
            animation_type (VehicleComponentType, UserDefinedComponent, PedestrianAnimation, AnimationFile or UserDefinedAnimation): the animation to be taken place

            duration (float): the duraton of the animation
                Default: None

            loop (bool): if the animation should be looped
                Default: None

            state (float): what state the animation should be put to
                Default: None
        &#34;&#34;&#34;

        try:
            self.animation_type = _ComponentAnimation(_VehicleComponent(animation_type))
        except Exception as e:
            self.animation_type = None
        if self.animation_type:
            pass
        elif isinstance(animation_type, UserDefinedComponent):
            self.animation_type = _ComponentAnimation(animation_type)
        else:
            self.animation_type = animation_type
        self.duration = convert_float(duration)
        if loop is not None and not isinstance(loop, bool):
            raise TypeError(&#34;loop input is not of type bool&#34;)
        self.loop = loop
        self.state = convert_float(state)

    def __eq__(self, other):
        if isinstance(other, AnimationAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.animation_type == other.animation_type
                and self.state == other.state
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AnimationAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AnimationAction element (same as generated by the class itself)

        Returns
        -------
            animation_action (AnimationAction): a AnimationAction object

        &#34;&#34;&#34;
        animation_element = element.find(&#34;AppearanceAction/AnimationAction&#34;)
        duration = None
        if &#34;animationDuration&#34; in animation_element.attrib:
            duration = convert_float(animation_element.attrib[&#34;animationDuration&#34;])
        loop = None
        if &#34;loop&#34; in animation_element.attrib:
            loop = convert_bool(animation_element.attrib[&#34;loop&#34;])
        animation_state = animation_element.find(&#34;AnimationState&#34;)
        state = None
        if animation_state is not None:
            state = convert_float(animation_state.attrib[&#34;state&#34;])
        animation_type = _AnimationTypeFactory.parse_animationtype(
            animation_element.find(&#34;AnimationType&#34;)
        )
        return AnimationAction(animation_type, duration, loop, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AnimationAction as a dict&#34;&#34;&#34;
        retdict = {}

        if self.duration is not None:
            retdict[&#34;animationDuration&#34;] = str(self.duration)
        if self.loop is not None:
            retdict[&#34;loop&#34;] = get_bool_string(self.loop)

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AnimationAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        animation_element = ET.SubElement(
            appear_element, &#34;AnimationAction&#34;, self.get_attributes()
        )

        animation_type_element = ET.SubElement(animation_element, &#34;AnimationType&#34;)
        animation_type_element.append(self.animation_type.get_element())
        if self.state is not None:
            ET.SubElement(
                animation_element, &#34;AnimationState&#34;, attrib={&#34;state&#34;: str(self.state)}
            )

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AnimationAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AnimationAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AnimationAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>animation_action (AnimationAction): a AnimationAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AnimationAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AnimationAction element (same as generated by the class itself)

    Returns
    -------
        animation_action (AnimationAction): a AnimationAction object

    &#34;&#34;&#34;
    animation_element = element.find(&#34;AppearanceAction/AnimationAction&#34;)
    duration = None
    if &#34;animationDuration&#34; in animation_element.attrib:
        duration = convert_float(animation_element.attrib[&#34;animationDuration&#34;])
    loop = None
    if &#34;loop&#34; in animation_element.attrib:
        loop = convert_bool(animation_element.attrib[&#34;loop&#34;])
    animation_state = animation_element.find(&#34;AnimationState&#34;)
    state = None
    if animation_state is not None:
        state = convert_float(animation_state.attrib[&#34;state&#34;])
    animation_type = _AnimationTypeFactory.parse_animationtype(
        animation_element.find(&#34;AnimationType&#34;)
    )
    return AnimationAction(animation_type, duration, loop, state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AnimationAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AnimationAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AnimationAction as a dict&#34;&#34;&#34;
    retdict = {}

    if self.duration is not None:
        retdict[&#34;animationDuration&#34;] = str(self.duration)
    if self.loop is not None:
        retdict[&#34;loop&#34;] = get_bool_string(self.loop)

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AnimationAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AnimationAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AnimationAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
    animation_element = ET.SubElement(
        appear_element, &#34;AnimationAction&#34;, self.get_attributes()
    )

    animation_type_element = ET.SubElement(animation_element, &#34;AnimationType&#34;)
    animation_type_element.append(self.animation_type.get_element())
    if self.state is not None:
        ET.SubElement(
            animation_element, &#34;AnimationState&#34;, attrib={&#34;state&#34;: str(self.state)}
        )

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction"><code class="flex name class">
<span>class <span class="ident">AssignControllerAction</span></span>
<span>(</span><span>controller, activateLateral=True, activateLongitudinal=True, activateLighting=False, activateAnimation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>AssignControllerAction creates a ControllerAction of type AssignControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>controller (Controller or Catalogreference): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)
    Default: True

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
    Default: True

activateLighting (bool): if the lighting control should be activated (valid from V1.2)
    Default: False

activateAnimation (bool): if the lighting control should be activated (valid from V1.2)
    Default: False
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>controller (boolController or Catalogreferenceean): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)

activateLighting (bool): if the lighting control should be activated (valid from V1.2)

activateAnimation (bool): if the lighting control should be activated (valid from V1.2)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AssignControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>controller (Controller or Catalogreference): a controller to assign

activateLateral (bool): if the lateral control should be activated (valid from V1.1)
    Default: True

activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignControllerAction(_PrivateActionType):
    &#34;&#34;&#34;AssignControllerAction creates a ControllerAction of type AssignControllerAction

    Parameters
    ----------
        controller (Controller or Catalogreference): a controller to assign

        activateLateral (bool): if the lateral control should be activated (valid from V1.1)
            Default: True

        activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
            Default: True

        activateLighting (bool): if the lighting control should be activated (valid from V1.2)
            Default: False

        activateAnimation (bool): if the lighting control should be activated (valid from V1.2)
            Default: False

    Attributes
    ----------
        controller (boolController or Catalogreferenceean): a controller to assign

        activateLateral (bool): if the lateral control should be activated (valid from V1.1)

        activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)

        activateLighting (bool): if the lighting control should be activated (valid from V1.2)

        activateAnimation (bool): if the lighting control should be activated (valid from V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        controller,
        activateLateral=True,
        activateLongitudinal=True,
        activateLighting=False,
        activateAnimation=False,
    ):
        &#34;&#34;&#34;initalizes the AssignControllerAction

        Parameters
        ----------
            controller (Controller or Catalogreference): a controller to assign

            activateLateral (bool): if the lateral control should be activated (valid from V1.1)
                Default: True

            activateLongitudinal (bool): if the longitudinal control should be activated (valid from V1.1)
                Default: True
        &#34;&#34;&#34;
        if not (
            isinstance(controller, Controller)
            or isinstance(controller, CatalogReference)
        ):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)
        self.controller = controller
        self.activateLateral = convert_bool(activateLateral)
        self.activateLongitudinal = convert_bool(activateLongitudinal)
        self.activateLighting = convert_bool(activateLighting)
        self.activateAnimation = convert_bool(activateAnimation)
        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, AssignControllerAction):
            if self.controller == other.controller:
                return True
        elif isinstance(other, ControllerAction):
            if self.controller == other.assignControllerAction.controller:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AssignControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AssignControllerAction element (same as generated by the class itself)

        Returns
        -------
            ac_action (AssignControllerAction): a AssignControllerAction object

        &#34;&#34;&#34;
        ca_element = element.find(&#34;ControllerAction&#34;)
        aca_element = ca_element.find(&#34;AssignControllerAction&#34;)
        activate_lateral = True
        if &#34;activateLateral&#34; in aca_element.attrib:
            activate_lateral = convert_bool(aca_element.attrib[&#34;activateLateral&#34;])

        activate_longitudinal = True
        if &#34;activateLongitudinal&#34; in aca_element.attrib:
            activate_longitudinal = convert_bool(
                aca_element.attrib[&#34;activateLongitudinal&#34;]
            )
        activate_lighting = False
        if &#34;activateLighting&#34; in aca_element.attrib:
            activate_lighting = convert_bool(aca_element.attrib[&#34;activateLighting&#34;])
        activate_animation = False
        if &#34;activateAnimation&#34; in aca_element.attrib:
            activate_animation = convert_bool(aca_element.attrib[&#34;activateAnimation&#34;])
        controller = None
        if aca_element.find(&#34;Controller&#34;) != None:
            controller = Controller.parse(aca_element.find(&#34;Controller&#34;))
        elif aca_element.find(&#34;CatalogReference&#34;) != None:
            controller = CatalogReference.parse(aca_element.find(&#34;CatalogReference&#34;))
        else:
            raise NotAValidElement(&#34;No Controller found for AssignControllerAction&#34;)

        return AssignControllerAction(
            controller,
            activate_lateral,
            activate_longitudinal,
            activate_lighting,
            activate_animation,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AssignControllerAction as a dict&#34;&#34;&#34;
        retdict = {}

        if self.isVersionEqLarger(minor=1):
            retdict = {
                &#34;activateLateral&#34;: get_bool_string(self.activateLateral),
                &#34;activateLongitudinal&#34;: get_bool_string(self.activateLongitudinal),
            }
        if self.isVersionEqLarger(minor=2):
            retdict[&#34;activateLighting&#34;] = get_bool_string(self.activateLighting)
            retdict[&#34;activateAnimation&#34;] = get_bool_string(self.activateAnimation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AssignControllerAction&#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;AssignControllerAction cannot be used alone in OSC 1.0, please add it to a ControllerAction.&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        assigncontrolleraction = ET.SubElement(
            controlleraction, &#34;AssignControllerAction&#34;, self.get_attributes()
        )
        assigncontrolleraction.append(self.controller.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AssignControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AssignControllerAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ac_action (AssignControllerAction): a AssignControllerAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AssignControllerAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AssignControllerAction element (same as generated by the class itself)

    Returns
    -------
        ac_action (AssignControllerAction): a AssignControllerAction object

    &#34;&#34;&#34;
    ca_element = element.find(&#34;ControllerAction&#34;)
    aca_element = ca_element.find(&#34;AssignControllerAction&#34;)
    activate_lateral = True
    if &#34;activateLateral&#34; in aca_element.attrib:
        activate_lateral = convert_bool(aca_element.attrib[&#34;activateLateral&#34;])

    activate_longitudinal = True
    if &#34;activateLongitudinal&#34; in aca_element.attrib:
        activate_longitudinal = convert_bool(
            aca_element.attrib[&#34;activateLongitudinal&#34;]
        )
    activate_lighting = False
    if &#34;activateLighting&#34; in aca_element.attrib:
        activate_lighting = convert_bool(aca_element.attrib[&#34;activateLighting&#34;])
    activate_animation = False
    if &#34;activateAnimation&#34; in aca_element.attrib:
        activate_animation = convert_bool(aca_element.attrib[&#34;activateAnimation&#34;])
    controller = None
    if aca_element.find(&#34;Controller&#34;) != None:
        controller = Controller.parse(aca_element.find(&#34;Controller&#34;))
    elif aca_element.find(&#34;CatalogReference&#34;) != None:
        controller = CatalogReference.parse(aca_element.find(&#34;CatalogReference&#34;))
    else:
        raise NotAValidElement(&#34;No Controller found for AssignControllerAction&#34;)

    return AssignControllerAction(
        controller,
        activate_lateral,
        activate_longitudinal,
        activate_lighting,
        activate_animation,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AssignControllerAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AssignControllerAction as a dict&#34;&#34;&#34;
    retdict = {}

    if self.isVersionEqLarger(minor=1):
        retdict = {
            &#34;activateLateral&#34;: get_bool_string(self.activateLateral),
            &#34;activateLongitudinal&#34;: get_bool_string(self.activateLongitudinal),
        }
    if self.isVersionEqLarger(minor=2):
        retdict[&#34;activateLighting&#34;] = get_bool_string(self.activateLighting)
        retdict[&#34;activateAnimation&#34;] = get_bool_string(self.activateAnimation)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AssignControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AssignControllerAction&#34;&#34;&#34;
    if self.isVersion(minor=0) and not self._used_by_parent:
        raise OpenSCENARIOVersionError(
            &#34;AssignControllerAction cannot be used alone in OSC 1.0, please add it to a ControllerAction.&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
    assigncontrolleraction = ET.SubElement(
        controlleraction, &#34;AssignControllerAction&#34;, self.get_attributes()
    )
    assigncontrolleraction.append(self.controller.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction"><code class="flex name class">
<span>class <span class="ident">AssignRouteAction</span></span>
<span>(</span><span>route)</span>
</code></dt>
<dd>
<div class="desc"><p>AssignRouteAction creates a RouteAction of type AssignRouteAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the AssignRouteAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>route (Route, or CatalogReference): the route to follow
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignRouteAction(_PrivateActionType):
    &#34;&#34;&#34;AssignRouteAction creates a RouteAction of type AssignRouteAction

    Parameters
    ----------
        route (Route, or CatalogReference): the route to follow

    Attributes
    ----------
        route (Route, or CatalogReference): the route to follow


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, route):
        &#34;&#34;&#34;initalizes the AssignRouteAction

        Parameters
        ----------
            route (Route, or CatalogReference): the route to follow

        &#34;&#34;&#34;
        if not (isinstance(route, Route) or isinstance(route, CatalogReference)):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)

        self.route = route

    def __eq__(self, other):
        if isinstance(other, AssignRouteAction):
            if self.route == other.route:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AssignRouteAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AssignRouteAction element (same as generated by the class itself)

        Returns
        -------
            ar_action (AssignRouteAction): a AssignRouteAction object

        &#34;&#34;&#34;
        ara_element = element.find(&#34;RoutingAction/AssignRouteAction&#34;)
        route = None
        if ara_element.find(&#34;Route&#34;) != None:
            route = Route.parse(ara_element.find(&#34;Route&#34;))
        elif ara_element.find(&#34;CatalogReference&#34;) != None:
            route = CatalogReference.parse(ara_element.find(&#34;CatalogReference&#34;))

        return AssignRouteAction(route)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AssignRouteAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        assignrouteaction = ET.SubElement(routeaction, &#34;AssignRouteAction&#34;)
        assignrouteaction.append(self.route.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AssignRouteAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AssignRouteAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ar_action (AssignRouteAction): a AssignRouteAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AssignRouteAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AssignRouteAction element (same as generated by the class itself)

    Returns
    -------
        ar_action (AssignRouteAction): a AssignRouteAction object

    &#34;&#34;&#34;
    ara_element = element.find(&#34;RoutingAction/AssignRouteAction&#34;)
    route = None
    if ara_element.find(&#34;Route&#34;) != None:
        route = Route.parse(ara_element.find(&#34;Route&#34;))
    elif ara_element.find(&#34;CatalogReference&#34;) != None:
        route = CatalogReference.parse(ara_element.find(&#34;CatalogReference&#34;))

    return AssignRouteAction(route)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.AssignRouteAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AssignRouteAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AssignRouteAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    assignrouteaction = ET.SubElement(routeaction, &#34;AssignRouteAction&#34;)
    assignrouteaction.append(self.route.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ControllerAction"><code class="flex name class">
<span>class <span class="ident">ControllerAction</span></span>
<span>(</span><span>assignControllerAction=None, overrideControllerValueAction=None, activateControllerAction=None)</span>
</code></dt>
<dd>
<div class="desc"><p>ControllerAction creates a ControllerAction of open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>assignControllerAction (AssignControllerAction): assign a controller to an entity

overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                        element in PrivateAction in 1.1
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the ControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>assignControllerAction (AssignControllerAction): assign a controller to an entity

overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                    element in PrivateAction in 1.1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControllerAction(_PrivateActionType):
    &#34;&#34;&#34;ControllerAction creates a ControllerAction of open scenario

    Parameters
    ----------
        assignControllerAction (AssignControllerAction): assign a controller to an entity

        overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

        activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                                element in PrivateAction in 1.1


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class


    &#34;&#34;&#34;

    def __init__(
        self,
        assignControllerAction=None,
        overrideControllerValueAction=None,
        activateControllerAction=None,
    ):
        &#34;&#34;&#34;initalizes the ControllerAction

        Parameters
        ----------
            assignControllerAction (AssignControllerAction): assign a controller to an entity

            overrideControllerValueAction (OverrideControllerValueAction): values for brake, clutch, parking brake, steering wheel or gear

            activateControllerAction (ActivateControllerAction): activate/deactivate a controller on the reference entity/entities. Replaces the depreciated
                                                                element in PrivateAction in 1.1

        &#34;&#34;&#34;
        if assignControllerAction is not None and not isinstance(
            assignControllerAction, AssignControllerAction
        ):
            raise TypeError(
                &#34;assignControllerAction is not of type AssignControllerAction&#34;
            )
        if overrideControllerValueAction is not None and not isinstance(
            overrideControllerValueAction, OverrideControllerValueAction
        ):
            raise TypeError(
                &#34;overrideControllerValueAction is not of type OverrideControllerValueAction&#34;
            )
        if activateControllerAction is not None and not isinstance(
            activateControllerAction, ActivateControllerAction
        ):
            raise TypeError(
                &#34;activateControllerAction is not of type ActivateControllerAction&#34;
            )
        self.assignControllerAction = assignControllerAction
        self.overrideControllerValueAction = overrideControllerValueAction
        self.activateControllerAction = activateControllerAction
        if self.assignControllerAction is not None:
            self.assignControllerAction._used_by_parent = True
        if self.overrideControllerValueAction is not None:
            self.overrideControllerValueAction._used_by_parent = True

    def __eq__(self, other):
        if isinstance(other, ControllerAction):
            if (
                self.activateControllerAction == other.activateControllerAction
                and self.overrideControllerValueAction
                == other.overrideControllerValueAction
                and self.assignControllerAction == other.assignControllerAction
            ):
                return True
        if isinstance(other, AssignControllerAction):
            if self.assignControllerAction == other:
                return True
        if isinstance(other, OverrideControllerValueAction):
            if self.overrideControllerValueAction == other:
                return True
        if isinstance(other, ActivateControllerAction):
            if self.activateControllerAction == other:
                return True

        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ControllerAction element (same as generated by the class itself)

        Returns
        -------
            (ControllerAction): a ActivateControllerAction object

        &#34;&#34;&#34;

        activateControllerAction = None
        overrideControllerValueAction = None
        assignControllerAction = None

        ca_element = element.find(&#34;ControllerAction&#34;)

        if ca_element.find(&#34;ActivateControllerAction&#34;) != None:
            activateControllerAction = ActivateControllerAction.parse(element)
        if ca_element.find(&#34;OverrideControllerValueAction&#34;) != None:
            overrideControllerValueAction = OverrideControllerValueAction.parse(element)
        if ca_element.find(&#34;AssignControllerAction&#34;) != None:
            assignControllerAction = AssignControllerAction.parse(element)

        return ControllerAction(
            assignControllerAction,
            overrideControllerValueAction,
            activateControllerAction,
        )

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ControllerAction&#34;&#34;&#34;
        if self.isVersion(minor=0):
            if (
                self.assignControllerAction is None
                or self.overrideControllerValueAction is None
            ):
                raise NotEnoughInputArguments(
                    &#34;Both assignControllerAction and overrideControllerValueAction are required in version 1.0.&#34;
                )
            if self.activateControllerAction is not None:
                raise OpenSCENARIOVersionError(
                    &#34;activateControllerAction is not parameter in version 1.0.&#34;
                )

        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)

        if self.activateControllerAction != None:
            pa_element = self.activateControllerAction.get_element()
            aca_element = pa_element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
            controlleraction.append(aca_element)

        if self.overrideControllerValueAction != None:
            pa_element = self.overrideControllerValueAction.get_element()
            ocva_element = pa_element.find(
                &#34;ControllerAction/OverrideControllerValueAction&#34;
            )
            controlleraction.append(ocva_element)

        if self.assignControllerAction != None:
            pa_element = self.assignControllerAction.get_element()
            aca_element = pa_element.find(&#34;ControllerAction/AssignControllerAction&#34;)
            controlleraction.append(aca_element)

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ControllerAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>(ControllerAction): a ActivateControllerAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ControllerAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ControllerAction element (same as generated by the class itself)

    Returns
    -------
        (ControllerAction): a ActivateControllerAction object

    &#34;&#34;&#34;

    activateControllerAction = None
    overrideControllerValueAction = None
    assignControllerAction = None

    ca_element = element.find(&#34;ControllerAction&#34;)

    if ca_element.find(&#34;ActivateControllerAction&#34;) != None:
        activateControllerAction = ActivateControllerAction.parse(element)
    if ca_element.find(&#34;OverrideControllerValueAction&#34;) != None:
        overrideControllerValueAction = OverrideControllerValueAction.parse(element)
    if ca_element.find(&#34;AssignControllerAction&#34;) != None:
        assignControllerAction = AssignControllerAction.parse(element)

    return ControllerAction(
        assignControllerAction,
        overrideControllerValueAction,
        activateControllerAction,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ControllerAction&#34;&#34;&#34;
    if self.isVersion(minor=0):
        if (
            self.assignControllerAction is None
            or self.overrideControllerValueAction is None
        ):
            raise NotEnoughInputArguments(
                &#34;Both assignControllerAction and overrideControllerValueAction are required in version 1.0.&#34;
            )
        if self.activateControllerAction is not None:
            raise OpenSCENARIOVersionError(
                &#34;activateControllerAction is not parameter in version 1.0.&#34;
            )

    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)

    if self.activateControllerAction != None:
        pa_element = self.activateControllerAction.get_element()
        aca_element = pa_element.find(&#34;ControllerAction/ActivateControllerAction&#34;)
        controlleraction.append(aca_element)

    if self.overrideControllerValueAction != None:
        pa_element = self.overrideControllerValueAction.get_element()
        ocva_element = pa_element.find(
            &#34;ControllerAction/OverrideControllerValueAction&#34;
        )
        controlleraction.append(ocva_element)

    if self.assignControllerAction != None:
        pa_element = self.assignControllerAction.get_element()
        aca_element = pa_element.find(&#34;ControllerAction/AssignControllerAction&#34;)
        controlleraction.append(aca_element)

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction"><code class="flex name class">
<span>class <span class="ident">CustomCommandAction</span></span>
<span>(</span><span>type, content)</span>
</code></dt>
<dd>
<div class="desc"><p>The CustomCommandAction creates a simulator defined action</p>
<h2 id="parameters">Parameters</h2>
<h2 id="attributes">Attributes</h2>
<pre><code>type (str): type of the custom command
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the CustomCommandAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>type (str): type of the custom command

content (str): content of the custom command
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomCommandAction(_ActionType):
    &#34;&#34;&#34;The CustomCommandAction creates a simulator defined action


    Parameters
    ----------

    Attributes
    ----------

        type (str): type of the custom command

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, type, content):
        &#34;&#34;&#34;initalize the CustomCommandAction

        Parameters
        ----------
            type (str): type of the custom command

            content (str): content of the custom command
        &#34;&#34;&#34;
        self.type = type
        self.content = content

    def __eq__(self, other):
        if isinstance(other, CustomCommandAction):
            if other.type == self.type:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parsese the xml element of a CustomCommandAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a CustomCommandAction element

        Returns
        -------
            customCommandAction (CustomCommandAction): a CustomCommandAction object

        &#34;&#34;&#34;
        if element.tag != &#34;CustomCommandAction&#34;:
            raise NotAValidElement(
                f&#39;Expected &#34;CustomCommandAction&#34; element, received &#34;{element.tag}&#34;.&#39;
            )
        action_type = element.attrib.get(&#34;type&#34;, None)
        if action_type == None:
            raise NotAValidElement(
                &#39;CustomCommandAction is missing required argument &#34;type&#34;.&#39;
            )

        return CustomCommandAction(action_type, element.text)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the CustomCommandAction&#34;&#34;&#34;
        element = ET.Element(&#34;CustomCommandAction&#34;, attrib={&#34;type&#34;: self.type})
        element.text = self.content
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parsese the xml element of a CustomCommandAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a CustomCommandAction element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>customCommandAction (CustomCommandAction): a CustomCommandAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parsese the xml element of a CustomCommandAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a CustomCommandAction element

    Returns
    -------
        customCommandAction (CustomCommandAction): a CustomCommandAction object

    &#34;&#34;&#34;
    if element.tag != &#34;CustomCommandAction&#34;:
        raise NotAValidElement(
            f&#39;Expected &#34;CustomCommandAction&#34; element, received &#34;{element.tag}&#34;.&#39;
        )
    action_type = element.attrib.get(&#34;type&#34;, None)
    if action_type == None:
        raise NotAValidElement(
            &#39;CustomCommandAction is missing required argument &#34;type&#34;.&#39;
        )

    return CustomCommandAction(action_type, element.text)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.CustomCommandAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the CustomCommandAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the CustomCommandAction&#34;&#34;&#34;
    element = ET.Element(&#34;CustomCommandAction&#34;, attrib={&#34;type&#34;: self.type})
    element.text = self.content
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction"><code class="flex name class">
<span>class <span class="ident">DeleteEntityAction</span></span>
<span>(</span><span>entityref)</span>
</code></dt>
<dd>
<div class="desc"><p>The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the DeleteEntityAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entityref (str): reference name of the vehicle to remove
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteEntityAction(_ActionType):
    &#34;&#34;&#34;The DeleteEntityAction class creates a EntityAction which removes an entity to the scenario

    Parameters
    ----------
        entityref (str): reference name of the vehicle to remove

    Attributes
    ----------

        entityref (str): reference name of the vehicle to remove


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, entityref):
        &#34;&#34;&#34;initalize the DeleteEntityAction

        Parameters
        ----------
            entityref (str): reference name of the vehicle to remove

        &#34;&#34;&#34;

        self.entityref = entityref

    def __eq__(self, other):
        if isinstance(other, DeleteEntityAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of DeleteEntityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A DeleteEntityAction element (same as generated by the class itself)

        Returns
        -------
            de_action (DeleteEntityAction): a DeleteEntityAction object

        &#34;&#34;&#34;
        ea_element = element.find(&#34;EntityAction&#34;)
        entityref = ea_element.attrib[&#34;entityRef&#34;]
        return DeleteEntityAction(entityref)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DeleteEntityAction as a dict&#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entityref}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the DeleteEntityAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
        ET.SubElement(entityact, &#34;DeleteEntityAction&#34;)

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of DeleteEntityAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A DeleteEntityAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>de_action (DeleteEntityAction): a DeleteEntityAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of DeleteEntityAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A DeleteEntityAction element (same as generated by the class itself)

    Returns
    -------
        de_action (DeleteEntityAction): a DeleteEntityAction object

    &#34;&#34;&#34;
    ea_element = element.find(&#34;EntityAction&#34;)
    entityref = ea_element.attrib[&#34;entityRef&#34;]
    return DeleteEntityAction(entityref)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the DeleteEntityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the DeleteEntityAction as a dict&#34;&#34;&#34;
    return {&#34;entityRef&#34;: self.entityref}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.DeleteEntityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the DeleteEntityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the DeleteEntityAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    entityact = ET.SubElement(element, &#34;EntityAction&#34;, attrib=self.get_attributes())
    ET.SubElement(entityact, &#34;DeleteEntityAction&#34;)

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction"><code class="flex name class">
<span>class <span class="ident">EnvironmentAction</span></span>
<span>(</span><span>environment)</span>
</code></dt>
<dd>
<div class="desc"><p>The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>environment (Environment or CatalogReference): the environment to change to
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>environment (Environment or CatalogReference): the environment to change to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the EnvironmentAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the action

environment (Environment or CatalogReference): the environment to change to
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnvironmentAction(_ActionType):
    &#34;&#34;&#34;The EnvironmentAction class creates a GlobalAction of the typ EnvironmentAction

    Parameters
    ----------
        environment (Environment or CatalogReference): the environment to change to

    Attributes
    ----------

        environment (Environment or CatalogReference): the environment to change to

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, environment):
        &#34;&#34;&#34;initalize the EnvironmentAction

        Parameters
        ----------
            name (str): name of the action

            environment (Environment or CatalogReference): the environment to change to

        &#34;&#34;&#34;
        if not (
            isinstance(environment, Environment)
            or isinstance(environment, CatalogReference)
        ):
            raise TypeError(
                &#34;environment input not of type Environment or CatalogReference&#34;
            )
        self.environment = environment

    def __eq__(self, other):
        if isinstance(other, EnvironmentAction):
            if self.environment == other.environment:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of BoundingBox

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            boundingBox (BoundingBox): a BoundingBox object

        &#34;&#34;&#34;
        action_element = element.find(&#34;EnvironmentAction&#34;)
        if action_element.find(&#34;Environment&#34;) != None:
            environment = Environment.parse(action_element.find(&#34;Environment&#34;))
        elif action_element.find(&#34;CatalogReference&#34;) != None:
            environment = CatalogReference.parse(
                action_element.find(&#34;CatalogReference&#34;)
            )

        return EnvironmentAction(environment)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the EnvironmentAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        envaction = ET.SubElement(element, &#34;EnvironmentAction&#34;)
        envaction.append(self.environment.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of BoundingBox</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>boundingBox (BoundingBox): a BoundingBox object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of BoundingBox

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

    Returns
    -------
        boundingBox (BoundingBox): a BoundingBox object

    &#34;&#34;&#34;
    action_element = element.find(&#34;EnvironmentAction&#34;)
    if action_element.find(&#34;Environment&#34;) != None:
        environment = Environment.parse(action_element.find(&#34;Environment&#34;))
    elif action_element.find(&#34;CatalogReference&#34;) != None:
        environment = CatalogReference.parse(
            action_element.find(&#34;CatalogReference&#34;)
        )

    return EnvironmentAction(environment)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.EnvironmentAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the EnvironmentAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the EnvironmentAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    envaction = ET.SubElement(element, &#34;EnvironmentAction&#34;)
    envaction.append(self.environment.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction"><code class="flex name class">
<span>class <span class="ident">FollowTrajectoryAction</span></span>
<span>(</span><span>trajectory, following_mode, reference_domain=None, scale=None, offset=None, initialDistanceOffset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (FollowingMode): the following mode of the action

reference_domain (ReferenceContext): how to follow
    Default: None
scale (float): scalefactor of the timeings (must be combined with reference_domain and offset)
    Default: None
offset (float): offset for time values (must be combined with reference_domain and scale)
    Default: None
initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (str): the following mode of the action

timeref (TimeReference): the time reference of the trajectory

initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the FollowTrajectoryAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>trajectory (Trajectory, or CatalogReference): the trajectory to follow

following_mode (FollowingMode): the following mode of the action

reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
    Default: None
scale (float): scalefactor of the timings (must be combined with reference_domain and offset)
    Default: None
offset (float): offset for time values (must be combined with reference_domain and scale)
    Default: None
initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FollowTrajectoryAction(_PrivateActionType):
    &#34;&#34;&#34;FollowTrajectoryAction creates a RouteAction of type FollowTrajectoryAction

    Parameters
    ----------
        trajectory (Trajectory, or CatalogReference): the trajectory to follow

        following_mode (FollowingMode): the following mode of the action

        reference_domain (ReferenceContext): how to follow
            Default: None
        scale (float): scalefactor of the timeings (must be combined with reference_domain and offset)
            Default: None
        offset (float): offset for time values (must be combined with reference_domain and scale)
            Default: None
        initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
            Default: None

    Attributes
    ----------
        trajectory (Trajectory, or CatalogReference): the trajectory to follow

        following_mode (str): the following mode of the action

        timeref (TimeReference): the time reference of the trajectory

        initialDistanceOffset (float): start at this offset into the trajectory (v1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        trajectory,
        following_mode,
        reference_domain=None,
        scale=None,
        offset=None,
        initialDistanceOffset=None,
    ):
        &#34;&#34;&#34;initalize the FollowTrajectoryAction

        Parameters
        ----------
            trajectory (Trajectory, or CatalogReference): the trajectory to follow

            following_mode (FollowingMode): the following mode of the action

            reference_domain (str): absolute or relative time reference (must be combined with scale and offset)
                Default: None
            scale (float): scalefactor of the timings (must be combined with reference_domain and offset)
                Default: None
            offset (float): offset for time values (must be combined with reference_domain and scale)
                Default: None
            initialDistanceOffset (float): start at this offset into the trajectory (v1.1)
                Default: None

        &#34;&#34;&#34;
        # if following_mode not in FollowingMode:
        #     ValueError(str(following_mode) + &#39; is not a valied following mode.&#39;)
        if not (
            isinstance(trajectory, Trajectory)
            or isinstance(trajectory, CatalogReference)
        ):
            raise TypeError(&#34;route input not of type Route or CatalogReference&#34;)
        self.trajectory = trajectory
        self.following_mode = convert_enum(following_mode, FollowingMode)
        # TODO: check reference_domain
        self.timeref = TimeReference(reference_domain, scale, offset)
        self.initialDistanceOffset = convert_float(initialDistanceOffset)

    def __eq__(self, other):
        if isinstance(other, FollowTrajectoryAction):
            if (
                self.timeref == other.timeref
                and self.get_attributes() == other.get_attributes()
                and self.trajectory == other.trajectory
                and self.following_mode == other.following_mode
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of FollowTrajectoryAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A FollowTrajectoryAction element (same as generated by the class itself)

        Returns
        -------
            ft_action (FollowTrajectoryAction): a FollowTrajectoryAction object

        &#34;&#34;&#34;
        fta_element = element.find(&#34;RoutingAction/FollowTrajectoryAction&#34;)
        initial_distance_offset = None
        if &#34;initialDistanceOffset&#34; in fta_element.attrib:
            initial_distance_offset = convert_float(
                fta_element.attrib[&#34;initialDistanceOffset&#34;]
            )

        timeref = TimeReference.parse(fta_element.find(&#34;TimeReference&#34;))
        reference_domain = timeref.reference_domain
        offset = timeref.offset
        scale = timeref.scale

        tfm_element = fta_element.find(&#34;TrajectoryFollowingMode&#34;)
        following_mode = convert_enum(
            tfm_element.attrib[&#34;followingMode&#34;], FollowingMode
        )

        if fta_element.find(&#34;TrajectoryRef&#34;) != None:
            fta_element = fta_element.find(&#34;TrajectoryRef&#34;)
        trajectory = None
        if fta_element.find(&#34;Trajectory&#34;) != None:
            trajectory = Trajectory.parse(fta_element.find(&#34;Trajectory&#34;))
        if fta_element.find(&#34;CatalogReference&#34;) != None:
            trajectory = CatalogReference.parse(fta_element.find(&#34;CatalogReference&#34;))

        return FollowTrajectoryAction(
            trajectory,
            following_mode,
            reference_domain,
            scale,
            offset,
            initial_distance_offset,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the FollowTrajectoryAction as a dict&#34;&#34;&#34;
        if self.initialDistanceOffset:
            return {&#34;initialDistanceOffset&#34;: str(self.initialDistanceOffset)}
        else:
            # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
            return {}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the FollowTrajectoryAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
        trajaction = ET.SubElement(
            routeaction, &#34;FollowTrajectoryAction&#34;, attrib=self.get_attributes()
        )
        if self.isVersion(minor=0):
            trajaction.append(self.trajectory.get_element())
        else:
            trajref = ET.SubElement(trajaction, &#34;TrajectoryRef&#34;)
            trajref.append(self.trajectory.get_element())
        trajaction.append(self.timeref.get_element())
        ET.SubElement(
            trajaction,
            &#34;TrajectoryFollowingMode&#34;,
            attrib={&#34;followingMode&#34;: self.following_mode.get_name()},
        )

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of FollowTrajectoryAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A FollowTrajectoryAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ft_action (FollowTrajectoryAction): a FollowTrajectoryAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of FollowTrajectoryAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A FollowTrajectoryAction element (same as generated by the class itself)

    Returns
    -------
        ft_action (FollowTrajectoryAction): a FollowTrajectoryAction object

    &#34;&#34;&#34;
    fta_element = element.find(&#34;RoutingAction/FollowTrajectoryAction&#34;)
    initial_distance_offset = None
    if &#34;initialDistanceOffset&#34; in fta_element.attrib:
        initial_distance_offset = convert_float(
            fta_element.attrib[&#34;initialDistanceOffset&#34;]
        )

    timeref = TimeReference.parse(fta_element.find(&#34;TimeReference&#34;))
    reference_domain = timeref.reference_domain
    offset = timeref.offset
    scale = timeref.scale

    tfm_element = fta_element.find(&#34;TrajectoryFollowingMode&#34;)
    following_mode = convert_enum(
        tfm_element.attrib[&#34;followingMode&#34;], FollowingMode
    )

    if fta_element.find(&#34;TrajectoryRef&#34;) != None:
        fta_element = fta_element.find(&#34;TrajectoryRef&#34;)
    trajectory = None
    if fta_element.find(&#34;Trajectory&#34;) != None:
        trajectory = Trajectory.parse(fta_element.find(&#34;Trajectory&#34;))
    if fta_element.find(&#34;CatalogReference&#34;) != None:
        trajectory = CatalogReference.parse(fta_element.find(&#34;CatalogReference&#34;))

    return FollowTrajectoryAction(
        trajectory,
        following_mode,
        reference_domain,
        scale,
        offset,
        initial_distance_offset,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the FollowTrajectoryAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the FollowTrajectoryAction as a dict&#34;&#34;&#34;
    if self.initialDistanceOffset:
        return {&#34;initialDistanceOffset&#34;: str(self.initialDistanceOffset)}
    else:
        # If initialDistanceOffset is not set, return empty to stay backward compatible with v1.0
        return {}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the FollowTrajectoryAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the FollowTrajectoryAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    routeaction = ET.SubElement(element, &#34;RoutingAction&#34;)
    trajaction = ET.SubElement(
        routeaction, &#34;FollowTrajectoryAction&#34;, attrib=self.get_attributes()
    )
    if self.isVersion(minor=0):
        trajaction.append(self.trajectory.get_element())
    else:
        trajref = ET.SubElement(trajaction, &#34;TrajectoryRef&#34;)
        trajref.append(self.trajectory.get_element())
    trajaction.append(self.timeref.get_element())
    ET.SubElement(
        trajaction,
        &#34;TrajectoryFollowingMode&#34;,
        attrib={&#34;followingMode&#34;: self.following_mode.get_name()},
    )

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction"><code class="flex name class">
<span>class <span class="ident">LateralDistanceAction</span></span>
<span>(</span><span>entity, distance=None, freespace=True, continuous=True, max_acceleration=None, max_deceleration=None, max_speed=None, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, displacement=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LateralDisplacement): type of displacement wanted
    Default LateralDisplacement.any
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

continuous (bool): if the controller tries to keep the relative speed

distance (float): if the distance metric is used

timegap (float): if timegap metric is used

dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

displacement (LateralDisplacement): type of displacement wanted
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the LateralDistanceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): the target name

distance (float): the lateral distance to the entity

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LateralDisplacement): type of displacement wanted
    Default LateralDisplacement.any
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LateralDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;

    Parameters
    ----------
        entity (str): the target name

        distance (float): the lateral distance to the entity

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

        max_acceleration (float): maximum acceleration allowed
            Default: None

        max_deceleration (float): maximum deceleration allowed
            Default: None

        max_speed (float): maximum speed allowed
            Default: None

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
            Default CoordinateSystem.entity

        displacement (LateralDisplacement): type of displacement wanted
            Default LateralDisplacement.any
    Attributes
    ----------
        entity (str): the target name

        distance (float): the lateral distance to the entity

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        continuous (bool): if the controller tries to keep the relative speed

        distance (float): if the distance metric is used

        timegap (float): if timegap metric is used

        dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

        displacement (LateralDisplacement): type of displacement wanted

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        distance=None,
        freespace=True,
        continuous=True,
        max_acceleration=None,
        max_deceleration=None,
        max_speed=None,
        coordinate_system=CoordinateSystem.entity,
        displacement=LateralDisplacement.any,
    ):
        &#34;&#34;&#34;initalizes the LateralDistanceAction

        Parameters
        ----------
            entity (str): the target name

            distance (float): the lateral distance to the entity

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LateralDisplacement): type of displacement wanted
                Default LateralDisplacement.any
        &#34;&#34;&#34;
        self.distance = distance
        self.target = entity

        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration, max_deceleration, max_speed
        )
        self.coordinate_system = convert_enum(coordinate_system, CoordinateSystem)
        self.displacement = convert_enum(displacement, LateralDisplacement)

    def __eq__(self, other):
        if isinstance(other, LateralDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LateralDistanceAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LateralDistanceAction element (same as generated by the class itself)

        Returns
        -------
            ld_action (LateralDistanceAction): a LateralDistanceActionobject

        &#34;&#34;&#34;
        lda_element = element.find(&#34;LateralAction/LateralDistanceAction&#34;)
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        entity = lda_element.attrib[&#34;entityRef&#34;]
        distance = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = lda_element.attrib[&#34;distance&#34;]
        coordinate = None
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem
            )
        displacement = None
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;], LateralDisplacement
            )
        constraints = None
        max_acc = None
        max_dec = None
        max_speed = None
        if lda_element.find(&#34;DynamicConstraints&#34;) != None:
            constraints = DynamicsConstraints.parse(
                lda_element.find(&#34;DynamicConstraints&#34;)
            )
            max_acc = constraints.max_acceleration
            max_dec = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LateralDistanceAction(
            entity,
            distance,
            freespace,
            continuous,
            max_acc,
            max_dec,
            max_speed,
            coordinate,
            displacement,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LateralDistanceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance != None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LateralDistanceAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        lateraldistanceaction = ET.SubElement(
            lataction, &#34;LateralDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            lateraldistanceaction.append(self.dynamic_constraint.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of LateralDistanceAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A LateralDistanceAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ld_action (LateralDistanceAction): a LateralDistanceActionobject
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of LateralDistanceAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A LateralDistanceAction element (same as generated by the class itself)

    Returns
    -------
        ld_action (LateralDistanceAction): a LateralDistanceActionobject

    &#34;&#34;&#34;
    lda_element = element.find(&#34;LateralAction/LateralDistanceAction&#34;)
    continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
    freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
    entity = lda_element.attrib[&#34;entityRef&#34;]
    distance = None
    if &#34;distance&#34; in lda_element.attrib:
        distance = lda_element.attrib[&#34;distance&#34;]
    coordinate = None
    if &#34;coordinateSystem&#34; in lda_element.attrib:
        coordinate = convert_enum(
            lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem
        )
    displacement = None
    if &#34;displacement&#34; in lda_element.attrib:
        displacement = convert_enum(
            lda_element.attrib[&#34;displacement&#34;], LateralDisplacement
        )
    constraints = None
    max_acc = None
    max_dec = None
    max_speed = None
    if lda_element.find(&#34;DynamicConstraints&#34;) != None:
        constraints = DynamicsConstraints.parse(
            lda_element.find(&#34;DynamicConstraints&#34;)
        )
        max_acc = constraints.max_acceleration
        max_dec = constraints.max_deceleration
        max_speed = constraints.max_speed

    return LateralDistanceAction(
        entity,
        distance,
        freespace,
        continuous,
        max_acc,
        max_dec,
        max_speed,
        coordinate,
        displacement,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LateralDistanceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LateralDistanceAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
    retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
    if self.distance != None:
        retdict[&#34;distance&#34;] = str(self.distance)
    if not self.isVersion(minor=0):
        retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        retdict[&#34;displacement&#34;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LateralDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LateralDistanceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LateralDistanceAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    lateraldistanceaction = ET.SubElement(
        lataction, &#34;LateralDistanceAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamic_constraint.is_filled():
        lateraldistanceaction.append(self.dynamic_constraint.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LightStateAction"><code class="flex name class">
<span>class <span class="ident">LightStateAction</span></span>
<span>(</span><span>light_type, mode, transition_time=0, flashing_off_duration=None, flashing_on_duration=None, intensity=None, color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>LightStateAction creates an AppearanceAction of of the Type LightStateAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>light_type (VehicleLightType or UserDefinedLight):

mode (LightMode): the new mode of the light

transition_time (float): the transition time of the light
    Default: 0

flashing_off_duration (float): how long the light should be off when LightMode is set to "flashing"

flashing_on_duration (float): how long the light should be on when when LightMode is set to "flashing"

intensity (float): the luminous intensity of the light

color (Color): the color of the light
</code></pre>
<h2 id="attributes">Attributes</h2>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalize the LightStateAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>light_type (VehicleLightType or UserDefinedLight):

mode (LightMode): the new mode of the light

transition_time (float): the transition time of the light
    Default: 0

flashing_off_duration (float): how long the light should be off when LightMode is set to "flashing"

flashing_on_duration (float): how long the light should be on when when LightMode is set to "flashing"

intensity (float): the luminous intensity of the light

color (Color): the color of the light
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightStateAction(_PrivateActionType):
    &#34;&#34;&#34;LightStateAction creates an AppearanceAction of of the Type LightStateAction

    Parameters
    ----------
        light_type (VehicleLightType or UserDefinedLight):

        mode (LightMode): the new mode of the light

        transition_time (float): the transition time of the light
            Default: 0

        flashing_off_duration (float): how long the light should be off when LightMode is set to &#34;flashing&#34;

        flashing_on_duration (float): how long the light should be on when when LightMode is set to &#34;flashing&#34;

        intensity (float): the luminous intensity of the light

        color (Color): the color of the light

    Attributes
    ----------


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        light_type,
        mode,
        transition_time=0,
        flashing_off_duration=None,
        flashing_on_duration=None,
        intensity=None,
        color=None,
    ):
        &#34;&#34;&#34;initalize the LightStateAction

        Parameters
        ----------
            light_type (VehicleLightType or UserDefinedLight):

            mode (LightMode): the new mode of the light

            transition_time (float): the transition time of the light
                Default: 0

            flashing_off_duration (float): how long the light should be off when LightMode is set to &#34;flashing&#34;

            flashing_on_duration (float): how long the light should be on when when LightMode is set to &#34;flashing&#34;

            intensity (float): the luminous intensity of the light

            color (Color): the color of the light
        &#34;&#34;&#34;
        try:
            self.light_type = convert_enum(light_type, VehicleLightType)
        except Exception as e:
            if not isinstance(light_type, UserDefinedLight):
                raise TypeError(
                    &#34;light_type input is not of type VehicleLightType or UserDefinedLight&#34;
                )
            else:
                self.light_type = light_type

        self.lightstate = _LightState(
            mode, color, intensity, flashing_off_duration, flashing_on_duration
        )

        self.transition_time = convert_float(transition_time)

    def __eq__(self, other):
        if isinstance(other, LightStateAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.light_type == other.light_type
                and self.lightstate == other.lightstate
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LightStateAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LightStateAction element (same as generated by the class itself)

        Returns
        -------
            light_state_action (LightStateAction): a LightStateAction object

        &#34;&#34;&#34;
        light_element = element.find(&#34;AppearanceAction/LightStateAction&#34;)
        transition_time = None
        if &#34;transitionTime&#34; in light_element.attrib:
            transition_time = convert_float(light_element.attrib[&#34;transitionTime&#34;])
        light_state = _LightState.parse(light_element.find(&#34;LightState&#34;))
        type_element = light_element.find(&#34;LightType&#34;)
        if type_element.find(&#34;UserDefinedLight&#34;) is not None:
            light_type = UserDefinedLight.parse(type_element.find(&#34;UserDefinedLight&#34;))
        else:
            light_type = convert_enum(
                type_element.find(&#34;VehicleLight&#34;).attrib[&#34;vehicleLightType&#34;],
                VehicleLightType,
            )
        # create with dummy mode
        light_state_action = LightStateAction(light_type, LightMode.on, transition_time)
        light_state_action.lightstate = light_state
        return light_state_action

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LightStateAction as a dict&#34;&#34;&#34;
        attr = {&#34;transitionTime&#34;: str(self.transition_time)}
        return attr

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LightStateAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
        light_element = ET.SubElement(
            appear_element, &#34;LightStateAction&#34;, self.get_attributes()
        )
        light_element.append(self.lightstate.get_element())

        light_type_element = ET.SubElement(light_element, &#34;LightType&#34;)
        if hasattr(VehicleLightType, str(self.light_type)):
            ET.SubElement(
                light_type_element,
                &#34;VehicleLight&#34;,
                attrib={&#34;vehicleLightType&#34;: self.light_type.get_name()},
            )
        else:
            light_type_element.append(self.light_type.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LightStateAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of LightStateAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A LightStateAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>light_state_action (LightStateAction): a LightStateAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of LightStateAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A LightStateAction element (same as generated by the class itself)

    Returns
    -------
        light_state_action (LightStateAction): a LightStateAction object

    &#34;&#34;&#34;
    light_element = element.find(&#34;AppearanceAction/LightStateAction&#34;)
    transition_time = None
    if &#34;transitionTime&#34; in light_element.attrib:
        transition_time = convert_float(light_element.attrib[&#34;transitionTime&#34;])
    light_state = _LightState.parse(light_element.find(&#34;LightState&#34;))
    type_element = light_element.find(&#34;LightType&#34;)
    if type_element.find(&#34;UserDefinedLight&#34;) is not None:
        light_type = UserDefinedLight.parse(type_element.find(&#34;UserDefinedLight&#34;))
    else:
        light_type = convert_enum(
            type_element.find(&#34;VehicleLight&#34;).attrib[&#34;vehicleLightType&#34;],
            VehicleLightType,
        )
    # create with dummy mode
    light_state_action = LightStateAction(light_type, LightMode.on, transition_time)
    light_state_action.lightstate = light_state
    return light_state_action</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LightStateAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LightStateAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LightStateAction as a dict&#34;&#34;&#34;
    attr = {&#34;transitionTime&#34;: str(self.transition_time)}
    return attr</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LightStateAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LightStateAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LightStateAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    appear_element = ET.SubElement(element, &#34;AppearanceAction&#34;)
    light_element = ET.SubElement(
        appear_element, &#34;LightStateAction&#34;, self.get_attributes()
    )
    light_element.append(self.lightstate.get_element())

    light_type_element = ET.SubElement(light_element, &#34;LightType&#34;)
    if hasattr(VehicleLightType, str(self.light_type)):
        ET.SubElement(
            light_type_element,
            &#34;VehicleLight&#34;,
            attrib={&#34;vehicleLightType&#34;: self.light_type.get_name()},
        )
    else:
        light_type_element.append(self.light_type.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction"><code class="flex name class">
<span>class <span class="ident">LongitudinalDistanceAction</span></span>
<span>(</span><span>entity, freespace=True, continuous=True, max_acceleration=None, max_deceleration=None, max_speed=None, distance=None, timeGap=None, coordinate_system=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, displacement=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>The LongitudinalAction creates a LongitudinalAction of type LongitudinalAction with a distance target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>distance (float): distance to the entity

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LongitudinalDisplacement): type of displacement wanted
    Default LongitudinalDisplacement.any
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

continuous (bool): if the controller tries to keep the relative speed

distance (float): the distance to the entity

dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

displacement (LongitudinalDisplacement): type of displacement wanted
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the LongitudinalDistanceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>distance (float): distance to the entity

timegap (float): time to the target

entity (str): the target name

freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
    Default: True

continuous (bool): if the controller tries to keep the relative speed
    Default: True

max_acceleration (float): maximum acceleration allowed
    Default: None

max_deceleration (float): maximum deceleration allowed
    Default: None

max_speed (float): maximum speed allowed
    Default: None

coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
    Default CoordinateSystem.entity

displacement (LongitudinalDisplacement): type of displacement wanted
    Default LongitudinalDisplacement.any
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LongitudinalDistanceAction(_PrivateActionType):
    &#34;&#34;&#34;The LongitudinalAction creates a LongitudinalAction of type LongitudinalAction with a distance target

    Parameters
    ----------
        distance (float): distance to the entity

        entity (str): the target name

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
            Default: True

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

        max_acceleration (float): maximum acceleration allowed
            Default: None

        max_deceleration (float): maximum deceleration allowed
            Default: None

        max_speed (float): maximum speed allowed
            Default: None

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
            Default CoordinateSystem.entity

        displacement (LongitudinalDisplacement): type of displacement wanted
            Default LongitudinalDisplacement.any

    Attributes
    ----------
        entity (str): the target name

        freespace (bool): (True) distance between bounding boxes, (False) distance between ref point

        continuous (bool): if the controller tries to keep the relative speed

        distance (float): the distance to the entity

        dynamic_constraint (DynamicsConstraints): Dynamics constraints of the action

        coordinate_system (CoordinateSystem): the coordinate system for the distance calculation

        displacement (LongitudinalDisplacement): type of displacement wanted

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        freespace=True,
        continuous=True,
        max_acceleration=None,
        max_deceleration=None,
        max_speed=None,
        distance=None,
        timeGap=None,
        coordinate_system=CoordinateSystem.entity,
        displacement=LongitudinalDisplacement.any,
    ):
        &#34;&#34;&#34;initalize the LongitudinalDistanceAction

        Parameters
        ----------
            distance (float): distance to the entity

            timegap (float): time to the target

            entity (str): the target name

            freespace (bool): (True) distance between bounding boxes, (False) distance between ref point
                Default: True

            continuous (bool): if the controller tries to keep the relative speed
                Default: True

            max_acceleration (float): maximum acceleration allowed
                Default: None

            max_deceleration (float): maximum deceleration allowed
                Default: None

            max_speed (float): maximum speed allowed
                Default: None

            coordinate_system (CoordinateSystem): the coordinate system for the distance calculation
                Default CoordinateSystem.entity

            displacement (LongitudinalDisplacement): type of displacement wanted
                Default LongitudinalDisplacement.any
        &#34;&#34;&#34;
        self.target = entity
        self.freespace = convert_bool(freespace)
        self.continuous = convert_bool(continuous)
        self.dynamic_constraint = DynamicsConstraints(
            max_acceleration, max_deceleration, max_speed
        )

        if distance is not None and timeGap is not None:
            raise ToManyOptionalArguments(
                &#34;Not both of distance and timeGap can be used.&#34;
            )
        if distance is None and timeGap is None:
            raise NotEnoughInputArguments(&#34;Either ds or dsLane is needed as input.&#34;)
        self.distance = convert_float(distance)
        self.timeGap = convert_float(timeGap)

        self.coordinate_system = convert_enum(coordinate_system, CoordinateSystem)
        self.displacement = convert_enum(displacement, LongitudinalDisplacement)

    def __eq__(self, other):
        if isinstance(other, LongitudinalDistanceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamic_constraint == other.dynamic_constraint
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of LongitudinalAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A LongitudinalDistanceAction element (same as generated by the class itself)

        Returns
        -------
            ld_action (LongitudinalDistanceAction): a LongitudinalDistanceAction object

        &#34;&#34;&#34;
        lda_element = element.find(&#34;LongitudinalAction/LongitudinalDistanceAction&#34;)
        entity = lda_element.attrib[&#34;entityRef&#34;]
        freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
        continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
        distance = None
        timeGap = None
        if &#34;distance&#34; in lda_element.attrib:
            distance = convert_float(lda_element.attrib[&#34;distance&#34;])
        if &#34;timeGap&#34; in lda_element.attrib:
            timeGap = convert_float(lda_element.attrib[&#34;timeGap&#34;])

        coordinate_system = CoordinateSystem.entity
        if &#34;coordinateSystem&#34; in lda_element.attrib:
            coordinate_system = convert_enum(
                lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem, False
            )
        displacement = LongitudinalDisplacement.any
        if &#34;displacement&#34; in lda_element.attrib:
            displacement = convert_enum(
                lda_element.attrib[&#34;displacement&#34;], LongitudinalDisplacement, False
            )
        max_acceleration = None
        max_deceleration = None
        max_speed = None
        constraints = None
        if lda_element.find(&#34;DynamicConstraints&#34;) != None:
            constraints = DynamicsConstraints.parse(
                lda_element.find(&#34;DynamicConstraints&#34;)
            )
            max_acceleration = constraints.max_acceleration
            max_deceleration = constraints.max_deceleration
            max_speed = constraints.max_speed

        return LongitudinalDistanceAction(
            entity,
            freespace,
            continuous,
            max_acceleration,
            max_deceleration,
            max_speed,
            distance,
            timeGap,
            coordinate_system,
            displacement,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the LongitudinalDistanceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;entityRef&#34;] = self.target
        retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
        retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
        if self.distance != None:
            retdict[&#34;distance&#34;] = str(self.distance)
        if self.timeGap != None:
            retdict[&#34;timeGap&#34;] = str(self.timeGap)
        if not self.isVersion(minor=0):
            retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
            retdict[&#34;displacement&#34;] = self.displacement.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the LongitudinalDistanceAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longact = ET.SubElement(element, &#34;LongitudinalAction&#34;)

        longdistaction = ET.SubElement(
            longact, &#34;LongitudinalDistanceAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamic_constraint.is_filled():
            longdistaction.append(self.dynamic_constraint.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of LongitudinalAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A LongitudinalDistanceAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ld_action (LongitudinalDistanceAction): a LongitudinalDistanceAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of LongitudinalAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A LongitudinalDistanceAction element (same as generated by the class itself)

    Returns
    -------
        ld_action (LongitudinalDistanceAction): a LongitudinalDistanceAction object

    &#34;&#34;&#34;
    lda_element = element.find(&#34;LongitudinalAction/LongitudinalDistanceAction&#34;)
    entity = lda_element.attrib[&#34;entityRef&#34;]
    freespace = convert_bool(lda_element.attrib[&#34;freespace&#34;])
    continuous = convert_bool(lda_element.attrib[&#34;continuous&#34;])
    distance = None
    timeGap = None
    if &#34;distance&#34; in lda_element.attrib:
        distance = convert_float(lda_element.attrib[&#34;distance&#34;])
    if &#34;timeGap&#34; in lda_element.attrib:
        timeGap = convert_float(lda_element.attrib[&#34;timeGap&#34;])

    coordinate_system = CoordinateSystem.entity
    if &#34;coordinateSystem&#34; in lda_element.attrib:
        coordinate_system = convert_enum(
            lda_element.attrib[&#34;coordinateSystem&#34;], CoordinateSystem, False
        )
    displacement = LongitudinalDisplacement.any
    if &#34;displacement&#34; in lda_element.attrib:
        displacement = convert_enum(
            lda_element.attrib[&#34;displacement&#34;], LongitudinalDisplacement, False
        )
    max_acceleration = None
    max_deceleration = None
    max_speed = None
    constraints = None
    if lda_element.find(&#34;DynamicConstraints&#34;) != None:
        constraints = DynamicsConstraints.parse(
            lda_element.find(&#34;DynamicConstraints&#34;)
        )
        max_acceleration = constraints.max_acceleration
        max_deceleration = constraints.max_deceleration
        max_speed = constraints.max_speed

    return LongitudinalDistanceAction(
        entity,
        freespace,
        continuous,
        max_acceleration,
        max_deceleration,
        max_speed,
        distance,
        timeGap,
        coordinate_system,
        displacement,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the LongitudinalDistanceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the LongitudinalDistanceAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;entityRef&#34;] = self.target
    retdict[&#34;freespace&#34;] = get_bool_string(self.freespace)
    retdict[&#34;continuous&#34;] = get_bool_string(self.continuous)
    if self.distance != None:
        retdict[&#34;distance&#34;] = str(self.distance)
    if self.timeGap != None:
        retdict[&#34;timeGap&#34;] = str(self.timeGap)
    if not self.isVersion(minor=0):
        retdict[&#34;coordinateSystem&#34;] = self.coordinate_system.get_name()
        retdict[&#34;displacement&#34;] = self.displacement.get_name()
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the LongitudinalDistanceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the LongitudinalDistanceAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    longact = ET.SubElement(element, &#34;LongitudinalAction&#34;)

    longdistaction = ET.SubElement(
        longact, &#34;LongitudinalDistanceAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamic_constraint.is_filled():
        longdistaction.append(self.dynamic_constraint.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction"><code class="flex name class">
<span>class <span class="ident">OverrideControllerValueAction</span></span>
</code></dt>
<dd>
<div class="desc"><p>OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
NOTE: this implementation is compatible with osc v.1.1 where all attributes don't have to be set.</p>
<h2 id="attributes">Attributes</h2>
<pre><code>throttle_active (bool): if the throttle is active
    Default: None (will not be written)

throttle_value (float): value of the throttle

brake_active (bool): if the brake is active
    Default: None (will not be written)

brake_value (float): value of the brake

clutch_active (bool): if the clutch is active
    Default: None (will not be written)

clutch_value (float): value of the clutch

steeringwheel_active (bool): if the steeringwheel is active
    Default: None (will not be written)

steeringwheel_value (float): value of the steeringwheel

gear_active (bool): if the gear is active
    Default: None (will not be written)

gear_value (float): value of the gear

parkingbrake_active (bool): if the parkingbrake is active
    Default: None (will not be written)

parkingbrake_value (float): value of the parkingbrake
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class

set_throttle(active,value)
    sets the throttle value

set_brake(active,value)
    sets the brake value

set_steeringwheel(active,value)
    sets the steeringwheel value

set_clutch(active,value)
    sets the clutch value

set_gear(active,value)
    sets the gear value

set_parkingbrake(active,value)
    sets the parkingbrake value
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OverrideControllerValueAction(_PrivateActionType):
    &#34;&#34;&#34;OverrideControllerValueAction creates a OverrideControllerValueAction action of openscenario which can include, throttle, brake, clutch, steeringwheel, gear, parkingbrake
    NOTE: this implementation is compatible with osc v.1.1 where all attributes don&#39;t have to be set.

    Attributes
    ----------
        throttle_active (bool): if the throttle is active
            Default: None (will not be written)

        throttle_value (float): value of the throttle

        brake_active (bool): if the brake is active
            Default: None (will not be written)

        brake_value (float): value of the brake

        clutch_active (bool): if the clutch is active
            Default: None (will not be written)

        clutch_value (float): value of the clutch

        steeringwheel_active (bool): if the steeringwheel is active
            Default: None (will not be written)

        steeringwheel_value (float): value of the steeringwheel

        gear_active (bool): if the gear is active
            Default: None (will not be written)

        gear_value (float): value of the gear

        parkingbrake_active (bool): if the parkingbrake is active
            Default: None (will not be written)

        parkingbrake_value (float): value of the parkingbrake

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

        set_throttle(active,value)
            sets the throttle value

        set_brake(active,value)
            sets the brake value

        set_steeringwheel(active,value)
            sets the steeringwheel value

        set_clutch(active,value)
            sets the clutch value

        set_gear(active,value)
            sets the gear value

        set_parkingbrake(active,value)
            sets the parkingbrake value

    &#34;&#34;&#34;

    def __init__(self):
        self.throttle_active = None
        self.throttle_value = convert_float(0)
        self.throttle_rate = None
        self.brake_active = None
        self.brake_value = convert_float(0)
        self.brake_rate = None
        self.brake_force = False
        self.clutch_active = None
        self.clutch_value = convert_float(0)
        self.clutch_rate = None
        self.steeringwheel_active = None
        self.steeringwheel_value = convert_float(0)
        self.steeringwheel_rate = None
        self.steeringwheel_torque = None
        self.gear_active = None
        self.gear_value = convert_float(0)
        self._gear_maunal = True
        self.parkingbrake_active = None
        self.parkingbrake_value = convert_float(0)
        self.parkingbrake_rate = None
        self.parkingbrake_force = False

        self._used_by_parent = False

    def __eq__(self, other):
        if isinstance(other, OverrideControllerValueAction):
            if (
                self.throttle_value == other.throttle_value
                and self.throttle_value == other.throttle_value
                and self.throttle_rate == other.throttle_rate
                and self.brake_active == other.brake_active
                and self.brake_value == other.brake_value
                and self.brake_rate == other.brake_rate
                and self.brake_force == other.brake_force
                and self.clutch_active == other.clutch_active
                and self.clutch_value == other.clutch_value
                and self.clutch_rate == other.clutch_rate
                and self.steeringwheel_active == other.steeringwheel_active
                and self.steeringwheel_value == other.steeringwheel_value
                and self.steeringwheel_rate == other.steeringwheel_rate
                and self.steeringwheel_torque == other.steeringwheel_torque
                and self.gear_active == other.gear_active
                and self.gear_value == other.gear_value
                and self.parkingbrake_active == other.parkingbrake_active
                and self.parkingbrake_value == other.parkingbrake_value
                and self.parkingbrake_force == other.parkingbrake_force
                and self.parkingbrake_rate == other.parkingbrake_rate
            ):
                return True
        elif isinstance(other, ControllerAction):
            if (
                self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_value
                == other.overrideControllerValueAction.throttle_value
                and self.throttle_rate
                == other.overrideControllerValueAction.throttle_rate
                and self.brake_active
                == other.overrideControllerValueAction.brake_active
                and self.brake_value == other.overrideControllerValueAction.brake_value
                and self.brake_rate == other.overrideControllerValueAction.brake_rate
                and self.brake_force == other.overrideControllerValueAction.brake_force
                and self.clutch_active
                == other.overrideControllerValueAction.clutch_active
                and self.clutch_value
                == other.overrideControllerValueAction.clutch_value
                and self.clutch_rate == other.overrideControllerValueAction.clutch_rate
                and self.steeringwheel_active
                == other.overrideControllerValueAction.steeringwheel_active
                and self.steeringwheel_value
                == other.overrideControllerValueAction.steeringwheel_value
                and self.steeringwheel_rate
                == other.overrideControllerValueAction.steeringwheel_rate
                and self.steeringwheel_torque
                == other.overrideControllerValueAction.steeringwheel_torque
                and self.gear_active == other.overrideControllerValueAction.gear_active
                and self.gear_value == other.overrideControllerValueAction.gear_value
                and self.parkingbrake_active
                == other.overrideControllerValueAction.parkingbrake_active
                and self.parkingbrake_value
                == other.overrideControllerValueAction.parkingbrake_value
                and self.parkingbrake_force
                == other.overrideControllerValueAction.parkingbrake_force
                and self.parkingbrake_rate
                == other.overrideControllerValueAction.parkingbrake_rate
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of OverrideControllerValueAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A OverrideControllerValueAction element (same as generated by the class itself)

        Returns
        -------
            ocv_action (OverrideControllerValueAction): a OverrideControllerValueAction object

        &#34;&#34;&#34;
        ocv_action = OverrideControllerValueAction()
        ocva_element = element.find(&#34;ControllerAction/OverrideControllerValueAction&#34;)

        ocv_action.throttle_active = None
        ocv_action.throttle_value = convert_float(0)
        if ocva_element.find(&#34;Throttle&#34;) != None:
            throttle_element = ocva_element.find(&#34;Throttle&#34;)
            ocv_action.throttle_active = convert_bool(throttle_element.attrib[&#34;active&#34;])
            ocv_action.throttle_value = convert_float(throttle_element.attrib[&#34;value&#34;])
            if &#34;maxRate&#34; in throttle_element.attrib:
                ocv_action.throttle_rate = convert_float(
                    throttle_element.attrib[&#34;maxRate&#34;]
                )

        ocv_action.brake_active = None
        ocv_action.brake_value = convert_float(0)
        if ocva_element.find(&#34;Brake&#34;) != None:
            brake_element = ocva_element.find(&#34;Brake&#34;)
            ocv_action.brake_active = convert_bool(brake_element.attrib[&#34;active&#34;])
            if &#34;value&#34; in brake_element.attrib:
                ocv_action.brake_value = convert_float(brake_element.attrib[&#34;value&#34;])
            else:
                if brake_element.find(&#34;BrakePercent&#34;) is not None:
                    brake_input_element = brake_element.find(&#34;BrakePercent&#34;)
                    ocv_action.brake_force = False

                elif brake_element.find(&#34;BrakeForce&#34;) is not None:
                    brake_input_element = brake_element.find(&#34;BrakeForce&#34;)
                    ocv_action.brake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.brake_value = convert_float(
                    brake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in brake_input_element.attrib:
                    ocv_action.brake_rate = brake_input_element.attrib[&#34;maxRate&#34;]

        ocv_action.clutch_active = None
        ocv_action.clutch_value = convert_float(0)
        if ocva_element.find(&#34;Clutch&#34;) != None:
            cluth_element = ocva_element.find(&#34;Clutch&#34;)
            ocv_action.clutch_active = convert_bool(cluth_element.attrib[&#34;active&#34;])
            ocv_action.clutch_value = convert_float(cluth_element.attrib[&#34;value&#34;])
            if &#34;maxRate&#34; in cluth_element.attrib:
                ocv_action.clutch_rate = convert_float(cluth_element.attrib[&#34;maxRate&#34;])

        ocv_action.parkingbrake_active = None
        ocv_action.parkingbrake_value = convert_float(0)
        if ocva_element.find(&#34;ParkingBrake&#34;) != None:
            parkingbrake_element = ocva_element.find(&#34;ParkingBrake&#34;)
            ocv_action.parkingbrake_active = convert_bool(
                parkingbrake_element.attrib[&#34;active&#34;]
            )

            if &#34;value&#34; in parkingbrake_element.attrib:
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_element.attrib[&#34;value&#34;]
                )
            else:
                if parkingbrake_element.find(&#34;BrakePercent&#34;) is not None:
                    parkingbrake_input_element = parkingbrake_element.find(
                        &#34;BrakePercent&#34;
                    )
                    ocv_action.parkingbrake_force = False

                elif parkingbrake_element.find(&#34;BrakeForce&#34;) is not None:
                    parkingbrake_input_element = parkingbrake_element.find(&#34;BrakeForce&#34;)
                    ocv_action.parkingbrake_force = True
                else:
                    raise ValueError(&#34;No value found while parsing brake.&#34;)
                ocv_action.parkingbrake_value = convert_float(
                    parkingbrake_input_element.attrib[&#34;value&#34;]
                )
                if &#34;maxRate&#34; in parkingbrake_input_element.attrib:
                    ocv_action.parkingbrake_rate = convert_float(
                        parkingbrake_input_element.attrib[&#34;maxRate&#34;]
                    )

        ocv_action.steeringwheel_active = None
        ocv_action.steeringwheel_value = convert_float(0)
        if ocva_element.find(&#34;SteeringWheel&#34;) != None:
            steeringwheel_element = ocva_element.find(&#34;SteeringWheel&#34;)
            ocv_action.steeringwheel_active = convert_bool(
                steeringwheel_element.attrib[&#34;active&#34;]
            )
            ocv_action.steeringwheel_value = convert_float(
                steeringwheel_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_rate = convert_float(
                    steeringwheel_element.attrib[&#34;maxRate&#34;]
                )
            if &#34;maxTorque&#34; in steeringwheel_element.attrib:
                ocv_action.steeringwheel_torque = convert_float(
                    steeringwheel_element.attrib[&#34;maxTorque&#34;]
                )

        ocv_action.gear_active = None
        ocv_action.gear_value = convert_float(0)
        if ocva_element.find(&#34;Gear&#34;) != None:
            gear_element = ocva_element.find(&#34;Gear&#34;)
            ocv_action.gear_active = convert_bool(gear_element.attrib[&#34;active&#34;])
            if &#34;number&#34; in gear_element.attrib:
                ocv_action.gear_value = convert_float(gear_element.attrib[&#34;number&#34;])
            elif gear_element.find(&#34;AutomaticGear&#34;) is not None:
                ocv_action.gear_value = getattr(
                    AutomaticGearType,
                    gear_element.find(&#34;AutomaticGear&#34;).attrib[&#34;gear&#34;],
                )

            elif gear_element.find(&#34;ManualGear&#34;) is not None:
                ocv_action.gear_value = convert_float(
                    gear_element.find(&#34;ManualGear&#34;).attrib[&#34;number&#34;]
                )
            else:
                raise ValueError(&#34;no gear number found in OverrideGearAction&#34;)

        return ocv_action

    def set_clutch(self, active, value=0, rate=None):
        &#34;&#34;&#34;Sets the clutch value

        Parameters
        ----------
            active (bool): if the clutch should be overridden

            value (float): value of the clutch
                Default: 0

            rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.clutch_active = convert_bool(active)
        self.clutch_value = convert_float(value)
        self.clutch_rate = rate

    def set_brake(self, active, value=0, rate=None, interpret_as_force=False):
        &#34;&#34;&#34;Sets the brake value

        Parameters
        ----------
            active (bool): if the brake should be overridden

            value (float): value of the brake
                Default: 0

            rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
                Default: None

        &#34;&#34;&#34;
        self.brake_active = convert_bool(active)
        self.brake_value = convert_float(value)
        self.brake_rate = rate
        self.brake_force = interpret_as_force

    def set_throttle(self, active, value=0, rate=None):
        &#34;&#34;&#34;Sets the throttle value

        Parameters
        ----------
            active (bool): if the throttle should be overridden

            value (float): value of the throttle
                Default: 0

            rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.throttle_active = convert_bool(active)
        self.throttle_value = convert_float(value)
        self.throttle_rate = rate

    def set_steeringwheel(self, active, value=0, rate=None, torque=None):
        &#34;&#34;&#34;Sets the steeringwheel value

        Parameters
        ----------
            active (bool): if the steeringwheel should be overridden

            value (float): value of the steeringwheel
                Default: 0

            rate (float): the Max Rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            torque (float): the Max Torque of the change (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.steeringwheel_active = convert_bool(active)
        self.steeringwheel_value = convert_float(value)
        self.steeringwheel_rate = convert_float(rate)
        self.steeringwheel_torque = convert_float(torque)

    def set_parkingbrake(self, active, value=0, rate=None, interpret_as_force=False):
        &#34;&#34;&#34;Sets the parkingbrake value

        Parameters
        ----------
            active (bool): if the parkingbrake should be overridden

            value (float): value of the parkingbrake
                Default: 0

            rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
                Default: None

            interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        self.parkingbrake_active = convert_bool(active)
        self.parkingbrake_value = convert_float(value)
        self.parkingbrake_rate = rate
        self.parkingbrake_force = interpret_as_force

    def set_gear(self, active, value=0):
        &#34;&#34;&#34;Sets the gear value

        Parameters
        ----------
            active (bool): if the gear should be overridden

            value (float/AutomaticGearType): value of the gear
                Default: 0
        &#34;&#34;&#34;
        self.gear_active = convert_bool(active)
        if hasattr(AutomaticGearType, str(value)):
            self.gear_value = value
            self._gear_maunal = False
        else:
            self.gear_value = convert_float(value)
            self._gear_maunal = True

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the OverrideControllerValueAction&#34;&#34;&#34;
        if self.isVersion(minor=0) and not self._used_by_parent:
            raise OpenSCENARIOVersionError(
                &#34;OverrideControllerValueAction cannot be used alone in OSC 1.0, please add it to a ControllerAction&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
        overrideaction = ET.SubElement(
            controlleraction, &#34;OverrideControllerValueAction&#34;
        )

        if (
            self.throttle_active == None
            and self.brake_active == None
            and self.clutch_active == None
            and self.parkingbrake_active == None
            and self.steeringwheel_active == None
            and self.gear_active == None
        ):
            raise NoActionsDefinedError(
                &#34;No actions were added to the OverrideControllerValueAction&#34;
            )
        if self.throttle_active != None:
            throttle_dict = {
                &#34;active&#34;: get_bool_string(self.throttle_active),
                &#34;value&#34;: str(self.throttle_value),
            }
            if self.throttle_rate is not None and self.isVersion(minor=2):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Throttle&#34;,
                throttle_dict,
            )
        if self.brake_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.brake_active),
                        &#34;value&#34;: str(self.brake_value),
                    },
                )
            else:
                override_brake = ET.SubElement(
                    overrideaction,
                    &#34;Brake&#34;,
                    {&#34;active&#34;: get_bool_string(self.brake_active)},
                )
                brake_dict = {&#34;value&#34;: str(self.brake_value)}
                if self.brake_rate is not None:
                    brake_dict[&#34;maxRate&#34;] = str(self.brake_rate)
                if self.brake_force:
                    ET.SubElement(override_brake, &#34;BrakeForce&#34;, attrib=brake_dict)
                else:
                    ET.SubElement(override_brake, &#34;BrakePercent&#34;, attrib=brake_dict)

        if self.clutch_active != None:
            if self.throttle_rate is not None and self.isVersion(minor=2):
                throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
            elif self.throttle_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            clutch_dict = {
                &#34;active&#34;: get_bool_string(self.clutch_active),
                &#34;value&#34;: str(self.clutch_value),
            }
            if self.clutch_rate is not None and self.isVersion(minor=2):
                clutch_dict[&#34;maxRate&#34;] = str(self.clutch_rate)
            elif self.clutch_rate is not None and not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
            ET.SubElement(
                overrideaction,
                &#34;Clutch&#34;,
                clutch_dict,
            )
        if self.parkingbrake_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.parkingbrake_active),
                        &#34;value&#34;: str(self.parkingbrake_value),
                    },
                )
            else:
                override_parking = ET.SubElement(
                    overrideaction,
                    &#34;ParkingBrake&#34;,
                    {&#34;active&#34;: get_bool_string(self.parkingbrake_active)},
                )
                parkingbrake_dict = {&#34;value&#34;: str(self.parkingbrake_value)}
                if self.parkingbrake_rate is not None:
                    parkingbrake_dict[&#34;maxRate&#34;] = str(self.parkingbrake_rate)
                if self.parkingbrake_force:
                    ET.SubElement(
                        override_parking, &#34;BrakeForce&#34;, attrib=parkingbrake_dict
                    )
                else:
                    ET.SubElement(
                        override_parking, &#34;BrakePercent&#34;, attrib=parkingbrake_dict
                    )
        if self.steeringwheel_active != None:
            steering_dict = {
                &#34;active&#34;: get_bool_string(self.steeringwheel_active),
                &#34;value&#34;: str(self.steeringwheel_value),
            }
            if self.steeringwheel_torque is not None:
                if self.isVersion(minor=2):
                    steering_dict[&#34;maxTorque&#34;] = str(self.steeringwheel_torque)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxTorque was introduced in OpenSCENARIO v1.2&#34;
                    )
            if self.steeringwheel_rate is not None:
                if self.isVersion(minor=2):
                    steering_dict[&#34;maxRate&#34;] = str(self.steeringwheel_rate)
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                    )
            ET.SubElement(
                overrideaction,
                &#34;SteeringWheel&#34;,
                steering_dict,
            )

        if self.gear_active != None:
            if not self.isVersion(minor=2):
                ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                        &#34;number&#34;: str(self.gear_value),
                    },
                )
            else:
                override_gear_action = ET.SubElement(
                    overrideaction,
                    &#34;Gear&#34;,
                    {
                        &#34;active&#34;: get_bool_string(self.gear_active),
                    },
                )
                if self._gear_maunal:
                    ET.SubElement(
                        override_gear_action,
                        &#34;ManualGear&#34;,
                        {&#34;number&#34;: str(int(self.gear_value))},
                    )
                else:
                    ET.SubElement(
                        override_gear_action,
                        &#34;AutomaticGear&#34;,
                        {&#34;gear&#34;: self.gear_value.get_name()},
                    )

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of OverrideControllerValueAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A OverrideControllerValueAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ocv_action (OverrideControllerValueAction): a OverrideControllerValueAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of OverrideControllerValueAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A OverrideControllerValueAction element (same as generated by the class itself)

    Returns
    -------
        ocv_action (OverrideControllerValueAction): a OverrideControllerValueAction object

    &#34;&#34;&#34;
    ocv_action = OverrideControllerValueAction()
    ocva_element = element.find(&#34;ControllerAction/OverrideControllerValueAction&#34;)

    ocv_action.throttle_active = None
    ocv_action.throttle_value = convert_float(0)
    if ocva_element.find(&#34;Throttle&#34;) != None:
        throttle_element = ocva_element.find(&#34;Throttle&#34;)
        ocv_action.throttle_active = convert_bool(throttle_element.attrib[&#34;active&#34;])
        ocv_action.throttle_value = convert_float(throttle_element.attrib[&#34;value&#34;])
        if &#34;maxRate&#34; in throttle_element.attrib:
            ocv_action.throttle_rate = convert_float(
                throttle_element.attrib[&#34;maxRate&#34;]
            )

    ocv_action.brake_active = None
    ocv_action.brake_value = convert_float(0)
    if ocva_element.find(&#34;Brake&#34;) != None:
        brake_element = ocva_element.find(&#34;Brake&#34;)
        ocv_action.brake_active = convert_bool(brake_element.attrib[&#34;active&#34;])
        if &#34;value&#34; in brake_element.attrib:
            ocv_action.brake_value = convert_float(brake_element.attrib[&#34;value&#34;])
        else:
            if brake_element.find(&#34;BrakePercent&#34;) is not None:
                brake_input_element = brake_element.find(&#34;BrakePercent&#34;)
                ocv_action.brake_force = False

            elif brake_element.find(&#34;BrakeForce&#34;) is not None:
                brake_input_element = brake_element.find(&#34;BrakeForce&#34;)
                ocv_action.brake_force = True
            else:
                raise ValueError(&#34;No value found while parsing brake.&#34;)
            ocv_action.brake_value = convert_float(
                brake_input_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in brake_input_element.attrib:
                ocv_action.brake_rate = brake_input_element.attrib[&#34;maxRate&#34;]

    ocv_action.clutch_active = None
    ocv_action.clutch_value = convert_float(0)
    if ocva_element.find(&#34;Clutch&#34;) != None:
        cluth_element = ocva_element.find(&#34;Clutch&#34;)
        ocv_action.clutch_active = convert_bool(cluth_element.attrib[&#34;active&#34;])
        ocv_action.clutch_value = convert_float(cluth_element.attrib[&#34;value&#34;])
        if &#34;maxRate&#34; in cluth_element.attrib:
            ocv_action.clutch_rate = convert_float(cluth_element.attrib[&#34;maxRate&#34;])

    ocv_action.parkingbrake_active = None
    ocv_action.parkingbrake_value = convert_float(0)
    if ocva_element.find(&#34;ParkingBrake&#34;) != None:
        parkingbrake_element = ocva_element.find(&#34;ParkingBrake&#34;)
        ocv_action.parkingbrake_active = convert_bool(
            parkingbrake_element.attrib[&#34;active&#34;]
        )

        if &#34;value&#34; in parkingbrake_element.attrib:
            ocv_action.parkingbrake_value = convert_float(
                parkingbrake_element.attrib[&#34;value&#34;]
            )
        else:
            if parkingbrake_element.find(&#34;BrakePercent&#34;) is not None:
                parkingbrake_input_element = parkingbrake_element.find(
                    &#34;BrakePercent&#34;
                )
                ocv_action.parkingbrake_force = False

            elif parkingbrake_element.find(&#34;BrakeForce&#34;) is not None:
                parkingbrake_input_element = parkingbrake_element.find(&#34;BrakeForce&#34;)
                ocv_action.parkingbrake_force = True
            else:
                raise ValueError(&#34;No value found while parsing brake.&#34;)
            ocv_action.parkingbrake_value = convert_float(
                parkingbrake_input_element.attrib[&#34;value&#34;]
            )
            if &#34;maxRate&#34; in parkingbrake_input_element.attrib:
                ocv_action.parkingbrake_rate = convert_float(
                    parkingbrake_input_element.attrib[&#34;maxRate&#34;]
                )

    ocv_action.steeringwheel_active = None
    ocv_action.steeringwheel_value = convert_float(0)
    if ocva_element.find(&#34;SteeringWheel&#34;) != None:
        steeringwheel_element = ocva_element.find(&#34;SteeringWheel&#34;)
        ocv_action.steeringwheel_active = convert_bool(
            steeringwheel_element.attrib[&#34;active&#34;]
        )
        ocv_action.steeringwheel_value = convert_float(
            steeringwheel_element.attrib[&#34;value&#34;]
        )
        if &#34;maxRate&#34; in steeringwheel_element.attrib:
            ocv_action.steeringwheel_rate = convert_float(
                steeringwheel_element.attrib[&#34;maxRate&#34;]
            )
        if &#34;maxTorque&#34; in steeringwheel_element.attrib:
            ocv_action.steeringwheel_torque = convert_float(
                steeringwheel_element.attrib[&#34;maxTorque&#34;]
            )

    ocv_action.gear_active = None
    ocv_action.gear_value = convert_float(0)
    if ocva_element.find(&#34;Gear&#34;) != None:
        gear_element = ocva_element.find(&#34;Gear&#34;)
        ocv_action.gear_active = convert_bool(gear_element.attrib[&#34;active&#34;])
        if &#34;number&#34; in gear_element.attrib:
            ocv_action.gear_value = convert_float(gear_element.attrib[&#34;number&#34;])
        elif gear_element.find(&#34;AutomaticGear&#34;) is not None:
            ocv_action.gear_value = getattr(
                AutomaticGearType,
                gear_element.find(&#34;AutomaticGear&#34;).attrib[&#34;gear&#34;],
            )

        elif gear_element.find(&#34;ManualGear&#34;) is not None:
            ocv_action.gear_value = convert_float(
                gear_element.find(&#34;ManualGear&#34;).attrib[&#34;number&#34;]
            )
        else:
            raise ValueError(&#34;no gear number found in OverrideGearAction&#34;)

    return ocv_action</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the OverrideControllerValueAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the OverrideControllerValueAction&#34;&#34;&#34;
    if self.isVersion(minor=0) and not self._used_by_parent:
        raise OpenSCENARIOVersionError(
            &#34;OverrideControllerValueAction cannot be used alone in OSC 1.0, please add it to a ControllerAction&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    controlleraction = ET.SubElement(element, &#34;ControllerAction&#34;)
    overrideaction = ET.SubElement(
        controlleraction, &#34;OverrideControllerValueAction&#34;
    )

    if (
        self.throttle_active == None
        and self.brake_active == None
        and self.clutch_active == None
        and self.parkingbrake_active == None
        and self.steeringwheel_active == None
        and self.gear_active == None
    ):
        raise NoActionsDefinedError(
            &#34;No actions were added to the OverrideControllerValueAction&#34;
        )
    if self.throttle_active != None:
        throttle_dict = {
            &#34;active&#34;: get_bool_string(self.throttle_active),
            &#34;value&#34;: str(self.throttle_value),
        }
        if self.throttle_rate is not None and self.isVersion(minor=2):
            throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
        elif self.throttle_rate is not None and not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        ET.SubElement(
            overrideaction,
            &#34;Throttle&#34;,
            throttle_dict,
        )
    if self.brake_active != None:
        if not self.isVersion(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;Brake&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.brake_active),
                    &#34;value&#34;: str(self.brake_value),
                },
            )
        else:
            override_brake = ET.SubElement(
                overrideaction,
                &#34;Brake&#34;,
                {&#34;active&#34;: get_bool_string(self.brake_active)},
            )
            brake_dict = {&#34;value&#34;: str(self.brake_value)}
            if self.brake_rate is not None:
                brake_dict[&#34;maxRate&#34;] = str(self.brake_rate)
            if self.brake_force:
                ET.SubElement(override_brake, &#34;BrakeForce&#34;, attrib=brake_dict)
            else:
                ET.SubElement(override_brake, &#34;BrakePercent&#34;, attrib=brake_dict)

    if self.clutch_active != None:
        if self.throttle_rate is not None and self.isVersion(minor=2):
            throttle_dict[&#34;maxRate&#34;] = str(self.throttle_rate)
        elif self.throttle_rate is not None and not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        clutch_dict = {
            &#34;active&#34;: get_bool_string(self.clutch_active),
            &#34;value&#34;: str(self.clutch_value),
        }
        if self.clutch_rate is not None and self.isVersion(minor=2):
            clutch_dict[&#34;maxRate&#34;] = str(self.clutch_rate)
        elif self.clutch_rate is not None and not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
            )
        ET.SubElement(
            overrideaction,
            &#34;Clutch&#34;,
            clutch_dict,
        )
    if self.parkingbrake_active != None:
        if not self.isVersion(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;ParkingBrake&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.parkingbrake_active),
                    &#34;value&#34;: str(self.parkingbrake_value),
                },
            )
        else:
            override_parking = ET.SubElement(
                overrideaction,
                &#34;ParkingBrake&#34;,
                {&#34;active&#34;: get_bool_string(self.parkingbrake_active)},
            )
            parkingbrake_dict = {&#34;value&#34;: str(self.parkingbrake_value)}
            if self.parkingbrake_rate is not None:
                parkingbrake_dict[&#34;maxRate&#34;] = str(self.parkingbrake_rate)
            if self.parkingbrake_force:
                ET.SubElement(
                    override_parking, &#34;BrakeForce&#34;, attrib=parkingbrake_dict
                )
            else:
                ET.SubElement(
                    override_parking, &#34;BrakePercent&#34;, attrib=parkingbrake_dict
                )
    if self.steeringwheel_active != None:
        steering_dict = {
            &#34;active&#34;: get_bool_string(self.steeringwheel_active),
            &#34;value&#34;: str(self.steeringwheel_value),
        }
        if self.steeringwheel_torque is not None:
            if self.isVersion(minor=2):
                steering_dict[&#34;maxTorque&#34;] = str(self.steeringwheel_torque)
            else:
                raise OpenSCENARIOVersionError(
                    &#34;maxTorque was introduced in OpenSCENARIO v1.2&#34;
                )
        if self.steeringwheel_rate is not None:
            if self.isVersion(minor=2):
                steering_dict[&#34;maxRate&#34;] = str(self.steeringwheel_rate)
            else:
                raise OpenSCENARIOVersionError(
                    &#34;maxRate was introduced in OpenSCENARIO v1.2&#34;
                )
        ET.SubElement(
            overrideaction,
            &#34;SteeringWheel&#34;,
            steering_dict,
        )

    if self.gear_active != None:
        if not self.isVersion(minor=2):
            ET.SubElement(
                overrideaction,
                &#34;Gear&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.gear_active),
                    &#34;number&#34;: str(self.gear_value),
                },
            )
        else:
            override_gear_action = ET.SubElement(
                overrideaction,
                &#34;Gear&#34;,
                {
                    &#34;active&#34;: get_bool_string(self.gear_active),
                },
            )
            if self._gear_maunal:
                ET.SubElement(
                    override_gear_action,
                    &#34;ManualGear&#34;,
                    {&#34;number&#34;: str(int(self.gear_value))},
                )
            else:
                ET.SubElement(
                    override_gear_action,
                    &#34;AutomaticGear&#34;,
                    {&#34;gear&#34;: self.gear_value.get_name()},
                )

    return element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake"><code class="name flex">
<span>def <span class="ident">set_brake</span></span>(<span>self, active, value=0, rate=None, interpret_as_force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the brake value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the brake should be overridden

value (float): value of the brake
    Default: 0

rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
    Default: None

interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_brake(self, active, value=0, rate=None, interpret_as_force=False):
    &#34;&#34;&#34;Sets the brake value

    Parameters
    ----------
        active (bool): if the brake should be overridden

        value (float): value of the brake
            Default: 0

        rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
            Default: None

        interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
            Default: None

    &#34;&#34;&#34;
    self.brake_active = convert_bool(active)
    self.brake_value = convert_float(value)
    self.brake_rate = rate
    self.brake_force = interpret_as_force</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch"><code class="name flex">
<span>def <span class="ident">set_clutch</span></span>(<span>self, active, value=0, rate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the clutch value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the clutch should be overridden

value (float): value of the clutch
    Default: 0

rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_clutch(self, active, value=0, rate=None):
    &#34;&#34;&#34;Sets the clutch value

    Parameters
    ----------
        active (bool): if the clutch should be overridden

        value (float): value of the clutch
            Default: 0

        rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
            Default: None
    &#34;&#34;&#34;
    self.clutch_active = convert_bool(active)
    self.clutch_value = convert_float(value)
    self.clutch_rate = rate</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear"><code class="name flex">
<span>def <span class="ident">set_gear</span></span>(<span>self, active, value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the gear value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the gear should be overridden

value (float/AutomaticGearType): value of the gear
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gear(self, active, value=0):
    &#34;&#34;&#34;Sets the gear value

    Parameters
    ----------
        active (bool): if the gear should be overridden

        value (float/AutomaticGearType): value of the gear
            Default: 0
    &#34;&#34;&#34;
    self.gear_active = convert_bool(active)
    if hasattr(AutomaticGearType, str(value)):
        self.gear_value = value
        self._gear_maunal = False
    else:
        self.gear_value = convert_float(value)
        self._gear_maunal = True</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake"><code class="name flex">
<span>def <span class="ident">set_parkingbrake</span></span>(<span>self, active, value=0, rate=None, interpret_as_force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the parkingbrake value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the parkingbrake should be overridden

value (float): value of the parkingbrake
    Default: 0

rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
    Default: None

interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parkingbrake(self, active, value=0, rate=None, interpret_as_force=False):
    &#34;&#34;&#34;Sets the parkingbrake value

    Parameters
    ----------
        active (bool): if the parkingbrake should be overridden

        value (float): value of the parkingbrake
            Default: 0

        rate (float): the rate of the change (Valid from OpenSCENARIO V1.2)
            Default: None

        interpret_as_force (bool): interpret the value as force instead of percent (Valid from OpenSCENARIO V1.2)
            Default: None
    &#34;&#34;&#34;
    self.parkingbrake_active = convert_bool(active)
    self.parkingbrake_value = convert_float(value)
    self.parkingbrake_rate = rate
    self.parkingbrake_force = interpret_as_force</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel"><code class="name flex">
<span>def <span class="ident">set_steeringwheel</span></span>(<span>self, active, value=0, rate=None, torque=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the steeringwheel value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the steeringwheel should be overridden

value (float): value of the steeringwheel
    Default: 0

rate (float): the Max Rate of the change (Valid from OpenSCENARIO V1.2)
    Default: None

torque (float): the Max Torque of the change (Valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_steeringwheel(self, active, value=0, rate=None, torque=None):
    &#34;&#34;&#34;Sets the steeringwheel value

    Parameters
    ----------
        active (bool): if the steeringwheel should be overridden

        value (float): value of the steeringwheel
            Default: 0

        rate (float): the Max Rate of the change (Valid from OpenSCENARIO V1.2)
            Default: None

        torque (float): the Max Torque of the change (Valid from OpenSCENARIO V1.2)
            Default: None
    &#34;&#34;&#34;
    self.steeringwheel_active = convert_bool(active)
    self.steeringwheel_value = convert_float(value)
    self.steeringwheel_rate = convert_float(rate)
    self.steeringwheel_torque = convert_float(torque)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle"><code class="name flex">
<span>def <span class="ident">set_throttle</span></span>(<span>self, active, value=0, rate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the throttle value</p>
<h2 id="parameters">Parameters</h2>
<pre><code>active (bool): if the throttle should be overridden

value (float): value of the throttle
    Default: 0

rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_throttle(self, active, value=0, rate=None):
    &#34;&#34;&#34;Sets the throttle value

    Parameters
    ----------
        active (bool): if the throttle should be overridden

        value (float): value of the throttle
            Default: 0

        rate (float): rate of the change (Valid from OpenSCENARIO V1.2)
            Default: None
    &#34;&#34;&#34;
    self.throttle_active = convert_bool(active)
    self.throttle_value = convert_float(value)
    self.throttle_rate = rate</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction"><code class="flex name class">
<span>class <span class="ident">ParameterAddAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter
(valid to V1.1, deprecated since V1.2)
Parameters</p>
<hr>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be added to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be added to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterAddAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterAddAction(_ActionType):
    &#34;&#34;&#34;The ParameterAddAction class creates a ParameterAction of type ParameterModifyAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be added to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be added to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterAddAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other):
        if isinstance(other, ParameterAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterAddAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterAddAction element (same as generated by the class itself)

        Returns
        -------
            paa_action (ParameterAddAction): a ParameterAddAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;AddValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterAddAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterAddAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterAddAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterAddAction was deprecated in OSC 1.2, please use VariableAddAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterAddAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ParameterAddAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>paa_action (ParameterAddAction): a ParameterAddAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterAddAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ParameterAddAction element (same as generated by the class itself)

    Returns
    -------
        paa_action (ParameterAddAction): a ParameterAddAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

    ma_element = pa_element.find(&#34;ModifyAction&#34;)
    rule_element = ma_element.find(&#34;Rule&#34;)
    mbv_element = rule_element.find(&#34;AddValue&#34;)
    value = convert_float(mbv_element.attrib[&#34;value&#34;])

    return ParameterAddAction(parameterRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterAddAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ParameterAddAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterAddAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterAddAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterAddAction&#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterAddAction was deprecated in OSC 1.2, please use VariableAddAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction"><code class="flex name class">
<span>class <span class="ident">ParameterMultiplyAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter
(valid to V1.1, deprecated since V1.2)
Parameters</p>
<hr>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be multiplied to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be multiplied to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterMultiplyAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterMultiplyAction(_ActionType):
    &#34;&#34;&#34;The ParameterMultiplyAction class creates a ParameterAction of tyoe ParameterModifyAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be multiplied to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be multiplied to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterMultiplyAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = convert_float(value)

    def __eq__(self, other):
        if isinstance(other, ParameterMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterMultiplyAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterMultiplyAction element (same as generated by the class itself)

        Returns
        -------
            pma_action (ParameterMultiplyAction): a ParameterMultiplyAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
        value = convert_float(mbv_element.attrib[&#34;value&#34;])

        return ParameterMultiplyAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterMultiplyAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterMultiplyAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterMultiplyAction was deprecated in OSC 1.2, please use VariableMultiplyAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterMultiplyAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ParameterMultiplyAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>pma_action (ParameterMultiplyAction): a ParameterMultiplyAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterMultiplyAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ParameterMultiplyAction element (same as generated by the class itself)

    Returns
    -------
        pma_action (ParameterMultiplyAction): a ParameterMultiplyAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]

    ma_element = pa_element.find(&#34;ModifyAction&#34;)
    rule_element = ma_element.find(&#34;Rule&#34;)
    mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
    value = convert_float(mbv_element.attrib[&#34;value&#34;])

    return ParameterMultiplyAction(parameterRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterMultiplyAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ParameterMultiplyAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterMultiplyAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterMultiplyAction&#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterMultiplyAction was deprecated in OSC 1.2, please use VariableMultiplyAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction"><code class="flex name class">
<span>class <span class="ident">ParameterSetAction</span></span>
<span>(</span><span>parameter_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter
(valid to V1.1, deprecated since V1.2)
Parameters</p>
<hr>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be set to the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be set to the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterSetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter_ref (str): name of the parameter

value (float): the value that should be added to the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterSetAction(_ActionType):
    &#34;&#34;&#34;The ParameterSetAction class creates a ParameterAction which adds a value to an existing Parameter
    (valid to V1.1, deprecated since V1.2)
    Parameters
    ----------
        parameter_ref (str): name of the parameter

        value (float): the value that should be set to the parameter

    Attributes
    ----------

        parameter_ref (str): name of the parameter

        value (float): the value that should be set to the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, parameter_ref, value):
        &#34;&#34;&#34;initalize the ParameterSetAction

        Parameters
        ----------
            parameter_ref (str): name of the parameter

            value (float): the value that should be added to the parameter

        &#34;&#34;&#34;
        self.parameter_ref = parameter_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, ParameterSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameter_ref == other.parameter_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterSetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ParameterSetAction element (same as generated by the class itself)

        Returns
        -------
            psa_action (ParameterSetAction): a ParameterSetAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;ParameterAction&#34;)
        parameterRef = pa_element.attrib[&#34;parameterRef&#34;]
        psa_element = pa_element.find(&#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        psa = ParameterSetAction(parameterRef, value)
        psa.setVersion(minor=1)
        return psa  # ParameterSetAction(parameterRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterSetAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterSetAction&#34;&#34;&#34;
        if self.version_minor &gt; 1:
            raise OpenSCENARIOVersionError(
                &#34;ParameterSetAction was deprecated in OSC 1.2, please use VariableSetAction instead&#34;
            )
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterSetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ParameterSetAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>psa_action (ParameterSetAction): a ParameterSetAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterSetAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ParameterSetAction element (same as generated by the class itself)

    Returns
    -------
        psa_action (ParameterSetAction): a ParameterSetAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;ParameterAction&#34;)
    parameterRef = pa_element.attrib[&#34;parameterRef&#34;]
    psa_element = pa_element.find(&#34;SetAction&#34;)
    value = psa_element.attrib[&#34;value&#34;]
    psa = ParameterSetAction(parameterRef, value)
    psa.setVersion(minor=1)
    return psa  # ParameterSetAction(parameterRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterSetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ParameterSetAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.ParameterSetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterSetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterSetAction&#34;&#34;&#34;
    if self.version_minor &gt; 1:
        raise OpenSCENARIOVersionError(
            &#34;ParameterSetAction was deprecated in OSC 1.2, please use VariableSetAction instead&#34;
        )
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;ParameterAction&#34;, {&#34;parameterRef&#34;: self.parameter_ref}
    )
    ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneChangeAction</span></span>
<span>(</span><span>lane, entity, transition_dynamics, target_lane_offset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (int): relative lane number

entity (str): the entity to run relative to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (int): lane to change to

target (str): target for relative lane change

target_lane_offset (float): offset in the target lane is wanted

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize RelativeLaneChangeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane (int): relative lane number

entity (str): the entity to run relative to

transition_dynamics (TransitionDynamics): how the change should be made

target_lane_offset (float): if a offset in the target lane is wanted
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneChangeAction(_PrivateActionType):
    &#34;&#34;&#34;the RelativeLaneChangeAction creates a LateralAction of type LaneChangeAction with a relative target

    Parameters
    ----------
        lane (int): relative lane number

        entity (str): the entity to run relative to

        transition_dynamics (TransitionDynamics): how the change should be made

        target_lane_offset (float): if a offset in the target lane is wanted
            Default: None

    Attributes
    ----------
        value (int): lane to change to

        target (str): target for relative lane change

        target_lane_offset (float): offset in the target lane is wanted

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, lane, entity, transition_dynamics, target_lane_offset=None):
        &#34;&#34;&#34;initalize RelativeLaneChangeAction

        Parameters
        ----------
            lane (int): relative lane number

            entity (str): the entity to run relative to

            transition_dynamics (TransitionDynamics): how the change should be made

            target_lane_offset (float): if a offset in the target lane is wanted
                Default: None

        &#34;&#34;&#34;

        self.lane = convert_int(lane)
        self.target = entity
        self.target_lane_offset = convert_float(target_lane_offset)
        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics

    def __eq__(self, other):
        if isinstance(other, RelativeLaneChangeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
                and self.target_lane_offset == other.target_lane_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

        Returns
        -------
            alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

        &#34;&#34;&#34;
        lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
        target_lane_offset = None
        if &#34;targetLaneOffset&#34; in lca_element.attrib:
            target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
        dynamics = TransitionDynamics.parse(
            lca_element.find(&#34;LaneChangeActionDynamics&#34;)
        )
        targetlane_element = lca_element.find(&#34;LaneChangeTarget/RelativeTargetLane&#34;)
        lane = convert_int(targetlane_element.attrib[&#34;value&#34;])
        target = targetlane_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneChangeAction(lane, target, dynamics, target_lane_offset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeLaneChangeAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.lane)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeLaneChangeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        laneoffset = {}
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        if self.target_lane_offset is not None:
            laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
        lanechangeaction = ET.SubElement(
            lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
        )

        lanechangeaction.append(
            self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
        )
        lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

        ET.SubElement(lanchangetarget, &#34;RelativeTargetLane&#34;, self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AbsoluteLaneChangeAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AbsoluteLaneChangeAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AbsoluteLaneChangeAction element (same as generated by the class itself)

    Returns
    -------
        alc_action (AbsoluteLaneChangeAction): a AbsoluteLaneChangeAction object

    &#34;&#34;&#34;
    lca_element = element.find(&#34;LateralAction/LaneChangeAction&#34;)
    target_lane_offset = None
    if &#34;targetLaneOffset&#34; in lca_element.attrib:
        target_lane_offset = convert_float(lca_element.attrib[&#34;targetLaneOffset&#34;])
    dynamics = TransitionDynamics.parse(
        lca_element.find(&#34;LaneChangeActionDynamics&#34;)
    )
    targetlane_element = lca_element.find(&#34;LaneChangeTarget/RelativeTargetLane&#34;)
    lane = convert_int(targetlane_element.attrib[&#34;value&#34;])
    target = targetlane_element.attrib[&#34;entityRef&#34;]

    return RelativeLaneChangeAction(lane, target, dynamics, target_lane_offset)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeLaneChangeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeLaneChangeAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.lane)
    retdict[&#34;entityRef&#34;] = self.target
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeLaneChangeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeLaneChangeAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    laneoffset = {}
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    if self.target_lane_offset is not None:
        laneoffset = {&#34;targetLaneOffset&#34;: str(self.target_lane_offset)}
    lanechangeaction = ET.SubElement(
        lataction, &#34;LaneChangeAction&#34;, attrib=laneoffset
    )

    lanechangeaction.append(
        self.transition_dynamics.get_element(&#34;LaneChangeActionDynamics&#34;)
    )
    lanchangetarget = ET.SubElement(lanechangeaction, &#34;LaneChangeTarget&#34;)

    ET.SubElement(lanchangetarget, &#34;RelativeTargetLane&#34;, self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction"><code class="flex name class">
<span>class <span class="ident">RelativeLaneOffsetAction</span></span>
<span>(</span><span>value, entity, shape, maxlatacc, continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value (float): relative lateral offset of the target

entity (str): name of the entity

shape (str): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>continuous (bool): if the controller tries to keep the relative speed

value (float): relative lateral offset of the arget

target (str): the name of the entity

dynshape (str): the shape of the action

maxlatacc (float): maximum allowed lateral acceleration
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the RelativeLaneOffsetAction,</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): relative lateral offset of the target

entity (str): name of the entity

shape (str): shape of the offset action

maxlatacc (float): maximum allowed lateral acceleration

continuous (bool): if the controller tries to keep the relative speed
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeLaneOffsetAction(_PrivateActionType):
    &#34;&#34;&#34;the RelativeLaneOffsetAction class creates a LateralAction of type LaneOffsetAction with a relative target

    Parameters
    ----------
        value (float): relative lateral offset of the target

        entity (str): name of the entity

        shape (str): shape of the offset action

        maxlatacc (float): maximum allowed lateral acceleration

        continuous (bool): if the controller tries to keep the relative speed
            Default: True

    Attributes
    ----------
        continuous (bool): if the controller tries to keep the relative speed

        value (float): relative lateral offset of the arget

        target (str): the name of the entity

        dynshape (str): the shape of the action

        maxlatacc (float): maximum allowed lateral acceleration

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, value, entity, shape, maxlatacc, continuous=True):
        &#34;&#34;&#34;initalizes the RelativeLaneOffsetAction,

        Parameters
        ----------
            value (float): relative lateral offset of the target

            entity (str): name of the entity

            shape (str): shape of the offset action

            maxlatacc (float): maximum allowed lateral acceleration

            continuous (bool): if the controller tries to keep the relative speed
                Default: True
        &#34;&#34;&#34;
        self.continuous = convert_bool(continuous)
        self.value = convert_float(value)
        self.target = entity
        if not hasattr(DynamicsShapes, str(shape)):
            raise ValueError(shape + &#34;; is not a valid shape.&#34;)
        self.dynshape = shape
        self.maxlatacc = convert_float(maxlatacc)

    def __eq__(self, other):
        if isinstance(other, RelativeLaneOffsetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynshape == other.dynshape
                and self.maxlatacc == other.maxlatacc
                and self.continuous == other.continuous
                and self.target == other.target
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

        Returns
        -------
            alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

        &#34;&#34;&#34;
        loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

        contiuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
        load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
        maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
        dynamics = getattr(DynamicsShapes, load_element.attrib[&#34;dynamicsShape&#34;])

        rtlo_element = loa_element.find(&#34;LaneOffsetTarget/RelativeTargetLaneOffset&#34;)
        value = convert_float(rtlo_element.attrib[&#34;value&#34;])
        entity = rtlo_element.attrib[&#34;entityRef&#34;]

        return RelativeLaneOffsetAction(value, entity, dynamics, maxacc, contiuous)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeLaneOffsetAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;value&#34;] = str(self.value)
        retdict[&#34;entityRef&#34;] = self.target
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeLaneOffsetAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        lataction = ET.SubElement(element, &#34;LateralAction&#34;)
        laneoffsetaction = ET.SubElement(
            lataction,
            &#34;LaneOffsetAction&#34;,
            attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
        )
        ET.SubElement(
            laneoffsetaction,
            &#34;LaneOffsetActionDynamics&#34;,
            {
                &#34;maxLateralAcc&#34;: str(self.maxlatacc),
                &#34;dynamicsShape&#34;: self.dynshape.get_name(),
            },
        )
        laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
        ET.SubElement(
            laneoftarget, &#34;RelativeTargetLaneOffset&#34;, attrib=self.get_attributes()
        )

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AbsoluteLaneOffsetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AbsoluteLaneOffsetAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A AbsoluteLaneOffsetAction element (same as generated by the class itself)

    Returns
    -------
        alco_action (AbsoluteLaneOffsetAction): a AbsoluteLaneOffsetAction object

    &#34;&#34;&#34;
    loa_element = element.find(&#34;LateralAction/LaneOffsetAction&#34;)

    contiuous = convert_bool(loa_element.attrib[&#34;continuous&#34;])
    load_element = loa_element.find(&#34;LaneOffsetActionDynamics&#34;)
    maxacc = convert_float(load_element.attrib[&#34;maxLateralAcc&#34;])
    dynamics = getattr(DynamicsShapes, load_element.attrib[&#34;dynamicsShape&#34;])

    rtlo_element = loa_element.find(&#34;LaneOffsetTarget/RelativeTargetLaneOffset&#34;)
    value = convert_float(rtlo_element.attrib[&#34;value&#34;])
    entity = rtlo_element.attrib[&#34;entityRef&#34;]

    return RelativeLaneOffsetAction(value, entity, dynamics, maxacc, contiuous)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeLaneOffsetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeLaneOffsetAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;value&#34;] = str(self.value)
    retdict[&#34;entityRef&#34;] = self.target
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeLaneOffsetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeLaneOffsetAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    lataction = ET.SubElement(element, &#34;LateralAction&#34;)
    laneoffsetaction = ET.SubElement(
        lataction,
        &#34;LaneOffsetAction&#34;,
        attrib={&#34;continuous&#34;: get_bool_string(self.continuous)},
    )
    ET.SubElement(
        laneoffsetaction,
        &#34;LaneOffsetActionDynamics&#34;,
        {
            &#34;maxLateralAcc&#34;: str(self.maxlatacc),
            &#34;dynamicsShape&#34;: self.dynshape.get_name(),
        },
    )
    laneoftarget = ET.SubElement(laneoffsetaction, &#34;LaneOffsetTarget&#34;)
    ET.SubElement(
        laneoftarget, &#34;RelativeTargetLaneOffset&#34;, attrib=self.get_attributes()
    )

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedAction</span></span>
<span>(</span><span>speed, entity, transition_dynamics, valuetype=&lt;scenariogeneration.xosc.enumerations._OscEnum object&gt;, continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target</p>
<h2 id="parameters">Parameters</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target (used for relative speed)

transition_dynamics (TransitionDynamics): how the change should be made

valuetype (str): the type of relative speed wanted (used for relative speed)

continuous (bool): if the controller tries to keep the relative speed
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target (used for relative speed)

valuetype (str): the type of relative speed wanted (used for relative speed)

continuous (bool): if the controller tries to keep the relative speed

transition_dynamics (TransitionDynamics): how the change should be made
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes RelativeSpeedAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speed (float): the speed wanted

target (str): the name of the relative target

transition_dynamics (TransitionDynamics): how the change should be made

valuetype (SpeedTargetValueType): the type of relative speed wanted

continuous (bool): if the controller tries to keep the relative speed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedAction(_PrivateActionType):
    &#34;&#34;&#34;The RelativeSpeedAction creates a LongitudinalAction of type SpeedAction with a relative target

    Parameters
    ----------
        speed (float): the speed wanted

        target (str): the name of the relative target (used for relative speed)

        transition_dynamics (TransitionDynamics): how the change should be made

        valuetype (str): the type of relative speed wanted (used for relative speed)

        continuous (bool): if the controller tries to keep the relative speed

    Attributes
    ----------
        speed (float): the speed wanted

        target (str): the name of the relative target (used for relative speed)

        valuetype (str): the type of relative speed wanted (used for relative speed)

        continuous (bool): if the controller tries to keep the relative speed

        transition_dynamics (TransitionDynamics): how the change should be made

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        speed,
        entity,
        transition_dynamics,
        valuetype=SpeedTargetValueType.delta,
        continuous=True,
    ):
        &#34;&#34;&#34;initalizes RelativeSpeedAction

        Parameters
        ----------
            speed (float): the speed wanted

            target (str): the name of the relative target

            transition_dynamics (TransitionDynamics): how the change should be made

            valuetype (SpeedTargetValueType): the type of relative speed wanted

            continuous (bool): if the controller tries to keep the relative speed

        &#34;&#34;&#34;
        self.speed = convert_float(speed)
        self.target = entity
        if not hasattr(SpeedTargetValueType, str(valuetype)):
            raise TypeError(&#34;valuetype input not of type SpeedTargetValueType&#34;)
        self.valuetype = valuetype

        if not isinstance(transition_dynamics, TransitionDynamics):
            raise TypeError(&#34;transition_dynamics input not of type TransitionDynamics&#34;)
        self.transition_dynamics = transition_dynamics
        self.continuous = convert_bool(continuous)

    def __eq__(self, other):
        if isinstance(other, RelativeSpeedAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.transition_dynamics == other.transition_dynamics
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RelativeSpeedAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            action (RelativeSpeedAction): the RelativeSpeedAction

        &#34;&#34;&#34;
        speed_element = element.find(
            &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;
        )
        td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
        speed = speed_element.attrib[&#34;value&#34;]
        entity = speed_element.attrib[&#34;entityRef&#34;]
        continuous = convert_bool(speed_element.attrib[&#34;continuous&#34;])
        valuetype = getattr(
            SpeedTargetValueType, speed_element.attrib[&#34;speedTargetValueType&#34;]
        )
        transition_dynamics = TransitionDynamics.parse(td_element)
        return RelativeSpeedAction(
            speed, entity, transition_dynamics, valuetype, continuous
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeSpeedAction as a dict&#34;&#34;&#34;
        return {
            &#34;entityRef&#34;: self.target,
            &#34;value&#34;: str(self.speed),
            &#34;speedTargetValueType&#34;: self.valuetype.get_name(),
            &#34;continuous&#34;: get_bool_string(self.continuous),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeSpeedAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)
        speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
        speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

        ET.SubElement(speedactiontarget, &#34;RelativeTargetSpeed&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of RelativeSpeedAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>action (RelativeSpeedAction): the RelativeSpeedAction
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of RelativeSpeedAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        action (RelativeSpeedAction): the RelativeSpeedAction

    &#34;&#34;&#34;
    speed_element = element.find(
        &#34;LongitudinalAction/SpeedAction/SpeedActionTarget/RelativeTargetSpeed&#34;
    )
    td_element = element.find(&#34;LongitudinalAction/SpeedAction/SpeedActionDynamics&#34;)
    speed = speed_element.attrib[&#34;value&#34;]
    entity = speed_element.attrib[&#34;entityRef&#34;]
    continuous = convert_bool(speed_element.attrib[&#34;continuous&#34;])
    valuetype = getattr(
        SpeedTargetValueType, speed_element.attrib[&#34;speedTargetValueType&#34;]
    )
    transition_dynamics = TransitionDynamics.parse(td_element)
    return RelativeSpeedAction(
        speed, entity, transition_dynamics, valuetype, continuous
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeSpeedAction as a dict&#34;&#34;&#34;
    return {
        &#34;entityRef&#34;: self.target,
        &#34;value&#34;: str(self.speed),
        &#34;speedTargetValueType&#34;: self.valuetype.get_name(),
        &#34;continuous&#34;: get_bool_string(self.continuous),
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeSpeedAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(longaction, &#34;SpeedAction&#34;)
    speedaction.append(self.transition_dynamics.get_element(&#34;SpeedActionDynamics&#34;))
    speedactiontarget = ET.SubElement(speedaction, &#34;SpeedActionTarget&#34;)

    ET.SubElement(speedactiontarget, &#34;RelativeTargetSpeed&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction"><code class="flex name class">
<span>class <span class="ident">SpeedProfileAction</span></span>
<span>(</span><span>speeds, following_mode, times=None, dynamics_constraint=None, entity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The SpeedProfileAction class specifies a LongitudinalAction of type SpeedProfileAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>speeds (list of float): the different speed entries wanted

following_mode (FollowingMode): how to follow the speed changes

times (list of float): optional time entries when the speed entries should be achieved
    Default: None

dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
    Default: None

entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>speeds (list of float): the different speed entries wanted

following_mode (FollowingMode): how to follow the speed changes

times (list of float): optional time entries when the speed entries should be achieved

dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile

entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the SpeedProfileAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>speeds (list of float): the different speed entries wanted

following_mode (FollowingMode): how to follow the speed changes

times (list of float): optional time entries when the speed entries should be achieved
    Default: None

dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
    Default: None

entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpeedProfileAction(_PrivateActionType):
    &#34;&#34;&#34;The SpeedProfileAction class specifies a LongitudinalAction of type SpeedProfileAction

    Parameters
    ----------
        speeds (list of float): the different speed entries wanted

        following_mode (FollowingMode): how to follow the speed changes

        times (list of float): optional time entries when the speed entries should be achieved
            Default: None

        dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
            Default: None

        entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
            Default: None

    Attributes
    ----------

        speeds (list of float): the different speed entries wanted

        following_mode (FollowingMode): how to follow the speed changes

        times (list of float): optional time entries when the speed entries should be achieved

        dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile

        entity (str): name of an entity, the speeds will then be interpreted as relative to that entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self, speeds, following_mode, times=None, dynamics_constraint=None, entity=None
    ):
        &#34;&#34;&#34;initalize the SpeedProfileAction

        Parameters
        ----------
            speeds (list of float): the different speed entries wanted

            following_mode (FollowingMode): how to follow the speed changes

            times (list of float): optional time entries when the speed entries should be achieved
                Default: None

            dynamics_constraint (DynamicsConstraints): optional constraints for the speed profile
                Default: None

            entity (str): name of an entity, the speeds will then be interpreted as relative to that entity
                Default: None

        &#34;&#34;&#34;
        if times and (len(times) != len(speeds)):
            raise ValueError(&#34;times and speeds are not the same lenght&#34;)
        self.speeds = [convert_float(x) for x in speeds]
        if dynamics_constraint and not isinstance(
            dynamics_constraint, DynamicsConstraints
        ):
            raise TypeError(&#34;dynamics_constraint input not of type DynamicsConstraints&#34;)
        self.dynamics_constraint = dynamics_constraint
        self.following_mode = convert_enum(following_mode, FollowingMode)
        if times:
            self.times = [convert_float(x) for x in times]
        else:
            self.times = times
        self.entity = entity

    def __eq__(self, other):
        if isinstance(other, SpeedProfileAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.dynamics_constraint == other.dynamics_constraint
                and self.entity == other.entity
                and self.speeds == other.speeds
                and self.times == other.times
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SpeedProfileAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A SpeedProfileAction element (same as generated by the class itself)

        Returns
        -------
            action (SpeedProfileAction): a SpeedProfileAction object

        &#34;&#34;&#34;
        speed_profile_element = element.find(&#34;LongitudinalAction/SpeedProfileAction&#34;)
        following_mode = convert_enum(
            speed_profile_element.attrib[&#34;followingMode&#34;], FollowingMode
        )
        dynamics_constraint = None
        entity = None

        if &#34;entityRef&#34; in speed_profile_element.attrib:
            entity = speed_profile_element.attrib[&#34;entityRef&#34;]
        if speed_profile_element.find(&#34;DynamicConstraints&#34;) is not None:
            dynamics_constraint = DynamicsConstraints.parse(
                speed_profile_element.find(&#34;DynamicConstraints&#34;)
            )

        entires = speed_profile_element.findall(&#34;SpeedProfileEntry&#34;)
        speeds = []
        times = []
        for i in entires:
            if &#34;time&#34; in i.attrib:
                times.append(convert_float(i.attrib[&#34;time&#34;]))
            speeds.append(convert_float(i.attrib[&#34;speed&#34;]))

        return SpeedProfileAction(
            speeds, following_mode, times, dynamics_constraint, entity
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the SpeedProfileAction as a dict&#34;&#34;&#34;
        retdict = {&#34;followingMode&#34;: self.following_mode.get_name()}
        if self.entity:
            retdict[&#34;entityRef&#34;] = self.entity
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the SpeedProfileAction&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;SpeedProfileAction was introduced in OpenSCENARIO V1.2&#34;
            )
        element = ET.Element(&#34;PrivateAction&#34;)
        longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
        speedaction = ET.SubElement(
            longaction, &#34;SpeedProfileAction&#34;, attrib=self.get_attributes()
        )
        if self.dynamics_constraint is not None:
            speedaction.append(self.dynamics_constraint.get_element())

        for i in range(len(self.speeds)):
            tmp_dict = {&#34;speed&#34;: str(self.speeds[i])}
            if self.times:
                tmp_dict[&#34;time&#34;] = str(self.times[i])
            ET.SubElement(speedaction, &#34;SpeedProfileEntry&#34;, attrib=tmp_dict)

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of SpeedProfileAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A SpeedProfileAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>action (SpeedProfileAction): a SpeedProfileAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of SpeedProfileAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A SpeedProfileAction element (same as generated by the class itself)

    Returns
    -------
        action (SpeedProfileAction): a SpeedProfileAction object

    &#34;&#34;&#34;
    speed_profile_element = element.find(&#34;LongitudinalAction/SpeedProfileAction&#34;)
    following_mode = convert_enum(
        speed_profile_element.attrib[&#34;followingMode&#34;], FollowingMode
    )
    dynamics_constraint = None
    entity = None

    if &#34;entityRef&#34; in speed_profile_element.attrib:
        entity = speed_profile_element.attrib[&#34;entityRef&#34;]
    if speed_profile_element.find(&#34;DynamicConstraints&#34;) is not None:
        dynamics_constraint = DynamicsConstraints.parse(
            speed_profile_element.find(&#34;DynamicConstraints&#34;)
        )

    entires = speed_profile_element.findall(&#34;SpeedProfileEntry&#34;)
    speeds = []
    times = []
    for i in entires:
        if &#34;time&#34; in i.attrib:
            times.append(convert_float(i.attrib[&#34;time&#34;]))
        speeds.append(convert_float(i.attrib[&#34;speed&#34;]))

    return SpeedProfileAction(
        speeds, following_mode, times, dynamics_constraint, entity
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the SpeedProfileAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the SpeedProfileAction as a dict&#34;&#34;&#34;
    retdict = {&#34;followingMode&#34;: self.following_mode.get_name()}
    if self.entity:
        retdict[&#34;entityRef&#34;] = self.entity
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.SpeedProfileAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the SpeedProfileAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the SpeedProfileAction&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;SpeedProfileAction was introduced in OpenSCENARIO V1.2&#34;
        )
    element = ET.Element(&#34;PrivateAction&#34;)
    longaction = ET.SubElement(element, &#34;LongitudinalAction&#34;)
    speedaction = ET.SubElement(
        longaction, &#34;SpeedProfileAction&#34;, attrib=self.get_attributes()
    )
    if self.dynamics_constraint is not None:
        speedaction.append(self.dynamics_constraint.get_element())

    for i in range(len(self.speeds)):
        tmp_dict = {&#34;speed&#34;: str(self.speeds[i])}
        if self.times:
            tmp_dict[&#34;time&#34;] = str(self.times[i])
        ET.SubElement(speedaction, &#34;SpeedProfileEntry&#34;, attrib=tmp_dict)

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction"><code class="flex name class">
<span>class <span class="ident">SynchronizeAction</span></span>
<span>(</span><span>entity, entity_PositionType:Â scenariogeneration.xosc.utils._PositionType, target_PositionType:Â scenariogeneration.xosc.utils._PositionType, target_tolerance_master=None, target_tolerance=None, final_speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronizes an entity's arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

speed (float): the absolute speed of the target that should syncronize

target_tolerance_master (optional) (float): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (float): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

speed (float): the absolute speed of the target that should syncronize

target_tolerance_master (optional) (float): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (float): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalize the SynchronizeAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): entity to syncronize with

entity_PositionType (*Position): the position of the entity to syncronize to

target_PositionType (*Position): the position of the target that should syncronize

target_tolerance_master (optional) (float): tolerance offset of the master's position [m]. (Valid from OpenSCENARIO V1.1)

target_tolerance (optional) (float): tolerance offset of the target's position [m]. (Valid from OpenSCENARIO V1.1)

final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynchronizeAction(_PrivateActionType):
    &#34;&#34;&#34;Synchronizes an entity&#39;s arrival at a destination with a master entity. Both entities are provided with their own reference position which shall be reached at the same time. Final speed can be specified. Note that the reference positions can be different or identical.

    Parameters
    ----------
        entity (str): entity to syncronize with

        entity_PositionType (*Position): the position of the entity to syncronize to

        target_PositionType (*Position): the position of the target that should syncronize

        speed (float): the absolute speed of the target that should syncronize

        target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
            Default: None
    Attributes
    ----------
        entity (str): entity to syncronize with

        entity_PositionType (*Position): the position of the entity to syncronize to

        target_PositionType (*Position): the position of the target that should syncronize

        speed (float): the absolute speed of the target that should syncronize

        target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

        final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        entity,
        entity_PositionType: _PositionType,
        target_PositionType: _PositionType,
        target_tolerance_master=None,
        target_tolerance=None,
        final_speed=None,
    ):
        &#34;&#34;&#34;initalize the SynchronizeAction

        Parameters
        ----------
            entity (str): entity to syncronize with

            entity_PositionType (*Position): the position of the entity to syncronize to

            target_PositionType (*Position): the position of the target that should syncronize

            target_tolerance_master (optional) (float): tolerance offset of the master&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            target_tolerance (optional) (float): tolerance offset of the target&#39;s position [m]. (Valid from OpenSCENARIO V1.1)

            final_speed (AbsoluteSpeed or RelativeSpeedToMaster): The speed that the synchronized entity should have at its target position. (Valid from OpenSCENARIO V1.1)
            Default: None
        &#34;&#34;&#34;

        self.entity = entity
        if not isinstance(entity_PositionType, _PositionType):
            raise TypeError(&#34;entity_PositionType input is not a valid Position&#34;)

        if not isinstance(target_PositionType, _PositionType):
            raise TypeError(&#34;target_PositionType input is not a valid Position&#34;)
        self.entity_PositionType = entity_PositionType
        self.target_PositionType = target_PositionType
        self.target_tolerance_master = convert_float(target_tolerance_master)
        self.target_tolerance = convert_float(target_tolerance)
        if final_speed and not (
            isinstance(final_speed, AbsoluteSpeed)
            or isinstance(final_speed, RelativeSpeedToMaster)
        ):
            raise TypeError(
                &#34;final_speed input is not AbsoluteSpeed or RelativeSpeedToMaster type&#34;
            )
        else:
            self.final_speed = final_speed

    def __eq__(self, other):
        if isinstance(other, SynchronizeAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.entity_PositionType == other.entity_PositionType
                and self.target_PositionType == other.target_PositionType
                and self.final_speed == other.final_speed
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of SynchronizeAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A SynchronizeAction element (same as generated by the class itself)

        Returns
        -------
            sync_action (SynchronizeAction): a SynchronizeAction object

        &#34;&#34;&#34;
        sa_element = element.find(&#34;SynchronizeAction&#34;)
        entity = sa_element.attrib[&#34;masterEntityRef&#34;]

        target_tolerance = None
        if &#34;targetTolerance&#34; in sa_element.attrib:
            target_tolerance = convert_float(sa_element.attrib[&#34;targetTolerance&#34;])

        target_tolerance_master = None
        if &#34;targetToleranceMaster&#34; in sa_element.attrib:
            target_tolerance_master = convert_float(
                sa_element.attrib[&#34;targetToleranceMaster&#34;]
            )

        targetPositionMaster = _PositionFactory.parse_position(
            sa_element.find(&#34;TargetPositionMaster&#34;)
        )
        targetPosition = _PositionFactory.parse_position(
            sa_element.find(&#34;TargetPosition&#34;)
        )

        finalSpeed = None
        if sa_element.find(&#34;FinalSpeed&#34;) != None:
            sa_element = sa_element.find(&#34;FinalSpeed&#34;)
            if sa_element.find(&#34;AbsoluteSpeed&#34;) != None:
                finalSpeed = AbsoluteSpeed.parse(sa_element)
            if sa_element.find(&#34;RelativeSpeedToMaster&#34;) != None:
                finalSpeed = RelativeSpeedToMaster.parse(sa_element)

        return SynchronizeAction(
            entity,
            targetPositionMaster,
            targetPosition,
            target_tolerance_master,
            target_tolerance,
            finalSpeed,
        )
        _

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSynchronizeAction as a dict&#34;&#34;&#34;
        attr = {&#34;masterEntityRef&#34;: self.entity}
        if self.isVersion(1, 0):
            return attr
        if self.target_tolerance_master is not None:
            attr.update({&#34;targetToleranceMaster&#34;: str(self.target_tolerance_master)})
        if self.target_tolerance is not None:
            attr.update({&#34;targetTolerance&#34;: str(self.target_tolerance)})
        return attr

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSynchronizeAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        syncaction = ET.SubElement(element, &#34;SynchronizeAction&#34;, self.get_attributes())
        syncaction.append(self.entity_PositionType.get_element(&#34;TargetPositionMaster&#34;))
        syncaction.append(self.target_PositionType.get_element(&#34;TargetPosition&#34;))
        if self.final_speed is not None:
            syncaction.append(self.final_speed.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of SynchronizeAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A SynchronizeAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>sync_action (SynchronizeAction): a SynchronizeAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of SynchronizeAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A SynchronizeAction element (same as generated by the class itself)

    Returns
    -------
        sync_action (SynchronizeAction): a SynchronizeAction object

    &#34;&#34;&#34;
    sa_element = element.find(&#34;SynchronizeAction&#34;)
    entity = sa_element.attrib[&#34;masterEntityRef&#34;]

    target_tolerance = None
    if &#34;targetTolerance&#34; in sa_element.attrib:
        target_tolerance = convert_float(sa_element.attrib[&#34;targetTolerance&#34;])

    target_tolerance_master = None
    if &#34;targetToleranceMaster&#34; in sa_element.attrib:
        target_tolerance_master = convert_float(
            sa_element.attrib[&#34;targetToleranceMaster&#34;]
        )

    targetPositionMaster = _PositionFactory.parse_position(
        sa_element.find(&#34;TargetPositionMaster&#34;)
    )
    targetPosition = _PositionFactory.parse_position(
        sa_element.find(&#34;TargetPosition&#34;)
    )

    finalSpeed = None
    if sa_element.find(&#34;FinalSpeed&#34;) != None:
        sa_element = sa_element.find(&#34;FinalSpeed&#34;)
        if sa_element.find(&#34;AbsoluteSpeed&#34;) != None:
            finalSpeed = AbsoluteSpeed.parse(sa_element)
        if sa_element.find(&#34;RelativeSpeedToMaster&#34;) != None:
            finalSpeed = RelativeSpeedToMaster.parse(sa_element)

    return SynchronizeAction(
        entity,
        targetPositionMaster,
        targetPosition,
        target_tolerance_master,
        target_tolerance,
        finalSpeed,
    )
    _</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSynchronizeAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteSynchronizeAction as a dict&#34;&#34;&#34;
    attr = {&#34;masterEntityRef&#34;: self.entity}
    if self.isVersion(1, 0):
        return attr
    if self.target_tolerance_master is not None:
        attr.update({&#34;targetToleranceMaster&#34;: str(self.target_tolerance_master)})
    if self.target_tolerance is not None:
        attr.update({&#34;targetTolerance&#34;: str(self.target_tolerance)})
    return attr</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.SynchronizeAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSynchronizeAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteSynchronizeAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    syncaction = ET.SubElement(element, &#34;SynchronizeAction&#34;, self.get_attributes())
    syncaction.append(self.entity_PositionType.get_element(&#34;TargetPositionMaster&#34;))
    syncaction.append(self.target_PositionType.get_element(&#34;TargetPosition&#34;))
    if self.final_speed is not None:
        syncaction.append(self.final_speed.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TeleportAction"><code class="flex name class">
<span>class <span class="ident">TeleportAction</span></span>
<span>(</span><span>position)</span>
</code></dt>
<dd>
<div class="desc"><p>the TeleportAction creates the Teleport action of OpenScenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>position (*Position): any position object
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>position (*Position): any position object
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalizes the TeleportAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>position (*Position): any position object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TeleportAction(_PrivateActionType):
    &#34;&#34;&#34;the TeleportAction creates the Teleport action of OpenScenario

    Parameters
    ----------
        position (*Position): any position object

    Attributes
    ----------
        position (*Position): any position object


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34;initalizes the TeleportAction

        Parameters
        ----------
            position (*Position): any position object

        &#34;&#34;&#34;
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input not a valid Position type&#34;)

        self.position = position

    def __eq__(self, other):
        if isinstance(other, TeleportAction):
            if self.position == other.position:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of WorldPosition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            position (WorldPosition): a world position object

        &#34;&#34;&#34;
        position_element = element.find(&#34;TeleportAction/Position&#34;)

        position = _PositionFactory.parse_position(position_element)
        return TeleportAction(position)

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TeleportAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        telact = ET.SubElement(element, &#34;TeleportAction&#34;)
        telact.append(self.position.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TeleportAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of WorldPosition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>position (WorldPosition): a world position object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of WorldPosition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        position (WorldPosition): a world position object

    &#34;&#34;&#34;
    position_element = element.find(&#34;TeleportAction/Position&#34;)

    position = _PositionFactory.parse_position(position_element)
    return TeleportAction(position)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TeleportAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TeleportAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TeleportAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    telact = ET.SubElement(element, &#34;TeleportAction&#34;)
    telact.append(self.position.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalControllerAction</span></span>
<span>(</span><span>phase, traffic_signalcontroller_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalControllerAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>phase (str): phase of the signal

traffic_signalcontroller_ref (str): reference to traffic signal controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalControllerAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalControllerAction class creates a Infrastructure action which activates a controller of a traffic signal

    Parameters
    ----------
        phase (str): phase of the signal

        traffic_signalcontroller_ref (str): reference to traffic signal controller

    Attributes
    ----------

        phase (str): phase of the signal

        traffic_signalcontroller_ref (str): reference to traffic signal controller

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, phase, traffic_signalcontroller_ref):
        &#34;&#34;&#34;initalize the TrafficSignalControllerAction

        Parameters
        ----------
            phase (str): phase of the signal

            traffic_signalcontroller_ref (str): reference to traffic signal controller

        &#34;&#34;&#34;
        self.phase = phase
        self.traffic_signalcontroller_ref = traffic_signalcontroller_ref

    def __eq__(self, other):
        if isinstance(other, TrafficSignalControllerAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSignalControllerAction element (same as generated by the class itself)

        Returns
        -------
            tsc_action (TrafficSignalControllerAction): a TrafficSignalControllerAction object

        &#34;&#34;&#34;
        isa_element = element.find(&#34;InfrastructureAction&#34;)
        tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
        tsc_element = tsa_element.find(&#34;TrafficSignalControllerAction&#34;)

        phase = tsc_element.attrib[&#34;phase&#34;]
        tsc_ref = tsc_element.attrib[&#34;trafficSignalControllerRef&#34;]

        return TrafficSignalControllerAction(phase, tsc_ref)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerAction as a dict&#34;&#34;&#34;
        return {
            &#34;phase&#34;: self.phase,
            &#34;trafficSignalControllerRef&#34;: self.traffic_signalcontroller_ref,
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(tsa, &#34;TrafficSignalControllerAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSignalControllerAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficSignalControllerAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tsc_action (TrafficSignalControllerAction): a TrafficSignalControllerAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSignalControllerAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficSignalControllerAction element (same as generated by the class itself)

    Returns
    -------
        tsc_action (TrafficSignalControllerAction): a TrafficSignalControllerAction object

    &#34;&#34;&#34;
    isa_element = element.find(&#34;InfrastructureAction&#34;)
    tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
    tsc_element = tsa_element.find(&#34;TrafficSignalControllerAction&#34;)

    phase = tsc_element.attrib[&#34;phase&#34;]
    tsc_ref = tsc_element.attrib[&#34;trafficSignalControllerRef&#34;]

    return TrafficSignalControllerAction(phase, tsc_ref)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalControllerAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalControllerAction as a dict&#34;&#34;&#34;
    return {
        &#34;phase&#34;: self.phase,
        &#34;trafficSignalControllerRef&#34;: self.traffic_signalcontroller_ref,
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalControllerAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSignalControllerAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
    tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
    ET.SubElement(tsa, &#34;TrafficSignalControllerAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction"><code class="flex name class">
<span>class <span class="ident">TrafficSignalStateAction</span></span>
<span>(</span><span>name, state)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSignalStateAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): id of the signal in the road network

state (str): the state to set to the traffic light
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalStateAction(_ActionType):
    &#34;&#34;&#34;The TrafficSignalStateAction class creates a Infrastructure action which controls the state of a traffic signal

    Parameters
    ----------
        name (str): id of the signal in the road network

        state (str): the state to set to the traffic light

    Attributes
    ----------

        name (str): id of the signal in the road network

        state (str): the state to set to the traffic light

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, name, state):
        &#34;&#34;&#34;initalize the TrafficSignalStateAction

        Parameters
        ----------
            name (str): id of the signal in the road network

            state (str): the state to set to the traffic light

        &#34;&#34;&#34;
        self.name = name
        self.state = state

    def __eq__(self, other):
        if isinstance(other, TrafficSignalStateAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalStateAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSignalStateAction element (same as generated by the class itself)

        Returns
        -------
            tss_action (TrafficSignalStateAction): a TrafficSignalStateAction object

        &#34;&#34;&#34;
        isa_element = element.find(&#34;InfrastructureAction&#34;)
        tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
        tss_element = tsa_element.find(&#34;TrafficSignalStateAction&#34;)
        name = tss_element.attrib[&#34;name&#34;]
        state = tss_element.attrib[&#34;state&#34;]
        return TrafficSignalStateAction(name, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalStateAction as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalStateAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
        tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
        ET.SubElement(tsa, &#34;TrafficSignalStateAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSignalStateAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficSignalStateAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tss_action (TrafficSignalStateAction): a TrafficSignalStateAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSignalStateAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficSignalStateAction element (same as generated by the class itself)

    Returns
    -------
        tss_action (TrafficSignalStateAction): a TrafficSignalStateAction object

    &#34;&#34;&#34;
    isa_element = element.find(&#34;InfrastructureAction&#34;)
    tsa_element = isa_element.find(&#34;TrafficSignalAction&#34;)
    tss_element = tsa_element.find(&#34;TrafficSignalStateAction&#34;)
    name = tss_element.attrib[&#34;name&#34;]
    state = tss_element.attrib[&#34;state&#34;]
    return TrafficSignalStateAction(name, state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalStateAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalStateAction as a dict&#34;&#34;&#34;
    return {&#34;name&#34;: self.name, &#34;state&#34;: self.state}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalStateAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSignalStateAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    infra = ET.SubElement(element, &#34;InfrastructureAction&#34;)
    tsa = ET.SubElement(infra, &#34;TrafficSignalAction&#34;)
    ET.SubElement(tsa, &#34;TrafficSignalStateAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction"><code class="flex name class">
<span>class <span class="ident">TrafficSinkAction</span></span>
<span>(</span><span>radius, position, trafficdefinition, rate=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the sink around the position

position (*Position): any Position to define the sink

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSinkAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSinkAction(_ActionType):
    &#34;&#34;&#34;The TrafficSinkAction class creates a TrafficAction of the typ TrafficSinkAction

    Parameters
    ----------
        rate (float): rate of appearing traffic

        radius (float): the radius of the sink around the position

        position (*Position): any Position to define the sink

        trafficdefinition (TrafficDefinition): definition of the traffic

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

    Attributes
    ----------

        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, radius, position, trafficdefinition, rate=None, name=None):
        &#34;&#34;&#34;initalize the TrafficSinkAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficSinkAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
                and self.trafficdefinition == other.trafficdefinition
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSinkAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSinkAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficSinkAction): a TrafficSinkAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = ta_element.find(&#34;TrafficSinkAction&#34;)
        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = None
        if &#34;rate&#34; in tsa_element.attrib:
            rate = convert_float(tsa_element.attrib[&#34;rate&#34;])

        if tsa_element.find(&#34;TrafficDefinition&#34;) != None:
            trafficdefinition = TrafficDefinition.parse(
                tsa_element.find(&#34;TrafficDefinition&#34;)
            )

        position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))

        return TrafficSinkAction(radius, position, trafficdefinition, rate, name)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSinkAction as a dict&#34;&#34;&#34;
        retdict = {}

        retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSinkAction&#34;&#34;&#34;

        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
        sinkaction = ET.SubElement(
            trafficaction, &#34;TrafficSinkAction&#34;, attrib=self.get_attributes()
        )
        sinkaction.append(self.position.get_element())
        sinkaction.append(self.trafficdefinition.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSinkAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficSinkAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ts_action (TrafficSinkAction): a TrafficSinkAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSinkAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficSinkAction element (same as generated by the class itself)

    Returns
    -------
        ts_action (TrafficSinkAction): a TrafficSinkAction object

    &#34;&#34;&#34;
    ta_element = element.find(&#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]

    tsa_element = ta_element.find(&#34;TrafficSinkAction&#34;)
    radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
    rate = None
    if &#34;rate&#34; in tsa_element.attrib:
        rate = convert_float(tsa_element.attrib[&#34;rate&#34;])

    if tsa_element.find(&#34;TrafficDefinition&#34;) != None:
        trafficdefinition = TrafficDefinition.parse(
            tsa_element.find(&#34;TrafficDefinition&#34;)
        )

    position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))

    return TrafficSinkAction(radius, position, trafficdefinition, rate, name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSinkAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSinkAction as a dict&#34;&#34;&#34;
    retdict = {}

    retdict[&#34;rate&#34;] = str(self.rate)
    retdict[&#34;radius&#34;] = str(self.radius)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSinkAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSinkAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSinkAction&#34;&#34;&#34;

    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}
    trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
    sinkaction = ET.SubElement(
        trafficaction, &#34;TrafficSinkAction&#34;, attrib=self.get_attributes()
    )
    sinkaction.append(self.position.get_element())
    sinkaction.append(self.trafficdefinition.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction"><code class="flex name class">
<span>class <span class="ident">TrafficSourceAction</span></span>
<span>(</span><span>rate, radius, position, trafficdefinition, velocity=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSourceAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rate (float): rate of appearing traffic

radius (float): the radius of the source around the position

position (*Position): any Position to define the source

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity of the traffic
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSourceAction(_ActionType):
    &#34;&#34;&#34;The TrafficSourceAction class creates a TrafficAction of the typ TrafficSourceAction

    Parameters
    ----------
        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity of the traffic
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

    Attributes
    ----------

        rate (float): rate of appearing traffic

        radius (float): the radius of the source around the position

        position (*Position): any Position to define the source

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity of the traffic
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self, rate, radius, position, trafficdefinition, velocity=None, name=None
    ):
        &#34;&#34;&#34;initalize the TrafficSourceAction

        Parameters
        ----------
            rate (float): rate of appearing traffic

            radius (float): the radius of the source around the position

            position (*Position): any Position to define the source

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity of the traffic
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None
        &#34;&#34;&#34;
        self.rate = convert_float(rate)
        self.radius = convert_float(radius)
        if not isinstance(position, _PositionType):
            raise TypeError(&#34;position input is not a valid Position&#34;)

        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.position = position
        self.trafficdefinition = trafficdefinition
        self.velocity = convert_float(velocity)
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficSourceAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.position == other.position
                and self.trafficdefinition == other.trafficdefinition
                and self.name == other.name
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSourceAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSourceAction element (same as generated by the class itself)

        Returns
        -------
            tsa_action (TrafficSourceAction): a TrafficSourceAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]
        tsa_element = ta_element.find(&#34;TrafficSourceAction&#34;)

        radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
        rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif &#34;speed&#34; in tsa_element.attrib:
            velocity = tsa_element.attrib[&#34;speed&#34;]
        position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))
        trafficdefinition = TrafficDefinition.parse(
            tsa_element.find(&#34;TrafficDefinition&#34;)
        )

        return TrafficSourceAction(
            rate, radius, position, trafficdefinition, velocity, name
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSourceAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;rate&#34;] = str(self.rate)
        retdict[&#34;radius&#34;] = str(self.radius)
        if self.velocity is not None:
            if self.version_minor &lt; 2:
                retdict[&#34;velocity&#34;] = str(self.velocity)
            else:
                retdict[&#34;speed&#34;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSourceAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}

        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
        sourceaction = ET.SubElement(
            trafficaction, &#34;TrafficSourceAction&#34;, attrib=self.get_attributes()
        )
        sourceaction.append(self.position.get_element())
        sourceaction.append(self.trafficdefinition.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSourceAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficSourceAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tsa_action (TrafficSourceAction): a TrafficSourceAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSourceAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficSourceAction element (same as generated by the class itself)

    Returns
    -------
        tsa_action (TrafficSourceAction): a TrafficSourceAction object

    &#34;&#34;&#34;
    ta_element = element.find(&#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]
    tsa_element = ta_element.find(&#34;TrafficSourceAction&#34;)

    radius = convert_float(tsa_element.attrib[&#34;radius&#34;])
    rate = convert_float(tsa_element.attrib[&#34;rate&#34;])
    velocity = None
    if &#34;velocity&#34; in tsa_element.attrib:
        velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
    elif &#34;speed&#34; in tsa_element.attrib:
        velocity = tsa_element.attrib[&#34;speed&#34;]
    position = _PositionFactory.parse_position(tsa_element.find(&#34;Position&#34;))
    trafficdefinition = TrafficDefinition.parse(
        tsa_element.find(&#34;TrafficDefinition&#34;)
    )

    return TrafficSourceAction(
        rate, radius, position, trafficdefinition, velocity, name
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSourceAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSourceAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;rate&#34;] = str(self.rate)
    retdict[&#34;radius&#34;] = str(self.radius)
    if self.velocity is not None:
        if self.version_minor &lt; 2:
            retdict[&#34;velocity&#34;] = str(self.velocity)
        else:
            retdict[&#34;speed&#34;] = str(self.velocity)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSourceAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSourceAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSourceAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}

    trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)
    sourceaction = ET.SubElement(
        trafficaction, &#34;TrafficSourceAction&#34;, attrib=self.get_attributes()
    )
    sourceaction.append(self.position.get_element())
    sourceaction.append(self.trafficdefinition.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction"><code class="flex name class">
<span>class <span class="ident">TrafficStopAction</span></span>
<span>(</span><span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the Traffic to stop
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the Traffic to stop
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSwarmAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the Traffic to stop
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficStopAction(_ActionType):
    &#34;&#34;&#34;The TrafficStopAction class creates a TrafficAction of the typ TrafficStopAction

    Parameters
    ----------
        name (str): name of the Traffic to stop
            Default: None

    Attributes
    ----------

        name (str): name of the Traffic to stop

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, name=None):
        &#34;&#34;&#34;initalize the TrafficSwarmAction

        Parameters
        ----------
            name (str): name of the Traffic to stop
                Default: None
        &#34;&#34;&#34;
        self.name = name

    def __eq__(self, other):
        if isinstance(other, TrafficStopAction):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficStopAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficStopAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficStopAction): a TrafficStopAction object

        &#34;&#34;&#34;
        trafficaction_element = element.find(&#34;TrafficAction&#34;)
        name = trafficaction_element.attrib[&#34;trafficName&#34;]
        return TrafficStopAction(name)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficStopAction as a dict&#34;&#34;&#34;
        retdict = {}
        if self.name and not self.isVersion(minor=0):
            retdict[&#34;trafficName&#34;] = str(self.name)
        elif self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;TrafficStopAction was introduced in OpenSCENARIO V1.1&#34;
            )

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficStopAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        trafficaction = ET.SubElement(
            element, &#34;TrafficAction&#34;, attrib=self.get_attributes()
        )
        ET.SubElement(trafficaction, &#34;TrafficStopAction&#34;)

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficStopAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficStopAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ts_action (TrafficStopAction): a TrafficStopAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficStopAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficStopAction element (same as generated by the class itself)

    Returns
    -------
        ts_action (TrafficStopAction): a TrafficStopAction object

    &#34;&#34;&#34;
    trafficaction_element = element.find(&#34;TrafficAction&#34;)
    name = trafficaction_element.attrib[&#34;trafficName&#34;]
    return TrafficStopAction(name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficStopAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficStopAction as a dict&#34;&#34;&#34;
    retdict = {}
    if self.name and not self.isVersion(minor=0):
        retdict[&#34;trafficName&#34;] = str(self.name)
    elif self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;TrafficStopAction was introduced in OpenSCENARIO V1.1&#34;
        )

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficStopAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficStopAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficStopAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    trafficaction = ET.SubElement(
        element, &#34;TrafficAction&#34;, attrib=self.get_attributes()
    )
    ET.SubElement(trafficaction, &#34;TrafficStopAction&#34;)

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction"><code class="flex name class">
<span>class <span class="ident">TrafficSwarmAction</span></span>
<span>(</span><span>semimajoraxis, semiminoraxis, innerradius, offset, numberofvehicles, centralobject, trafficdefinition, velocity=None, name=None, direction_of_travel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner circle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float or Range): optional starting velocity (range is replacing velocity in OSC V1.2)
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None

direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner cirvle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TrafficSwarmAction</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>semimajoraxis (float): half length of major axis of ellipsis around target

semiminoraxis (float): half length of minor axis of ellipsis around target

innerradius (float): radius of inner circle

offset (float): longitudinal offset from central entity

numberofvehicles (int): maximum number of vehicles around entity

centralobject (str): entity to swarm around

trafficdefinition (TrafficDefinition): definition of the traffic

velocity (float): optional starting velocity
    Default: None

name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
    Default: None

direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSwarmAction(_ActionType):
    &#34;&#34;&#34;The TrafficSwarmAction class creates a TrafficAction of the typ TrafficSwarmAction

    Parameters
    ----------
        semimajoraxis (float): half length of major axis of ellipsis around target

        semiminoraxis (float): half length of minor axis of ellipsis around target

        innerradius (float): radius of inner circle

        offset (float): longitudinal offset from central entity

        numberofvehicles (int): maximum number of vehicles around entity

        centralobject (str): entity to swarm around

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float or Range): optional starting velocity (range is replacing velocity in OSC V1.2)
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
            Default: None

        direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
            Default: None

    Attributes
    ----------

        semimajoraxis (float): half length of major axis of ellipsis around target

        semiminoraxis (float): half length of minor axis of ellipsis around target

        innerradius (float): radius of inner cirvle

        offset (float): longitudinal offset from central entity

        numberofvehicles (int): maximum number of vehicles around entity

        centralobject (str): entity to swarm around

        trafficdefinition (TrafficDefinition): definition of the traffic

        velocity (float): optional starting velocity
            Default: None

        name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)

        direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(
        self,
        semimajoraxis,
        semiminoraxis,
        innerradius,
        offset,
        numberofvehicles,
        centralobject,
        trafficdefinition,
        velocity=None,
        name=None,
        direction_of_travel=None,
    ):
        &#34;&#34;&#34;initalize the TrafficSwarmAction

        Parameters
        ----------
            semimajoraxis (float): half length of major axis of ellipsis around target

            semiminoraxis (float): half length of minor axis of ellipsis around target

            innerradius (float): radius of inner circle

            offset (float): longitudinal offset from central entity

            numberofvehicles (int): maximum number of vehicles around entity

            centralobject (str): entity to swarm around

            trafficdefinition (TrafficDefinition): definition of the traffic

            velocity (float): optional starting velocity
                Default: None

            name (str): name of the TrafficAction, can be used to stop the TrafficAction, (valid from V1.1)
                Default: None

            direction_of_travel (DirectionOfTravelDistribution): adds the DirectionOfTravelDistribution to the action(valid from OSC V1.2)
                Default: None
        &#34;&#34;&#34;
        self.semimajoraxis = convert_float(semimajoraxis)
        self.semiminoraxis = convert_float(semiminoraxis)
        self.innerradius = convert_float(innerradius)
        self.offset = convert_float(offset)
        self.numberofvehicles = convert_int(numberofvehicles)
        self.centralobject = centralobject
        if not isinstance(trafficdefinition, TrafficDefinition):
            raise TypeError(&#34;trafficdefinition input is not of type TrafficDefinition&#34;)
        self.trafficdefinition = trafficdefinition
        if velocity is not None:
            if isinstance(velocity, Range):
                self.velocity = velocity
            else:
                self.velocity = convert_float(velocity)
        else:
            self.velocity = None
        self.name = name
        if direction_of_travel is not None and not isinstance(
            direction_of_travel, DirectionOfTravelDistribution
        ):
            raise TypeError(
                &#34;direction_of_travel is not of type DirectionOfTravelDistribution&#34;
            )
        self.direction_of_travel = direction_of_travel

    def __eq__(self, other):
        if isinstance(other, TrafficSwarmAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.centralobject == other.centralobject
                and self.trafficdefinition == other.trafficdefinition
                and self.name == other.name
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSwarmAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TrafficSwarmAction element (same as generated by the class itself)

        Returns
        -------
            ts_action (TrafficSwarmAction): a TrafficSwarmAction object

        &#34;&#34;&#34;
        ta_element = element.find(&#34;TrafficAction&#34;)
        name = None
        if &#34;trafficName&#34; in ta_element.attrib:
            name = ta_element.attrib[&#34;trafficName&#34;]

        tsa_element = ta_element.find(&#34;TrafficSwarmAction&#34;)

        innerradius = convert_float(tsa_element.attrib[&#34;innerRadius&#34;])
        numberofvehicles = convert_int(tsa_element.attrib[&#34;numberOfVehicles&#34;])
        offset = convert_float(tsa_element.attrib[&#34;offset&#34;])
        semimajoraxis = convert_float(tsa_element.attrib[&#34;semiMajorAxis&#34;])
        semiminoraxis = convert_float(tsa_element.attrib[&#34;semiMinorAxis&#34;])
        velocity = None
        if &#34;velocity&#34; in tsa_element.attrib:
            velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
        elif tsa_element.find(&#34;InitalSpeedRange&#34;) is not None:
            velocity = Range.parse(tsa_element.find(&#34;InitalSpeedRange&#34;))

        trafficdefinition = TrafficDefinition.parse(
            tsa_element.find(&#34;TrafficDefinition&#34;)
        )
        dot = None
        if tsa_element.find(&#34;DirectionOfTravelDistribution&#34;):
            dot = DirectionOfTravelDistribution.parse(
                tsa_element.find(&#34;DirectionOfTravelDistribution&#34;)
            )
        central_element = tsa_element.find(&#34;CentralObject&#34;)
        centralobject = central_element.attrib[&#34;entityRef&#34;]

        tsa_object = TrafficSwarmAction(
            semimajoraxis,
            semiminoraxis,
            innerradius,
            offset,
            numberofvehicles,
            centralobject,
            trafficdefinition,
            velocity,
            name,
            dot,
        )
        return tsa_object

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSwarmAction as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;semiMajorAxis&#34;] = str(self.semimajoraxis)
        retdict[&#34;semiMinorAxis&#34;] = str(self.semiminoraxis)
        retdict[&#34;innerRadius&#34;] = str(self.innerradius)
        retdict[&#34;offset&#34;] = str(self.offset)
        retdict[&#34;numberOfVehicles&#34;] = str(self.numberofvehicles)
        if self.velocity is not None and not isinstance(self.velocity, Range):
            retdict[&#34;velocity&#34;] = str(self.velocity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSwarmAction&#34;&#34;&#34;
        element = ET.Element(&#34;GlobalAction&#34;)
        traffic_attrib = {}
        if self.name and not self.isVersion(minor=0):
            traffic_attrib = {&#34;trafficName&#34;: self.name}
        trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)

        swarmaction = ET.SubElement(
            trafficaction, &#34;TrafficSwarmAction&#34;, attrib=self.get_attributes()
        )
        swarmaction.append(self.trafficdefinition.get_element())
        ET.SubElement(
            swarmaction, &#34;CentralObject&#34;, attrib={&#34;entityRef&#34;: self.centralobject}
        )
        if self.velocity is not None:
            if self.version_minor &gt; 1:
                if isinstance(self.velocity, Range):
                    swarmaction.append(self.velocity.get_element(&#34;InitialSpeedRange&#34;))
                else:
                    raise OpenSCENARIOVersionError(
                        &#34;Range for TrafficSwarmAction was introduced in OSC V1.2, velocity should not be used anymore.&#34;
                    )

        if self.direction_of_travel is not None:
            if self.version_minor &lt; 2:
                raise OpenSCENARIOVersionError(
                    &#34;DirectionOfTravelDistribution was added in OSC V1.2&#34;
                )
            swarmaction.append(self.direction_of_travel.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSwarmAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TrafficSwarmAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ts_action (TrafficSwarmAction): a TrafficSwarmAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSwarmAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TrafficSwarmAction element (same as generated by the class itself)

    Returns
    -------
        ts_action (TrafficSwarmAction): a TrafficSwarmAction object

    &#34;&#34;&#34;
    ta_element = element.find(&#34;TrafficAction&#34;)
    name = None
    if &#34;trafficName&#34; in ta_element.attrib:
        name = ta_element.attrib[&#34;trafficName&#34;]

    tsa_element = ta_element.find(&#34;TrafficSwarmAction&#34;)

    innerradius = convert_float(tsa_element.attrib[&#34;innerRadius&#34;])
    numberofvehicles = convert_int(tsa_element.attrib[&#34;numberOfVehicles&#34;])
    offset = convert_float(tsa_element.attrib[&#34;offset&#34;])
    semimajoraxis = convert_float(tsa_element.attrib[&#34;semiMajorAxis&#34;])
    semiminoraxis = convert_float(tsa_element.attrib[&#34;semiMinorAxis&#34;])
    velocity = None
    if &#34;velocity&#34; in tsa_element.attrib:
        velocity = convert_float(tsa_element.attrib[&#34;velocity&#34;])
    elif tsa_element.find(&#34;InitalSpeedRange&#34;) is not None:
        velocity = Range.parse(tsa_element.find(&#34;InitalSpeedRange&#34;))

    trafficdefinition = TrafficDefinition.parse(
        tsa_element.find(&#34;TrafficDefinition&#34;)
    )
    dot = None
    if tsa_element.find(&#34;DirectionOfTravelDistribution&#34;):
        dot = DirectionOfTravelDistribution.parse(
            tsa_element.find(&#34;DirectionOfTravelDistribution&#34;)
        )
    central_element = tsa_element.find(&#34;CentralObject&#34;)
    centralobject = central_element.attrib[&#34;entityRef&#34;]

    tsa_object = TrafficSwarmAction(
        semimajoraxis,
        semiminoraxis,
        innerradius,
        offset,
        numberofvehicles,
        centralobject,
        trafficdefinition,
        velocity,
        name,
        dot,
    )
    return tsa_object</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSwarmAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSwarmAction as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;semiMajorAxis&#34;] = str(self.semimajoraxis)
    retdict[&#34;semiMinorAxis&#34;] = str(self.semiminoraxis)
    retdict[&#34;innerRadius&#34;] = str(self.innerradius)
    retdict[&#34;offset&#34;] = str(self.offset)
    retdict[&#34;numberOfVehicles&#34;] = str(self.numberofvehicles)
    if self.velocity is not None and not isinstance(self.velocity, Range):
        retdict[&#34;velocity&#34;] = str(self.velocity)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSwarmAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSwarmAction&#34;&#34;&#34;
    element = ET.Element(&#34;GlobalAction&#34;)
    traffic_attrib = {}
    if self.name and not self.isVersion(minor=0):
        traffic_attrib = {&#34;trafficName&#34;: self.name}
    trafficaction = ET.SubElement(element, &#34;TrafficAction&#34;, attrib=traffic_attrib)

    swarmaction = ET.SubElement(
        trafficaction, &#34;TrafficSwarmAction&#34;, attrib=self.get_attributes()
    )
    swarmaction.append(self.trafficdefinition.get_element())
    ET.SubElement(
        swarmaction, &#34;CentralObject&#34;, attrib={&#34;entityRef&#34;: self.centralobject}
    )
    if self.velocity is not None:
        if self.version_minor &gt; 1:
            if isinstance(self.velocity, Range):
                swarmaction.append(self.velocity.get_element(&#34;InitialSpeedRange&#34;))
            else:
                raise OpenSCENARIOVersionError(
                    &#34;Range for TrafficSwarmAction was introduced in OSC V1.2, velocity should not be used anymore.&#34;
                )

    if self.direction_of_travel is not None:
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;DirectionOfTravelDistribution was added in OSC V1.2&#34;
            )
        swarmaction.append(self.direction_of_travel.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction"><code class="flex name class">
<span>class <span class="ident">UserDefinedAction</span></span>
<span>(</span><span>custom_command_action)</span>
</code></dt>
<dd>
<div class="desc"><p>The UserDefinedAction enables adding simulator-specific CustomCommandActions.</p>
<h2 id="parameters">Parameters</h2>
<h2 id="attributes">Attributes</h2>
<h2 id="methods">Methods</h2>
<pre><code>add_custom_command_action(custom_command_action)
    Adds a CustomCommandAction to the UserDefinedAction

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the UserDefinedAction</p>
<h2 id="parameters_1">Parameters</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedAction(_ActionType):
    &#34;&#34;&#34;The UserDefinedAction enables adding simulator-specific CustomCommandActions.

    Parameters
    ----------

    Attributes
    ----------

    Methods
    -------
        add_custom_command_action(custom_command_action)
            Adds a CustomCommandAction to the UserDefinedAction

        get_element()
            Returns the full ElementTree of the class
    &#34;&#34;&#34;

    def __init__(self, custom_command_action):
        &#34;&#34;&#34;initalize the UserDefinedAction

        Parameters
        ----------

        &#34;&#34;&#34;
        self.custom_command_action = custom_command_action

    def __eq__(self, other):
        if isinstance(other, UserDefinedAction):
            if self.custom_command_action == other.custom_command_action:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parsese the xml element of a UserDefinedAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedAction element

        Returns
        -------
            userDefinedAction (UserDefinedAction): a UserDefinedAction object

        &#34;&#34;&#34;
        custom_command_action = CustomCommandAction.parse(
            element.find(&#34;CustomCommandAction&#34;)
        )
        user_defined_action = UserDefinedAction(custom_command_action)
        return user_defined_action

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedAction&#34;&#34;&#34;
        element = ET.Element(&#34;UserDefinedAction&#34;)
        element.append(self.custom_command_action.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parsese the xml element of a UserDefinedAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a UserDefinedAction element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>userDefinedAction (UserDefinedAction): a UserDefinedAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parsese the xml element of a UserDefinedAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a UserDefinedAction element

    Returns
    -------
        userDefinedAction (UserDefinedAction): a UserDefinedAction object

    &#34;&#34;&#34;
    custom_command_action = CustomCommandAction.parse(
        element.find(&#34;CustomCommandAction&#34;)
    )
    user_defined_action = UserDefinedAction(custom_command_action)
    return user_defined_action</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.UserDefinedAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the UserDefinedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the UserDefinedAction&#34;&#34;&#34;
    element = ET.Element(&#34;UserDefinedAction&#34;)
    element.append(self.custom_command_action.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableAddAction"><code class="flex name class">
<span>class <span class="ident">VariableAddAction</span></span>
<span>(</span><span>variable_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The VariableAddAction class creates a VariableAction of type VariableModifyAction which adds a value to an existing Variable
(valid from V1.2)
Parameters</p>
<hr>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be added to the variable
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be added to the variable
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the VariableAddAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be added to the variable
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableAddAction(_ActionType):
    &#34;&#34;&#34;The VariableAddAction class creates a VariableAction of type VariableModifyAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be added to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be added to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableAddAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableAddAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableAddAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableAddAction element (same as generated by the class itself)

        Returns
        -------
            paa_action (VariableAddAction): a VariableAddAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;AddValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableAddAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of VariableAddAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A VariableAddAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>paa_action (VariableAddAction): a VariableAddAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of VariableAddAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A VariableAddAction element (same as generated by the class itself)

    Returns
    -------
        paa_action (VariableAddAction): a VariableAddAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]

    ma_element = pa_element.find(&#34;ModifyAction&#34;)
    rule_element = ma_element.find(&#34;Rule&#34;)
    mbv_element = rule_element.find(&#34;AddValue&#34;)
    value = mbv_element.attrib[&#34;value&#34;]

    return VariableAddAction(variableRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSpeedAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteSpeedAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableAddAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeedAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeedAction&#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;AddValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction"><code class="flex name class">
<span>class <span class="ident">VariableMultiplyAction</span></span>
<span>(</span><span>variable_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The VariableMultiplyAction class creates a VariableAction of tyoe VariableModifyAction which adds a value to an existing Variable
(valid from V1.2)
Parameters</p>
<hr>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be multiplied to the variable
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be multiplied to the variable
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the VariableMultiplyAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be added to the variable
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableMultiplyAction(_ActionType):
    &#34;&#34;&#34;The VariableMultiplyAction class creates a VariableAction of tyoe VariableModifyAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be multiplied to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be multiplied to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableMultiplyAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableMultiplyAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableMultiplyAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableMultiplyAction element (same as generated by the class itself)

        Returns
        -------
            pma_action (VariableMultiplyAction): a VariableMultiplyAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]

        ma_element = pa_element.find(&#34;ModifyAction&#34;)
        rule_element = ma_element.find(&#34;Rule&#34;)
        mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
        value = mbv_element.attrib[&#34;value&#34;]

        return VariableMultiplyAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VariableMultiplyAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VariableMultiplyAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
        rule = ET.SubElement(modifaction, &#34;Rule&#34;)
        ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of VariableMultiplyAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A VariableMultiplyAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>pma_action (VariableMultiplyAction): a VariableMultiplyAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of VariableMultiplyAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A VariableMultiplyAction element (same as generated by the class itself)

    Returns
    -------
        pma_action (VariableMultiplyAction): a VariableMultiplyAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]

    ma_element = pa_element.find(&#34;ModifyAction&#34;)
    rule_element = ma_element.find(&#34;Rule&#34;)
    mbv_element = rule_element.find(&#34;MultiplyByValue&#34;)
    value = mbv_element.attrib[&#34;value&#34;]

    return VariableMultiplyAction(variableRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the VariableMultiplyAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the VariableMultiplyAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableMultiplyAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the VariableMultiplyAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the VariableMultiplyAction&#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    modifaction = ET.SubElement(paramaction, &#34;ModifyAction&#34;)
    rule = ET.SubElement(modifaction, &#34;Rule&#34;)
    ET.SubElement(rule, &#34;MultiplyByValue&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableSetAction"><code class="flex name class">
<span>class <span class="ident">VariableSetAction</span></span>
<span>(</span><span>variable_ref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>The VariableSetAction class creates a VariableAction which adds a value to an existing Variable
(valid from V1.2)
Parameters</p>
<hr>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be set to the variable
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be set to the variable
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the VariableSetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>variable_ref (str): name of the variable

value (float): the value that should be added to the variable
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableSetAction(_ActionType):
    &#34;&#34;&#34;The VariableSetAction class creates a VariableAction which adds a value to an existing Variable
        (valid from V1.2)
    Parameters
    ----------
        variable_ref (str): name of the variable

        value (float): the value that should be set to the variable

    Attributes
    ----------

        variable_ref (str): name of the variable

        value (float): the value that should be set to the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, variable_ref, value):
        &#34;&#34;&#34;initalize the VariableSetAction

        Parameters
        ----------
            variable_ref (str): name of the variable

            value (float): the value that should be added to the variable

        &#34;&#34;&#34;
        self.variable_ref = variable_ref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, VariableSetAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.variable_ref == other.variable_ref
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableSetAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableSetAction element (same as generated by the class itself)

        Returns
        -------
            psa_action (VariableSetAction): a VariableSetAction object

        &#34;&#34;&#34;
        pa_element = element.find(&#34;VariableAction&#34;)
        variableRef = pa_element.attrib[&#34;variableRef&#34;]
        psa_element = pa_element.find(&#34;SetAction&#34;)
        value = psa_element.attrib[&#34;value&#34;]
        return VariableSetAction(variableRef, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VariableSetAction as a dict&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VariableSetAction&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
        element = ET.Element(&#34;GlobalAction&#34;)
        paramaction = ET.SubElement(
            element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
        )
        ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of VariableSetAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A VariableSetAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>psa_action (VariableSetAction): a VariableSetAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of VariableSetAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A VariableSetAction element (same as generated by the class itself)

    Returns
    -------
        psa_action (VariableSetAction): a VariableSetAction object

    &#34;&#34;&#34;
    pa_element = element.find(&#34;VariableAction&#34;)
    variableRef = pa_element.attrib[&#34;variableRef&#34;]
    psa_element = pa_element.find(&#34;SetAction&#34;)
    value = psa_element.attrib[&#34;value&#34;]
    return VariableSetAction(variableRef, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the VariableSetAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the VariableSetAction as a dict&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VariableSetAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the VariableSetAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the VariableSetAction&#34;&#34;&#34;
    if self.version_minor &lt; 2:
        raise OpenSCENARIOVersionError(&#34;VariableActions were added in OSC 1.2&#34;)
    element = ET.Element(&#34;GlobalAction&#34;)
    paramaction = ET.SubElement(
        element, &#34;VariableAction&#34;, {&#34;variableRef&#34;: self.variable_ref}
    )
    ET.SubElement(paramaction, &#34;SetAction&#34;, self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction"><code class="flex name class">
<span>class <span class="ident">VisibilityAction</span></span>
<span>(</span><span>graphics, traffic, sensors)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a VisibilityAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>graphics (boolean): visible for graphics or not

traffic (boolean): visible for traffic

sensors (boolean): visible to sensors or not
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>graphics (boolean): visible for graphics or not

traffic (boolean): visible for traffic

sensors (boolean): visible to sensors or not

sensor_refs (list of str): all sensor references
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the the attributes of the class
</code></pre>
<p>initalizes the VisibilityAction</p>
<h2 id="parameters_1">Parameters</h2>
<p>graphics (boolean): visible for graphics or not</p>
<p>traffic (boolean): visible for traffic</p>
<p>sensors (boolean): visible to sensors or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisibilityAction(_PrivateActionType):
    &#34;&#34;&#34;creates a VisibilityAction

    Parameters
    ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

    Attributes
    ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

        sensor_refs (list of str): all sensor references

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the the attributes of the class

    &#34;&#34;&#34;

    def __init__(self, graphics, traffic, sensors):
        &#34;&#34;&#34;initalizes the VisibilityAction

        Parameters
        ----------
        graphics (boolean): visible for graphics or not

        traffic (boolean): visible for traffic

        sensors (boolean): visible to sensors or not

        &#34;&#34;&#34;
        self.graphics = convert_bool(graphics)
        self.traffic = convert_bool(traffic)
        self.sensors = convert_bool(sensors)
        self.sensor_refs = []

    def __eq__(self, other):
        if isinstance(other, VisibilityAction):
            if (
                self.get_attributes() == other.get_attributes()
                and self.sensor_refs == other.sensor_refs
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VisibilityAction

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VisibilityAction element (same as generated by the class itself)

        Returns
        -------
            v_action (VisibilityAction): a VisibilityAction object

        &#34;&#34;&#34;
        va_element = element.find(&#34;VisibilityAction&#34;)
        graphics = convert_bool(va_element.attrib[&#34;graphics&#34;])
        traffic = convert_bool(va_element.attrib[&#34;traffic&#34;])
        sensors = convert_bool(va_element.attrib[&#34;sensors&#34;])
        visibility_action = VisibilityAction(graphics, traffic, sensors)
        sensor_ref_element = va_element.find(&#34;SensorReferenceSet&#34;)
        if sensor_ref_element is not None:
            for sensor_element in sensor_ref_element.findall(&#34;SensorReference&#34;):
                visibility_action.add_sensor_reference(sensor_element.attrib[&#34;name&#34;])
        return visibility_action

    def add_sensor_reference(self, sensor_ref):
        &#34;&#34;&#34;adds a sensor reference to the visibility action (Valid since OSC V1.2)

        Parameters
        ----------
            sensor_ref (str): name of a sensor
        &#34;&#34;&#34;
        self.sensor_refs.append(sensor_ref)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the VisibilityAction as a dict&#34;&#34;&#34;
        return {
            &#34;graphics&#34;: get_bool_string(self.graphics),
            &#34;traffic&#34;: get_bool_string(self.traffic),
            &#34;sensors&#34;: get_bool_string(self.sensors),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VisibilityAction&#34;&#34;&#34;
        element = ET.Element(&#34;PrivateAction&#34;)
        visibility_element = ET.SubElement(
            element, &#34;VisibilityAction&#34;, self.get_attributes()
        )
        if self.sensor_refs:
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(&#34;SensorReference was added in OSC V1.2&#34;)
            sensor_ref_element = ET.SubElement(visibility_element, &#34;SensorReferenceSet&#34;)
            for sensor in self.sensor_refs:
                ET.SubElement(
                    sensor_ref_element, &#34;SensorReference&#34;, {&#34;name&#34;: str(sensor)}
                )
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.actions._PrivateActionType</li>
<li>scenariogeneration.xosc.actions._ActionType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of VisibilityAction</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A VisibilityAction element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>v_action (VisibilityAction): a VisibilityAction object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of VisibilityAction

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A VisibilityAction element (same as generated by the class itself)

    Returns
    -------
        v_action (VisibilityAction): a VisibilityAction object

    &#34;&#34;&#34;
    va_element = element.find(&#34;VisibilityAction&#34;)
    graphics = convert_bool(va_element.attrib[&#34;graphics&#34;])
    traffic = convert_bool(va_element.attrib[&#34;traffic&#34;])
    sensors = convert_bool(va_element.attrib[&#34;sensors&#34;])
    visibility_action = VisibilityAction(graphics, traffic, sensors)
    sensor_ref_element = va_element.find(&#34;SensorReferenceSet&#34;)
    if sensor_ref_element is not None:
        for sensor_element in sensor_ref_element.findall(&#34;SensorReference&#34;):
            visibility_action.add_sensor_reference(sensor_element.attrib[&#34;name&#34;])
    return visibility_action</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference"><code class="name flex">
<span>def <span class="ident">add_sensor_reference</span></span>(<span>self, sensor_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a sensor reference to the visibility action (Valid since OSC V1.2)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>sensor_ref (str): name of a sensor
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sensor_reference(self, sensor_ref):
    &#34;&#34;&#34;adds a sensor reference to the visibility action (Valid since OSC V1.2)

    Parameters
    ----------
        sensor_ref (str): name of a sensor
    &#34;&#34;&#34;
    self.sensor_refs.append(sensor_ref)
    return self</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the VisibilityAction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the VisibilityAction as a dict&#34;&#34;&#34;
    return {
        &#34;graphics&#34;: get_bool_string(self.graphics),
        &#34;traffic&#34;: get_bool_string(self.traffic),
        &#34;sensors&#34;: get_bool_string(self.sensors),
    }</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.actions.VisibilityAction.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the VisibilityAction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the VisibilityAction&#34;&#34;&#34;
    element = ET.Element(&#34;PrivateAction&#34;)
    visibility_element = ET.SubElement(
        element, &#34;VisibilityAction&#34;, self.get_attributes()
    )
    if self.sensor_refs:
        if self.isVersionEqLess(minor=1):
            raise OpenSCENARIOVersionError(&#34;SensorReference was added in OSC V1.2&#34;)
        sensor_ref_element = ET.SubElement(visibility_element, &#34;SensorReferenceSet&#34;)
        for sensor in self.sensor_refs:
            ET.SubElement(
                sensor_ref_element, &#34;SensorReference&#34;, {&#34;name&#34;: str(sensor)}
            )
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction">AbsoluteLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteLaneChangeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction">AbsoluteLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteLaneOffsetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction">AbsoluteSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse" href="#scenariogeneration.xosc.actions.AbsoluteSpeedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction" href="#scenariogeneration.xosc.actions.AcquirePositionAction">AcquirePositionAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction.get_element" href="#scenariogeneration.xosc.actions.AcquirePositionAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AcquirePositionAction.parse" href="#scenariogeneration.xosc.actions.AcquirePositionAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction" href="#scenariogeneration.xosc.actions.ActivateControllerAction">ActivateControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.get_element" href="#scenariogeneration.xosc.actions.ActivateControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ActivateControllerAction.parse" href="#scenariogeneration.xosc.actions.ActivateControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AddEntityAction" href="#scenariogeneration.xosc.actions.AddEntityAction">AddEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.AddEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.get_element" href="#scenariogeneration.xosc.actions.AddEntityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AddEntityAction.parse" href="#scenariogeneration.xosc.actions.AddEntityAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AnimationAction" href="#scenariogeneration.xosc.actions.AnimationAction">AnimationAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.get_attributes" href="#scenariogeneration.xosc.actions.AnimationAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.get_element" href="#scenariogeneration.xosc.actions.AnimationAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AnimationAction.parse" href="#scenariogeneration.xosc.actions.AnimationAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignControllerAction" href="#scenariogeneration.xosc.actions.AssignControllerAction">AssignControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.get_element" href="#scenariogeneration.xosc.actions.AssignControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignControllerAction.parse" href="#scenariogeneration.xosc.actions.AssignControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.AssignRouteAction" href="#scenariogeneration.xosc.actions.AssignRouteAction">AssignRouteAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.AssignRouteAction.get_element" href="#scenariogeneration.xosc.actions.AssignRouteAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.AssignRouteAction.parse" href="#scenariogeneration.xosc.actions.AssignRouteAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ControllerAction" href="#scenariogeneration.xosc.actions.ControllerAction">ControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ControllerAction.get_element" href="#scenariogeneration.xosc.actions.ControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ControllerAction.parse" href="#scenariogeneration.xosc.actions.ControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.CustomCommandAction" href="#scenariogeneration.xosc.actions.CustomCommandAction">CustomCommandAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.get_element" href="#scenariogeneration.xosc.actions.CustomCommandAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.CustomCommandAction.parse" href="#scenariogeneration.xosc.actions.CustomCommandAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction" href="#scenariogeneration.xosc.actions.DeleteEntityAction">DeleteEntityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.get_element" href="#scenariogeneration.xosc.actions.DeleteEntityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.DeleteEntityAction.parse" href="#scenariogeneration.xosc.actions.DeleteEntityAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.EnvironmentAction" href="#scenariogeneration.xosc.actions.EnvironmentAction">EnvironmentAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.get_element" href="#scenariogeneration.xosc.actions.EnvironmentAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.EnvironmentAction.parse" href="#scenariogeneration.xosc.actions.EnvironmentAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction">FollowTrajectoryAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.FollowTrajectoryAction.parse" href="#scenariogeneration.xosc.actions.FollowTrajectoryAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction" href="#scenariogeneration.xosc.actions.LateralDistanceAction">LateralDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LateralDistanceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LateralDistanceAction.parse" href="#scenariogeneration.xosc.actions.LateralDistanceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LightStateAction" href="#scenariogeneration.xosc.actions.LightStateAction">LightStateAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.get_attributes" href="#scenariogeneration.xosc.actions.LightStateAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.get_element" href="#scenariogeneration.xosc.actions.LightStateAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LightStateAction.parse" href="#scenariogeneration.xosc.actions.LightStateAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction">LongitudinalDistanceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse" href="#scenariogeneration.xosc.actions.LongitudinalDistanceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction">OverrideControllerValueAction</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.parse" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.parse">parse</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_brake">set_brake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_clutch">set_clutch</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_gear">set_gear</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_parkingbrake">set_parkingbrake</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_steeringwheel">set_steeringwheel</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle" href="#scenariogeneration.xosc.actions.OverrideControllerValueAction.set_throttle">set_throttle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterAddAction" href="#scenariogeneration.xosc.actions.ParameterAddAction">ParameterAddAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.get_element" href="#scenariogeneration.xosc.actions.ParameterAddAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterAddAction.parse" href="#scenariogeneration.xosc.actions.ParameterAddAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction">ParameterMultiplyAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterMultiplyAction.parse" href="#scenariogeneration.xosc.actions.ParameterMultiplyAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.ParameterSetAction" href="#scenariogeneration.xosc.actions.ParameterSetAction">ParameterSetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_attributes" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.get_element" href="#scenariogeneration.xosc.actions.ParameterSetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.ParameterSetAction.parse" href="#scenariogeneration.xosc.actions.ParameterSetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction">RelativeLaneChangeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse" href="#scenariogeneration.xosc.actions.RelativeLaneChangeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction">RelativeLaneOffsetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse" href="#scenariogeneration.xosc.actions.RelativeLaneOffsetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction" href="#scenariogeneration.xosc.actions.RelativeSpeedAction">RelativeSpeedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.get_element" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.RelativeSpeedAction.parse" href="#scenariogeneration.xosc.actions.RelativeSpeedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction" href="#scenariogeneration.xosc.actions.SpeedProfileAction">SpeedProfileAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes" href="#scenariogeneration.xosc.actions.SpeedProfileAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.get_element" href="#scenariogeneration.xosc.actions.SpeedProfileAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SpeedProfileAction.parse" href="#scenariogeneration.xosc.actions.SpeedProfileAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.SynchronizeAction" href="#scenariogeneration.xosc.actions.SynchronizeAction">SynchronizeAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_attributes" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.get_element" href="#scenariogeneration.xosc.actions.SynchronizeAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.SynchronizeAction.parse" href="#scenariogeneration.xosc.actions.SynchronizeAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TeleportAction" href="#scenariogeneration.xosc.actions.TeleportAction">TeleportAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TeleportAction.get_element" href="#scenariogeneration.xosc.actions.TeleportAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TeleportAction.parse" href="#scenariogeneration.xosc.actions.TeleportAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction">TrafficSignalControllerAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse" href="#scenariogeneration.xosc.actions.TrafficSignalControllerAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction">TrafficSignalStateAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSignalStateAction.parse" href="#scenariogeneration.xosc.actions.TrafficSignalStateAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction" href="#scenariogeneration.xosc.actions.TrafficSinkAction">TrafficSinkAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSinkAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSinkAction.parse" href="#scenariogeneration.xosc.actions.TrafficSinkAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction" href="#scenariogeneration.xosc.actions.TrafficSourceAction">TrafficSourceAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSourceAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSourceAction.parse" href="#scenariogeneration.xosc.actions.TrafficSourceAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficStopAction" href="#scenariogeneration.xosc.actions.TrafficStopAction">TrafficStopAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.get_element" href="#scenariogeneration.xosc.actions.TrafficStopAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficStopAction.parse" href="#scenariogeneration.xosc.actions.TrafficStopAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction" href="#scenariogeneration.xosc.actions.TrafficSwarmAction">TrafficSwarmAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.get_element" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.TrafficSwarmAction.parse" href="#scenariogeneration.xosc.actions.TrafficSwarmAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.UserDefinedAction" href="#scenariogeneration.xosc.actions.UserDefinedAction">UserDefinedAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.UserDefinedAction.get_element" href="#scenariogeneration.xosc.actions.UserDefinedAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.UserDefinedAction.parse" href="#scenariogeneration.xosc.actions.UserDefinedAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableAddAction" href="#scenariogeneration.xosc.actions.VariableAddAction">VariableAddAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableAddAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.get_element" href="#scenariogeneration.xosc.actions.VariableAddAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableAddAction.parse" href="#scenariogeneration.xosc.actions.VariableAddAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction" href="#scenariogeneration.xosc.actions.VariableMultiplyAction">VariableMultiplyAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.get_element" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableMultiplyAction.parse" href="#scenariogeneration.xosc.actions.VariableMultiplyAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VariableSetAction" href="#scenariogeneration.xosc.actions.VariableSetAction">VariableSetAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.get_attributes" href="#scenariogeneration.xosc.actions.VariableSetAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.get_element" href="#scenariogeneration.xosc.actions.VariableSetAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VariableSetAction.parse" href="#scenariogeneration.xosc.actions.VariableSetAction.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.actions.VisibilityAction" href="#scenariogeneration.xosc.actions.VisibilityAction">VisibilityAction</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference" href="#scenariogeneration.xosc.actions.VisibilityAction.add_sensor_reference">add_sensor_reference</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_attributes" href="#scenariogeneration.xosc.actions.VisibilityAction.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.get_element" href="#scenariogeneration.xosc.actions.VisibilityAction.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.actions.VisibilityAction.parse" href="#scenariogeneration.xosc.actions.VisibilityAction.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>