<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>scenariogeneration.xosc.utils API documentation</title>
<meta name="description" content="scenariogeneration
https://github.com/pyoscx/scenariogeneration â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.utils</code></h1>
</header>
<section id="section-intro">
<p>scenariogeneration
<a href="https://github.com/pyoscx/scenariogeneration">https://github.com/pyoscx/scenariogeneration</a></p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/.">https://mozilla.org/MPL/2.0/.</a></p>
<p>Copyright (c) 2022 The scenariogeneration Authors.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenariogeneration.xosc.utils.convert_bool"><code class="name flex">
<span>def <span class="ident">convert_bool</span></span>(<span>value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bool(value):
    &#34;&#34;&#34;Method to transform booleans to correct xml version (lower case)

    Parameter
    ---------
        value (bool): the boolean

    Return
    ------
        boolean (str)
    &#34;&#34;&#34;
    if isinstance(value, str):
        if value == &#34;true&#34; or value == &#34;1&#34;:
            return True
        elif value == &#34;false&#34; or value == &#34;0&#34;:
            return False
        elif value[0] == &#34;$&#34;:
            return value
        else:
            raise ValueError(
                value
                + &#34;is not a valid type of boolean input to openscenario, if a string is used as a boolean value (parameter or expression), it should have a $ as the first char..&#34;
            )

    if value:
        return True
    elif value == None:
        return None
    else:
        return False</code></pre>
</details>
<div class="desc"><p>Method to transform booleans to correct xml version (lower case)</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (bool): the boolean
</code></pre>
<h2 id="return">Return</h2>
<pre><code>boolean (str)
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.convert_enum"><code class="name flex">
<span>def <span class="ident">convert_enum</span></span>(<span>value, enumtype, none_ok=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_enum(value, enumtype, none_ok=False):
    if isinstance(value, _OscEnum):
        if hasattr(enumtype, str(value)) or &#34;$&#34; == str(value)[0]:
            return value
        else:
            raise TypeError(
                value.get_name() + &#34; is not of Enumeration type :&#34; + str(enumtype)
            )
    elif isinstance(value, str):
        if hasattr(enumtype, value):
            return _OscEnum(enumtype.__name__, value)
        elif &#34;$&#34; == value[0]:
            return _OscEnum(enumtype.__name__, value)
        else:
            raise ValueError(
                value
                + &#34; is not a valid string input for Enumeration type &#34;
                + str(enumtype)
            )
    elif value == None:
        if none_ok:
            return None
        else:
            raise TypeError(&#34;None value not a valid option for: &#34; + str(enumtype))

    raise TypeError(str(value) + &#34; is not of a valid enumeration or str type.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="scenariogeneration.xosc.utils.convert_float"><code class="name flex">
<span>def <span class="ident">convert_float</span></span>(<span>value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_float(value):
    &#34;&#34;&#34;Method to ensure floats are floats, will take care of None values aswell

    Parameter
    ---------
        value (float/str/int/None): a value to transform to float

    Return
    ------
        value (float/None)
    &#34;&#34;&#34;
    if isinstance(value, str):
        if value[0] == &#34;$&#34;:
            return value
        try:
            float(value)
        except ValueError:
            raise ValueError(
                value
                + &#34;is not a valid type of float input to openscenario, if a string is used as a float value (parameter or expression), it should have a $ as the first char..&#34;
            )

    if value is not None:
        return float(value)
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Method to ensure floats are floats, will take care of None values aswell</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (float/str/int/None): a value to transform to float
</code></pre>
<h2 id="return">Return</h2>
<pre><code>value (float/None)
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.convert_int"><code class="name flex">
<span>def <span class="ident">convert_int</span></span>(<span>value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_int(value):
    &#34;&#34;&#34;Method to ensure ints are ints, will take care of None values aswell

    Parameter
    ---------
        value (float/str/int/None): a value to transform to int

    Return
    ------
        value (int/None)
    &#34;&#34;&#34;
    if isinstance(value, str):
        if value[0] == &#34;$&#34;:
            return value
        try:
            int(value)
        except ValueError:
            raise ValueError(
                value
                + &#34;is not a valid type of int input to openscenario, if a string is used as a int value (parameter or expression), it should have a $ as the first char.&#34;
            )

    if value is not None:
        return int(value)
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Method to ensure ints are ints, will take care of None values aswell</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (float/str/int/None): a value to transform to int
</code></pre>
<h2 id="return">Return</h2>
<pre><code>value (int/None)
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.get_bool_string"><code class="name flex">
<span>def <span class="ident">get_bool_string</span></span>(<span>value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bool_string(value):
    if isinstance(value, str) and value[0] == &#34;$&#34;:
        return value
    elif value:
        return &#34;true&#34;
    else:
        return &#34;false&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="scenariogeneration.xosc.utils.merge_dicts"><code class="name flex">
<span>def <span class="ident">merge_dicts</span></span>(<span>*dict_args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_dicts(*dict_args):
    &#34;&#34;&#34;Funciton to merge dicts&#34;&#34;&#34;
    retdict = {}
    for d in dict_args:
        retdict.update(d)

    return retdict</code></pre>
</details>
<div class="desc"><p>Funciton to merge dicts</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed"><code class="flex name class">
<span>class <span class="ident">AbsoluteSpeed</span></span>
<span>(</span><span>value, steadyState=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteSpeed(VersionBase):
    &#34;&#34;&#34;
    Parameters
    ----------
        value (float): absolute speed [m/s]

        steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

    Attributes
    ----------
        value (float): absolute speed [m/s]

        steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the attributes of the class
    &#34;&#34;&#34;

    def __init__(self, value, steadyState=None):
        &#34;&#34;&#34;initalzie the AbsoluteSpeed

        Parameters
        ----------
            value (float): absolute speed [m/s]
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState) Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (
                isinstance(steadyState, TargetTimeSteadyState)
                or isinstance(steadyState, TargetDistanceSteadyState)
            ):
                raise TypeError(
                    &#34;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#34;
                )
        self.steadyState = steadyState

    def __eq__(self, other):
        if isinstance(other, AbsoluteSpeed):
            if (
                self.get_attributes() == other.get_attributes()
                and self.steadyState == other.steadyState
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of AbsoluteSpeed

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)

        Returns
        -------
            absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object

        &#34;&#34;&#34;
        absolute_speed_element = element.find(&#34;AbsoluteSpeed&#34;)
        value = absolute_speed_element.attrib[&#34;value&#34;]

        state = None
        if absolute_speed_element.find(&#34;TargetDistanceSteadyState&#34;) != None:
            state = TargetDistanceSteadyState.parse(
                absolute_speed_element.find(&#34;TargetDistanceSteadyState&#34;)
            )
        elif absolute_speed_element.find(&#34;TargetTimeSteadyState&#34;) != None:
            state = TargetTimeSteadyState.parse(
                absolute_speed_element.find(&#34;TargetTimeSteadyState&#34;)
            )

        return AbsoluteSpeed(value, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AbsoluteSpeed&#34;&#34;&#34;
        return {&#34;value&#34;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeed&#34;&#34;&#34;

        elementFinalSpeed = ET.Element(&#34;FinalSpeed&#34;)
        elementAbsoluteSpeed = ET.SubElement(
            elementFinalSpeed, &#34;AbsoluteSpeed&#34;, attrib=self.get_attributes()
        )
        if self.steadyState:
            if self.isVersion(minor=0):
                raise OpenSCENARIOVersionError(
                    &#34;steadyState was introduced in OpenSCENARIO V1.1&#34;
                )
            ET.SubElement(
                elementAbsoluteSpeed,
                self.steadyState.__class__.__name__,
                attrib=self.steadyState.get_attributes(),
            )

        return elementFinalSpeed</code></pre>
</details>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>value (float): absolute speed [m/s]

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): absolute speed [m/s]

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the attributes of the class
</code></pre>
<p>initalzie the AbsoluteSpeed</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): absolute speed [m/s]
steadyState (TargetTimeSteadyState / TargetDistanceSteadyState) Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of AbsoluteSpeed

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)

    Returns
    -------
        absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object

    &#34;&#34;&#34;
    absolute_speed_element = element.find(&#34;AbsoluteSpeed&#34;)
    value = absolute_speed_element.attrib[&#34;value&#34;]

    state = None
    if absolute_speed_element.find(&#34;TargetDistanceSteadyState&#34;) != None:
        state = TargetDistanceSteadyState.parse(
            absolute_speed_element.find(&#34;TargetDistanceSteadyState&#34;)
        )
    elif absolute_speed_element.find(&#34;TargetTimeSteadyState&#34;) != None:
        state = TargetTimeSteadyState.parse(
            absolute_speed_element.find(&#34;TargetTimeSteadyState&#34;)
        )

    return AbsoluteSpeed(value, state)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of AbsoluteSpeed</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AbsoluteSpeed&#34;&#34;&#34;
    return {&#34;value&#34;: str(self.value)}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the AbsoluteSpeed</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AbsoluteSpeed&#34;&#34;&#34;

    elementFinalSpeed = ET.Element(&#34;FinalSpeed&#34;)
    elementAbsoluteSpeed = ET.SubElement(
        elementFinalSpeed, &#34;AbsoluteSpeed&#34;, attrib=self.get_attributes()
    )
    if self.steadyState:
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;steadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        ET.SubElement(
            elementAbsoluteSpeed,
            self.steadyState.__class__.__name__,
            attrib=self.steadyState.get_attributes(),
        )

    return elementFinalSpeed</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeed</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.AnimationFile"><code class="flex name class">
<span>class <span class="ident">AnimationFile</span></span>
<span>(</span><span>file, timeOffset=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnimationFile(_AnimationType):
    &#34;&#34;&#34;The AnimationFile creates a AnimationFile element used by AnimationType

    Parameters
    ----------
        file (string): filepath of the annimation / motion file

        timeOffset (float): time offset from beginning of animation

    Attributes
    ----------

        timeOffset (float): time offset from beginning of animation

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, file, timeOffset=None):
        &#34;&#34;&#34;initalizes the AnimationFile

        Parameters
        ----------
        file (string): filepath of the annimation / motion file

        timeOffset (float): time offset from beginning of animation

        &#34;&#34;&#34;
        self.file = file
        self.timeOffset = convert_float(timeOffset)

    def __eq__(self, other):
        if isinstance(other, AnimationFile):
            if (
                other.get_attributes() == self.get_attributes()
                and other.file == self.file
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of a AnimationFile

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a AnimationFile element

        Returns
        -------
            AnimationFile (AnimationFile): a AnimationFile object

        &#34;&#34;&#34;

        timeOffset = None
        if element.find(&#34;File&#34;) is not None:
            file = element.find(&#34;File&#34;).attrib[&#34;filepath&#34;]
        if &#34;timeOffset&#34; in element.attrib:
            timeOffset = convert_float(element.attrib[&#34;timeOffset&#34;])
        return AnimationFile(file, timeOffset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the AnimationFile as a dict&#34;&#34;&#34;
        retdict = {}
        if self.timeOffset is not None:
            retdict[&#34;timeOffset&#34;] = str(self.timeOffset)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the AnimationFile&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;AnimationFile was introduced in OpenSCENARIO V1.2&#34;
            )

        element = ET.Element(&#34;AnimationFile&#34;, attrib=self.get_attributes())
        if self.file:
            ET.SubElement(element, &#34;File&#34;, {&#34;filepath&#34;: self.file})
        return element</code></pre>
</details>
<div class="desc"><p>The AnimationFile creates a AnimationFile element used by AnimationType</p>
<h2 id="parameters">Parameters</h2>
<pre><code>file (string): filepath of the annimation / motion file

timeOffset (float): time offset from beginning of animation
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>timeOffset (float): time offset from beginning of animation
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the AnimationFile</p>
<h2 id="parameters_1">Parameters</h2>
<p>file (string): filepath of the annimation / motion file</p>
<p>timeOffset (float): time offset from beginning of animation</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._AnimationType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AnimationFile.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of a AnimationFile

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a AnimationFile element

    Returns
    -------
        AnimationFile (AnimationFile): a AnimationFile object

    &#34;&#34;&#34;

    timeOffset = None
    if element.find(&#34;File&#34;) is not None:
        file = element.find(&#34;File&#34;).attrib[&#34;filepath&#34;]
    if &#34;timeOffset&#34; in element.attrib:
        timeOffset = convert_float(element.attrib[&#34;timeOffset&#34;])
    return AnimationFile(file, timeOffset)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of a AnimationFile</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a AnimationFile element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>AnimationFile (AnimationFile): a AnimationFile object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AnimationFile.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the AnimationFile as a dict&#34;&#34;&#34;
    retdict = {}
    if self.timeOffset is not None:
        retdict[&#34;timeOffset&#34;] = str(self.timeOffset)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the AnimationFile as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.AnimationFile.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the AnimationFile&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;AnimationFile was introduced in OpenSCENARIO V1.2&#34;
        )

    element = ET.Element(&#34;AnimationFile&#34;, attrib=self.get_attributes())
    if self.file:
        ET.SubElement(element, &#34;File&#34;, {&#34;filepath&#34;: self.file})
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the AnimationFile</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.BoundingBox"><code class="flex name class">
<span>class <span class="ident">BoundingBox</span></span>
<span>(</span><span>width, length, height, x_center, y_center, z_center)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundingBox(VersionBase):
    &#34;&#34;&#34;the Dimensions describes the size of an entity

    Parameters
    ----------
        width (float): the width of the entity

        length (float): the lenght of the entity

        height (float): the height of the entity

        x_center (float): x distance from back axel to center

        y_center (float): y distance from back axel to clas

        z_center (float): z distance from back axel to center


    Attributes
    ----------
        dimensions (Dimensions): the dimensions of the entity

        center (Center): the center of the object relative the the back axel

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself


    &#34;&#34;&#34;

    def __init__(self, width, length, height, x_center, y_center, z_center):
        &#34;&#34;&#34;initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

            x_center (float): x distance from back axel to center

            y_center (float): y distance from back axel to center

            z_center (float): z distance from back axel to center

        &#34;&#34;&#34;
        self.boundingbox = Dimensions(width, length, height)
        self.center = Center(x_center, y_center, z_center)

    def __eq__(self, other):
        if isinstance(other, BoundingBox):
            if self.boundingbox == other.boundingbox and self.center == other.center:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Dimensions&#34;&#34;&#34;
        element = ET.Element(&#34;BoundingBox&#34;)
        element.append(self.center.get_element())
        element.append(self.boundingbox.get_element())
        return element

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of BoundingBox

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            boundingBox (BoundingBox): a BoundingBox object

        &#34;&#34;&#34;
        center = Center.parse(element.find(&#34;Center&#34;))
        cen_dict = center.get_attributes()
        dimension = Dimensions.parse(element.find(&#34;Dimensions&#34;))
        dim_dict = dimension.get_attributes()
        return BoundingBox(
            dim_dict[&#34;width&#34;],
            dim_dict[&#34;length&#34;],
            dim_dict[&#34;height&#34;],
            cen_dict[&#34;x&#34;],
            cen_dict[&#34;y&#34;],
            cen_dict[&#34;z&#34;],
        )</code></pre>
</details>
<div class="desc"><p>the Dimensions describes the size of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity

x_center (float): x distance from back axel to center

y_center (float): y distance from back axel to clas

z_center (float): z distance from back axel to center
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>dimensions (Dimensions): the dimensions of the entity

center (Center): the center of the object relative the the back axel
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Dimensions</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity

x_center (float): x distance from back axel to center

y_center (float): y distance from back axel to center

z_center (float): z distance from back axel to center
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.BoundingBox.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of BoundingBox

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

    Returns
    -------
        boundingBox (BoundingBox): a BoundingBox object

    &#34;&#34;&#34;
    center = Center.parse(element.find(&#34;Center&#34;))
    cen_dict = center.get_attributes()
    dimension = Dimensions.parse(element.find(&#34;Dimensions&#34;))
    dim_dict = dimension.get_attributes()
    return BoundingBox(
        dim_dict[&#34;width&#34;],
        dim_dict[&#34;length&#34;],
        dim_dict[&#34;height&#34;],
        cen_dict[&#34;x&#34;],
        cen_dict[&#34;y&#34;],
        cen_dict[&#34;z&#34;],
    )</code></pre>
</details>
<div class="desc"><p>Parses the xml element of BoundingBox</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>boundingBox (BoundingBox): a BoundingBox object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.BoundingBox.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Dimensions&#34;&#34;&#34;
    element = ET.Element(&#34;BoundingBox&#34;)
    element.append(self.center.get_element())
    element.append(self.boundingbox.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Dimensions</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Catalog"><code class="flex name class">
<span>class <span class="ident">Catalog</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Catalog(VersionBase):
    &#34;&#34;&#34;The Catalog class creates the CatalogLocation of the OpenScenario input

    Parameters
    ----------

    Attributes
    ----------
        catalogs: dict of catalogs to add, and their path
    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        add_catalog(catalogname, path)
            Adds a new catalog
    &#34;&#34;&#34;

    _CATALOGS = [
        &#34;VehicleCatalog&#34;,
        &#34;ControllerCatalog&#34;,
        &#34;PedestrianCatalog&#34;,
        &#34;MiscObjectCatalog&#34;,
        &#34;EnvironmentCatalog&#34;,
        &#34;ManeuverCatalog&#34;,
        &#34;TrajectoryCatalog&#34;,
        &#34;RouteCatalog&#34;,
    ]

    def __init__(self):
        &#34;&#34;&#34;initalize the Catalog class&#34;&#34;&#34;
        self.catalogs = {}

    def __eq__(self, other):
        if isinstance(other, Catalog):
            if self.catalogs == other.catalogs:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Catalog

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)

        Returns
        -------
            catalog (Catalog): a Catalog object

        &#34;&#34;&#34;
        catalog = Catalog()

        vc_element = element.find(&#34;VehicleCatalog&#34;)
        if vc_element is not None:
            path = vc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;VehicleCatalog&#34;, path)

        cc_element = element.find(&#34;ControllerCatalog&#34;)
        if cc_element is not None:
            path = cc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;ControllerCatalog&#34;, path)

        pc_element = element.find(&#34;PedestrianCatalog&#34;)
        if pc_element is not None:
            path = pc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;PedestrianCatalog&#34;, path)

        moc_element = element.find(&#34;MiscObjectCatalog&#34;)
        if moc_element is not None:
            path = moc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;MiscObjectCatalog&#34;, path)

        ec_element = element.find(&#34;EnvironmentCatalog&#34;)
        if ec_element is not None:
            path = ec_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;EnvironmentCatalog&#34;, path)

        mc_element = element.find(&#34;ManeuverCatalog&#34;)
        if mc_element is not None:
            path = mc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;ManeuverCatalog&#34;, path)

        tc_element = element.find(&#34;TrajectoryCatalog&#34;)
        if tc_element is not None:
            path = tc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;TrajectoryCatalog&#34;, path)

        rc_element = element.find(&#34;RouteCatalog&#34;)
        if rc_element is not None:
            path = rc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
            catalog.add_catalog(&#34;RouteCatalog&#34;, path)

        return catalog

    def add_catalog(self, catalogname, path):
        &#34;&#34;&#34;add new catalog to be used

        Parameters
        ----------
            catalogname (str): name of the catalog

            path (str): path to the catalog

        &#34;&#34;&#34;

        if catalogname not in self._CATALOGS:
            raise ValueError(
                f&#34;Not a correct catalog, approved catalogs are: {&#39;, &#39;.join(self._CATALOGS)}.&#34;
            )

        self.catalogs[catalogname] = path
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Catalog&#34;&#34;&#34;

        catloc = ET.Element(&#34;CatalogLocations&#34;)

        for i in self.catalogs:
            tmpel = ET.SubElement(catloc, i)
            ET.SubElement(tmpel, &#34;Directory&#34;, {&#34;path&#34;: self.catalogs[i]})
        return catloc</code></pre>
</details>
<div class="desc"><p>The Catalog class creates the CatalogLocation of the OpenScenario input</p>
<h2 id="parameters">Parameters</h2>
<h2 id="attributes">Attributes</h2>
<pre><code>catalogs: dict of catalogs to add, and their path
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

add_catalog(catalogname, path)
    Adds a new catalog
</code></pre>
<p>initalize the Catalog class</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Catalog.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Catalog

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)

    Returns
    -------
        catalog (Catalog): a Catalog object

    &#34;&#34;&#34;
    catalog = Catalog()

    vc_element = element.find(&#34;VehicleCatalog&#34;)
    if vc_element is not None:
        path = vc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;VehicleCatalog&#34;, path)

    cc_element = element.find(&#34;ControllerCatalog&#34;)
    if cc_element is not None:
        path = cc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;ControllerCatalog&#34;, path)

    pc_element = element.find(&#34;PedestrianCatalog&#34;)
    if pc_element is not None:
        path = pc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;PedestrianCatalog&#34;, path)

    moc_element = element.find(&#34;MiscObjectCatalog&#34;)
    if moc_element is not None:
        path = moc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;MiscObjectCatalog&#34;, path)

    ec_element = element.find(&#34;EnvironmentCatalog&#34;)
    if ec_element is not None:
        path = ec_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;EnvironmentCatalog&#34;, path)

    mc_element = element.find(&#34;ManeuverCatalog&#34;)
    if mc_element is not None:
        path = mc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;ManeuverCatalog&#34;, path)

    tc_element = element.find(&#34;TrajectoryCatalog&#34;)
    if tc_element is not None:
        path = tc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;TrajectoryCatalog&#34;, path)

    rc_element = element.find(&#34;RouteCatalog&#34;)
    if rc_element is not None:
        path = rc_element.find(&#34;Directory&#34;).attrib[&#34;path&#34;]
        catalog.add_catalog(&#34;RouteCatalog&#34;, path)

    return catalog</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>catalog (Catalog): a Catalog object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Catalog.add_catalog"><code class="name flex">
<span>def <span class="ident">add_catalog</span></span>(<span>self, catalogname, path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_catalog(self, catalogname, path):
    &#34;&#34;&#34;add new catalog to be used

    Parameters
    ----------
        catalogname (str): name of the catalog

        path (str): path to the catalog

    &#34;&#34;&#34;

    if catalogname not in self._CATALOGS:
        raise ValueError(
            f&#34;Not a correct catalog, approved catalogs are: {&#39;, &#39;.join(self._CATALOGS)}.&#34;
        )

    self.catalogs[catalogname] = path
    return self</code></pre>
</details>
<div class="desc"><p>add new catalog to be used</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

path (str): path to the catalog
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Catalog.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Catalog&#34;&#34;&#34;

    catloc = ET.Element(&#34;CatalogLocations&#34;)

    for i in self.catalogs:
        tmpel = ET.SubElement(catloc, i)
        ET.SubElement(tmpel, &#34;Directory&#34;, {&#34;path&#34;: self.catalogs[i]})
    return catloc</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Catalog</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile"><code class="flex name class">
<span>class <span class="ident">CatalogFile</span></span>
<span>(</span><span>prettyprint=True, encoding='utf-8')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatalogFile(VersionBase):
    &#34;&#34;&#34;The CatalogFile class handles any catalogs in open scenario, such as writing, and updating them

    Parameters
    ----------
        prettyprint (boolean): if the final file should have prettyprint or not
            Default: True

    Attributes
    ----------
        prettyprint: if the final file should have prettyprint or not

        catalog_element (Element): the element that is worked with

        filename (str): path to the file to be written to

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_catalog(catalogname, path)
            Adds a new catalog
    &#34;&#34;&#34;

    def __init__(self, prettyprint=True, encoding=&#34;utf-8&#34;):
        &#34;&#34;&#34;initalize the CatalogFile class

        Parameters
        ----------
            prettyprint (boolean): if the final file should have prettyprint or not
                Default: True
        &#34;&#34;&#34;
        self.prettyprint = prettyprint
        self.catalog_element = None
        self.filename = &#34;&#34;
        self.encoding = encoding

    def add_to_catalog(self, obj):
        &#34;&#34;&#34;add_to_catalog adds an element to the catalog

        Parameters
        ----------
            obj (*pyoscx): any pyoscx object (should be matching with the catalog)

            osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
                Default: same as package
        &#34;&#34;&#34;
        if self.catalog_element == None:
            OSError(&#34;No file has been created or opened&#34;)
        fileheader = self.catalog_element.find(&#34;FileHeader&#34;)

        if convert_int(fileheader.attrib[&#34;revMinor&#34;]) != obj.version_minor:
            warnings.warn(
                &#34;The Catalog and the added object does not have the same OpenSCENARIO version.&#34;
            )
        catalogs = self.catalog_element.find(&#34;Catalog&#34;)
        catalogs.append(obj.get_element())
        return self

    def open_catalog(self, filename):
        &#34;&#34;&#34;open_catalog reads an existing catalog file

        Parameters
        ----------
            filename (str): path to the catalog file

        &#34;&#34;&#34;
        self.filename = filename
        tree = ET.parse(self.filename)
        self.catalog_element = tree.getroot()

    def create_catalog(self, filename, catalogtype, description, author):
        &#34;&#34;&#34;create_catalog_element creates an empty catalog of a desiered type,

        Parameters
        ----------
            filename (str): path of the new catalog file

            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog

        &#34;&#34;&#34;
        self.filename = filename
        self.catalog_element = self.create_catalog_element(
            catalogtype, description, author
        )

    def create_catalog_element(self, catalogtype, description, author):
        &#34;&#34;&#34;create_catalog_element creates an empty catalog of a desiered type,

        Parameters
        ----------
            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog

        &#34;&#34;&#34;
        element = ET.Element(
            &#34;OpenSCENARIO&#34;,
            attrib={
                &#34;xmlns:xsi&#34;: XMLNS,
                &#34;xsi:noNamespaceSchemaLocation&#34;: &#34;../../&#34; + XSI,
            },
        )
        header = FileHeader(author, description, revMinor=self.version_minor)
        element.append(header.get_element())
        ET.SubElement(element, &#34;Catalog&#34;, attrib={&#34;name&#34;: catalogtype})

        return element

    def dump(self):
        &#34;&#34;&#34;writes the new/updated catalog file&#34;&#34;&#34;
        printToFile(
            self.catalog_element, self.filename, self.prettyprint, self.encoding
        )</code></pre>
</details>
<div class="desc"><p>The CatalogFile class handles any catalogs in open scenario, such as writing, and updating them</p>
<h2 id="parameters">Parameters</h2>
<pre><code>prettyprint (boolean): if the final file should have prettyprint or not
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>prettyprint: if the final file should have prettyprint or not

catalog_element (Element): the element that is worked with

filename (str): path to the file to be written to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_catalog(catalogname, path)
    Adds a new catalog
</code></pre>
<p>initalize the CatalogFile class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>prettyprint (boolean): if the final file should have prettyprint or not
    Default: True
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogFile.add_to_catalog"><code class="name flex">
<span>def <span class="ident">add_to_catalog</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_catalog(self, obj):
    &#34;&#34;&#34;add_to_catalog adds an element to the catalog

    Parameters
    ----------
        obj (*pyoscx): any pyoscx object (should be matching with the catalog)

        osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
            Default: same as package
    &#34;&#34;&#34;
    if self.catalog_element == None:
        OSError(&#34;No file has been created or opened&#34;)
    fileheader = self.catalog_element.find(&#34;FileHeader&#34;)

    if convert_int(fileheader.attrib[&#34;revMinor&#34;]) != obj.version_minor:
        warnings.warn(
            &#34;The Catalog and the added object does not have the same OpenSCENARIO version.&#34;
        )
    catalogs = self.catalog_element.find(&#34;Catalog&#34;)
    catalogs.append(obj.get_element())
    return self</code></pre>
</details>
<div class="desc"><p>add_to_catalog adds an element to the catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>obj (*pyoscx): any pyoscx object (should be matching with the catalog)

osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
    Default: same as package
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.create_catalog"><code class="name flex">
<span>def <span class="ident">create_catalog</span></span>(<span>self, filename, catalogtype, description, author)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_catalog(self, filename, catalogtype, description, author):
    &#34;&#34;&#34;create_catalog_element creates an empty catalog of a desiered type,

    Parameters
    ----------
        filename (str): path of the new catalog file

        catalogtype (str): name of the catalog

        description (str): description of the catalog

        author (str): author of the catalog

    &#34;&#34;&#34;
    self.filename = filename
    self.catalog_element = self.create_catalog_element(
        catalogtype, description, author
    )</code></pre>
</details>
<div class="desc"><p>create_catalog_element creates an empty catalog of a desiered type,</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path of the new catalog file

catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.create_catalog_element"><code class="name flex">
<span>def <span class="ident">create_catalog_element</span></span>(<span>self, catalogtype, description, author)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_catalog_element(self, catalogtype, description, author):
    &#34;&#34;&#34;create_catalog_element creates an empty catalog of a desiered type,

    Parameters
    ----------
        catalogtype (str): name of the catalog

        description (str): description of the catalog

        author (str): author of the catalog

    &#34;&#34;&#34;
    element = ET.Element(
        &#34;OpenSCENARIO&#34;,
        attrib={
            &#34;xmlns:xsi&#34;: XMLNS,
            &#34;xsi:noNamespaceSchemaLocation&#34;: &#34;../../&#34; + XSI,
        },
    )
    header = FileHeader(author, description, revMinor=self.version_minor)
    element.append(header.get_element())
    ET.SubElement(element, &#34;Catalog&#34;, attrib={&#34;name&#34;: catalogtype})

    return element</code></pre>
</details>
<div class="desc"><p>create_catalog_element creates an empty catalog of a desiered type,</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self):
    &#34;&#34;&#34;writes the new/updated catalog file&#34;&#34;&#34;
    printToFile(
        self.catalog_element, self.filename, self.prettyprint, self.encoding
    )</code></pre>
</details>
<div class="desc"><p>writes the new/updated catalog file</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.open_catalog"><code class="name flex">
<span>def <span class="ident">open_catalog</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_catalog(self, filename):
    &#34;&#34;&#34;open_catalog reads an existing catalog file

    Parameters
    ----------
        filename (str): path to the catalog file

    &#34;&#34;&#34;
    self.filename = filename
    tree = ET.parse(self.filename)
    self.catalog_element = tree.getroot()</code></pre>
</details>
<div class="desc"><p>open_catalog reads an existing catalog file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path to the catalog file
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference"><code class="flex name class">
<span>class <span class="ident">CatalogReference</span></span>
<span>(</span><span>catalogname, entryname)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatalogReference(VersionBase):
    &#34;&#34;&#34;CatalogReference creates an CatalogReference element of openscenario

    Parameters
    ----------
        catalogname (str): name of the catalog

        entryname (str): name of the entry in the catalog

    Attributes
    ----------
        catalogname (str): name of the catalog

        entryname (str): name of the entry in the catalog

        parameterassignments (list of ParameterAssignment): the parameter assignments for the given catalogreference

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_parameter_assignment(parameterref,value)
            Assigns a parameter with a value

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, catalogname, entryname):
        &#34;&#34;&#34;initalize the CatalogReference

        Parameters
        ----------
            catalogname (str): name of the catalog

            entryname (str): name of the entry in the catalog

        &#34;&#34;&#34;
        self.catalogname = catalogname
        self.entryname = entryname
        self.parameterassignments = []

    def __eq__(self, other):
        if isinstance(other, CatalogReference):
            if (
                self.get_attributes() == other.get_attributes()
                and self.parameterassignments == other.parameterassignments
            ):
                return True
        return False

    # TODO: CatalogElement???

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of CatalogReference

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)

        Returns
        -------
            reference (CatalogReference): a catalog reference object

        &#34;&#34;&#34;
        catalogname = element.attrib[&#34;catalogName&#34;]
        entryname = element.attrib[&#34;entryName&#34;]
        reference = CatalogReference(catalogname, entryname)

        parameter_assignments = element.find(&#34;ParameterAssignments&#34;)
        if parameter_assignments != None:
            parameters = parameter_assignments.findall(&#34;ParameterAssignment&#34;)
            for parameter in parameters:
                parameter_assignment = ParameterAssignment.parse(parameter)
                reference.parameterassignments.append(parameter_assignment)

        return reference

    def add_parameter_assignment(self, parameterref, value):
        &#34;&#34;&#34;add_parameter_assignment adds a parameter and value to the catalog reference

        Parameters
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter
        &#34;&#34;&#34;
        self.parameterassignments.append(ParameterAssignment(parameterref, value))
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the CatalogReference as a dict&#34;&#34;&#34;
        return {&#34;catalogName&#34;: self.catalogname, &#34;entryName&#34;: self.entryname}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the CatalogReference&#34;&#34;&#34;
        element = ET.Element(&#34;CatalogReference&#34;, attrib=self.get_attributes())
        if self.parameterassignments:
            parameterassigns = ET.SubElement(element, &#34;ParameterAssignments&#34;)
        for parass in self.parameterassignments:
            parameterassigns.append(parass.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>CatalogReference creates an CatalogReference element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog

parameterassignments (list of ParameterAssignment): the parameter assignments for the given catalogreference
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_parameter_assignment(parameterref,value)
    Assigns a parameter with a value

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the CatalogReference</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogReference.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of CatalogReference

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)

    Returns
    -------
        reference (CatalogReference): a catalog reference object

    &#34;&#34;&#34;
    catalogname = element.attrib[&#34;catalogName&#34;]
    entryname = element.attrib[&#34;entryName&#34;]
    reference = CatalogReference(catalogname, entryname)

    parameter_assignments = element.find(&#34;ParameterAssignments&#34;)
    if parameter_assignments != None:
        parameters = parameter_assignments.findall(&#34;ParameterAssignment&#34;)
        for parameter in parameters:
            parameter_assignment = ParameterAssignment.parse(parameter)
            reference.parameterassignments.append(parameter_assignment)

    return reference</code></pre>
</details>
<div class="desc"><p>Parses the xml element of CatalogReference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>reference (CatalogReference): a catalog reference object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment"><code class="name flex">
<span>def <span class="ident">add_parameter_assignment</span></span>(<span>self, parameterref, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter_assignment(self, parameterref, value):
    &#34;&#34;&#34;add_parameter_assignment adds a parameter and value to the catalog reference

    Parameters
    ----------
        parameterref (str): name of the parameter

        value (str): assigned value of the parameter
    &#34;&#34;&#34;
    self.parameterassignments.append(ParameterAssignment(parameterref, value))
    return self</code></pre>
</details>
<div class="desc"><p>add_parameter_assignment adds a parameter and value to the catalog reference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the CatalogReference as a dict&#34;&#34;&#34;
    return {&#34;catalogName&#34;: self.catalogname, &#34;entryName&#34;: self.entryname}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the CatalogReference as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the CatalogReference&#34;&#34;&#34;
    element = ET.Element(&#34;CatalogReference&#34;, attrib=self.get_attributes())
    if self.parameterassignments:
        parameterassigns = ET.SubElement(element, &#34;ParameterAssignments&#34;)
    for parass in self.parameterassignments:
        parameterassigns.append(parass.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the CatalogReference</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Center"><code class="flex name class">
<span>class <span class="ident">Center</span></span>
<span>(</span><span>x, y, z)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Center(VersionBase):
    &#34;&#34;&#34;the Center Class creates a centerpoint for a bounding box, reference point of a vehicle is the back axel

    Parameters
    ----------
        x (float): x distance from back axel to center

        y (float): y distance from back axel to center

        z (float): z distance from back axel to center


    Attributes
    ----------
        x (float): x distance from back axel to center

        y (float): y distance from back axel to center

        z (float): z distance from back axel to center

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;

    def __init__(self, x, y, z):
        &#34;&#34;&#34;initalzie the Center Class

        Parameters
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center

        &#34;&#34;&#34;
        self.x = convert_float(x)
        self.y = convert_float(y)
        self.z = convert_float(z)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element to Center

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)

        Returns
        ------
            center (Center): a Center object

        &#34;&#34;&#34;
        x = convert_float(element.attrib[&#34;x&#34;])
        y = convert_float(element.attrib[&#34;y&#34;])
        z = convert_float(element.attrib[&#34;z&#34;])
        return Center(x, y, z)

    def __eq__(self, other):
        if isinstance(other, Center):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes as a dict of the Center&#34;&#34;&#34;
        return {&#34;x&#34;: str(self.x), &#34;y&#34;: str(self.y), &#34;z&#34;: str(self.z)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Center&#34;&#34;&#34;
        element = ET.Element(&#34;Center&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>the Center Class creates a centerpoint for a bounding box, reference point of a vehicle is the back axel</p>
<h2 id="parameters">Parameters</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Center Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Center.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element to Center

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)

    Returns
    ------
        center (Center): a Center object

    &#34;&#34;&#34;
    x = convert_float(element.attrib[&#34;x&#34;])
    y = convert_float(element.attrib[&#34;y&#34;])
    z = convert_float(element.attrib[&#34;z&#34;])
    return Center(x, y, z)</code></pre>
</details>
<div class="desc"><p>Parses the xml element to Center</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>center (Center): a Center object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Center.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes as a dict of the Center&#34;&#34;&#34;
    return {&#34;x&#34;: str(self.x), &#34;y&#34;: str(self.y), &#34;z&#34;: str(self.z)}</code></pre>
</details>
<div class="desc"><p>returns the attributes as a dict of the Center</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Center.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Center&#34;&#34;&#34;
    element = ET.Element(&#34;Center&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Center</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Color"><code class="flex name class">
<span>class <span class="ident">Color</span></span>
<span>(</span><span>color_type, color_definition)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Color(VersionBase):
    &#34;&#34;&#34;Creates the Color element in OpenSCENARIO

    Parameters
    ----------
        color_type (ColorType): semantic value of color

        color_definition (_ColorDefinition): the color definition

    Attributes
    ----------
        color_type (ColorType): semantic value of color

        color_definition (_ColorDefinition): the color definition

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, color_type, color_definition):
        &#34;&#34;&#34;initalzie the Color Class

        Parameters
        ----------
            color_type (ColorType): semantic value of color

            color_definition (ColorRGB or ColorCmyk): the color definition

        &#34;&#34;&#34;
        self.color_type = convert_enum(color_type, ColorType, False)
        if not isinstance(color_definition, _ColorDefinition):
            raise TypeError(&#34;input is not a color definition&#34;)
        self.color_definition = color_definition

    def __eq__(self, other):
        if isinstance(other, Color):
            if (
                self.get_attributes() == other.get_attributes()
                and self.color_definition == other.color_definition
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Color

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

        Returns
        -------
            color (Color): Color object

        &#34;&#34;&#34;

        color_type = convert_enum(element.attrib[&#34;colorType&#34;], ColorType)
        if element.find(&#34;ColorRgb&#34;) is not None:
            color_def = ColorRGB.parse(element.find(&#34;ColorRgb&#34;))
        elif element.find(&#34;ColorCmyk&#34;) is not None:
            color_def = ColorCMYK.parse(element.find(&#34;ColorCmyk&#34;))
        return Color(color_type, color_def)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Color as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;colorType&#34;] = self.color_type.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Color&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(&#34;Color was introduced in OpenSCENARIO V1.2&#34;)
        element = ET.Element(&#34;Color&#34;, attrib=self.get_attributes())
        element.append(self.color_definition.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Creates the Color element in OpenSCENARIO</p>
<h2 id="parameters">Parameters</h2>
<pre><code>color_type (ColorType): semantic value of color

color_definition (_ColorDefinition): the color definition
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>color_type (ColorType): semantic value of color

color_definition (_ColorDefinition): the color definition
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the Color Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>color_type (ColorType): semantic value of color

color_definition (ColorRGB or ColorCmyk): the color definition
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Color.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Color

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

    Returns
    -------
        color (Color): Color object

    &#34;&#34;&#34;

    color_type = convert_enum(element.attrib[&#34;colorType&#34;], ColorType)
    if element.find(&#34;ColorRgb&#34;) is not None:
        color_def = ColorRGB.parse(element.find(&#34;ColorRgb&#34;))
    elif element.find(&#34;ColorCmyk&#34;) is not None:
        color_def = ColorCMYK.parse(element.find(&#34;ColorCmyk&#34;))
    return Color(color_type, color_def)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Color</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>color (Color): Color object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Color.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Color as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;colorType&#34;] = self.color_type.get_name()
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Color as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Color.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Color&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(&#34;Color was introduced in OpenSCENARIO V1.2&#34;)
    element = ET.Element(&#34;Color&#34;, attrib=self.get_attributes())
    element.append(self.color_definition.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Color</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ColorCMYK"><code class="flex name class">
<span>class <span class="ident">ColorCMYK</span></span>
<span>(</span><span>cyan=0, magenta=0, yellow=0, key=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColorCMYK(_ColorDefinition):
    &#34;&#34;&#34;Creates the CMYK Color element in OpenSCENARIO

    Parameters
    ----------
        cyan (float): cyan component (0..1)
            Default: 0

        magenta (float): magenta component (0..1)
            Default: 0

        yellow (float): yellow component (0..1)
            Default: 0

        key (float): black component (0..1)
            Default: 0

    Attributes
    ----------
        cyan (float): cyan component (0..1)

        magenta (float): magenta component (0..1)

        yellow (float): yellow component (0..1)

        key (float): black component (0..1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, cyan=0, magenta=0, yellow=0, key=0):
        &#34;&#34;&#34;initalzie the ColorCMYK Class

        Parameters
        ----------
            cyan (float): cyan component (0..1)
                Default: 0

            magenta (float): magenta component (0..1)
                Default: 0

            yellow (float): yellow component (0..1)
                Default: 0

            key (float): black component (0..1)
                Default: 0
        &#34;&#34;&#34;
        self.cyan = cyan
        self.magenta = magenta
        self.yellow = yellow
        self.key = key

    def __eq__(self, other):
        if isinstance(other, ColorCMYK):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ColorCMYK

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

        Returns
        -------
            color (ColorCMYK): ColorCMYK object

        &#34;&#34;&#34;

        cyan = element.attrib[&#34;cyan&#34;]
        magenta = element.attrib[&#34;magenta&#34;]
        yellow = element.attrib[&#34;yellow&#34;]
        key = element.attrib[&#34;key&#34;]
        return ColorCMYK(cyan, magenta, yellow, key)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ColorCMYK as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;cyan&#34;] = str(self.cyan)
        retdict[&#34;magenta&#34;] = str(self.magenta)
        retdict[&#34;yellow&#34;] = str(self.yellow)
        retdict[&#34;key&#34;] = str(self.key)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ColorCMYK&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;ColorCMYK was introduced in OpenSCENARIO V1.2&#34;
            )
        element = ET.Element(&#34;ColorCmyk&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>Creates the CMYK Color element in OpenSCENARIO</p>
<h2 id="parameters">Parameters</h2>
<pre><code>cyan (float): cyan component (0..1)
    Default: 0

magenta (float): magenta component (0..1)
    Default: 0

yellow (float): yellow component (0..1)
    Default: 0

key (float): black component (0..1)
    Default: 0
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>cyan (float): cyan component (0..1)

magenta (float): magenta component (0..1)

yellow (float): yellow component (0..1)

key (float): black component (0..1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the ColorCMYK Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>cyan (float): cyan component (0..1)
    Default: 0

magenta (float): magenta component (0..1)
    Default: 0

yellow (float): yellow component (0..1)
    Default: 0

key (float): black component (0..1)
    Default: 0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ColorDefinition</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ColorCMYK.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ColorCMYK

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

    Returns
    -------
        color (ColorCMYK): ColorCMYK object

    &#34;&#34;&#34;

    cyan = element.attrib[&#34;cyan&#34;]
    magenta = element.attrib[&#34;magenta&#34;]
    yellow = element.attrib[&#34;yellow&#34;]
    key = element.attrib[&#34;key&#34;]
    return ColorCMYK(cyan, magenta, yellow, key)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ColorCMYK</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>color (ColorCMYK): ColorCMYK object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ColorCMYK.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ColorCMYK as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;cyan&#34;] = str(self.cyan)
    retdict[&#34;magenta&#34;] = str(self.magenta)
    retdict[&#34;yellow&#34;] = str(self.yellow)
    retdict[&#34;key&#34;] = str(self.key)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the ColorCMYK as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ColorCMYK.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ColorCMYK&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;ColorCMYK was introduced in OpenSCENARIO V1.2&#34;
        )
    element = ET.Element(&#34;ColorCmyk&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ColorCMYK</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ColorRGB"><code class="flex name class">
<span>class <span class="ident">ColorRGB</span></span>
<span>(</span><span>red=0, green=0, blue=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColorRGB(_ColorDefinition):
    &#34;&#34;&#34;Creates the RGB Color element in OpenSCENARIO

    Parameters
    ----------
        red (float): red component (0..1)
            Default: 0

        green (float): green component (0..1)
            Default: 0

        blue (float): blue component (0..1)
            Default: 0


    Attributes
    ----------
        red (float): red component (0..1)

        green (float): green component (0..1)

        blue (float): blue component (0..1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, red=0, green=0, blue=0):
        &#34;&#34;&#34;initalzie the ColorRGB Class

        Parameters
        ----------
            red (float): red component (0..1)
                Default: 0

            green (float): green component (0..1)
                Default: 0

            blue (float): blue component (0..1)
                Default: 0
        &#34;&#34;&#34;
        self.red = red
        self.green = green
        self.blue = blue

    def __eq__(self, other):
        if isinstance(other, ColorRGB):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ColorRGB

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

        Returns
        -------
            color (ColorRGB): ColorRGB object

        &#34;&#34;&#34;

        red = element.attrib[&#34;red&#34;]
        green = element.attrib[&#34;green&#34;]
        blue = element.attrib[&#34;blue&#34;]
        return ColorRGB(red, green, blue)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ValueConstraint as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;red&#34;] = str(self.red)
        retdict[&#34;green&#34;] = str(self.green)
        retdict[&#34;blue&#34;] = str(self.blue)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ValueConstraint&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;ColorRGB was introduced in OpenSCENARIO V1.2&#34;
            )
        element = ET.Element(&#34;ColorRgb&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>Creates the RGB Color element in OpenSCENARIO</p>
<h2 id="parameters">Parameters</h2>
<pre><code>red (float): red component (0..1)
    Default: 0

green (float): green component (0..1)
    Default: 0

blue (float): blue component (0..1)
    Default: 0
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>red (float): red component (0..1)

green (float): green component (0..1)

blue (float): blue component (0..1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the ColorRGB Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>red (float): red component (0..1)
    Default: 0

green (float): green component (0..1)
    Default: 0

blue (float): blue component (0..1)
    Default: 0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._ColorDefinition</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ColorRGB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ColorRGB

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

    Returns
    -------
        color (ColorRGB): ColorRGB object

    &#34;&#34;&#34;

    red = element.attrib[&#34;red&#34;]
    green = element.attrib[&#34;green&#34;]
    blue = element.attrib[&#34;blue&#34;]
    return ColorRGB(red, green, blue)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ColorRGB</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>color (ColorRGB): ColorRGB object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ColorRGB.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ValueConstraint as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;red&#34;] = str(self.red)
    retdict[&#34;green&#34;] = str(self.green)
    retdict[&#34;blue&#34;] = str(self.blue)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the ValueConstraint as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ColorRGB.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ValueConstraint&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;ColorRGB was introduced in OpenSCENARIO V1.2&#34;
        )
    element = ET.Element(&#34;ColorRgb&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ValueConstraint</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
<span>(</span><span>name, properties, controller_type=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller(_BaseCatalog):
    &#34;&#34;&#34;the Controller class creates a controller of openScenario

    Parameters
    ----------
        name (str): name of the object

        properties (Properties): properties of the controller

        controller_type (ControllerType): controller type (valid from V1.2)
            Default: None

    Attributes
    ----------
        parameters (ParameterDeclaration): Parameter declarations of the vehicle

        properties (Properties): additional properties of the vehicle

        controller_type (ControllerType): controller type
    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_parameter(parameter)
            adds a parameter declaration to the Controller

        append_to_catalog(filename)
            adds the vehicle to an existing catalog

        dump_to_catalog(filename,name,description,author)
            crates a new catalog with the vehicle

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, properties, controller_type=None):
        &#34;&#34;&#34;initalzie the Controller Class

        Parameters
        ----------
            name (str): name of the object

            properties (Properties): properties of the Controller

            controller_type (ControllerType): controller type (valid from V1.2)
                Default: None
        &#34;&#34;&#34;
        super().__init__()
        self.name = name

        if not isinstance(properties, Properties):
            raise TypeError(&#34;properties input is not of type Properties&#34;)
        self.properties = properties
        self.controller_type = convert_enum(controller_type, ControllerType, True)

    def __eq__(self, other):
        if isinstance(other, Controller):
            if (
                self.properties == other.properties
                and self.parameters == other.parameters
                and self.name == other.name
                and self.controller_type == other.controller_type
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Controller

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)

        Returns
        -------
            controller (Controller): a Controller object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        properties_element = element.find(&#34;Properties&#34;)
        properties = Properties.parse(properties_element)
        cnt_type = None
        if &#34;controllerType&#34; in element.attrib:
            cnt_type = convert_enum(
                element.attrib[&#34;controllerType&#34;], ControllerType, False
            )
        controller = Controller(name, properties, cnt_type)

        parameters_element = element.find(&#34;ParameterDeclarations&#34;)
        if parameters_element:
            controller.parameters = ParameterDeclarations.parse(parameters_element)

        return controller

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Controller as a dict&#34;&#34;&#34;
        retdict = {&#34;name&#34;: self.name}
        if self.controller_type:
            if self.isVersion(minor=2):
                retdict[&#34;controllerType&#34;] = self.controller_type.get_name()
            else:
                raise OpenSCENARIOVersionError(
                    &#34;controllerType was introduced in OSC v1.2&#34;
                )

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Controller&#34;&#34;&#34;
        element = ET.Element(&#34;Controller&#34;, attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        element.append(self.properties.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>the Controller class creates a controller of openScenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the object

properties (Properties): properties of the controller

controller_type (ControllerType): controller type (valid from V1.2)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameters (ParameterDeclaration): Parameter declarations of the vehicle

properties (Properties): additional properties of the vehicle

controller_type (ControllerType): controller type
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_parameter(parameter)
    adds a parameter declaration to the Controller

append_to_catalog(filename)
    adds the vehicle to an existing catalog

dump_to_catalog(filename,name,description,author)
    crates a new catalog with the vehicle

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the Controller Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the object

properties (Properties): properties of the Controller

controller_type (ControllerType): controller type (valid from V1.2)
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._BaseCatalog</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Controller.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Controller

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)

    Returns
    -------
        controller (Controller): a Controller object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    properties_element = element.find(&#34;Properties&#34;)
    properties = Properties.parse(properties_element)
    cnt_type = None
    if &#34;controllerType&#34; in element.attrib:
        cnt_type = convert_enum(
            element.attrib[&#34;controllerType&#34;], ControllerType, False
        )
    controller = Controller(name, properties, cnt_type)

    parameters_element = element.find(&#34;ParameterDeclarations&#34;)
    if parameters_element:
        controller.parameters = ParameterDeclarations.parse(parameters_element)

    return controller</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Controller</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>controller (Controller): a Controller object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Controller.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Controller as a dict&#34;&#34;&#34;
    retdict = {&#34;name&#34;: self.name}
    if self.controller_type:
        if self.isVersion(minor=2):
            retdict[&#34;controllerType&#34;] = self.controller_type.get_name()
        else:
            raise OpenSCENARIOVersionError(
                &#34;controllerType was introduced in OSC v1.2&#34;
            )

    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Controller as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Controller&#34;&#34;&#34;
    element = ET.Element(&#34;Controller&#34;, attrib=self.get_attributes())
    self.add_parameters_to_element(element)
    element.append(self.properties.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Controller</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Dimensions"><code class="flex name class">
<span>class <span class="ident">Dimensions</span></span>
<span>(</span><span>width, length, height)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dimensions(VersionBase):
    &#34;&#34;&#34;the Dimensions describes the size of an entity

    Parameters
    ----------
        width (float): the width of the entity

        length (float): the lenght of the entity

        height (float): the height of the entity


    Attributes
    ----------
        width (float): the width of the entity

        length (float): the lenght of the entity

        height (float): the height of the entity

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;

    def __init__(self, width, length, height):
        &#34;&#34;&#34;initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

        &#34;&#34;&#34;
        self.width = convert_float(width)
        self.length = convert_float(length)
        self.height = convert_float(height)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element to Dimensions

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)

        Returns
        ------
            dimension (Dimensions): a Dimensions object

        &#34;&#34;&#34;
        width = convert_float(element.attrib[&#34;width&#34;])
        height = convert_float(element.attrib[&#34;height&#34;])
        length = convert_float(element.attrib[&#34;length&#34;])
        return Dimensions(width, length, height)

    def __eq__(self, other):
        if isinstance(other, Dimensions):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes as a dict of the Dimensions&#34;&#34;&#34;
        return {
            &#34;width&#34;: str(self.width),
            &#34;length&#34;: str(self.length),
            &#34;height&#34;: str(self.height),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Dimensions&#34;&#34;&#34;
        element = ET.Element(&#34;Dimensions&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>the Dimensions describes the size of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Dimensions</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Dimensions.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element to Dimensions

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)

    Returns
    ------
        dimension (Dimensions): a Dimensions object

    &#34;&#34;&#34;
    width = convert_float(element.attrib[&#34;width&#34;])
    height = convert_float(element.attrib[&#34;height&#34;])
    length = convert_float(element.attrib[&#34;length&#34;])
    return Dimensions(width, length, height)</code></pre>
</details>
<div class="desc"><p>Parses the xml element to Dimensions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>dimension (Dimensions): a Dimensions object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Dimensions.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes as a dict of the Dimensions&#34;&#34;&#34;
    return {
        &#34;width&#34;: str(self.width),
        &#34;length&#34;: str(self.length),
        &#34;height&#34;: str(self.height),
    }</code></pre>
</details>
<div class="desc"><p>returns the attributes as a dict of the Dimensions</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Dimensions.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Dimensions&#34;&#34;&#34;
    element = ET.Element(&#34;Dimensions&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Dimensions</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.DirectionOfTravelDistribution"><code class="flex name class">
<span>class <span class="ident">DirectionOfTravelDistribution</span></span>
<span>(</span><span>opposite, same)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectionOfTravelDistribution(VersionBase):
    &#34;&#34;&#34;The DirectionOfTravelDistribution is used by SwarmTraffic to define how the traffic should flow

    Parameters
    ----------
        opposite (float): weight of traffic going against the reference entity

        same (float): weight of traffic going the same way the reference entity

    Attributes
    ----------

        opposite (float): weight of traffic going against the reference entity

        same (float): weight of traffic going the same way the reference entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, opposite, same):
        &#34;&#34;&#34;initalizes the DirectionOfTravelDistribution

        Parameters
        ----------
        opposite (float): weight of traffic going against the reference entity

        same (float): weight of traffic going the same way the reference entity

        &#34;&#34;&#34;
        self.opposite = convert_float(opposite)
        self.same = convert_float(same)

    def __eq__(self, other):
        if isinstance(other, DirectionOfTravelDistribution):
            if other.get_attributes() == self.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of a DirectionOfTravelDistribution

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a DirectionOfTravelDistribution element

        Returns
        -------
            DirectionOfTravelDistribution (DirectionOfTravelDistribution): a DirectionOfTravelDistribution object

        &#34;&#34;&#34;

        return DirectionOfTravelDistribution(
            convert_float(element.attrib[&#34;opposite&#34;]),
            convert_float(element.attrib[&#34;same&#34;]),
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DirectionOfTravelDistribution as a dict&#34;&#34;&#34;
        retdict = {&#34;opposite&#34;: str(self.opposite), &#34;same&#34;: str(self.same)}
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the DirectionOfTravelDistribution&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;DirectionOfTravelDistribution was introduced in OpenSCENARIO V1.2&#34;
            )

        element = ET.Element(
            &#34;DirectionOfTravelDistribution&#34;, attrib=self.get_attributes()
        )
        return element</code></pre>
</details>
<div class="desc"><p>The DirectionOfTravelDistribution is used by SwarmTraffic to define how the traffic should flow</p>
<h2 id="parameters">Parameters</h2>
<pre><code>opposite (float): weight of traffic going against the reference entity

same (float): weight of traffic going the same way the reference entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>opposite (float): weight of traffic going against the reference entity

same (float): weight of traffic going the same way the reference entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the DirectionOfTravelDistribution</p>
<h2 id="parameters_1">Parameters</h2>
<p>opposite (float): weight of traffic going against the reference entity</p>
<p>same (float): weight of traffic going the same way the reference entity</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of a DirectionOfTravelDistribution

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a DirectionOfTravelDistribution element

    Returns
    -------
        DirectionOfTravelDistribution (DirectionOfTravelDistribution): a DirectionOfTravelDistribution object

    &#34;&#34;&#34;

    return DirectionOfTravelDistribution(
        convert_float(element.attrib[&#34;opposite&#34;]),
        convert_float(element.attrib[&#34;same&#34;]),
    )</code></pre>
</details>
<div class="desc"><p>Parses the xml element of a DirectionOfTravelDistribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a DirectionOfTravelDistribution element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>DirectionOfTravelDistribution (DirectionOfTravelDistribution): a DirectionOfTravelDistribution object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the DirectionOfTravelDistribution as a dict&#34;&#34;&#34;
    retdict = {&#34;opposite&#34;: str(self.opposite), &#34;same&#34;: str(self.same)}
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the DirectionOfTravelDistribution as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the DirectionOfTravelDistribution&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;DirectionOfTravelDistribution was introduced in OpenSCENARIO V1.2&#34;
        )

    element = ET.Element(
        &#34;DirectionOfTravelDistribution&#34;, attrib=self.get_attributes()
    )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the DirectionOfTravelDistribution</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints"><code class="flex name class">
<span>class <span class="ident">DynamicsConstraints</span></span>
<span>(</span><span>max_acceleration=None,<br>max_deceleration=None,<br>max_speed=None,<br>max_acceleration_rate=None,<br>max_deceleration_rate=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicsConstraints(VersionBase):
    &#34;&#34;&#34;DynamicsConstraints is used by triggers

    Parameters
    ----------
        max_acceleration (float): maximum acceleration allowed

        max_deceleration (float): maximum deceleration allowed

        max_speed (float): maximum speed allowed

        max_acceleration_rate (float): maximum acceleration rate allowed

        max_deceleration_rate (float): maximum deceleration rate allowed

    Attributes
    ----------
        max_acceleration (float): maximum acceleration allowed

        max_deceleration (float): maximum deceleration allowed

        max_speed (float): maximum speed allowed

        max_acceleration_rate (float): maximum acceleration rate allowed

        max_deceleration_rate (float): maximum deceleration rate allowed

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        is_filled()
            check is any constraints are set

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        max_acceleration=None,
        max_deceleration=None,
        max_speed=None,
        max_acceleration_rate=None,
        max_deceleration_rate=None,
    ):
        &#34;&#34;&#34;initalize DynamicsConstrains&#34;&#34;&#34;

        self.max_acceleration = convert_float(max_acceleration)
        self.max_deceleration = convert_float(max_deceleration)
        self.max_speed = convert_float(max_speed)
        self.max_acceleration_rate = convert_float(max_acceleration_rate)
        self.max_deceleration_rate = convert_float(max_deceleration_rate)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of DynamicsConstraints

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)

        Returns
        -------
            constrains (DynamicsConstrains): a DynamicsConstrains object

        &#34;&#34;&#34;
        max_acceleration = None
        max_deceleration = None
        max_speed = None
        max_acceleration_rate = None
        max_deceleration_rate = None

        if &#34;maxAcceleration&#34; in element.attrib:
            max_acceleration = convert_float(element.attrib[&#34;maxAcceleration&#34;])
        if &#34;maxDeceleration&#34; in element.attrib:
            max_deceleration = convert_float(element.attrib[&#34;maxDeceleration&#34;])
        if &#34;maxSpeed&#34; in element.attrib:
            max_speed = convert_float(element.attrib[&#34;maxSpeed&#34;])
        if &#34;maxAccelerationRate&#34; in element.attrib:
            max_acceleration_rate = convert_float(element.attrib[&#34;maxAccelerationRate&#34;])
        if &#34;maxDecelerationRate&#34; in element.attrib:
            max_deceleration_rate = convert_float(element.attrib[&#34;maxDecelerationRate&#34;])

        return DynamicsConstraints(
            max_acceleration,
            max_deceleration,
            max_speed,
            max_acceleration_rate,
            max_deceleration_rate,
        )

    def __eq__(self, other):
        if isinstance(other, DynamicsConstraints):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def is_filled(self):
        &#34;&#34;&#34;is_filled check is any constraints are set

        Returns: boolean

        &#34;&#34;&#34;

        if self.max_acceleration or self.max_deceleration or self.max_speed:
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the DynamicsConstrains as a dict&#34;&#34;&#34;
        retdict = {}
        if self.max_speed is not None:
            retdict[&#34;maxSpeed&#34;] = str(self.max_speed)
        if self.max_deceleration is not None:
            retdict[&#34;maxDeceleration&#34;] = str(self.max_deceleration)
        if self.max_acceleration is not None:
            retdict[&#34;maxAcceleration&#34;] = str(self.max_acceleration)
        if self.max_acceleration_rate is not None:
            if not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxAccelerationRate was introduced in OpenSCENARIO V1.2&#34;
                )
            retdict[&#34;maxAccelerationRate&#34;] = str(self.max_acceleration_rate)
        if self.max_deceleration_rate is not None:
            if not self.isVersion(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;maxDecelerationRate was introduced in OpenSCENARIO V1.2&#34;
                )
            retdict[&#34;maxDecelerationRate&#34;] = str(self.max_deceleration_rate)
        return retdict

    def get_element(self, name=&#34;DynamicConstraints&#34;):
        &#34;&#34;&#34;returns the elementTree of the DynamicsConstrains&#34;&#34;&#34;
        return ET.Element(name, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>DynamicsConstraints is used by triggers</p>
<h2 id="parameters">Parameters</h2>
<pre><code>max_acceleration (float): maximum acceleration allowed

max_deceleration (float): maximum deceleration allowed

max_speed (float): maximum speed allowed

max_acceleration_rate (float): maximum acceleration rate allowed

max_deceleration_rate (float): maximum deceleration rate allowed
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>max_acceleration (float): maximum acceleration allowed

max_deceleration (float): maximum deceleration allowed

max_speed (float): maximum speed allowed

max_acceleration_rate (float): maximum acceleration rate allowed

max_deceleration_rate (float): maximum deceleration rate allowed
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

is_filled()
    check is any constraints are set

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize DynamicsConstrains</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of DynamicsConstraints

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)

    Returns
    -------
        constrains (DynamicsConstrains): a DynamicsConstrains object

    &#34;&#34;&#34;
    max_acceleration = None
    max_deceleration = None
    max_speed = None
    max_acceleration_rate = None
    max_deceleration_rate = None

    if &#34;maxAcceleration&#34; in element.attrib:
        max_acceleration = convert_float(element.attrib[&#34;maxAcceleration&#34;])
    if &#34;maxDeceleration&#34; in element.attrib:
        max_deceleration = convert_float(element.attrib[&#34;maxDeceleration&#34;])
    if &#34;maxSpeed&#34; in element.attrib:
        max_speed = convert_float(element.attrib[&#34;maxSpeed&#34;])
    if &#34;maxAccelerationRate&#34; in element.attrib:
        max_acceleration_rate = convert_float(element.attrib[&#34;maxAccelerationRate&#34;])
    if &#34;maxDecelerationRate&#34; in element.attrib:
        max_deceleration_rate = convert_float(element.attrib[&#34;maxDecelerationRate&#34;])

    return DynamicsConstraints(
        max_acceleration,
        max_deceleration,
        max_speed,
        max_acceleration_rate,
        max_deceleration_rate,
    )</code></pre>
</details>
<div class="desc"><p>Parses the xml element of DynamicsConstraints</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>constrains (DynamicsConstrains): a DynamicsConstrains object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the DynamicsConstrains as a dict&#34;&#34;&#34;
    retdict = {}
    if self.max_speed is not None:
        retdict[&#34;maxSpeed&#34;] = str(self.max_speed)
    if self.max_deceleration is not None:
        retdict[&#34;maxDeceleration&#34;] = str(self.max_deceleration)
    if self.max_acceleration is not None:
        retdict[&#34;maxAcceleration&#34;] = str(self.max_acceleration)
    if self.max_acceleration_rate is not None:
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;maxAccelerationRate was introduced in OpenSCENARIO V1.2&#34;
            )
        retdict[&#34;maxAccelerationRate&#34;] = str(self.max_acceleration_rate)
    if self.max_deceleration_rate is not None:
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;maxDecelerationRate was introduced in OpenSCENARIO V1.2&#34;
            )
        retdict[&#34;maxDecelerationRate&#34;] = str(self.max_deceleration_rate)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the DynamicsConstrains as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, name='DynamicConstraints')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, name=&#34;DynamicConstraints&#34;):
    &#34;&#34;&#34;returns the elementTree of the DynamicsConstrains&#34;&#34;&#34;
    return ET.Element(name, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the DynamicsConstrains</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.is_filled"><code class="name flex">
<span>def <span class="ident">is_filled</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_filled(self):
    &#34;&#34;&#34;is_filled check is any constraints are set

    Returns: boolean

    &#34;&#34;&#34;

    if self.max_acceleration or self.max_deceleration or self.max_speed:
        return True
    else:
        return False</code></pre>
</details>
<div class="desc"><p>is_filled check is any constraints are set</p>
<p>Returns: boolean</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.EntityRef"><code class="flex name class">
<span>class <span class="ident">EntityRef</span></span>
<span>(</span><span>entity)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntityRef(VersionBase):
    &#34;&#34;&#34;EntityRef creates an EntityRef element of openscenario

    Parameters
    ----------
        entity (str): name of the entity

    Attributes
    ----------
        entity (str): name of the entity

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, entity):
        &#34;&#34;&#34;initalize the EntityRef

        Parameters
        ----------
            entity (str): name of the entity

        &#34;&#34;&#34;
        self.entity = entity

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of EntityRef

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)

        Returns
        -------
            entityref (EntityRef): a EntityRef object

        &#34;&#34;&#34;
        entity = element.attrib[&#34;entityRef&#34;]
        return EntityRef(entity)

    def __eq__(self, other):
        if isinstance(other, EntityRef):
            if self.entity == other.entity:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the EntityRef as a dict&#34;&#34;&#34;
        return {&#34;entityRef&#34;: self.entity}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the EntityRef&#34;&#34;&#34;
        return ET.Element(&#34;EntityRef&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>EntityRef creates an EntityRef element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): name of the entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): name of the entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the EntityRef</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): name of the entity
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.EntityRef.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of EntityRef

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)

    Returns
    -------
        entityref (EntityRef): a EntityRef object

    &#34;&#34;&#34;
    entity = element.attrib[&#34;entityRef&#34;]
    return EntityRef(entity)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of EntityRef</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>entityref (EntityRef): a EntityRef object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.EntityRef.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the EntityRef as a dict&#34;&#34;&#34;
    return {&#34;entityRef&#34;: self.entity}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the EntityRef as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.EntityRef.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the EntityRef&#34;&#34;&#34;
    return ET.Element(&#34;EntityRef&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the EntityRef</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>name, timeofday=None, weather=None, roadcondition=None, parameters=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment(_BaseCatalog):
    &#34;&#34;&#34;The Environment class creates a environment used by Environment

    Parameters
    ----------
        name (string): Name of the environment. If used in catalog name is required.

        timeofday (TimeOfDay): time of day for the environment

        weather (Weather): weather of the environment

        roadcondition (RoadCondition): road condition of the environment

        parameters (ParameterDeclarations): the parameters to be used in the scenario
            Default: None

    Attributes
    ----------
        name (string): Name of the environment. If used in catalog name is required.

        timeofday (TimeOfDay): time of day for the environment

        weather (Weather): weather of the environment

        roadcondition (RoadCondition): road condition of the environment

        parameters (ParameterDeclarations): the parameters to be used in the scenario

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        append_to_catalog(filename)
            adds the vehicle to an existing catalog

        dump_to_catalog(filename,name,description,author)
            crates a new catalog with the vehicle

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(
        self, name, timeofday=None, weather=None, roadcondition=None, parameters=None
    ):
        &#34;&#34;&#34;initalize the Environment

        Parameters
        ----------
            name (string): Name of the environment. If used in catalog name is required.

            timeofday (TimeOfDay): time of day for the environment

            weather (Weather): weather of the environment

            roadcondition (RoadCondition): road condition of the environment

            parameters (ParameterDeclarations): the parameters to be used in the scenario
                Default: None
        &#34;&#34;&#34;
        super().__init__()
        self.name = name
        if timeofday is not None and not isinstance(timeofday, TimeOfDay):
            raise TypeError(&#34;timeofday input is not of type TimeOfDay&#34;)
        if weather is not None and not isinstance(weather, Weather):
            raise TypeError(&#34;weather input is not of type Weather&#34;)
        if roadcondition is not None and not isinstance(roadcondition, RoadCondition):
            raise TypeError(&#34;roadcondition input is not of type RoadCondition&#34;)
        if parameters is not None and not isinstance(parameters, ParameterDeclarations):
            raise TypeError(&#34;parameters input is not of type ParameterDeclarations&#34;)
        self.timeofday = timeofday
        self.weather = weather
        self.roadcondition = roadcondition
        if parameters is not None:
            self.parameters = parameters

    def __eq__(self, other):
        if isinstance(other, Environment):
            if (
                self.get_attributes() == other.get_attributes()
                and self.timeofday == other.timeofday
                and self.weather == other.weather
                and self.roadcondition == other.roadcondition
                and self.parameters == other.parameters
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Environment

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)

        Returns
        -------
            environment (Environment): a Environment object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        parameters = None
        weather = None
        timeofday = None
        roadcondition = None

        if element.find(&#34;ParameterDeclarations&#34;) != None:
            parameters = ParameterAssignment.parse(element.find(&#34;ParamterDeclarations&#34;))
        if element.find(&#34;TimeOfDay&#34;) != None:
            timeofday = TimeOfDay.parse(element.find(&#34;TimeOfDay&#34;))
        if element.find(&#34;Weather&#34;) != None:
            weather = Weather.parse(element.find(&#34;Weather&#34;))
        if element.find(&#34;RoadCondition&#34;) != None:
            roadcondition = RoadCondition.parse(element.find(&#34;RoadCondition&#34;))

        return Environment(name, timeofday, weather, roadcondition, parameters)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Environment as a dict&#34;&#34;&#34;
        return {&#34;name&#34;: str(self.name)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Environment&#34;&#34;&#34;
        element = ET.Element(&#34;Environment&#34;, attrib=self.get_attributes())
        if self.timeofday:
            element.append(self.timeofday.get_element())
        if self.weather:
            element.append(self.weather.get_element())
        if self.roadcondition:
            element.append(self.roadcondition.get_element())
        self.add_parameters_to_element(element)
        return element</code></pre>
</details>
<div class="desc"><p>The Environment class creates a environment used by Environment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

append_to_catalog(filename)
    adds the vehicle to an existing catalog

dump_to_catalog(filename,name,description,author)
    crates a new catalog with the vehicle

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the Environment</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._BaseCatalog</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Environment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Environment

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)

    Returns
    -------
        environment (Environment): a Environment object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    parameters = None
    weather = None
    timeofday = None
    roadcondition = None

    if element.find(&#34;ParameterDeclarations&#34;) != None:
        parameters = ParameterAssignment.parse(element.find(&#34;ParamterDeclarations&#34;))
    if element.find(&#34;TimeOfDay&#34;) != None:
        timeofday = TimeOfDay.parse(element.find(&#34;TimeOfDay&#34;))
    if element.find(&#34;Weather&#34;) != None:
        weather = Weather.parse(element.find(&#34;Weather&#34;))
    if element.find(&#34;RoadCondition&#34;) != None:
        roadcondition = RoadCondition.parse(element.find(&#34;RoadCondition&#34;))

    return Environment(name, timeofday, weather, roadcondition, parameters)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Environment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>environment (Environment): a Environment object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Environment.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Environment as a dict&#34;&#34;&#34;
    return {&#34;name&#34;: str(self.name)}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Environment as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Environment&#34;&#34;&#34;
    element = ET.Element(&#34;Environment&#34;, attrib=self.get_attributes())
    if self.timeofday:
        element.append(self.timeofday.get_element())
    if self.weather:
        element.append(self.weather.get_element())
    if self.roadcondition:
        element.append(self.roadcondition.get_element())
    self.add_parameters_to_element(element)
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Environment</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.FileHeader"><code class="flex name class">
<span>class <span class="ident">FileHeader</span></span>
<span>(</span><span>author, description, revMinor=2, license=None, creation_date=None, properties=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileHeader(VersionBase):
    &#34;&#34;&#34;FileHeader creates the header of the OpenScenario file1

    Parameters
    ----------
        name (str): name of the scenario

        author (str): the author of the scenario

        revMinor (int): the minor revision of the standard
            Default: 2

        license (License): license (valid from OpenSCENARIO V1.1)
            Default: None

        creation_date (datetime.datetime): optional hardcoded creation date
            Default: datetime.datetime.now() (when actually generating the xml)

        properties (Properties): additional info about the scenario
            Default: None
    Attributes
    ----------
        name (str): name of the scenario

        author (str): the author of the scenario

        license (License): license (valid from OpenSCENARIO V1.1)

        creation_date (datetime.datetime): optional hardcoded creation date

        properties (Properties): additional info about the scenarios
    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of FileHeader

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;

    def __init__(
        self,
        author,
        description,
        revMinor=_MINOR_VERSION,
        license=None,
        creation_date=None,
        properties=None,
    ):
        &#34;&#34;&#34;FileHeader creates the header of the OpenScenario file1

        Parameters
        ----------
            name (str): name of the scenario

            author (str): the author of the scenario

            revMinor (int): the minor revision of the standard
                Default: 1

            license (License): license (valid from OpenSCENARIO V1.1)
                Default: None

            creation_date (datetime.datetime): optional hardcoded creation date
                Default: datetime.datetime.now() (when actually generating the xml)
            properties (Properties): additional info about the scenario
                Default: None
        &#34;&#34;&#34;
        self.description = description
        self.author = author
        self._revMajor = 1
        self._revMinor = revMinor
        self.creation_date = creation_date
        self.setVersion(minor=revMinor)
        if license and not isinstance(license, License):
            raise TypeError(&#34;license is not of type License&#34;)
        self.license = license
        if properties and not isinstance(properties, Properties):
            raise TypeError(&#34;properties is not of type Properties&#34;)
        self.properties = properties

    def __eq__(self, other):
        if isinstance(other, FileHeader):
            if (
                self.description == other.description
                and self.author == other.author
                and self._revMajor == other._revMajor
                and self._revMinor == other._revMinor
                and self.properties == other.properties
            ):
                # will not compare date, since this will never be the same
                return True
        return False

    # TODO: License handling add_license ???

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of FileHeader

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)

        Returns
        -------
            header (FileHeader): a FileHeader object

        &#34;&#34;&#34;
        author = element.attrib[&#34;author&#34;]
        description = element.attrib[&#34;description&#34;]
        # revMinor = element.attrib[&#39;revMinor&#39;]
        # revMajor = element.attrib[&#39;revMajor&#39;]
        license = None
        if element.find(&#34;license&#34;) != None:
            license = License.parse(element.find(&#34;license&#34;))

        return FileHeader(author=author, description=description, license=license)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes as a dict of the FileHeader&#34;&#34;&#34;
        retdict = {
            &#34;description&#34;: self.description,
            &#34;author&#34;: self.author,
            &#34;revMajor&#34;: str(self.version_major),
            &#34;revMinor&#34;: str(self.version_minor),
        }
        if self.creation_date != None:
            retdict[&#34;date&#34;] = self.creation_date.isoformat()
        else:
            retdict[&#34;date&#34;] = dt.datetime.now().isoformat()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the FileHeader&#34;&#34;&#34;
        element = ET.Element(&#34;FileHeader&#34;, attrib=self.get_attributes())
        if self.license:
            if self.isVersionEqLarger(minor=1):
                element.append(self.license.get_element())
            else:
                raise OpenSCENARIOVersionError(
                    &#34;License in FileHeader was introduced in OSC 1.1&#34;
                )
        if self.properties:
            if self.isVersionEqLarger(minor=2):
                element.append(self.properties.get_element())
            else:
                raise OpenSCENARIOVersionError(
                    &#34;Properties in FileHeader was introduced in OSC 1.2&#34;
                )

        return element</code></pre>
</details>
<div class="desc"><p>FileHeader creates the header of the OpenScenario file1</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the scenario

author (str): the author of the scenario

revMinor (int): the minor revision of the standard
    Default: 2

license (License): license (valid from OpenSCENARIO V1.1)
    Default: None

creation_date (datetime.datetime): optional hardcoded creation date
    Default: datetime.datetime.now() (when actually generating the xml)

properties (Properties): additional info about the scenario
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the scenario

author (str): the author of the scenario

license (License): license (valid from OpenSCENARIO V1.1)

creation_date (datetime.datetime): optional hardcoded creation date

properties (Properties): additional info about the scenarios
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of FileHeader

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre>
<p>FileHeader creates the header of the OpenScenario file1</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the scenario

author (str): the author of the scenario

revMinor (int): the minor revision of the standard
    Default: 1

license (License): license (valid from OpenSCENARIO V1.1)
    Default: None

creation_date (datetime.datetime): optional hardcoded creation date
    Default: datetime.datetime.now() (when actually generating the xml)
properties (Properties): additional info about the scenario
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.FileHeader.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of FileHeader

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)

    Returns
    -------
        header (FileHeader): a FileHeader object

    &#34;&#34;&#34;
    author = element.attrib[&#34;author&#34;]
    description = element.attrib[&#34;description&#34;]
    # revMinor = element.attrib[&#39;revMinor&#39;]
    # revMajor = element.attrib[&#39;revMajor&#39;]
    license = None
    if element.find(&#34;license&#34;) != None:
        license = License.parse(element.find(&#34;license&#34;))

    return FileHeader(author=author, description=description, license=license)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of FileHeader</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>header (FileHeader): a FileHeader object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.FileHeader.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes as a dict of the FileHeader&#34;&#34;&#34;
    retdict = {
        &#34;description&#34;: self.description,
        &#34;author&#34;: self.author,
        &#34;revMajor&#34;: str(self.version_major),
        &#34;revMinor&#34;: str(self.version_minor),
    }
    if self.creation_date != None:
        retdict[&#34;date&#34;] = self.creation_date.isoformat()
    else:
        retdict[&#34;date&#34;] = dt.datetime.now().isoformat()
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes as a dict of the FileHeader</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.FileHeader.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the FileHeader&#34;&#34;&#34;
    element = ET.Element(&#34;FileHeader&#34;, attrib=self.get_attributes())
    if self.license:
        if self.isVersionEqLarger(minor=1):
            element.append(self.license.get_element())
        else:
            raise OpenSCENARIOVersionError(
                &#34;License in FileHeader was introduced in OSC 1.1&#34;
            )
    if self.properties:
        if self.isVersionEqLarger(minor=2):
            element.append(self.properties.get_element())
        else:
            raise OpenSCENARIOVersionError(
                &#34;Properties in FileHeader was introduced in OSC 1.2&#34;
            )

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the FileHeader</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Fog"><code class="flex name class">
<span>class <span class="ident">Fog</span></span>
<span>(</span><span>visual_range, bounding_box=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fog(VersionBase):
    &#34;&#34;&#34;Fog creates an Fog element used by the Weather element of openscenario

    Parameters
    ----------
        visual_range (int): visual range of fog

        bounding_box (BoundingBox): bounding box of fog
            Default: None

    Attributes
    ----------
        visual_range (int): visual range of fog

        bounding_box (BoundingBox): bounding box of fog

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, visual_range, bounding_box=None):
        &#34;&#34;&#34;initalize the Fog

        Parameters
        ----------
            visual_range (int): visual range of fog

            bounding_box (BoundingBox): bounding box of fog
                Default: None

        &#34;&#34;&#34;

        self.visual_range = visual_range
        if bounding_box and not isinstance(bounding_box, BoundingBox):
            raise TypeError(&#34;bounding_box not of type BoundingBox&#34;)
        self.bounding_box = bounding_box

    def __eq__(self, other):
        if isinstance(other, Fog):
            if (
                self.get_attributes() == other.get_attributes()
                and self.bounding_box == other.bounding_box
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Fog

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)

        Returns
        -------
            fog (Fog): a Fog object

        &#34;&#34;&#34;

        visual_range = element.attrib[&#34;visualRange&#34;]
        bounding_box = None
        if element.find(&#34;BoundingBox&#34;) != None:
            bounding_box = BoundingBox.parse(element.find(&#34;BoundingBox&#34;))

        return Fog(visual_range, bounding_box)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;visualRange&#34;] = str(self.visual_range)

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Fog&#34;&#34;&#34;
        element = ET.Element(&#34;Fog&#34;, attrib=self.get_attributes())
        if self.bounding_box is not None:
            element.append(self.bounding_box.get_element())

        return element</code></pre>
</details>
<div class="desc"><p>Fog creates an Fog element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Fog</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Fog.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Fog

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)

    Returns
    -------
        fog (Fog): a Fog object

    &#34;&#34;&#34;

    visual_range = element.attrib[&#34;visualRange&#34;]
    bounding_box = None
    if element.find(&#34;BoundingBox&#34;) != None:
        bounding_box = BoundingBox.parse(element.find(&#34;BoundingBox&#34;))

    return Fog(visual_range, bounding_box)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Fog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>fog (Fog): a Fog object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Fog.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;visualRange&#34;] = str(self.visual_range)

    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Fog.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Fog&#34;&#34;&#34;
    element = ET.Element(&#34;Fog&#34;, attrib=self.get_attributes())
    if self.bounding_box is not None:
        element.append(self.bounding_box.get_element())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Fog</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.License"><code class="flex name class">
<span>class <span class="ident">License</span></span>
<span>(</span><span>name, resource=None, spdxId=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class License(VersionBase):
    &#34;&#34;&#34;License creates the License used by FileHeader in the OpenScenario file
    (valid from OpenSCENARIO V1.1)

    Parameters
    ----------
        name (str): name of the License

        resource (str): link to URL
            Default: None

        spdxId (str): license identifier
            Default: None

    Attributes
    ----------
        name (str): name of the License

        resource (str): link to URL

        spdxId (str): license identifier

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of FileHeader

        get_attributes()
            Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;

    def __init__(self, name, resource=None, spdxId=None):
        &#34;&#34;&#34;init the License

        Parameters
        ----------
            name (str): name of the License

            resource (str): link to URL
                Default: None

            spdxId (str): license identifier
                Default: None
        &#34;&#34;&#34;
        self.name = name
        self.resource = resource
        self.spdxId = spdxId

    def __eq__(self, other):
        if isinstance(other, License):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    # TODO: Check Class License test string 0..1 The full license

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of License

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)

        Returns
        -------
            license (License): a License object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        resource = None
        if &#34;resource&#34; in element.attrib:
            resource = element.attrib[&#34;resource&#34;]
        spdxId = None
        if &#34;spdxId&#34; in element.attrib:
            spdxId = element.attrib[&#34;spdxId&#34;]

        return License(name, resource, spdxId)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes as a dict of the License&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        if self.resource:
            retdict[&#34;resource&#34;] = self.resource
        if self.spdxId:
            retdict[&#34;spdxId&#34;] = self.spdxId
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the License&#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;License was introduced in OpenSCENARIO V1.1&#34;
            )
        element = ET.Element(&#34;License&#34;, attrib=self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>License creates the License used by FileHeader in the OpenScenario file
(valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the License

resource (str): link to URL
    Default: None

spdxId (str): license identifier
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the License

resource (str): link to URL

spdxId (str): license identifier
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of FileHeader

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre>
<p>init the License</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the License

resource (str): link to URL
    Default: None

spdxId (str): license identifier
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.License.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of License

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)

    Returns
    -------
        license (License): a License object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    resource = None
    if &#34;resource&#34; in element.attrib:
        resource = element.attrib[&#34;resource&#34;]
    spdxId = None
    if &#34;spdxId&#34; in element.attrib:
        spdxId = element.attrib[&#34;spdxId&#34;]

    return License(name, resource, spdxId)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of License</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>license (License): a License object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.License.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes as a dict of the License&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    if self.resource:
        retdict[&#34;resource&#34;] = self.resource
    if self.spdxId:
        retdict[&#34;spdxId&#34;] = self.spdxId
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes as a dict of the License</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.License.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the License&#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;License was introduced in OpenSCENARIO V1.1&#34;
        )
    element = ET.Element(&#34;License&#34;, attrib=self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the License</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation"><code class="flex name class">
<span>class <span class="ident">Orientation</span></span>
<span>(</span><span>h=None, p=None, r=None, reference=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orientation(VersionBase):
    &#34;&#34;&#34;Orientation describes the angular orientation of an entity

    Parameters
    ----------
        h (float): header

        p (float): pitch

        r (float): roll

        reference (ReferenceContext): absolute or relative

    Attributes
    ----------
        h (float): header

        p (float): pitch

        r (float): roll

        reference (ReferenceContext): absolute or relative

    Methods
    -------
        is_filled()
            check is any orientations are set

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, h=None, p=None, r=None, reference=None):
        &#34;&#34;&#34;initalize Orientation

        Parameters
        ----------
            h (float): header

            p (float): pitch

            r (float): roll

            reference (ReferenceContext): absolute or relative
        &#34;&#34;&#34;
        self.h = convert_float(h)
        self.p = convert_float(p)
        self.r = convert_float(r)
        self.ref = convert_enum(reference, ReferenceContext, True)

    def __eq__(self, other):
        if isinstance(other, Orientation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Orientation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            orientation (Orientation): a Orientation object

        &#34;&#34;&#34;
        h = None
        p = None
        r = None
        reference = None
        if &#34;h&#34; in element.attrib:
            h = convert_float(element.attrib[&#34;h&#34;])
        if &#34;p&#34; in element.attrib:
            p = convert_float(element.attrib[&#34;p&#34;])
        if &#34;r&#34; in element.attrib:
            r = convert_float(element.attrib[&#34;r&#34;])
        if &#34;type&#34; in element.attrib:
            reference_str = element.attrib[&#34;type&#34;]
            reference = convert_enum(reference_str, ReferenceContext, False)

        return Orientation(h, p, r, reference)

    def is_filled(self):
        &#34;&#34;&#34;is_filled check is any orientations are  set

        Returns: boolean

        &#34;&#34;&#34;
        if (
            self.h is not None
            or self.p is not None
            or self.r is not None
            or self.ref is not None
        ):
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Orientation as a dict&#34;&#34;&#34;
        retdict = {}
        if self.h is not None:
            retdict[&#34;h&#34;] = str(self.h)

        if self.p is not None:
            retdict[&#34;p&#34;] = str(self.p)

        if self.r is not None:
            retdict[&#34;r&#34;] = str(self.r)

        if self.ref is not None:
            retdict[&#34;type&#34;] = self.ref.get_name()

        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Orientation&#34;&#34;&#34;
        return ET.Element(&#34;Orientation&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>Orientation describes the angular orientation of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>is_filled()
    check is any orientations are set

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize Orientation</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Orientation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Orientation

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

    Returns
    -------
        orientation (Orientation): a Orientation object

    &#34;&#34;&#34;
    h = None
    p = None
    r = None
    reference = None
    if &#34;h&#34; in element.attrib:
        h = convert_float(element.attrib[&#34;h&#34;])
    if &#34;p&#34; in element.attrib:
        p = convert_float(element.attrib[&#34;p&#34;])
    if &#34;r&#34; in element.attrib:
        r = convert_float(element.attrib[&#34;r&#34;])
    if &#34;type&#34; in element.attrib:
        reference_str = element.attrib[&#34;type&#34;]
        reference = convert_enum(reference_str, ReferenceContext, False)

    return Orientation(h, p, r, reference)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Orientation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>orientation (Orientation): a Orientation object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Orientation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Orientation as a dict&#34;&#34;&#34;
    retdict = {}
    if self.h is not None:
        retdict[&#34;h&#34;] = str(self.h)

    if self.p is not None:
        retdict[&#34;p&#34;] = str(self.p)

    if self.r is not None:
        retdict[&#34;r&#34;] = str(self.r)

    if self.ref is not None:
        retdict[&#34;type&#34;] = self.ref.get_name()

    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Orientation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Orientation&#34;&#34;&#34;
    return ET.Element(&#34;Orientation&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Orientation</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation.is_filled"><code class="name flex">
<span>def <span class="ident">is_filled</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_filled(self):
    &#34;&#34;&#34;is_filled check is any orientations are  set

    Returns: boolean

    &#34;&#34;&#34;
    if (
        self.h is not None
        or self.p is not None
        or self.r is not None
        or self.ref is not None
    ):
        return True
    else:
        return False</code></pre>
</details>
<div class="desc"><p>is_filled check is any orientations are
set</p>
<p>Returns: boolean</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter"><code class="flex name class">
<span>class <span class="ident">Parameter</span></span>
<span>(</span><span>name, parameter_type, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parameter(VersionBase):
    &#34;&#34;&#34;Parameter is a declaration of a ParameterDeclaration for declarations

    Parameters
    ----------
        name (str): name of parameter

        parameter_type (ParameterType): type of the parameter

        value (str): value of the parameter

    Attributes
    ----------
        name (str): name of parameter

        parameter_type (ParameterType): type of the parameter

        value (str): value of the parameter

        constraint_group (ValueConstraintGroup) constraint groups to the parameter value

    Methods
    -------
        add_parameter ???

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_value_constraint_group(constraint_group)
            adds a value constraint group to the Parameter

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, parameter_type, value):
        &#34;&#34;&#34;initalize the Parameter

        Parameters
        ----------
            name (str): name of parameter

            parameter_type (ParameterType): type of the parameter

            value (str): value of the parameter

        &#34;&#34;&#34;
        self.name = name
        self.parameter_type = convert_enum(parameter_type, ParameterType, False)
        if isinstance(value, bool):
            value = get_bool_string(value)
        self.value = value
        self.constraint_groups = []

    def __eq__(self, other):
        if isinstance(other, Parameter):
            if (
                self.get_attributes() == other.get_attributes()
                and self.constraint_groups == other.constraint_groups
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Parameter

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)

        Returns
        -------
            parameter (Parameter): Parameter object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        value = element.attrib[&#34;value&#34;]
        parameter_type = convert_enum(
            element.attrib[&#34;parameterType&#34;], ParameterType, False
        )
        parameter = Parameter(name, parameter_type, value)
        constraint_groups = element.findall(&#34;ConstraintGroup&#34;)
        for constraint_group in constraint_groups:
            parameter.add_value_constraint_group(
                ValueConstraintGroup.parse(constraint_group)
            )
        return parameter

    def add_value_constraint_group(self, constraint_group):
        &#34;&#34;&#34;adds a value constraint to the value constraint group

        Parameters
        ----------
            constraint_group (ValueConstraintGroup): the value constraint group to be added

        &#34;&#34;&#34;
        if not isinstance(constraint_group, ValueConstraintGroup):
            raise TypeError(
                &#34;value_conatraint input is not of type ValueConstraintGroup&#34;
            )
        self.constraint_groups.append(constraint_group)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Parameter as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;parameterType&#34;: self.parameter_type.get_name(),
            &#34;value&#34;: str(self.value),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Parameter&#34;&#34;&#34;
        element = ET.Element(&#34;ParameterDeclaration&#34;, attrib=self.get_attributes())
        if self.constraint_groups:
            for constraint_group in self.constraint_groups:
                element.append(constraint_group.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Parameter is a declaration of a ParameterDeclaration for declarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter

constraint_group (ValueConstraintGroup) constraint groups to the parameter value
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_parameter ???

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_value_constraint_group(constraint_group)
    adds a value constraint group to the Parameter

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Parameter</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Parameter.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Parameter

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)

    Returns
    -------
        parameter (Parameter): Parameter object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    value = element.attrib[&#34;value&#34;]
    parameter_type = convert_enum(
        element.attrib[&#34;parameterType&#34;], ParameterType, False
    )
    parameter = Parameter(name, parameter_type, value)
    constraint_groups = element.findall(&#34;ConstraintGroup&#34;)
    for constraint_group in constraint_groups:
        parameter.add_value_constraint_group(
            ValueConstraintGroup.parse(constraint_group)
        )
    return parameter</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Parameter</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameter (Parameter): Parameter object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Parameter.add_value_constraint_group"><code class="name flex">
<span>def <span class="ident">add_value_constraint_group</span></span>(<span>self, constraint_group)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_value_constraint_group(self, constraint_group):
    &#34;&#34;&#34;adds a value constraint to the value constraint group

    Parameters
    ----------
        constraint_group (ValueConstraintGroup): the value constraint group to be added

    &#34;&#34;&#34;
    if not isinstance(constraint_group, ValueConstraintGroup):
        raise TypeError(
            &#34;value_conatraint input is not of type ValueConstraintGroup&#34;
        )
    self.constraint_groups.append(constraint_group)
    return self</code></pre>
</details>
<div class="desc"><p>adds a value constraint to the value constraint group</p>
<h2 id="parameters">Parameters</h2>
<pre><code>constraint_group (ValueConstraintGroup): the value constraint group to be added
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Parameter as a dict&#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;parameterType&#34;: self.parameter_type.get_name(),
        &#34;value&#34;: str(self.value),
    }</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Parameter as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Parameter&#34;&#34;&#34;
    element = ET.Element(&#34;ParameterDeclaration&#34;, attrib=self.get_attributes())
    if self.constraint_groups:
        for constraint_group in self.constraint_groups:
            element.append(constraint_group.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Parameter</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment"><code class="flex name class">
<span>class <span class="ident">ParameterAssignment</span></span>
<span>(</span><span>parameterref, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterAssignment(VersionBase):
    &#34;&#34;&#34;ParameterAssignment creates an ParameterAssignment element of openscenario

    Parameters
    ----------
        parameterref (str): name of the parameter

        value (str): assigned value of the parameter


    Attributes
    ----------
        parameterref (str): name of the parameter

        value (str): assigned value of the parameter

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, parameterref, value):
        &#34;&#34;&#34;initalize the ParameterAssignment

        Parameters
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter

        &#34;&#34;&#34;
        self.parameterref = parameterref
        self.value = value

    def __eq__(self, other):
        if isinstance(other, ParameterAssignment):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterAssignment

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)

        Returns
        -------
            parameterassignment (ParameterAssignment): a ParameterAssignment object

        &#34;&#34;&#34;

        value = element.attrib[&#34;value&#34;]
        parameterref = element.attrib[&#34;parameterRef&#34;]

        return ParameterAssignment(parameterref, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ParameterAssignment as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;parameterRef&#34;] = self.parameterref
        retdict[&#34;value&#34;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterAssignment&#34;&#34;&#34;
        return ET.Element(&#34;ParameterAssignment&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>ParameterAssignment creates an ParameterAssignment element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterAssignment</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterAssignment

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)

    Returns
    -------
        parameterassignment (ParameterAssignment): a ParameterAssignment object

    &#34;&#34;&#34;

    value = element.attrib[&#34;value&#34;]
    parameterref = element.attrib[&#34;parameterRef&#34;]

    return ParameterAssignment(parameterref, value)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ParameterAssignment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameterassignment (ParameterAssignment): a ParameterAssignment object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ParameterAssignment as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;parameterRef&#34;] = self.parameterref
    retdict[&#34;value&#34;] = str(self.value)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the ParameterAssignment as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterAssignment&#34;&#34;&#34;
    return ET.Element(&#34;ParameterAssignment&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ParameterAssignment</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations"><code class="flex name class">
<span>class <span class="ident">ParameterDeclarations</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterDeclarations(VersionBase):
    &#34;&#34;&#34;The ParameterDeclarations class creates the ParameterDeclaration of OpenScenario

    Attributes
    ----------
        parameters: list of Parameter objects

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_parameter(Parameter)
            adds a Parameter to the ParameterDeclarations

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;initalizes the ParameterDeclarations&#34;&#34;&#34;
        self.parameters = []

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ParameterDeclarations

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)

        Returns
        -------
            parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object

        &#34;&#34;&#34;
        parameter_declarations = ParameterDeclarations()
        declarations = element.findall(&#34;ParameterDeclaration&#34;)
        for declaration in declarations:
            parameter_declaration = Parameter.parse(declaration)
            parameter_declarations.add_parameter(parameter_declaration)
        return parameter_declarations

    def __eq__(self, other):
        if isinstance(other, ParameterDeclarations):
            if self.parameters == other.parameters:
                return True
        return False

    def add_parameter(self, parameter):
        &#34;&#34;&#34;add_parameter adds a Parameter to the ParameterDeclarations

        Parameters
        ----------
            parameter (Parameter): a new parameter


        &#34;&#34;&#34;
        if not isinstance(parameter, Parameter):
            raise TypeError(&#34;parameter input is not of type Parameter&#34;)
        self.parameters.append(parameter)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ParameterDeclarations&#34;&#34;&#34;
        if self.parameters:
            element = ET.Element(&#34;ParameterDeclarations&#34;)
            for p in self.parameters:
                element.append(p.get_element())
            return element</code></pre>
</details>
<div class="desc"><p>The ParameterDeclarations class creates the ParameterDeclaration of OpenScenario</p>
<h2 id="attributes">Attributes</h2>
<pre><code>parameters: list of Parameter objects
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_parameter(Parameter)
    adds a Parameter to the ParameterDeclarations

parse(element)
    parses a ElementTree created by the class and returns an instance of the class
</code></pre>
<p>initalizes the ParameterDeclarations</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ParameterDeclarations

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)

    Returns
    -------
        parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object

    &#34;&#34;&#34;
    parameter_declarations = ParameterDeclarations()
    declarations = element.findall(&#34;ParameterDeclaration&#34;)
    for declaration in declarations:
        parameter_declaration = Parameter.parse(declaration)
        parameter_declarations.add_parameter(parameter_declaration)
    return parameter_declarations</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ParameterDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter"><code class="name flex">
<span>def <span class="ident">add_parameter</span></span>(<span>self, parameter)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter(self, parameter):
    &#34;&#34;&#34;add_parameter adds a Parameter to the ParameterDeclarations

    Parameters
    ----------
        parameter (Parameter): a new parameter


    &#34;&#34;&#34;
    if not isinstance(parameter, Parameter):
        raise TypeError(&#34;parameter input is not of type Parameter&#34;)
    self.parameters.append(parameter)
    return self</code></pre>
</details>
<div class="desc"><p>add_parameter adds a Parameter to the ParameterDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter (Parameter): a new parameter
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ParameterDeclarations&#34;&#34;&#34;
    if self.parameters:
        element = ET.Element(&#34;ParameterDeclarations&#34;)
        for p in self.parameters:
            element.append(p.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ParameterDeclarations</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.PedestrianAnimation"><code class="flex name class">
<span>class <span class="ident">PedestrianAnimation</span></span>
<span>(</span><span>motion=None, animation=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PedestrianAnimation(_AnimationType):
    &#34;&#34;&#34;The PedestrianAnimation creates a PedestrianAnimation element used by AnimationType

    Parameters
    ----------
        motion (PedestrianMotionType): Motion of a pedestrian

        userDefinedPedestrianAnimation (str): User defined pedestrian animation

    Attributes
    ----------

        motion (PedestrianMotionType): Motion of a pedestrian

        userDefinedPedestrianAnimation (str): User defined pedestrian animation

        gestures (list of PedestrianGestureTpe): Gestures of a pedestrian

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_gesture(gesture)
            Adds a pedestrian gesture to the pedestrian animation

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, motion=None, animation=None):
        &#34;&#34;&#34;initalizes the PedestrianAnimation

        Parameters
        ----------
        motion (PedestrianMotionType): Motion of a pedestrian

        userDefinedPedestrianAnimation (str): User defined pedestrian animation

        &#34;&#34;&#34;
        self.motion = convert_enum(motion, PedestrianMotionType, True)
        self.animation = animation
        self.gestures = []

    def __eq__(self, other):
        if isinstance(other, PedestrianAnimation):
            if (
                other.get_attributes() == self.get_attributes()
                and other.gestures == self.gestures
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of a PedestrianAnimation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedAnimation element

        Returns
        -------
            PedestrianAnimation (PedestrianAnimation): a PedestrianAnimation object

        &#34;&#34;&#34;
        motion = convert_enum(element.attrib[&#34;motion&#34;], PedestrianMotionType)
        animation = element.attrib[&#34;userDefinedPedestrianAnimation&#34;]
        pa = PedestrianAnimation(motion, animation)

        for gesture in element.findall(&#34;PedestrianGesture&#34;):
            pa.add_gesture(
                convert_enum(gesture.attrib[&#34;gesture&#34;], PedestrianGestureType)
            )
        return pa

    def add_gesture(self, gesture):
        &#34;&#34;&#34;adds a pedestrian gesture to the vehicle

        Parameters
        ----------
            gesture (PedestrianGestureType): A new gesture of the pedestrian

        &#34;&#34;&#34;
        self.gestures.append(convert_enum(gesture, PedestrianGestureType))
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the PedestrianAnimation as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;motion&#34;] = self.motion.get_name()
        retdict[&#34;userDefinedPedestrianAnimation&#34;] = str(self.animation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the PedestrianAnimation&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;PedestrianAnimation was introduced in OpenSCENARIO V1.2&#34;
            )

        element = ET.Element(&#34;PedestrianAnimation&#34;, attrib=self.get_attributes())
        for gesture in self.gestures:
            ET.SubElement(
                element, &#34;PedestrianGesture&#34;, attrib={&#34;gesture&#34;: gesture.get_name()}
            )
        return element</code></pre>
</details>
<div class="desc"><p>The PedestrianAnimation creates a PedestrianAnimation element used by AnimationType</p>
<h2 id="parameters">Parameters</h2>
<pre><code>motion (PedestrianMotionType): Motion of a pedestrian

userDefinedPedestrianAnimation (str): User defined pedestrian animation
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>motion (PedestrianMotionType): Motion of a pedestrian

userDefinedPedestrianAnimation (str): User defined pedestrian animation

gestures (list of PedestrianGestureTpe): Gestures of a pedestrian
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_gesture(gesture)
    Adds a pedestrian gesture to the pedestrian animation

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the PedestrianAnimation</p>
<h2 id="parameters_1">Parameters</h2>
<p>motion (PedestrianMotionType): Motion of a pedestrian</p>
<p>userDefinedPedestrianAnimation (str): User defined pedestrian animation</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._AnimationType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.PedestrianAnimation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of a PedestrianAnimation

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a UserDefinedAnimation element

    Returns
    -------
        PedestrianAnimation (PedestrianAnimation): a PedestrianAnimation object

    &#34;&#34;&#34;
    motion = convert_enum(element.attrib[&#34;motion&#34;], PedestrianMotionType)
    animation = element.attrib[&#34;userDefinedPedestrianAnimation&#34;]
    pa = PedestrianAnimation(motion, animation)

    for gesture in element.findall(&#34;PedestrianGesture&#34;):
        pa.add_gesture(
            convert_enum(gesture.attrib[&#34;gesture&#34;], PedestrianGestureType)
        )
    return pa</code></pre>
</details>
<div class="desc"><p>Parses the xml element of a PedestrianAnimation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a UserDefinedAnimation element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>PedestrianAnimation (PedestrianAnimation): a PedestrianAnimation object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.PedestrianAnimation.add_gesture"><code class="name flex">
<span>def <span class="ident">add_gesture</span></span>(<span>self, gesture)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_gesture(self, gesture):
    &#34;&#34;&#34;adds a pedestrian gesture to the vehicle

    Parameters
    ----------
        gesture (PedestrianGestureType): A new gesture of the pedestrian

    &#34;&#34;&#34;
    self.gestures.append(convert_enum(gesture, PedestrianGestureType))
    return self</code></pre>
</details>
<div class="desc"><p>adds a pedestrian gesture to the vehicle</p>
<h2 id="parameters">Parameters</h2>
<pre><code>gesture (PedestrianGestureType): A new gesture of the pedestrian
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.PedestrianAnimation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the PedestrianAnimation as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;motion&#34;] = self.motion.get_name()
    retdict[&#34;userDefinedPedestrianAnimation&#34;] = str(self.animation)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the PedestrianAnimation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.PedestrianAnimation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the PedestrianAnimation&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;PedestrianAnimation was introduced in OpenSCENARIO V1.2&#34;
        )

    element = ET.Element(&#34;PedestrianAnimation&#34;, attrib=self.get_attributes())
    for gesture in self.gestures:
        ET.SubElement(
            element, &#34;PedestrianGesture&#34;, attrib={&#34;gesture&#34;: gesture.get_name()}
        )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the PedestrianAnimation</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase"><code class="flex name class">
<span>class <span class="ident">Phase</span></span>
<span>(</span><span>name, duration, traffic_group_state=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Phase(VersionBase):
    &#34;&#34;&#34;crates a Traffic light phase

    Parameters
    ----------
        name (str): if of the phase

        duration (float): duration of the phase

        traffic_group_state (str): state for a group of signals (valid since V1.2)
            Default: None

    Attributes
    ----------
        name (str): if of the phase

        duration (float): duration of the phase

        signalstates (list of _TrafficSignalState): traffic signal states

        traffic_group_state (str): state for a group of signals (valid since V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

        add_stignal_state(signal_id,state)
            add a traffic signal state
    &#34;&#34;&#34;

    def __init__(self, name, duration, traffic_group_state=None):
        &#34;&#34;&#34;initalize the Phase

        Parameters
        ----------
            name (str): if of the phase

            duration (float): duration of the phase

            traffic_group_state (str): state for a group of signals (valid since V1.2)
                Default: None

        &#34;&#34;&#34;

        self.name = name
        self.duration = convert_float(duration)
        self.signalstates = []
        self.traffic_group_state = traffic_group_state

    def __eq__(self, other):
        if isinstance(other, Phase):
            if (
                self.get_attributes() == other.get_attributes()
                and self.signalstates == other.signalstates
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Phase

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)

        Returns
        -------
            phase (Phase): a Phase object

        &#34;&#34;&#34;
        duration = convert_float(element.attrib[&#34;duration&#34;])
        name = element.attrib[&#34;name&#34;]
        group = None
        # NOTE: Misspelling according to standard...
        if element.find(&#34;TrafficeSignalGroupState&#34;) is not None:
            group = element.find(&#34;TrafficeSignalGroupState&#34;).attrib[&#34;state&#34;]
        phase = Phase(name, duration, group)
        signalstates = element.findall(&#34;TrafficSignalState&#34;)
        if signalstates != None:
            for signalstate in signalstates:
                traffic_signal_state = _TrafficSignalState.parse(signalstate)
                phase.signalstates.append(traffic_signal_state)
        return phase

    def add_signal_state(self, signal_id, state):
        &#34;&#34;&#34;Adds a phase of the traffic signal

        Parameters
        ----------
            signal_id (str): id of the traffic signal in the road network

            state (str): state of the signal defined in the road network

        &#34;&#34;&#34;
        self.signalstates.append(_TrafficSignalState(signal_id, state))
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalController&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        retdict[&#34;duration&#34;] = str(self.duration)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Polyline&#34;&#34;&#34;
        element = ET.Element(&#34;Phase&#34;, attrib=self.get_attributes())
        for s in self.signalstates:
            element.append(s.get_element())
        if self.traffic_group_state is not None:
            # NOTE: Misspelling according to standard...
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(
                    &#34;TrafficSignalGroupStage was added in OSC 1.2.&#34;
                )
            ET.SubElement(
                element,
                &#34;TrafficeSignalGroupState&#34;,
                attrib={&#34;state&#34;: self.traffic_group_state},
            )
        return element</code></pre>
</details>
<div class="desc"><p>crates a Traffic light phase</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase

traffic_group_state (str): state for a group of signals (valid since V1.2)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase

signalstates (list of _TrafficSignalState): traffic signal states

traffic_group_state (str): state for a group of signals (valid since V1.2)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_stignal_state(signal_id,state)
    add a traffic signal state
</code></pre>
<p>initalize the Phase</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase

traffic_group_state (str): state for a group of signals (valid since V1.2)
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Phase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Phase

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)

    Returns
    -------
        phase (Phase): a Phase object

    &#34;&#34;&#34;
    duration = convert_float(element.attrib[&#34;duration&#34;])
    name = element.attrib[&#34;name&#34;]
    group = None
    # NOTE: Misspelling according to standard...
    if element.find(&#34;TrafficeSignalGroupState&#34;) is not None:
        group = element.find(&#34;TrafficeSignalGroupState&#34;).attrib[&#34;state&#34;]
    phase = Phase(name, duration, group)
    signalstates = element.findall(&#34;TrafficSignalState&#34;)
    if signalstates != None:
        for signalstate in signalstates:
            traffic_signal_state = _TrafficSignalState.parse(signalstate)
            phase.signalstates.append(traffic_signal_state)
    return phase</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Phase</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>phase (Phase): a Phase object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Phase.add_signal_state"><code class="name flex">
<span>def <span class="ident">add_signal_state</span></span>(<span>self, signal_id, state)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal_state(self, signal_id, state):
    &#34;&#34;&#34;Adds a phase of the traffic signal

    Parameters
    ----------
        signal_id (str): id of the traffic signal in the road network

        state (str): state of the signal defined in the road network

    &#34;&#34;&#34;
    self.signalstates.append(_TrafficSignalState(signal_id, state))
    return self</code></pre>
</details>
<div class="desc"><p>Adds a phase of the traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>signal_id (str): id of the traffic signal in the road network

state (str): state of the signal defined in the road network
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalController&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    retdict[&#34;duration&#34;] = str(self.duration)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TrafficSignalController</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Polyline&#34;&#34;&#34;
    element = ET.Element(&#34;Phase&#34;, attrib=self.get_attributes())
    for s in self.signalstates:
        element.append(s.get_element())
    if self.traffic_group_state is not None:
        # NOTE: Misspelling according to standard...
        if self.isVersionEqLess(minor=1):
            raise OpenSCENARIOVersionError(
                &#34;TrafficSignalGroupStage was added in OSC 1.2.&#34;
            )
        ET.SubElement(
            element,
            &#34;TrafficeSignalGroupState&#34;,
            attrib={&#34;state&#34;: self.traffic_group_state},
        )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Polyline</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Precipitation"><code class="flex name class">
<span>class <span class="ident">Precipitation</span></span>
<span>(</span><span>precipitation, intensity)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Precipitation(VersionBase):
    &#34;&#34;&#34;Precipitation creates an Precipitation element used by the Weather element of openscenario

    Parameters
    ----------
        precipitation (PrecipitationType): dry, rain or snow

        intensity (float): intensity of precipitation (0...1)

    Attributes
    ----------
        precipitation (PrecipitationType): dry, rain or snow

        intensity (float): intensity of precipitation (0...1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, precipitation, intensity):
        &#34;&#34;&#34;initalize the Precipitation

        Parameters
        ----------
            precipitation (PrecipitationType): dry, rain or snow

            intensity (float): intensity of precipitation (0...1)

        &#34;&#34;&#34;
        self.precipitation = convert_enum(precipitation, PrecipitationType, False)
        self.intensity = convert_float(intensity)

    def __eq__(self, other):
        if isinstance(other, Precipitation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Precipitation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)

        Returns
        -------
            precipitation (Precipitation): a Precipitation object

        &#34;&#34;&#34;
        intesity = None
        if &#34;precipitationIntensity&#34; in element.attrib:
            intesity = element.attrib[&#34;precipitationIntensity&#34;]
        elif &#34;intensity&#34; in element.attrib:
            intesity = element.attrib[&#34;intensity&#34;]
        precipitation = convert_enum(
            element.attrib[&#34;precipitationType&#34;], PrecipitationType, False
        )

        return Precipitation(precipitation, intesity)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;precipitationType&#34;] = self.precipitation.get_name()
        if self.isVersion(minor=0):
            retdict[&#34;intensity&#34;] = str(self.intensity)
        else:
            retdict[&#34;precipitationIntensity&#34;] = str(self.intensity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Precipitation&#34;&#34;&#34;
        element = ET.Element(&#34;Precipitation&#34;, attrib=self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>Precipitation creates an Precipitation element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Precipitation</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Precipitation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Precipitation

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)

    Returns
    -------
        precipitation (Precipitation): a Precipitation object

    &#34;&#34;&#34;
    intesity = None
    if &#34;precipitationIntensity&#34; in element.attrib:
        intesity = element.attrib[&#34;precipitationIntensity&#34;]
    elif &#34;intensity&#34; in element.attrib:
        intesity = element.attrib[&#34;intensity&#34;]
    precipitation = convert_enum(
        element.attrib[&#34;precipitationType&#34;], PrecipitationType, False
    )

    return Precipitation(precipitation, intesity)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Precipitation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>precipitation (Precipitation): a Precipitation object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Precipitation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;precipitationType&#34;] = self.precipitation.get_name()
    if self.isVersion(minor=0):
        retdict[&#34;intensity&#34;] = str(self.intensity)
    else:
        retdict[&#34;precipitationIntensity&#34;] = str(self.intensity)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Precipitation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Precipitation&#34;&#34;&#34;
    element = ET.Element(&#34;Precipitation&#34;, attrib=self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Precipitation</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties"><code class="flex name class">
<span>class <span class="ident">Properties</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Properties(VersionBase):
    &#34;&#34;&#34;the Properties contains are for user defined properties of an object

    Attributes
    ----------
        files (list of str): arbitrary files with properties

        properties (list of tuple(str,str)): properties in name/value pairs

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_file(file)
            adds a file with properties

        add_property(name,value)
            adds a property pair, with name and value

        get_element()
            Returns the full ElementTree of the class


    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;initalzie the Properties&#34;&#34;&#34;
        self.files = []
        self.properties = []

    def __eq__(self, other):
        if isinstance(other, Properties):
            if self.files == other.files and self.properties == other.properties:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of class Properties:


        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            properties (Properties): a Properties object

        &#34;&#34;&#34;
        properties = Properties()
        files = element.findall(&#34;File&#34;)
        if files != None:
            for file in files:
                filepath = file.attrib[&#34;filepath&#34;]
                properties.add_file(filepath)
        props = element.findall(&#34;Property&#34;)
        if props != None:
            for property in props:
                name = property.attrib[&#34;name&#34;]
                value = property.attrib[&#34;value&#34;]
                properties.add_property(name, value)

        return properties

    def add_file(self, filename):
        &#34;&#34;&#34;adds a property file

        Parameters
        ----------
            filename (str): name of the file

        &#34;&#34;&#34;

        self.files.append(filename)
        return self

    def add_property(self, name, value):
        &#34;&#34;&#34;adds a property pair

        Parameters
        ----------
            name (str): name of the property

            value (str): value of the property

        &#34;&#34;&#34;
        self.properties.append((name, value))
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Properties&#34;&#34;&#34;
        element = ET.Element(&#34;Properties&#34;)
        for p in self.properties:
            ET.SubElement(element, &#34;Property&#34;, attrib={&#34;name&#34;: p[0], &#34;value&#34;: p[1]})
        for f in self.files:
            ET.SubElement(element, &#34;File&#34;, attrib={&#34;filepath&#34;: f})

        return element</code></pre>
</details>
<div class="desc"><p>the Properties contains are for user defined properties of an object</p>
<h2 id="attributes">Attributes</h2>
<pre><code>files (list of str): arbitrary files with properties

properties (list of tuple(str,str)): properties in name/value pairs
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_file(file)
    adds a file with properties

add_property(name,value)
    adds a property pair, with name and value

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the Properties</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Properties.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of class Properties:


    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

    Returns
    -------
        properties (Properties): a Properties object

    &#34;&#34;&#34;
    properties = Properties()
    files = element.findall(&#34;File&#34;)
    if files != None:
        for file in files:
            filepath = file.attrib[&#34;filepath&#34;]
            properties.add_file(filepath)
    props = element.findall(&#34;Property&#34;)
    if props != None:
        for property in props:
            name = property.attrib[&#34;name&#34;]
            value = property.attrib[&#34;value&#34;]
            properties.add_property(name, value)

    return properties</code></pre>
</details>
<div class="desc"><p>Parses the xml element of class Properties:</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>properties (Properties): a Properties object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Properties.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, filename):
    &#34;&#34;&#34;adds a property file

    Parameters
    ----------
        filename (str): name of the file

    &#34;&#34;&#34;

    self.files.append(filename)
    return self</code></pre>
</details>
<div class="desc"><p>adds a property file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): name of the file
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self, name, value):
    &#34;&#34;&#34;adds a property pair

    Parameters
    ----------
        name (str): name of the property

        value (str): value of the property

    &#34;&#34;&#34;
    self.properties.append((name, value))
    return self</code></pre>
</details>
<div class="desc"><p>adds a property pair</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the property

value (str): value of the property
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Properties&#34;&#34;&#34;
    element = ET.Element(&#34;Properties&#34;)
    for p in self.properties:
        ET.SubElement(element, &#34;Property&#34;, attrib={&#34;name&#34;: p[0], &#34;value&#34;: p[1]})
    for f in self.files:
        ET.SubElement(element, &#34;File&#34;, attrib={&#34;filepath&#34;: f})

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Properties</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedToMaster</span></span>
<span>(</span><span>value, speedTargetValueType, steadyState=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedToMaster(VersionBase):
    &#34;&#34;&#34;
    Parameters
    ----------
        value (float): Relative speed. Unit: m/s.

        speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

        steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

    Attributes
    ----------
        value (float): Relative speed. Unit: m/s.

        speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

        steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class itself

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns the attributes of the class
    &#34;&#34;&#34;

    def __init__(self, value, speedTargetValueType, steadyState=None):
        &#34;&#34;&#34;

        Parameters
        ----------
            value (float): Relative speed. Unit: m/s.

            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed.
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (
                isinstance(steadyState, TargetTimeSteadyState)
                or isinstance(steadyState, TargetDistanceSteadyState)
            ):
                raise TypeError(
                    &#34;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#34;
                )
        self.steadyState = steadyState
        self.speedTargetValueType = convert_enum(
            speedTargetValueType, SpeedTargetValueType
        )

    def __eq__(self, other):
        if isinstance(other, RelativeSpeedToMaster):
            if (
                self.get_attributes() == other.get_attributes()
                and self.steadyState == other.steadyState
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element to RelativeSpeedToMaster

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)

        Returns
        ------
            rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object

        &#34;&#34;&#34;
        speed_element = element.find(&#34;RelativeSpeedToMaster&#34;)

        value = speed_element.attrib[&#34;value&#34;]
        speedTargetValueType = convert_enum(
            speed_element.attrib[&#34;speedTargetValueType&#34;], SpeedTargetValueType
        )
        state = None
        if speed_element.find(&#34;TargetDistanceSteadyState&#34;) != None:
            state = TargetDistanceSteadyState.parse(
                speed_element.find(&#34;TargetDistanceSteadyState&#34;)
            )
        elif speed_element.find(&#34;TargetTimeSteadyState&#34;) != None:
            state = TargetTimeSteadyState.parse(
                speed_element.find(&#34;TargetTimeSteadyState&#34;)
            )

        return RelativeSpeedToMaster(value, speedTargetValueType, state)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RelativeSpeedToMaster&#34;&#34;&#34;
        return {
            &#34;speedTargetValueType&#34;: str(self.speedTargetValueType),
            &#34;value&#34;: str(self.value),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RelativeSpeedToMaster&#34;&#34;&#34;
        elementFinalSpeed = ET.Element(&#34;FinalSpeed&#34;)
        elementRelativeSpeed = ET.SubElement(
            elementFinalSpeed, &#34;RelativeSpeedToMaster&#34;, attrib=self.get_attributes()
        )
        if self.steadyState:
            if self.isVersion(minor=0):
                raise OpenSCENARIOVersionError(
                    &#34;steadyState was introduced in OpenSCENARIO V1.1&#34;
                )
            ET.SubElement(
                elementRelativeSpeed,
                self.steadyState.__class__.__name__,
                attrib=self.steadyState.get_attributes(),
            )
        return elementFinalSpeed</code></pre>
</details>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the attributes of the class
</code></pre>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed.
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element to RelativeSpeedToMaster

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)

    Returns
    ------
        rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object

    &#34;&#34;&#34;
    speed_element = element.find(&#34;RelativeSpeedToMaster&#34;)

    value = speed_element.attrib[&#34;value&#34;]
    speedTargetValueType = convert_enum(
        speed_element.attrib[&#34;speedTargetValueType&#34;], SpeedTargetValueType
    )
    state = None
    if speed_element.find(&#34;TargetDistanceSteadyState&#34;) != None:
        state = TargetDistanceSteadyState.parse(
            speed_element.find(&#34;TargetDistanceSteadyState&#34;)
        )
    elif speed_element.find(&#34;TargetTimeSteadyState&#34;) != None:
        state = TargetTimeSteadyState.parse(
            speed_element.find(&#34;TargetTimeSteadyState&#34;)
        )

    return RelativeSpeedToMaster(value, speedTargetValueType, state)</code></pre>
</details>
<div class="desc"><p>Parses the xml element to RelativeSpeedToMaster</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RelativeSpeedToMaster&#34;&#34;&#34;
    return {
        &#34;speedTargetValueType&#34;: str(self.speedTargetValueType),
        &#34;value&#34;: str(self.value),
    }</code></pre>
</details>
<div class="desc"><p>returns the attributes of the RelativeSpeedToMaster</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RelativeSpeedToMaster&#34;&#34;&#34;
    elementFinalSpeed = ET.Element(&#34;FinalSpeed&#34;)
    elementRelativeSpeed = ET.SubElement(
        elementFinalSpeed, &#34;RelativeSpeedToMaster&#34;, attrib=self.get_attributes()
    )
    if self.steadyState:
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;steadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        ET.SubElement(
            elementRelativeSpeed,
            self.steadyState.__class__.__name__,
            attrib=self.steadyState.get_attributes(),
        )
    return elementFinalSpeed</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the RelativeSpeedToMaster</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.RoadCondition"><code class="flex name class">
<span>class <span class="ident">RoadCondition</span></span>
<span>(</span><span>friction_scale_factor, properties=None, wetness=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadCondition(VersionBase):
    &#34;&#34;&#34;Weather creates an Weather element of openscenario

    Parameters
    ----------
        friction_scale_factor (float): scale factor of the friction

        properties (Properties): properties of the roadcondition
            Default: None

        wetness (Wetness): wetness of the road
            Default: None

    Attributes
    ----------
        friction_scale_factor (float): scale factor of the friction

        properties (Properties): properties of the roadcondition

        wetness (Wetness): wetness of the road

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, friction_scale_factor, properties=None, wetness=None):
        &#34;&#34;&#34;initalize the Weather

        Parameters
        ----------
            friction_scale_factor (float): scale factor of the friction

            properties (Properties): properties of the roadcondition
                Default: None

            wetness (Wetness): wetness of the road
                Default: None
        &#34;&#34;&#34;
        self.friction_scale_factor = convert_float(friction_scale_factor)
        if properties is not None and not isinstance(properties, Properties):
            raise TypeError(&#34;properties input is not of type Properties&#34;)
        self.properties = properties
        self.wetness = convert_enum(wetness, Wetness, True)

    def __eq__(self, other):
        if isinstance(other, RoadCondition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.properties == other.properties
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of RoadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)

        Returns
        -------
            roadcondition (RoadCondition): a RoadCondition object

        &#34;&#34;&#34;
        friction_scale_factor = element.attrib[&#34;frictionScaleFactor&#34;]

        properties = None
        wetness = None
        if element.find(&#34;Properties&#34;) != None:
            properties = Properties.parse(element.find(&#34;Properties&#34;))
        if &#34;wetness&#34; in element.attrib:
            wetness = convert_enum(element.attrib[&#34;wetness&#34;], Wetness, False)
        return RoadCondition(friction_scale_factor, properties, wetness)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the RoadCondition as a dict&#34;&#34;&#34;
        retdict = {&#34;frictionScaleFactor&#34;: str(self.friction_scale_factor)}
        if self.wetness:
            retdict[&#34;wetness&#34;] = self.wetness.get_name()
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the RoadCondition&#34;&#34;&#34;
        element = ET.Element(&#34;RoadCondition&#34;, attrib=self.get_attributes())
        if self.properties:
            element.append(self.properties.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Weather creates an Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition
    Default: None

wetness (Wetness): wetness of the road
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition

wetness (Wetness): wetness of the road
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Weather</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition
    Default: None

wetness (Wetness): wetness of the road
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RoadCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of RoadCondition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)

    Returns
    -------
        roadcondition (RoadCondition): a RoadCondition object

    &#34;&#34;&#34;
    friction_scale_factor = element.attrib[&#34;frictionScaleFactor&#34;]

    properties = None
    wetness = None
    if element.find(&#34;Properties&#34;) != None:
        properties = Properties.parse(element.find(&#34;Properties&#34;))
    if &#34;wetness&#34; in element.attrib:
        wetness = convert_enum(element.attrib[&#34;wetness&#34;], Wetness, False)
    return RoadCondition(friction_scale_factor, properties, wetness)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of RoadCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>roadcondition (RoadCondition): a RoadCondition object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RoadCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the RoadCondition as a dict&#34;&#34;&#34;
    retdict = {&#34;frictionScaleFactor&#34;: str(self.friction_scale_factor)}
    if self.wetness:
        retdict[&#34;wetness&#34;] = self.wetness.get_name()
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the RoadCondition as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.RoadCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the RoadCondition&#34;&#34;&#34;
    element = ET.Element(&#34;RoadCondition&#34;, attrib=self.get_attributes())
    if self.properties:
        element.append(self.properties.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the RoadCondition</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Sun"><code class="flex name class">
<span>class <span class="ident">Sun</span></span>
<span>(</span><span>intensity, azimuth, elevation)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sun(VersionBase):
    &#34;&#34;&#34;Sun creates an Sun element used by the Weather element of openscenario

    Parameters
    ----------
        intensity (float): intensity of the sun (in lux)

        azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

        elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

    Attributes
    ----------
        intensity (float): intensity of the sun (in lux)

        azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

        elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, intensity, azimuth, elevation):
        &#34;&#34;&#34;initalize the Sun

        Parameters
        ----------
            intensity (float): intensity of the sun (in lux)

            azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

            elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

        &#34;&#34;&#34;

        self.azimuth = azimuth
        self.intensity = intensity
        self.elevation = elevation

    def __eq__(self, other):
        if isinstance(other, Sun):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Sun

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)

        Returns
        -------
            sun (Sun): a Sun object

        &#34;&#34;&#34;
        azimuth = element.attrib[&#34;azimuth&#34;]
        elevation = element.attrib[&#34;elevation&#34;]
        if &#34;intensity&#34; in element.attrib:
            intensity = element.attrib[&#34;intensity&#34;]
        else:
            intensity = element.attrib[&#34;illuminance&#34;]

        return Sun(intensity, azimuth, elevation)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;azimuth&#34;] = str(self.azimuth)
        if self.isVersion(minor=2):
            retdict[&#34;illuminance&#34;] = str(self.intensity)
        else:
            retdict[&#34;intensity&#34;] = str(self.intensity)
        retdict[&#34;elevation&#34;] = str(self.elevation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Sun&#34;&#34;&#34;
        element = ET.Element(&#34;Sun&#34;, attrib=self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>Sun creates an Sun element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Sun</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Sun.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Sun

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)

    Returns
    -------
        sun (Sun): a Sun object

    &#34;&#34;&#34;
    azimuth = element.attrib[&#34;azimuth&#34;]
    elevation = element.attrib[&#34;elevation&#34;]
    if &#34;intensity&#34; in element.attrib:
        intensity = element.attrib[&#34;intensity&#34;]
    else:
        intensity = element.attrib[&#34;illuminance&#34;]

    return Sun(intensity, azimuth, elevation)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Sun</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>sun (Sun): a Sun object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Sun.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Precipitation as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;azimuth&#34;] = str(self.azimuth)
    if self.isVersion(minor=2):
        retdict[&#34;illuminance&#34;] = str(self.intensity)
    else:
        retdict[&#34;intensity&#34;] = str(self.intensity)
    retdict[&#34;elevation&#34;] = str(self.elevation)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Sun.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Sun&#34;&#34;&#34;
    element = ET.Element(&#34;Sun&#34;, attrib=self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Sun</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState"><code class="flex name class">
<span>class <span class="ident">TargetDistanceSteadyState</span></span>
<span>(</span><span>distance)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetDistanceSteadyState(VersionBase):
    &#34;&#34;&#34;the TargetDistanceSteadyState describes a SteadyState of type TargetDistanceSteadyState
    (Valid from OpenSCENARIO V1.1)

    Parameters
    ----------
        distance (float): distance to target for the steady state

    Attributes
    ----------
        distance (float): distance to target for the steady state

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, distance):
        &#34;&#34;&#34;initalzie the TargetDistanceSteadyState

        Parameters
        ----------
            distance (float): distance to target for the steady state

        &#34;&#34;&#34;
        self.distance = distance

    def __eq__(self, other):
        if isinstance(other, TargetDistanceSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TargetDistanceSteadyState

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)

        Returns
        -------
            tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object

        &#34;&#34;&#34;
        distance = element.attrib[&#34;distance&#34;]
        return TargetDistanceSteadyState(distance)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TargetDistanceSteadyState&#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(
                &#34;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        return {&#34;distance&#34;: str(self.distance)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TargetDistanceSteadyState&#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(
                &#34;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        return ET.Element(&#34;TargetDistanceSteadyState&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>the TargetDistanceSteadyState describes a SteadyState of type TargetDistanceSteadyState
(Valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the TargetDistanceSteadyState</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TargetDistanceSteadyState

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)

    Returns
    -------
        tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object

    &#34;&#34;&#34;
    distance = element.attrib[&#34;distance&#34;]
    return TargetDistanceSteadyState(distance)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TargetDistanceSteadyState</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TargetDistanceSteadyState&#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(
            &#34;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#34;
        )
    return {&#34;distance&#34;: str(self.distance)}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TargetDistanceSteadyState</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TargetDistanceSteadyState&#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(
            &#34;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#34;
        )
    return ET.Element(&#34;TargetDistanceSteadyState&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TargetDistanceSteadyState</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState"><code class="flex name class">
<span>class <span class="ident">TargetTimeSteadyState</span></span>
<span>(</span><span>time_gap)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetTimeSteadyState(VersionBase):
    &#34;&#34;&#34;the TargetTimeSteadyState describes a SteadyState of type TargetTimeSteadyState
    (Valid from OpenSCENARIO V1.1)

    Parameters
    ----------
        time_gap (float): time_gap to target for the steady state

    Attributes
    ----------
        time_gap (float): time_gap to target for the steady state

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, time_gap):
        &#34;&#34;&#34;initalzie the TargetTimeSteadyState

        Parameters
        ----------
            time_gap (float): time_gap to target for the steady state

        &#34;&#34;&#34;
        self.time_gap = time_gap

    def __eq__(self, other):
        if isinstance(other, TargetTimeSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TargetTimeSteadyState

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)

        Returns
        -------
            ttss (TargetTimeSteadyState): a TargetTimeSteadyState object

        &#34;&#34;&#34;
        time = element.attrib[&#34;time&#34;]
        return TargetTimeSteadyState(time)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TargetTimeSteadyState&#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(
                &#34;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        return {&#34;time&#34;: str(self.time_gap)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TargetTimeSteadyState&#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(
                &#34;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#34;
            )
        return ET.Element(&#34;TargetTimeSteadyState&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>the TargetTimeSteadyState describes a SteadyState of type TargetTimeSteadyState
(Valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the TargetTimeSteadyState</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TargetTimeSteadyState

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)

    Returns
    -------
        ttss (TargetTimeSteadyState): a TargetTimeSteadyState object

    &#34;&#34;&#34;
    time = element.attrib[&#34;time&#34;]
    return TargetTimeSteadyState(time)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TargetTimeSteadyState</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ttss (TargetTimeSteadyState): a TargetTimeSteadyState object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TargetTimeSteadyState&#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(
            &#34;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#34;
        )
    return {&#34;time&#34;: str(self.time_gap)}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TargetTimeSteadyState</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TargetTimeSteadyState&#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(
            &#34;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#34;
        )
    return ET.Element(&#34;TargetTimeSteadyState&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TargetTimeSteadyState</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeOfDay"><code class="flex name class">
<span>class <span class="ident">TimeOfDay</span></span>
<span>(</span><span>animation, year, month, day, hour, minute, second)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeOfDay(VersionBase):
    &#34;&#34;&#34;TimeOfDay creates an TimeOfDay element of openscenario

    Parameters
    ----------
        animation (bool): if animation should be used

        year (int): year

        month (int): month

        day (int): day

        hour (int): hour

        minute (int): minute

        second (int): second

    Attributes
    ----------
        animation (bool): if animation should be used

        year (int): year

        month (int): month

        day (int): day

        hour (int): hour

        minute (int): minute

        second (int): second

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, animation, year, month, day, hour, minute, second):
        &#34;&#34;&#34;initalize the TimeOfDay

        Parameters
        ----------
            animation (bool): if animation should be used

            year (int): year

            month (int): month

            day (int): day

            hour (int): hour

            minute (int): minute

            second (int): second

        &#34;&#34;&#34;
        self.animation = convert_bool(animation)
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def __eq__(self, other):
        if isinstance(other, TimeOfDay):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeOfDay

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)

        Returns
        -------
            timeofday (TimeOfDay): a TimeOfDay object
        &#34;&#34;&#34;
        animation = convert_bool(element.attrib[&#34;animation&#34;])
        var = element.attrib[&#34;dateTime&#34;]
        year = convert_int(var[0:4])
        month = convert_int(var[5:7])
        day = convert_int(var[8:10])

        hour = convert_int(var[11:13])
        minute = convert_int(var[14:16])
        second = convert_int(var[17:19])

        return TimeOfDay(animation, year, month, day, hour, minute, second)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeOfDay as a dict&#34;&#34;&#34;
        dt = (
            str(self.year)
            + &#34;-&#34;
            + &#34;{:0&gt;2}&#34;.format(self.month)
            + &#34;-&#34;
            + &#34;{:0&gt;2}&#34;.format(self.day)
            + &#34;T&#34;
            + &#34;{:0&gt;2}&#34;.format(self.hour)
            + &#34;:&#34;
            + &#34;{:0&gt;2}&#34;.format(self.minute)
            + &#34;:&#34;
            + &#34;{:0&gt;2}&#34;.format(self.second)
        )
        return {&#34;animation&#34;: get_bool_string(self.animation), &#34;dateTime&#34;: dt}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeOfDay&#34;&#34;&#34;
        return ET.Element(&#34;TimeOfDay&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>TimeOfDay creates an TimeOfDay element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeOfDay</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TimeOfDay

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)

    Returns
    -------
        timeofday (TimeOfDay): a TimeOfDay object
    &#34;&#34;&#34;
    animation = convert_bool(element.attrib[&#34;animation&#34;])
    var = element.attrib[&#34;dateTime&#34;]
    year = convert_int(var[0:4])
    month = convert_int(var[5:7])
    day = convert_int(var[8:10])

    hour = convert_int(var[11:13])
    minute = convert_int(var[14:16])
    second = convert_int(var[17:19])

    return TimeOfDay(animation, year, month, day, hour, minute, second)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TimeOfDay</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>timeofday (TimeOfDay): a TimeOfDay object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TimeOfDay as a dict&#34;&#34;&#34;
    dt = (
        str(self.year)
        + &#34;-&#34;
        + &#34;{:0&gt;2}&#34;.format(self.month)
        + &#34;-&#34;
        + &#34;{:0&gt;2}&#34;.format(self.day)
        + &#34;T&#34;
        + &#34;{:0&gt;2}&#34;.format(self.hour)
        + &#34;:&#34;
        + &#34;{:0&gt;2}&#34;.format(self.minute)
        + &#34;:&#34;
        + &#34;{:0&gt;2}&#34;.format(self.second)
    )
    return {&#34;animation&#34;: get_bool_string(self.animation), &#34;dateTime&#34;: dt}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TimeOfDay as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TimeOfDay&#34;&#34;&#34;
    return ET.Element(&#34;TimeOfDay&#34;, attrib=self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TimeOfDay</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeReference"><code class="flex name class">
<span>class <span class="ident">TimeReference</span></span>
<span>(</span><span>reference_domain=None, scale=None, offset=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeReference(VersionBase):
    &#34;&#34;&#34;the TimeReference class creates a TimeReference,

    Parameters
    ----------
        referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
            Default: None

        scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
            Default: None

        offset (float): offset for time values (must be combined with referece_domain and scale)
            Default: None

    Attributes
    ----------
        referece_domain (ReferenceContext): absolute or relative time reference

        scale (float): scalefactor of the timeings

        offset (float): offset for time values

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, reference_domain=None, scale=None, offset=None):
        &#34;&#34;&#34;initalize the TimeReference

        Parameters
        ----------
        referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
            Default: None

        scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
            Default: None

        offset (float): offset for time values (must be combined with referece_domain and scale)
            Default: None

        &#34;&#34;&#34;
        nones = [reference_domain == None, scale == None, offset == None]
        if sum(nones) == 3:
            self._only_nones = True
        elif sum(nones) == 0:
            self._only_nones = False
        else:
            raise ValueError(&#34;missing inputs for time reference&#34;)
        self.reference_domain = convert_enum(reference_domain, ReferenceContext, True)
        self.scale = convert_float(scale)
        self.offset = convert_float(offset)

    def __eq__(self, other):
        if isinstance(other, TimeReference):
            if not self._only_nones and not other._only_nones:
                if self.get_attributes() == other.get_attributes():
                    return True
            elif self._only_nones == other._only_nones:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TimeReference

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)

        Returns
        -------
            timing (TimeReference): a TimeReference object

        &#34;&#34;&#34;
        if element.find(&#34;None&#34;) != None:
            return TimeReference()

        timing_element = element.find(&#34;Timing&#34;)
        scale = None
        offset = None
        reference_domain = None

        if &#34;offset&#34; in timing_element.attrib:
            offset = timing_element.attrib[&#34;offset&#34;]
        if &#34;scale&#34; in timing_element.attrib:
            scale = timing_element.attrib[&#34;scale&#34;]
        if &#34;domainAbsoluteRelative&#34; in timing_element.attrib:
            reference_domain = convert_enum(
                timing_element.attrib[&#34;domainAbsoluteRelative&#34;], ReferenceContext
            )

        return TimeReference(reference_domain, scale, offset)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TimeReference as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;domainAbsoluteRelative&#34;] = self.reference_domain.get_name()
        retdict[&#34;scale&#34;] = str(self.scale)
        retdict[&#34;offset&#34;] = str(self.offset)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TimeReference&#34;&#34;&#34;

        element = ET.Element(&#34;TimeReference&#34;)
        if self._only_nones:
            ET.SubElement(element, &#34;None&#34;)
        else:
            ET.SubElement(element, &#34;Timing&#34;, self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>the TimeReference class creates a TimeReference,</p>
<h2 id="parameters">Parameters</h2>
<pre><code>referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
    Default: None

scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
    Default: None

offset (float): offset for time values (must be combined with referece_domain and scale)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>referece_domain (ReferenceContext): absolute or relative time reference

scale (float): scalefactor of the timeings

offset (float): offset for time values
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeReference</p>
<h2 id="parameters_1">Parameters</h2>
<p>referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
Default: None</p>
<p>scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
Default: None</p>
<p>offset (float): offset for time values (must be combined with referece_domain and scale)
Default: None</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeReference.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TimeReference

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)

    Returns
    -------
        timing (TimeReference): a TimeReference object

    &#34;&#34;&#34;
    if element.find(&#34;None&#34;) != None:
        return TimeReference()

    timing_element = element.find(&#34;Timing&#34;)
    scale = None
    offset = None
    reference_domain = None

    if &#34;offset&#34; in timing_element.attrib:
        offset = timing_element.attrib[&#34;offset&#34;]
    if &#34;scale&#34; in timing_element.attrib:
        scale = timing_element.attrib[&#34;scale&#34;]
    if &#34;domainAbsoluteRelative&#34; in timing_element.attrib:
        reference_domain = convert_enum(
            timing_element.attrib[&#34;domainAbsoluteRelative&#34;], ReferenceContext
        )

    return TimeReference(reference_domain, scale, offset)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TimeReference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>timing (TimeReference): a TimeReference object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeReference.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TimeReference as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;domainAbsoluteRelative&#34;] = self.reference_domain.get_name()
    retdict[&#34;scale&#34;] = str(self.scale)
    retdict[&#34;offset&#34;] = str(self.offset)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TimeReference as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeReference.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TimeReference&#34;&#34;&#34;

    element = ET.Element(&#34;TimeReference&#34;)
    if self._only_nones:
        ET.SubElement(element, &#34;None&#34;)
    else:
        ET.SubElement(element, &#34;Timing&#34;, self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TimeReference</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition"><code class="flex name class">
<span>class <span class="ident">TrafficDefinition</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficDefinition(VersionBase):
    &#34;&#34;&#34;the TrafficDefinition class creates a TrafficDefinition used by the different TrafficActions

    Parameters
    ----------
        name (str): name of the traffic definition


    Attributes
    ----------
        name (str): name of the traffic definition

        vehicleweights (list of floats): The weights of the vehicle categories (VehicleCategoryDistribution-weight)

        vehiclecategories (list of VehicleCategory): the vehicle category ((VehicleCategoryDistribution-category))

        controllerweights (list of floats): The weights of the controllers

        controllers (list of Controller/CatalogReference): The controllers for the traffic


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

        add_vehicle(vehiclecategory,weight)
            Adds a vehicle to the traffic definition

        add_controller(controller,weight)
            Adds a controller to the traffic definition

    &#34;&#34;&#34;

    def __init__(self, name):
        &#34;&#34;&#34;initalize the TrafficDefinition

        Parameters
        ----------
            name (str): name of the traffic definition

        &#34;&#34;&#34;

        self.name = name
        self.vehicleweights = []
        self.vehiclecategories = []
        self.controllerweights = []
        self.controllers = []
        self.vehicle_roles = []
        self.vehicle_roles_weights = []

    def __eq__(self, other):
        if isinstance(other, TrafficDefinition):
            if (
                self.get_attributes() == other.get_attributes()
                and self.vehicleweights == other.vehicleweights
                and self.vehiclecategories == other.vehiclecategories
                and self.controllerweights == other.controllerweights
                and self.controllers == other.controllers
                and self.vehicle_roles == other.vehicle_roles
                and self.vehicle_roles_weights == other.vehicle_roles_weights
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficDefinition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)

        Returns
        -------
            td (TrafficDefinition): a TrafficDefinition object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        td = TrafficDefinition(name)

        vehicle_distributions = element.find(&#34;VehicleCategoryDistribution&#34;)
        vehicle_entries = vehicle_distributions.findall(
            &#34;VehicleCategoryDistributionEntry&#34;
        )
        for entry in vehicle_entries:
            weight = convert_float(entry.attrib[&#34;weight&#34;])
            category = convert_enum(entry.attrib[&#34;category&#34;], VehicleCategory)
            td.add_vehicle(category, weight)

        controller_distributions = element.find(&#34;ControllerDistribution&#34;)
        controller_entries = controller_distributions.findall(
            &#34;ControllerDistributionEntry&#34;
        )
        for controller_dist in controller_entries:
            weight = convert_float(controller_dist.attrib[&#34;weight&#34;])
            if controller_dist.find(&#34;Controller&#34;):
                controller = Controller.parse(controller_dist.find(&#34;Controller&#34;))
                td.add_controller(controller, weight)
            else:
                catalog_reference = CatalogReference.parse(
                    controller_dist.find(&#34;CatalogReference&#34;)
                )
                td.add_controller(catalog_reference, weight)

        vehicle_role_distributions = element.find(&#34;VehicleRoleDistribution&#34;)
        if vehicle_role_distributions is not None:
            for entry in vehicle_role_distributions.findall(
                &#34;VehicleRoleDistributionEntry&#34;
            ):
                td.add_vehicle_role(
                    convert_enum(entry.attrib[&#34;role&#34;], Role), entry.attrib[&#34;weight&#34;]
                )
        return td

    def add_vehicle(self, vehiclecategory, weight):
        &#34;&#34;&#34;Adds a vehicle to the traffic distribution

        Parameters
        ----------
            vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

            weight (float): the corresponding weight for the distribution of the vehicle category

        &#34;&#34;&#34;
        self.vehiclecategories.append(convert_enum(vehiclecategory, VehicleCategory))
        self.vehicleweights.append(weight)
        return self

    def add_vehicle_role(self, vehicle_role, weight):
        &#34;&#34;&#34;Adds a vehicle role to a distribution

        Parameters
        ----------
            vehicle_role (Role): add a role to the vehicle role distribution

            weight (float): the weight of that vehicle role
        &#34;&#34;&#34;
        self.vehicle_roles_weights.append(convert_float(weight))
        self.vehicle_roles.append(convert_enum(vehicle_role, Role))

    def add_controller(self, controller, weight):
        &#34;&#34;&#34;Adds a controller to the traffic distribution

        Parameters
        ----------
            controller (Controller or CatalogReference): a controller or catalog reference to a controller

            weight (float): the corresponding weight for the controller

        &#34;&#34;&#34;
        if not (
            isinstance(controller, Controller)
            or isinstance(controller, CatalogReference)
        ):
            raise TypeError(
                &#34;controller input not of type Controller or CatalogReference&#34;
            )
        self.controllers.append(controller)
        self.controllerweights.append(weight)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficDefinition&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficDefinition&#34;&#34;&#34;
        if not self.controllers:
            ValueError(&#34;No controllers defined for the TrafficDefinition&#34;)
        if not self.vehiclecategories:
            ValueError(&#34;No Vehicles defined for the TrafficDefinition&#34;)

        element = ET.Element(&#34;TrafficDefinition&#34;, attrib=self.get_attributes())

        veh_element = ET.SubElement(element, &#34;VehicleCategoryDistribution&#34;)
        for i in range(len(self.vehiclecategories)):
            ET.SubElement(
                veh_element,
                &#34;VehicleCategoryDistributionEntry&#34;,
                attrib={
                    &#34;category&#34;: self.vehiclecategories[i].get_name(),
                    &#34;weight&#34;: str(self.vehicleweights[i]),
                },
            )

        cnt_element = ET.SubElement(element, &#34;ControllerDistribution&#34;)
        for i in range(len(self.controllers)):
            tmp_controller = ET.SubElement(
                cnt_element,
                &#34;ControllerDistributionEntry&#34;,
                attrib={&#34;weight&#34;: str(self.controllerweights[i])},
            )
            tmp_controller.append(self.controllers[i].get_element())
        if self.vehicle_roles:
            if self.version_minor &lt; 2:
                raise OpenSCENARIOVersionError(
                    &#34;VehicleRoleDistribution was added in OSC V1.2&#34;
                )
            role_element = ET.SubElement(element, &#34;VehicleRoleDistribution&#34;)
            for i in range(len(self.vehicle_roles)):
                ET.SubElement(
                    role_element,
                    &#34;VehicleRoleDistributionEntry&#34;,
                    attrib={
                        &#34;role&#34;: self.vehicle_roles[i].get_name(),
                        &#34;weight&#34;: str(self.vehicle_roles_weights[i]),
                    },
                )
        return element</code></pre>
</details>
<div class="desc"><p>the TrafficDefinition class creates a TrafficDefinition used by the different TrafficActions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the traffic definition
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the traffic definition

vehicleweights (list of floats): The weights of the vehicle categories (VehicleCategoryDistribution-weight)

vehiclecategories (list of VehicleCategory): the vehicle category ((VehicleCategoryDistribution-category))

controllerweights (list of floats): The weights of the controllers

controllers (list of Controller/CatalogReference): The controllers for the traffic
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_vehicle(vehiclecategory,weight)
    Adds a vehicle to the traffic definition

add_controller(controller,weight)
    Adds a controller to the traffic definition
</code></pre>
<p>initalize the TrafficDefinition</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the traffic definition
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficDefinition

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)

    Returns
    -------
        td (TrafficDefinition): a TrafficDefinition object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    td = TrafficDefinition(name)

    vehicle_distributions = element.find(&#34;VehicleCategoryDistribution&#34;)
    vehicle_entries = vehicle_distributions.findall(
        &#34;VehicleCategoryDistributionEntry&#34;
    )
    for entry in vehicle_entries:
        weight = convert_float(entry.attrib[&#34;weight&#34;])
        category = convert_enum(entry.attrib[&#34;category&#34;], VehicleCategory)
        td.add_vehicle(category, weight)

    controller_distributions = element.find(&#34;ControllerDistribution&#34;)
    controller_entries = controller_distributions.findall(
        &#34;ControllerDistributionEntry&#34;
    )
    for controller_dist in controller_entries:
        weight = convert_float(controller_dist.attrib[&#34;weight&#34;])
        if controller_dist.find(&#34;Controller&#34;):
            controller = Controller.parse(controller_dist.find(&#34;Controller&#34;))
            td.add_controller(controller, weight)
        else:
            catalog_reference = CatalogReference.parse(
                controller_dist.find(&#34;CatalogReference&#34;)
            )
            td.add_controller(catalog_reference, weight)

    vehicle_role_distributions = element.find(&#34;VehicleRoleDistribution&#34;)
    if vehicle_role_distributions is not None:
        for entry in vehicle_role_distributions.findall(
            &#34;VehicleRoleDistributionEntry&#34;
        ):
            td.add_vehicle_role(
                convert_enum(entry.attrib[&#34;role&#34;], Role), entry.attrib[&#34;weight&#34;]
            )
    return td</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TrafficDefinition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>td (TrafficDefinition): a TrafficDefinition object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.add_controller"><code class="name flex">
<span>def <span class="ident">add_controller</span></span>(<span>self, controller, weight)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_controller(self, controller, weight):
    &#34;&#34;&#34;Adds a controller to the traffic distribution

    Parameters
    ----------
        controller (Controller or CatalogReference): a controller or catalog reference to a controller

        weight (float): the corresponding weight for the controller

    &#34;&#34;&#34;
    if not (
        isinstance(controller, Controller)
        or isinstance(controller, CatalogReference)
    ):
        raise TypeError(
            &#34;controller input not of type Controller or CatalogReference&#34;
        )
    self.controllers.append(controller)
    self.controllerweights.append(weight)
    return self</code></pre>
</details>
<div class="desc"><p>Adds a controller to the traffic distribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>controller (Controller or CatalogReference): a controller or catalog reference to a controller

weight (float): the corresponding weight for the controller
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle"><code class="name flex">
<span>def <span class="ident">add_vehicle</span></span>(<span>self, vehiclecategory, weight)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vehicle(self, vehiclecategory, weight):
    &#34;&#34;&#34;Adds a vehicle to the traffic distribution

    Parameters
    ----------
        vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

        weight (float): the corresponding weight for the distribution of the vehicle category

    &#34;&#34;&#34;
    self.vehiclecategories.append(convert_enum(vehiclecategory, VehicleCategory))
    self.vehicleweights.append(weight)
    return self</code></pre>
</details>
<div class="desc"><p>Adds a vehicle to the traffic distribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

weight (float): the corresponding weight for the distribution of the vehicle category
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle_role"><code class="name flex">
<span>def <span class="ident">add_vehicle_role</span></span>(<span>self, vehicle_role, weight)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vehicle_role(self, vehicle_role, weight):
    &#34;&#34;&#34;Adds a vehicle role to a distribution

    Parameters
    ----------
        vehicle_role (Role): add a role to the vehicle role distribution

        weight (float): the weight of that vehicle role
    &#34;&#34;&#34;
    self.vehicle_roles_weights.append(convert_float(weight))
    self.vehicle_roles.append(convert_enum(vehicle_role, Role))</code></pre>
</details>
<div class="desc"><p>Adds a vehicle role to a distribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>vehicle_role (Role): add a role to the vehicle role distribution

weight (float): the weight of that vehicle role
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficDefinition&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TrafficDefinition</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficDefinition&#34;&#34;&#34;
    if not self.controllers:
        ValueError(&#34;No controllers defined for the TrafficDefinition&#34;)
    if not self.vehiclecategories:
        ValueError(&#34;No Vehicles defined for the TrafficDefinition&#34;)

    element = ET.Element(&#34;TrafficDefinition&#34;, attrib=self.get_attributes())

    veh_element = ET.SubElement(element, &#34;VehicleCategoryDistribution&#34;)
    for i in range(len(self.vehiclecategories)):
        ET.SubElement(
            veh_element,
            &#34;VehicleCategoryDistributionEntry&#34;,
            attrib={
                &#34;category&#34;: self.vehiclecategories[i].get_name(),
                &#34;weight&#34;: str(self.vehicleweights[i]),
            },
        )

    cnt_element = ET.SubElement(element, &#34;ControllerDistribution&#34;)
    for i in range(len(self.controllers)):
        tmp_controller = ET.SubElement(
            cnt_element,
            &#34;ControllerDistributionEntry&#34;,
            attrib={&#34;weight&#34;: str(self.controllerweights[i])},
        )
        tmp_controller.append(self.controllers[i].get_element())
    if self.vehicle_roles:
        if self.version_minor &lt; 2:
            raise OpenSCENARIOVersionError(
                &#34;VehicleRoleDistribution was added in OSC V1.2&#34;
            )
        role_element = ET.SubElement(element, &#34;VehicleRoleDistribution&#34;)
        for i in range(len(self.vehicle_roles)):
            ET.SubElement(
                role_element,
                &#34;VehicleRoleDistributionEntry&#34;,
                attrib={
                    &#34;role&#34;: self.vehicle_roles[i].get_name(),
                    &#34;weight&#34;: str(self.vehicle_roles_weights[i]),
                },
            )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TrafficDefinition</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController"><code class="flex name class">
<span>class <span class="ident">TrafficSignalController</span></span>
<span>(</span><span>name, delay=None, reference=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalController(VersionBase):
    &#34;&#34;&#34;the TrafficSignalController class creates a polyline of (minimum 2) positions

    Parameters
    ----------
        name (str): if of the trafic signal

        delay (float): delay of the phase shift
            Default: None

        reference (string): id to the controller in the roadnetwork
            Default: None

    Attributes
    ----------
        name (str): if of the trafic signal

        delay (float): delay of the phase shift
            Default: None
        reference (string): id to the controller in the roadnetwork
            Default: None

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

        add_phase(Phase)
            add a phase to the trafficsitnal controller
    &#34;&#34;&#34;

    def __init__(self, name, delay=None, reference=None):
        &#34;&#34;&#34;initalize the TrafficSignalController

        Parameters
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None

            reference (string): id to the controller in the RoadNetwork
                Default: None

        &#34;&#34;&#34;

        self.name = name
        self.delay = delay
        self.reference = reference
        self.phases = []

    def __eq__(self, other):
        if isinstance(other, TrafficSignalController):
            if (
                self.get_attributes() == other.get_attributes()
                and self.phases == other.phases
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TrafficSignalController

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)

        Returns
        -------
            tsc (TrafficSignalController): a TrafficSignalController object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]

        delay = None
        if &#34;delay&#34; in element.attrib:
            delay = element.attrib[&#34;delay&#34;]

        reference = None
        if &#34;reference&#34; in element.attrib:
            reference = element.attrib[&#34;reference&#34;]

        tsc = TrafficSignalController(name, delay, reference)

        phases = element.findall(&#34;Phase&#34;)
        if phases != None:
            for phase in phases:
                tsc.phases.append(Phase.parse(phase))

        return tsc

    def add_phase(self, phase):
        &#34;&#34;&#34;Adds a phase of the traffic signal

        Parameters
        ----------
            phase (Phase): a phase of the trafficsignal

        &#34;&#34;&#34;
        if not isinstance(phase, Phase):
            raise TypeError(&#34;phase input is not of type Phase&#34;)
        self.phases.append(phase)
        return self

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TrafficSignalController&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;name&#34;] = self.name
        if self.delay is not None:
            retdict[&#34;delay&#34;] = str(self.delay)
        if self.reference:
            retdict[&#34;reference&#34;] = self.reference
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the TrafficSignalController&#34;&#34;&#34;
        element = ET.Element(&#34;TrafficSignalController&#34;, attrib=self.get_attributes())
        for ph in self.phases:
            element.append(ph.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>the TrafficSignalController class creates a polyline of (minimum 2) positions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None

reference (string): id to the controller in the roadnetwork
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None
reference (string): id to the controller in the roadnetwork
    Default: None
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_phase(Phase)
    add a phase to the trafficsitnal controller
</code></pre>
<p>initalize the TrafficSignalController</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None

reference (string): id to the controller in the RoadNetwork
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TrafficSignalController

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)

    Returns
    -------
        tsc (TrafficSignalController): a TrafficSignalController object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]

    delay = None
    if &#34;delay&#34; in element.attrib:
        delay = element.attrib[&#34;delay&#34;]

    reference = None
    if &#34;reference&#34; in element.attrib:
        reference = element.attrib[&#34;reference&#34;]

    tsc = TrafficSignalController(name, delay, reference)

    phases = element.findall(&#34;Phase&#34;)
    if phases != None:
        for phase in phases:
            tsc.phases.append(Phase.parse(phase))

    return tsc</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TrafficSignalController</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tsc (TrafficSignalController): a TrafficSignalController object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.add_phase"><code class="name flex">
<span>def <span class="ident">add_phase</span></span>(<span>self, phase)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_phase(self, phase):
    &#34;&#34;&#34;Adds a phase of the traffic signal

    Parameters
    ----------
        phase (Phase): a phase of the trafficsignal

    &#34;&#34;&#34;
    if not isinstance(phase, Phase):
        raise TypeError(&#34;phase input is not of type Phase&#34;)
    self.phases.append(phase)
    return self</code></pre>
</details>
<div class="desc"><p>Adds a phase of the traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>phase (Phase): a phase of the trafficsignal
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TrafficSignalController&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;name&#34;] = self.name
    if self.delay is not None:
        retdict[&#34;delay&#34;] = str(self.delay)
    if self.reference:
        retdict[&#34;reference&#34;] = self.reference
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TrafficSignalController</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the TrafficSignalController&#34;&#34;&#34;
    element = ET.Element(&#34;TrafficSignalController&#34;, attrib=self.get_attributes())
    for ph in self.phases:
        element.append(ph.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TrafficSignalController</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics"><code class="flex name class">
<span>class <span class="ident">TransitionDynamics</span></span>
<span>(</span><span>shape, dimension, value:Â float, following_mode=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransitionDynamics(VersionBase):
    &#34;&#34;&#34;TransitionDynamics is used to define how the dynamics of a change

    Parameters
    ----------
        shape (DynamicsShapes): shape of the transition

        dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

        value (float): the value of the dynamics (time rate or distance)

        following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)
            Default: None

    Attributes
    ----------
        shape (DynamicsShapes): shape of the transition

        dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

        value (float): the value of the dynamics (time rate or distance)

        following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, shape, dimension, value: float, following_mode=None):
        &#34;&#34;&#34;
        Parameters
        ----------
            shape (DynamicsShapes): shape of the transition

            dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

            value (float): the value of the dynamics (time rate or distance)

            following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)
                Default: None
        &#34;&#34;&#34;

        self.shape = convert_enum(shape, DynamicsShapes, False)
        self.dimension = convert_enum(dimension, DynamicsDimension, False)
        self.value = convert_float(value)
        self.following_mode = convert_enum(following_mode, FollowingMode, True)

    def __eq__(self, other):
        if isinstance(other, TransitionDynamics):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of TransitionDynamics

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)

        Returns
        -------
            transitiondynamics (TransitionDynamics): a TransitionDynamics object

        &#34;&#34;&#34;
        shape = convert_enum(element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes)
        dimension = convert_enum(element.attrib[&#34;dynamicsDimension&#34;], DynamicsDimension)
        value = convert_float(element.attrib[&#34;value&#34;])
        following_mode = None
        if &#34;followingMode&#34; in element.attrib:
            following_mode = convert_enum(
                element.attrib[&#34;followingMode&#34;], FollowingMode
            )
        return TransitionDynamics(shape, dimension, value, following_mode)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the TransitionDynamics as a dict&#34;&#34;&#34;
        retdict = {
            &#34;dynamicsShape&#34;: self.shape.get_name(),
            &#34;value&#34;: str(self.value),
            &#34;dynamicsDimension&#34;: self.dimension.get_name(),
        }
        if self.following_mode is not None:
            retdict[&#34;followingMode&#34;] = self.following_mode.get_name()
        return retdict

    def get_element(self, name=&#34;TransitionDynamics&#34;):
        &#34;&#34;&#34;returns the elementTree of the TransitionDynamics&#34;&#34;&#34;
        return ET.Element(name, self.get_attributes())</code></pre>
</details>
<div class="desc"><p>TransitionDynamics is used to define how the dynamics of a change</p>
<h2 id="parameters">Parameters</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)

following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)

following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<h2 id="parameters_1">Parameters</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)

following_mode (FollowingMode): the following mode of the TransitionDynamics (valid from OSC V1.2)
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of TransitionDynamics

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)

    Returns
    -------
        transitiondynamics (TransitionDynamics): a TransitionDynamics object

    &#34;&#34;&#34;
    shape = convert_enum(element.attrib[&#34;dynamicsShape&#34;], DynamicsShapes)
    dimension = convert_enum(element.attrib[&#34;dynamicsDimension&#34;], DynamicsDimension)
    value = convert_float(element.attrib[&#34;value&#34;])
    following_mode = None
    if &#34;followingMode&#34; in element.attrib:
        following_mode = convert_enum(
            element.attrib[&#34;followingMode&#34;], FollowingMode
        )
    return TransitionDynamics(shape, dimension, value, following_mode)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of TransitionDynamics</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>transitiondynamics (TransitionDynamics): a TransitionDynamics object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the TransitionDynamics as a dict&#34;&#34;&#34;
    retdict = {
        &#34;dynamicsShape&#34;: self.shape.get_name(),
        &#34;value&#34;: str(self.value),
        &#34;dynamicsDimension&#34;: self.dimension.get_name(),
    }
    if self.following_mode is not None:
        retdict[&#34;followingMode&#34;] = self.following_mode.get_name()
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the TransitionDynamics as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, name='TransitionDynamics')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, name=&#34;TransitionDynamics&#34;):
    &#34;&#34;&#34;returns the elementTree of the TransitionDynamics&#34;&#34;&#34;
    return ET.Element(name, self.get_attributes())</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the TransitionDynamics</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.UserDefinedAnimation"><code class="flex name class">
<span>class <span class="ident">UserDefinedAnimation</span></span>
<span>(</span><span>type)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedAnimation(_AnimationType):
    &#34;&#34;&#34;The UserDefinedAnimation creates a UserDefinedAnimation element used by AnimationType

    Parameters
    ----------
        userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.

    Attributes
    ----------

        userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, type):
        &#34;&#34;&#34;initalizes the UserDefinedAnimation

        Parameters
        ----------
        userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.

        &#34;&#34;&#34;
        self.type = type

    def __eq__(self, other):
        if isinstance(other, UserDefinedAnimation):
            if other.get_attributes() == self.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of a UserDefinedAnimation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedAnimation element

        Returns
        -------
            UserDefinedAnimation (UserDefinedAnimation): a UserDefinedAnimation object

        &#34;&#34;&#34;

        return UserDefinedAnimation(element.attrib[&#34;userDefinedAnimationType&#34;])

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the UserDefinedAnimation as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;userDefinedAnimationType&#34;] = self.type
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedAnimation&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;UserDefinedAnimation was introduced in OpenSCENARIO V1.2&#34;
            )

        element = ET.Element(&#34;UserDefinedAnimation&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>The UserDefinedAnimation creates a UserDefinedAnimation element used by AnimationType</p>
<h2 id="parameters">Parameters</h2>
<pre><code>userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the UserDefinedAnimation</p>
<h2 id="parameters_1">Parameters</h2>
<p>userDefinedAnimationType (str): the available user defined animation types are subject of a contract between simulation environment provider and scenario author.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._AnimationType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedAnimation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of a UserDefinedAnimation

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a UserDefinedAnimation element

    Returns
    -------
        UserDefinedAnimation (UserDefinedAnimation): a UserDefinedAnimation object

    &#34;&#34;&#34;

    return UserDefinedAnimation(element.attrib[&#34;userDefinedAnimationType&#34;])</code></pre>
</details>
<div class="desc"><p>Parses the xml element of a UserDefinedAnimation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a UserDefinedAnimation element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>UserDefinedAnimation (UserDefinedAnimation): a UserDefinedAnimation object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedAnimation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the UserDefinedAnimation as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;userDefinedAnimationType&#34;] = self.type
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the UserDefinedAnimation as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.UserDefinedAnimation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the UserDefinedAnimation&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;UserDefinedAnimation was introduced in OpenSCENARIO V1.2&#34;
        )

    element = ET.Element(&#34;UserDefinedAnimation&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the UserDefinedAnimation</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.UserDefinedComponent"><code class="flex name class">
<span>class <span class="ident">UserDefinedComponent</span></span>
<span>(</span><span>type)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedComponent(_AnimationType):
    &#34;&#34;&#34;The UserDefinedComponent creates a UserDefinedComponent as part of a ComponentAnimation

    Parameters
    ----------
        userDefinedComponentType (str): User defined component type.

    Attributes
    ----------

        userDefinedComponentType (str): User defined component type.

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, type):
        &#34;&#34;&#34;initalizes the UserDefinedComponent

        Parameters
        ----------
        userDefinedComponentType (str): User defined component type.

        &#34;&#34;&#34;
        self.type = type

    def __eq__(self, other):
        if isinstance(other, UserDefinedComponent):
            if other.get_attributes() == self.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of a UserDefinedComponent

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedComponent element

        Returns
        -------
            UserDefinedComponent (UserDefinedComponent): a UserDefinedComponent object

        &#34;&#34;&#34;

        return UserDefinedComponent(element.attrib[&#34;userDefinedComponentType&#34;])

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the UserDefinedComponent as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;userDefinedComponentType&#34;] = self.type
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedComponent&#34;&#34;&#34;
        if not self.isVersion(minor=2):
            raise OpenSCENARIOVersionError(
                &#34;UserDefinedComponent was introduced in OpenSCENARIO V1.2&#34;
            )

        element = ET.Element(&#34;UserDefinedComponent&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>The UserDefinedComponent creates a UserDefinedComponent as part of a ComponentAnimation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>userDefinedComponentType (str): User defined component type.
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>userDefinedComponentType (str): User defined component type.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalizes the UserDefinedComponent</p>
<h2 id="parameters_1">Parameters</h2>
<p>userDefinedComponentType (str): User defined component type.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scenariogeneration.xosc.utils._AnimationType</li>
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedComponent.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of a UserDefinedComponent

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a UserDefinedComponent element

    Returns
    -------
        UserDefinedComponent (UserDefinedComponent): a UserDefinedComponent object

    &#34;&#34;&#34;

    return UserDefinedComponent(element.attrib[&#34;userDefinedComponentType&#34;])</code></pre>
</details>
<div class="desc"><p>Parses the xml element of a UserDefinedComponent</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a UserDefinedComponent element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>UserDefinedComponent (UserDefinedComponent): a UserDefinedComponent object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedComponent.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the UserDefinedComponent as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;userDefinedComponentType&#34;] = self.type
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the UserDefinedComponent as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.UserDefinedComponent.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the UserDefinedComponent&#34;&#34;&#34;
    if not self.isVersion(minor=2):
        raise OpenSCENARIOVersionError(
            &#34;UserDefinedComponent was introduced in OpenSCENARIO V1.2&#34;
        )

    element = ET.Element(&#34;UserDefinedComponent&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the UserDefinedComponent</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.UserDefinedLight"><code class="flex name class">
<span>class <span class="ident">UserDefinedLight</span></span>
<span>(</span><span>user_defined_type)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedLight(VersionBase):
    &#34;&#34;&#34;The CustomCommandAction creates a simulator defined action


    Parameters
    ----------
        user_defined_type (str): string of the user defined light

    Attributes
    ----------

        type (str): type of the custom command

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, user_defined_type):
        &#34;&#34;&#34;initalize the UserDefinedLight

        Parameters
        ----------
            user_defined_type (str): type of the custom command

        &#34;&#34;&#34;
        self.type = user_defined_type

    def __eq__(self, other):
        if isinstance(other, UserDefinedLight):
            if other.type == self.type:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parsese the xml element of a UserDefinedLight

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): a UserDefinedLight element

        Returns
        -------
            UserDefinedLight (UserDefinedLight): a UserDefinedLight object

        &#34;&#34;&#34;

        return UserDefinedLight(element.attrib[&#34;userDefinedLightType&#34;])

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the UserDefinedLight&#34;&#34;&#34;
        if self.isVersionEqLess(minor=1):
            raise OpenSCENARIOVersionError(&#34;UserDefinedLight was introduced in OSC 1.2&#34;)
        element = ET.Element(
            &#34;UserDefinedLight&#34;, attrib={&#34;userDefinedLightType&#34;: self.type}
        )
        return element</code></pre>
</details>
<div class="desc"><p>The CustomCommandAction creates a simulator defined action</p>
<h2 id="parameters">Parameters</h2>
<pre><code>user_defined_type (str): string of the user defined light
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>type (str): type of the custom command
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the UserDefinedLight</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>user_defined_type (str): type of the custom command
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedLight.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parsese the xml element of a UserDefinedLight

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): a UserDefinedLight element

    Returns
    -------
        UserDefinedLight (UserDefinedLight): a UserDefinedLight object

    &#34;&#34;&#34;

    return UserDefinedLight(element.attrib[&#34;userDefinedLightType&#34;])</code></pre>
</details>
<div class="desc"><p>Parsese the xml element of a UserDefinedLight</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): a UserDefinedLight element
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>UserDefinedLight (UserDefinedLight): a UserDefinedLight object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.UserDefinedLight.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the UserDefinedLight&#34;&#34;&#34;
    if self.isVersionEqLess(minor=1):
        raise OpenSCENARIOVersionError(&#34;UserDefinedLight was introduced in OSC 1.2&#34;)
    element = ET.Element(
        &#34;UserDefinedLight&#34;, attrib={&#34;userDefinedLightType&#34;: self.type}
    )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the UserDefinedLight</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraint"><code class="flex name class">
<span>class <span class="ident">ValueConstraint</span></span>
<span>(</span><span>rule, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueConstraint(VersionBase):
    &#34;&#34;&#34;Creates the the ValueConstraint file for open scenario

    Parameters
    ----------
        rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34;

        value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.

    Attributes
    ----------
        rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34;

        value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.


    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    # TODO: Only equalTo and notEqualTo test
    def __init__(self, rule, value):
        &#34;&#34;&#34;initalzie the ValueConstraint Class

        Parameters
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34;

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
        &#34;&#34;&#34;
        self.value = value
        self.rule = convert_enum(rule, Rule)

    def __eq__(self, other):
        if isinstance(other, ValueConstraint):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ValueConstraint

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

        Returns
        -------
            constraint (ValueConstraint): ValueConstraint object

        &#34;&#34;&#34;
        value = element.attrib[&#34;value&#34;]
        rule = convert_enum(element.attrib[&#34;rule&#34;], Rule)
        return ValueConstraint(rule, value)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the ValueConstraint as a dict&#34;&#34;&#34;
        retdict = {}
        retdict[&#34;rule&#34;] = self.rule.get_name()
        retdict[&#34;value&#34;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ValueConstraint&#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;ValueConstraint was introduced in OpenSCENARIO V1.1&#34;
            )
        element = ET.Element(&#34;ValueConstraint&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>Creates the the ValueConstraint file for open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the ValueConstraint Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ValueConstraint

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

    Returns
    -------
        constraint (ValueConstraint): ValueConstraint object

    &#34;&#34;&#34;
    value = element.attrib[&#34;value&#34;]
    rule = convert_enum(element.attrib[&#34;rule&#34;], Rule)
    return ValueConstraint(rule, value)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ValueConstraint</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>constraint (ValueConstraint): ValueConstraint object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the ValueConstraint as a dict&#34;&#34;&#34;
    retdict = {}
    retdict[&#34;rule&#34;] = self.rule.get_name()
    retdict[&#34;value&#34;] = str(self.value)
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the ValueConstraint as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ValueConstraint&#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;ValueConstraint was introduced in OpenSCENARIO V1.1&#34;
        )
    element = ET.Element(&#34;ValueConstraint&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ValueConstraint</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup"><code class="flex name class">
<span>class <span class="ident">ValueConstraintGroup</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueConstraintGroup(VersionBase):
    &#34;&#34;&#34;Creates the the ValueConstraintGroup file for open scenario

    Parameters
    ----------
        None

    Attributes
    ----------
        value_constraint (ValueConstraint): logical constraint, needed to evaluate to true for a defined parameter to start the simulation.


    Methods
    -------
        add_value_constraint(value_constraint)
            adds value constraint to the value constraint group

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element(elementname)
            Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self):
        self.value_constraints = []

    def __eq__(self, other):
        if isinstance(other, ValueConstraintGroup):
            if self.value_constraints == other.value_constraints:
                return True
        return False

    def add_value_constraint(self, value_constraint):
        &#34;&#34;&#34;adds a value constraint to the value constraint group

        Parameters
        ----------
            value_constraint (ValueConstraint): the value constraint to be added

        &#34;&#34;&#34;
        if not isinstance(value_constraint, ValueConstraint):
            raise TypeError(&#34;value_conatraint input is not of type ValueConstraint&#34;)
        self.value_constraints.append(value_constraint)
        return self

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of ValueConstraintGroup

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)

        Returns
        -------
            group (ValueConstraintGroup): a ValueConstraintGroup object

        &#34;&#34;&#34;
        value_constraints = ValueConstraintGroup()
        constraints = element.findall(&#34;ValueConstraint&#34;)
        for constraint in constraints:
            value_constraint = ValueConstraint.parse(constraint)
            value_constraints.add_value_constraint(value_constraint)
        return value_constraints

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the ValueConstraintGroup&#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;ValueConstraintGroup was introduced in OpenSCENARIO V1.1&#34;
            )
        element = ET.Element(&#34;ConstraintGroup&#34;)
        if not self.value_constraints:
            raise ValueError(&#34;No Value Constraints in the Value Contraint Group&#34;)
        for value_constraint in self.value_constraints:
            element.append(value_constraint.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>Creates the the ValueConstraintGroup file for open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value_constraint (ValueConstraint): logical constraint, needed to evaluate to true for a defined parameter to start the simulation.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_value_constraint(value_constraint)
    adds value constraint to the value constraint group

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of ValueConstraintGroup

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)

    Returns
    -------
        group (ValueConstraintGroup): a ValueConstraintGroup object

    &#34;&#34;&#34;
    value_constraints = ValueConstraintGroup()
    constraints = element.findall(&#34;ValueConstraint&#34;)
    for constraint in constraints:
        value_constraint = ValueConstraint.parse(constraint)
        value_constraints.add_value_constraint(value_constraint)
    return value_constraints</code></pre>
</details>
<div class="desc"><p>Parses the xml element of ValueConstraintGroup</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>group (ValueConstraintGroup): a ValueConstraintGroup object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint"><code class="name flex">
<span>def <span class="ident">add_value_constraint</span></span>(<span>self, value_constraint)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_value_constraint(self, value_constraint):
    &#34;&#34;&#34;adds a value constraint to the value constraint group

    Parameters
    ----------
        value_constraint (ValueConstraint): the value constraint to be added

    &#34;&#34;&#34;
    if not isinstance(value_constraint, ValueConstraint):
        raise TypeError(&#34;value_conatraint input is not of type ValueConstraint&#34;)
    self.value_constraints.append(value_constraint)
    return self</code></pre>
</details>
<div class="desc"><p>adds a value constraint to the value constraint group</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value_constraint (ValueConstraint): the value constraint to be added
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the ValueConstraintGroup&#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;ValueConstraintGroup was introduced in OpenSCENARIO V1.1&#34;
        )
    element = ET.Element(&#34;ConstraintGroup&#34;)
    if not self.value_constraints:
        raise ValueError(&#34;No Value Constraints in the Value Contraint Group&#34;)
    for value_constraint in self.value_constraints:
        element.append(value_constraint.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the ValueConstraintGroup</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>name, variable_type, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Variable(VersionBase):
    &#34;&#34;&#34;Variable is a declaration of an entry in VariableDeclaration
    (valid from V1.2)
    Parameters
    ----------
        name (str): name of variable

        variable_type (ParameterType): type of the variable

        value (str): value of the variable

    Attributes
    ----------
        name (str): name of variable

        variable_type (ParameterType): type of the variable

        value (str): value of the variable

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, name, variable_type, value):
        &#34;&#34;&#34;initalize the Variable

        Parameters
        ----------
            name (str): name of variable

            variable_type (ParameterType): type of the variable

            value (str): value of the variable

        &#34;&#34;&#34;
        self.name = name
        self.variable_type = convert_enum(variable_type, ParameterType, False)
        self.value = value
        self.constraint_groups = []

    def __eq__(self, other):
        if isinstance(other, Variable):
            if (
                self.get_attributes() == other.get_attributes()
                and self.constraint_groups == other.constraint_groups
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Variable

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A variable element (same as generated by the class itself)

        Returns
        -------
            variable (Variable): Variable object

        &#34;&#34;&#34;
        name = element.attrib[&#34;name&#34;]
        value = element.attrib[&#34;value&#34;]
        variable_type = convert_enum(
            element.attrib[&#34;variableType&#34;], ParameterType, False
        )
        variable = Variable(name, variable_type, value)
        constraint_groups = element.findall(&#34;ValueConstraintGroup&#34;)
        for constraint_group in constraint_groups:
            variable.add_value_constraint_group(
                ValueConstraintGroup.parse(constraint_group)
            )
        return variable

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Variable as a dict&#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;variableType&#34;: self.variable_type.get_name(),
            &#34;value&#34;: str(self.value),
        }

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Variable&#34;&#34;&#34;
        if self.isVersionEqLess(minor=1):
            raise OpenSCENARIOVersionError(&#34;Variables were introduced in OSC 1.2&#34;)
        element = ET.Element(&#34;VariableDeclaration&#34;, attrib=self.get_attributes())
        return element</code></pre>
</details>
<div class="desc"><p>Variable is a declaration of an entry in VariableDeclaration
(valid from V1.2)
Parameters</p>
<hr>
<pre><code>name (str): name of variable

variable_type (ParameterType): type of the variable

value (str): value of the variable
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of variable

variable_type (ParameterType): type of the variable

value (str): value of the variable
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Variable</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of variable

variable_type (ParameterType): type of the variable

value (str): value of the variable
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Variable.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Variable

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A variable element (same as generated by the class itself)

    Returns
    -------
        variable (Variable): Variable object

    &#34;&#34;&#34;
    name = element.attrib[&#34;name&#34;]
    value = element.attrib[&#34;value&#34;]
    variable_type = convert_enum(
        element.attrib[&#34;variableType&#34;], ParameterType, False
    )
    variable = Variable(name, variable_type, value)
    constraint_groups = element.findall(&#34;ValueConstraintGroup&#34;)
    for constraint_group in constraint_groups:
        variable.add_value_constraint_group(
            ValueConstraintGroup.parse(constraint_group)
        )
    return variable</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Variable</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A variable element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>variable (Variable): Variable object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Variable.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Variable as a dict&#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;variableType&#34;: self.variable_type.get_name(),
        &#34;value&#34;: str(self.value),
    }</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Variable as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Variable.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Variable&#34;&#34;&#34;
    if self.isVersionEqLess(minor=1):
        raise OpenSCENARIOVersionError(&#34;Variables were introduced in OSC 1.2&#34;)
    element = ET.Element(&#34;VariableDeclaration&#34;, attrib=self.get_attributes())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Variable</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.VariableDeclarations"><code class="flex name class">
<span>class <span class="ident">VariableDeclarations</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableDeclarations(VersionBase):
    &#34;&#34;&#34;The VariableDeclarations class creates the VariableDeclarations of OpenScenario
    (Valid from V1.2)
    Attributes
    ----------
        variables: list of Variable objects

    Methods
    -------
        get_element()
            Returns the full ElementTree of the class

        add_variable(Variable)
            adds a Variable to the VariableDeclarations

        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;initalizes the VariableDeclarations&#34;&#34;&#34;
        self.variables = []

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of VariableDeclarations

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A VariableDeclarations element (same as generated by the class itself)

        Returns
        -------
            VariableDeclarations (VariableDeclarations): a VariableDeclarations object

        &#34;&#34;&#34;
        variable_declarations = VariableDeclarations()
        declarations = element.findall(&#34;VariableDeclaration&#34;)
        for declaration in declarations:
            variable = Variable.parse(declaration)
            variable_declarations.add_variable(variable)
        return variable_declarations

    def __eq__(self, other):
        if isinstance(other, VariableDeclarations):
            if self.variables == other.variables:
                return True
        return False

    def add_variable(self, variable):
        &#34;&#34;&#34;add_variable adds a Variable to the VariableDeclarations

        Parameters
        ----------
            variable (Variable): a new variable


        &#34;&#34;&#34;
        if not isinstance(variable, Variable):
            raise TypeError(&#34;variable input is not of type Variable&#34;)
        self.variables.append(variable)
        return self

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the VariableDeclarations&#34;&#34;&#34;
        if self.version_minor &lt; 2:
            OpenSCENARIOVersionError(&#34;Variables were introduced in OSC 1.2&#34;)
        element = ET.Element(&#34;VariableDeclarations&#34;)
        for p in self.variables:
            element.append(p.get_element())
        return element</code></pre>
</details>
<div class="desc"><p>The VariableDeclarations class creates the VariableDeclarations of OpenScenario
(Valid from V1.2)
Attributes</p>
<hr>
<pre><code>variables: list of Variable objects
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_variable(Variable)
    adds a Variable to the VariableDeclarations

parse(element)
    parses a ElementTree created by the class and returns an instance of the class
</code></pre>
<p>initalizes the VariableDeclarations</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.VariableDeclarations.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of VariableDeclarations

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A VariableDeclarations element (same as generated by the class itself)

    Returns
    -------
        VariableDeclarations (VariableDeclarations): a VariableDeclarations object

    &#34;&#34;&#34;
    variable_declarations = VariableDeclarations()
    declarations = element.findall(&#34;VariableDeclaration&#34;)
    for declaration in declarations:
        variable = Variable.parse(declaration)
        variable_declarations.add_variable(variable)
    return variable_declarations</code></pre>
</details>
<div class="desc"><p>Parses the xml element of VariableDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A VariableDeclarations element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>VariableDeclarations (VariableDeclarations): a VariableDeclarations object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.VariableDeclarations.add_variable"><code class="name flex">
<span>def <span class="ident">add_variable</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variable(self, variable):
    &#34;&#34;&#34;add_variable adds a Variable to the VariableDeclarations

    Parameters
    ----------
        variable (Variable): a new variable


    &#34;&#34;&#34;
    if not isinstance(variable, Variable):
        raise TypeError(&#34;variable input is not of type Variable&#34;)
    self.variables.append(variable)
    return self</code></pre>
</details>
<div class="desc"><p>add_variable adds a Variable to the VariableDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>variable (Variable): a new variable
</code></pre></div>
</dd>
<dt id="scenariogeneration.xosc.utils.VariableDeclarations.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the VariableDeclarations&#34;&#34;&#34;
    if self.version_minor &lt; 2:
        OpenSCENARIOVersionError(&#34;Variables were introduced in OSC 1.2&#34;)
    element = ET.Element(&#34;VariableDeclarations&#34;)
    for p in self.variables:
        element.append(p.get_element())
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the VariableDeclarations</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Weather"><code class="flex name class">
<span>class <span class="ident">Weather</span></span>
<span>(</span><span>cloudstate=None,<br>atmosphericPressure=None,<br>temperature=None,<br>sun=None,<br>fog=None,<br>precipitation=None,<br>wind=None,<br>dome_image=None,<br>dome_azimuth_offset=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Weather(VersionBase):
    &#34;&#34;&#34;Weather creates an Weather element of openscenario

    Parameters
    ----------
        cloudstate (CloudState, or FractionalCloudCover): cloudstate of the weather (CloudState (V1.0-1.1), FractionalCloudCover (&gt;V1.2 ))
            Default: None

        atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
            Default: None

        temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
            Default: None

        sun (Sun): the sun position
            Default: None

        fog (Fog): fot state
            Default: None

        precipitation (Precipitation): the precipitation state
            Default: None

        wind (Wind): the wind (valid from OpenSCENARIO V1.1)
            Default: None

        dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)
            Default: None

        dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)
            Default: None
    Attributes
    ----------
        cloudstate (CloudState): cloudstate of the weather

        atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)

        temperature (float): outside temperature (valid from OpenSCENARIO V1.1)

        sun (Sun): the sun position

        fog (Fog): fot state

        precipitation (Precipitation): the precipitation state

        wind (Wind): the wind (valid from OpenSCENARIO V1.1)

        dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)

        dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(
        self,
        cloudstate=None,
        atmosphericPressure=None,
        temperature=None,
        sun=None,
        fog=None,
        precipitation=None,
        wind=None,
        dome_image=None,
        dome_azimuth_offset=None,
    ):
        &#34;&#34;&#34;initalize the Weather

        Parameters
        ----------
            cloudstate (CloudState, or FractionalCloudCover): cloudstate of the weather (CloudState (V1.0-1.1), FractionalCloudCover (&gt;V1.2 ))
                Default: None

            atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
                Default: None

            temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
                Default: None

            sun (Sun): the sun position
                Default: None

            fog (Fog): fot state
                Default: None

            precipitation (Precipitation): the precipitation state
                Default: None

            wind (Wind): the wind (valid from OpenSCENARIO V1.1)
                Default: None

            dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)
                Default: None

            dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)
                Default: None
        &#34;&#34;&#34;
        try:
            self.cloudstate = convert_enum(cloudstate, CloudState, True)
        except Exception as e:
            self.cloudstate = convert_enum(cloudstate, FractionalCloudCover, True)

        if precipitation and not isinstance(precipitation, Precipitation):
            raise TypeError(&#34;precipitation input is not of type Precipitation&#34;)
        if fog and not isinstance(fog, Fog):
            raise TypeError(&#34;fog input is not of type Fog&#34;)
        if wind and not isinstance(wind, Wind):
            raise TypeError(&#34;wind input is not of type Wind&#34;)
        if sun and not isinstance(sun, Sun):
            raise TypeError(&#34;sun input is not of type Sun&#34;)

        # self.cloudstate = cloudstate
        self.atmosphericPressure = atmosphericPressure
        self.temperature = temperature
        self.fog = fog
        self.sun = sun
        self.wind = wind
        self.precipitation = precipitation
        self.dome_image = dome_image
        self.dome_azimuth_offset = convert_float(dome_azimuth_offset)

    def __eq__(self, other):
        if isinstance(other, Weather):
            if (
                self.get_attributes() == other.get_attributes()
                and self.fog == other.fog
                and self.wind == other.wind
                and self.sun == other.sun
                and self.precipitation == other.precipitation
                and self.dome_image == other.dome_image
                and self.dome_azimuth_offset == other.dome_azimuth_offset
            ):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Weather

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)

        Returns
        -------
            weather (Weather): a Weather object

        &#34;&#34;&#34;
        temperature = None
        atmosphericPressure = None
        cloudstate = None
        fog = None
        sun = None
        wind = None
        precipitation = None
        dome_file = None
        dome_azimuth = None

        if &#34;temperature&#34; in element.attrib:
            temperature = element.attrib[&#34;temperature&#34;]
        if &#34;atmosphericPressure&#34; in element.attrib:
            atmosphericPressure = element.attrib[&#34;atmosphericPressure&#34;]
        if &#34;cloudState&#34; in element.attrib:
            cloudstate = convert_enum(element.attrib[&#34;cloudState&#34;], CloudState, False)
        if &#34;fractionalCloudCover&#34; in element.attrib:
            cloudstate = convert_enum(
                element.attrib[&#34;fractionalCloudCover&#34;], FractionalCloudCover
            )
        if element.find(&#34;Sun&#34;) != None:
            sun = Sun.parse(element.find(&#34;Sun&#34;))
        if element.find(&#34;Fog&#34;) != None:
            fog = Fog.parse(element.find(&#34;Fog&#34;))
        if element.find(&#34;Precipitation&#34;) != None:
            precipitation = Precipitation.parse(element.find(&#34;Precipitation&#34;))
        if element.find(&#34;Wind&#34;) != None:
            wind = Wind.parse(element.find(&#34;Wind&#34;))
        if element.find(&#34;DomeImage&#34;) != None:
            dome_file = element.find(&#34;DomeImage&#34;).find(&#34;DomeFile&#34;).attrib[&#34;filepath&#34;]

            if &#34;azimuthOffset&#34; in element.find(&#34;DomeImage&#34;).attrib:
                dome_azimuth = convert_float(
                    element.find(&#34;DomeImage&#34;).attrib[&#34;azimuthOffset&#34;]
                )
        return Weather(
            cloudstate,
            atmosphericPressure,
            temperature,
            sun,
            fog,
            precipitation,
            wind,
            dome_file,
            dome_azimuth,
        )

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Weather as a dict&#34;&#34;&#34;
        retdict = {}
        if self.cloudstate:
            if hasattr(CloudState, str(self.cloudstate)):
                if self.isVersionEqLarger(minor=2):
                    raise OpenSCENARIOVersionError(
                        &#34;Cloudstate is replaced with FractionalCloudCover for OSC versions &gt; 1.1&#34;
                    )
                retdict[&#34;cloudState&#34;] = self.cloudstate.get_name()
            elif hasattr(FractionalCloudCover, str(self.cloudstate)):
                if self.isVersionEqLess(minor=1):
                    raise OpenSCENARIOVersionError(
                        &#34;FractionalCloudCover was introduced in OSC 1.2&#34;
                    )
                retdict[&#34;fractionalCloudCover&#34;] = self.cloudstate.get_name()
            elif str(self.cloudstate)[0] == &#34;$&#34;:
                if self.isVersionEqLarger(minor=2):
                    retdict[&#34;fractionalCloudCover&#34;] = self.cloudstate.get_name()
                else:
                    retdict[&#34;cloudState&#34;] = self.cloudstate.get_name()
        if self.temperature is not None and not self.isVersion(minor=0):
            retdict[&#34;temperature&#34;] = str(self.temperature)
        elif self.temperature is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;temperature was introduced in OpenSCENARIO V1.1&#34;
            )
        if self.atmosphericPressure is not None and not self.isVersion(minor=0):
            retdict[&#34;atmosphericPressure&#34;] = str(self.atmosphericPressure)
        elif self.atmosphericPressure is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                &#34;atmosphericPressure was introduced in OpenSCENARIO V1.1&#34;
            )
        return retdict

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Weather&#34;&#34;&#34;
        if self.isVersion(minor=0):
            if self.sun == None:
                raise OpenSCENARIOVersionError(&#34;In OpenScenario 1.0, Sun is required.&#34;)
            if self.cloudstate == None:
                raise OpenSCENARIOVersionError(
                    &#34;In OpenScenario 1.0, CloudState is required.&#34;
                )
            if self.fog == None:
                raise OpenSCENARIOVersionError(&#34;In OpenScenario 1.0, Fog is required.&#34;)
            if self.precipitation == None:
                raise OpenSCENARIOVersionError(
                    &#34;In OpenScenario 1.0, Precipitation is required.&#34;
                )
        element = ET.Element(&#34;Weather&#34;, attrib=self.get_attributes())
        if self.sun:
            element.append(self.sun.get_element())
        if self.fog:
            element.append(self.fog.get_element())
        if self.precipitation:
            element.append(self.precipitation.get_element())
        if self.wind and not self.isVersion(minor=0):
            element.append(self.wind.get_element())
        if self.wind and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#34;Wind was introduced in OpenSCENARIO V1.1&#34;)
        if self.dome_image and (self.isVersion(minor=0) or self.isVersion(minor=1)):
            raise OpenSCENARIOVersionError(
                &#34;DomeImage was introduced in OpenSCENARIO V1.2&#34;
            )
        if self.dome_image:
            dome_attr = {}
            if self.dome_azimuth_offset:
                dome_attr[&#34;azimuthOffset&#34;] = str(self.dome_azimuth_offset)
            dome_element = ET.SubElement(element, &#34;DomeImage&#34;, attrib=dome_attr)
            ET.SubElement(
                dome_element, &#34;DomeFile&#34;, attrib={&#34;filepath&#34;: self.dome_image}
            )
        return element</code></pre>
</details>
<div class="desc"><p>Weather creates an Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>cloudstate (CloudState, or FractionalCloudCover): cloudstate of the weather (CloudState (V1.0-1.1), FractionalCloudCover (&gt;V1.2 ))
    Default: None

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
    Default: None

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
    Default: None

sun (Sun): the sun position
    Default: None

fog (Fog): fot state
    Default: None

precipitation (Precipitation): the precipitation state
    Default: None

wind (Wind): the wind (valid from OpenSCENARIO V1.1)
    Default: None

dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)
    Default: None

dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>cloudstate (CloudState): cloudstate of the weather

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)

sun (Sun): the sun position

fog (Fog): fot state

precipitation (Precipitation): the precipitation state

wind (Wind): the wind (valid from OpenSCENARIO V1.1)

dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)

dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Weather</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>cloudstate (CloudState, or FractionalCloudCover): cloudstate of the weather (CloudState (V1.0-1.1), FractionalCloudCover (&gt;V1.2 ))
    Default: None

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
    Default: None

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
    Default: None

sun (Sun): the sun position
    Default: None

fog (Fog): fot state
    Default: None

precipitation (Precipitation): the precipitation state
    Default: None

wind (Wind): the wind (valid from OpenSCENARIO V1.1)
    Default: None

dome_image (str): image file for the sky (valid from OpenSCENARIO V1.2)
    Default: None

dome_azimuth_offset (float): offset for dome image (valid from OpenSCENARIO V1.2)
    Default: None
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Weather.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Weather

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)

    Returns
    -------
        weather (Weather): a Weather object

    &#34;&#34;&#34;
    temperature = None
    atmosphericPressure = None
    cloudstate = None
    fog = None
    sun = None
    wind = None
    precipitation = None
    dome_file = None
    dome_azimuth = None

    if &#34;temperature&#34; in element.attrib:
        temperature = element.attrib[&#34;temperature&#34;]
    if &#34;atmosphericPressure&#34; in element.attrib:
        atmosphericPressure = element.attrib[&#34;atmosphericPressure&#34;]
    if &#34;cloudState&#34; in element.attrib:
        cloudstate = convert_enum(element.attrib[&#34;cloudState&#34;], CloudState, False)
    if &#34;fractionalCloudCover&#34; in element.attrib:
        cloudstate = convert_enum(
            element.attrib[&#34;fractionalCloudCover&#34;], FractionalCloudCover
        )
    if element.find(&#34;Sun&#34;) != None:
        sun = Sun.parse(element.find(&#34;Sun&#34;))
    if element.find(&#34;Fog&#34;) != None:
        fog = Fog.parse(element.find(&#34;Fog&#34;))
    if element.find(&#34;Precipitation&#34;) != None:
        precipitation = Precipitation.parse(element.find(&#34;Precipitation&#34;))
    if element.find(&#34;Wind&#34;) != None:
        wind = Wind.parse(element.find(&#34;Wind&#34;))
    if element.find(&#34;DomeImage&#34;) != None:
        dome_file = element.find(&#34;DomeImage&#34;).find(&#34;DomeFile&#34;).attrib[&#34;filepath&#34;]

        if &#34;azimuthOffset&#34; in element.find(&#34;DomeImage&#34;).attrib:
            dome_azimuth = convert_float(
                element.find(&#34;DomeImage&#34;).attrib[&#34;azimuthOffset&#34;]
            )
    return Weather(
        cloudstate,
        atmosphericPressure,
        temperature,
        sun,
        fog,
        precipitation,
        wind,
        dome_file,
        dome_azimuth,
    )</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Weather</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>weather (Weather): a Weather object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Weather.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Weather as a dict&#34;&#34;&#34;
    retdict = {}
    if self.cloudstate:
        if hasattr(CloudState, str(self.cloudstate)):
            if self.isVersionEqLarger(minor=2):
                raise OpenSCENARIOVersionError(
                    &#34;Cloudstate is replaced with FractionalCloudCover for OSC versions &gt; 1.1&#34;
                )
            retdict[&#34;cloudState&#34;] = self.cloudstate.get_name()
        elif hasattr(FractionalCloudCover, str(self.cloudstate)):
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(
                    &#34;FractionalCloudCover was introduced in OSC 1.2&#34;
                )
            retdict[&#34;fractionalCloudCover&#34;] = self.cloudstate.get_name()
        elif str(self.cloudstate)[0] == &#34;$&#34;:
            if self.isVersionEqLarger(minor=2):
                retdict[&#34;fractionalCloudCover&#34;] = self.cloudstate.get_name()
            else:
                retdict[&#34;cloudState&#34;] = self.cloudstate.get_name()
    if self.temperature is not None and not self.isVersion(minor=0):
        retdict[&#34;temperature&#34;] = str(self.temperature)
    elif self.temperature is not None and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;temperature was introduced in OpenSCENARIO V1.1&#34;
        )
    if self.atmosphericPressure is not None and not self.isVersion(minor=0):
        retdict[&#34;atmosphericPressure&#34;] = str(self.atmosphericPressure)
    elif self.atmosphericPressure is not None and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(
            &#34;atmosphericPressure was introduced in OpenSCENARIO V1.1&#34;
        )
    return retdict</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Weather as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Weather.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Weather&#34;&#34;&#34;
    if self.isVersion(minor=0):
        if self.sun == None:
            raise OpenSCENARIOVersionError(&#34;In OpenScenario 1.0, Sun is required.&#34;)
        if self.cloudstate == None:
            raise OpenSCENARIOVersionError(
                &#34;In OpenScenario 1.0, CloudState is required.&#34;
            )
        if self.fog == None:
            raise OpenSCENARIOVersionError(&#34;In OpenScenario 1.0, Fog is required.&#34;)
        if self.precipitation == None:
            raise OpenSCENARIOVersionError(
                &#34;In OpenScenario 1.0, Precipitation is required.&#34;
            )
    element = ET.Element(&#34;Weather&#34;, attrib=self.get_attributes())
    if self.sun:
        element.append(self.sun.get_element())
    if self.fog:
        element.append(self.fog.get_element())
    if self.precipitation:
        element.append(self.precipitation.get_element())
    if self.wind and not self.isVersion(minor=0):
        element.append(self.wind.get_element())
    if self.wind and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#34;Wind was introduced in OpenSCENARIO V1.1&#34;)
    if self.dome_image and (self.isVersion(minor=0) or self.isVersion(minor=1)):
        raise OpenSCENARIOVersionError(
            &#34;DomeImage was introduced in OpenSCENARIO V1.2&#34;
        )
    if self.dome_image:
        dome_attr = {}
        if self.dome_azimuth_offset:
            dome_attr[&#34;azimuthOffset&#34;] = str(self.dome_azimuth_offset)
        dome_element = ET.SubElement(element, &#34;DomeImage&#34;, attrib=dome_attr)
        ET.SubElement(
            dome_element, &#34;DomeFile&#34;, attrib={&#34;filepath&#34;: self.dome_image}
        )
    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Weather</p></div>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Wind"><code class="flex name class">
<span>class <span class="ident">Wind</span></span>
<span>(</span><span>direction, speed)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wind(VersionBase):
    &#34;&#34;&#34;Wind creates an Wind element used by the Weather element of openscenario

    Parameters
    ----------
        direction (float): wind direction (radians)

        speed (float): wind speed (m/s)

    Attributes
    ----------
        direction (float): wind direction (radians)

        speed (float): wind speed (m/s)

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, direction, speed):
        &#34;&#34;&#34;initalize the Wind

        Parameters
        ----------
            direction (float): wind direction (radians)

            speed (float): wind speed (m/s)

        &#34;&#34;&#34;
        self.direction = direction
        self.speed = speed

    def __eq__(self, other):
        if isinstance(other, Wind):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34;Parses the xml element of Wind

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)

        Returns
        -------
            wind (Wind): a Wind object

        &#34;&#34;&#34;
        direction = element.attrib[&#34;direction&#34;]
        speed = element.attrib[&#34;speed&#34;]

        return Wind(direction, speed)

    def get_attributes(self):
        &#34;&#34;&#34;returns the attributes of the Wind as a dict&#34;&#34;&#34;
        return {&#34;direction&#34;: str(self.direction), &#34;speed&#34;: str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34;returns the elementTree of the Wind&#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#34;Wind was introduced in OSC 1.1&#34;)
        element = ET.Element(&#34;Wind&#34;, attrib=self.get_attributes())

        return element</code></pre>
</details>
<div class="desc"><p>Wind creates an Wind element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Wind</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Wind.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34;Parses the xml element of Wind

    Parameters
    ----------
        element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)

    Returns
    -------
        wind (Wind): a Wind object

    &#34;&#34;&#34;
    direction = element.attrib[&#34;direction&#34;]
    speed = element.attrib[&#34;speed&#34;]

    return Wind(direction, speed)</code></pre>
</details>
<div class="desc"><p>Parses the xml element of Wind</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>wind (Wind): a Wind object
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Wind.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34;returns the attributes of the Wind as a dict&#34;&#34;&#34;
    return {&#34;direction&#34;: str(self.direction), &#34;speed&#34;: str(self.speed)}</code></pre>
</details>
<div class="desc"><p>returns the attributes of the Wind as a dict</p></div>
</dd>
<dt id="scenariogeneration.xosc.utils.Wind.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34;returns the elementTree of the Wind&#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#34;Wind was introduced in OSC 1.1&#34;)
    element = ET.Element(&#34;Wind&#34;, attrib=self.get_attributes())

    return element</code></pre>
</details>
<div class="desc"><p>returns the elementTree of the Wind</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.utils.convert_bool" href="#scenariogeneration.xosc.utils.convert_bool">convert_bool</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.convert_enum" href="#scenariogeneration.xosc.utils.convert_enum">convert_enum</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.convert_float" href="#scenariogeneration.xosc.utils.convert_float">convert_float</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.convert_int" href="#scenariogeneration.xosc.utils.convert_int">convert_int</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.get_bool_string" href="#scenariogeneration.xosc.utils.get_bool_string">get_bool_string</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.merge_dicts" href="#scenariogeneration.xosc.utils.merge_dicts">merge_dicts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed" href="#scenariogeneration.xosc.utils.AbsoluteSpeed">AbsoluteSpeed</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.get_element" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.parse" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.AnimationFile" href="#scenariogeneration.xosc.utils.AnimationFile">AnimationFile</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.AnimationFile.get_attributes" href="#scenariogeneration.xosc.utils.AnimationFile.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AnimationFile.get_element" href="#scenariogeneration.xosc.utils.AnimationFile.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AnimationFile.parse" href="#scenariogeneration.xosc.utils.AnimationFile.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.BoundingBox" href="#scenariogeneration.xosc.utils.BoundingBox">BoundingBox</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.BoundingBox.get_element" href="#scenariogeneration.xosc.utils.BoundingBox.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.BoundingBox.parse" href="#scenariogeneration.xosc.utils.BoundingBox.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Catalog" href="#scenariogeneration.xosc.utils.Catalog">Catalog</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Catalog.add_catalog" href="#scenariogeneration.xosc.utils.Catalog.add_catalog">add_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Catalog.get_element" href="#scenariogeneration.xosc.utils.Catalog.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Catalog.parse" href="#scenariogeneration.xosc.utils.Catalog.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.CatalogFile" href="#scenariogeneration.xosc.utils.CatalogFile">CatalogFile</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.add_to_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.add_to_catalog">add_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.create_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.create_catalog">create_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.create_catalog_element" href="#scenariogeneration.xosc.utils.CatalogFile.create_catalog_element">create_catalog_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.dump" href="#scenariogeneration.xosc.utils.CatalogFile.dump">dump</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.open_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.open_catalog">open_catalog</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.CatalogReference" href="#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment" href="#scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment">add_parameter_assignment</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.get_attributes" href="#scenariogeneration.xosc.utils.CatalogReference.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.get_element" href="#scenariogeneration.xosc.utils.CatalogReference.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.parse" href="#scenariogeneration.xosc.utils.CatalogReference.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Center" href="#scenariogeneration.xosc.utils.Center">Center</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Center.get_attributes" href="#scenariogeneration.xosc.utils.Center.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Center.get_element" href="#scenariogeneration.xosc.utils.Center.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Center.parse" href="#scenariogeneration.xosc.utils.Center.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Color" href="#scenariogeneration.xosc.utils.Color">Color</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Color.get_attributes" href="#scenariogeneration.xosc.utils.Color.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Color.get_element" href="#scenariogeneration.xosc.utils.Color.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Color.parse" href="#scenariogeneration.xosc.utils.Color.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ColorCMYK" href="#scenariogeneration.xosc.utils.ColorCMYK">ColorCMYK</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ColorCMYK.get_attributes" href="#scenariogeneration.xosc.utils.ColorCMYK.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ColorCMYK.get_element" href="#scenariogeneration.xosc.utils.ColorCMYK.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ColorCMYK.parse" href="#scenariogeneration.xosc.utils.ColorCMYK.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ColorRGB" href="#scenariogeneration.xosc.utils.ColorRGB">ColorRGB</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ColorRGB.get_attributes" href="#scenariogeneration.xosc.utils.ColorRGB.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ColorRGB.get_element" href="#scenariogeneration.xosc.utils.ColorRGB.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ColorRGB.parse" href="#scenariogeneration.xosc.utils.ColorRGB.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Controller" href="#scenariogeneration.xosc.utils.Controller">Controller</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Controller.get_attributes" href="#scenariogeneration.xosc.utils.Controller.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.get_element" href="#scenariogeneration.xosc.utils.Controller.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.parse" href="#scenariogeneration.xosc.utils.Controller.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Dimensions" href="#scenariogeneration.xosc.utils.Dimensions">Dimensions</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.get_attributes" href="#scenariogeneration.xosc.utils.Dimensions.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.get_element" href="#scenariogeneration.xosc.utils.Dimensions.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.parse" href="#scenariogeneration.xosc.utils.Dimensions.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.DirectionOfTravelDistribution" href="#scenariogeneration.xosc.utils.DirectionOfTravelDistribution">DirectionOfTravelDistribution</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_attributes" href="#scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_element" href="#scenariogeneration.xosc.utils.DirectionOfTravelDistribution.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DirectionOfTravelDistribution.parse" href="#scenariogeneration.xosc.utils.DirectionOfTravelDistribution.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints" href="#scenariogeneration.xosc.utils.DynamicsConstraints">DynamicsConstraints</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes" href="#scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.get_element" href="#scenariogeneration.xosc.utils.DynamicsConstraints.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.is_filled" href="#scenariogeneration.xosc.utils.DynamicsConstraints.is_filled">is_filled</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.parse" href="#scenariogeneration.xosc.utils.DynamicsConstraints.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.EntityRef" href="#scenariogeneration.xosc.utils.EntityRef">EntityRef</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.get_attributes" href="#scenariogeneration.xosc.utils.EntityRef.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.get_element" href="#scenariogeneration.xosc.utils.EntityRef.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.parse" href="#scenariogeneration.xosc.utils.EntityRef.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Environment" href="#scenariogeneration.xosc.utils.Environment">Environment</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Environment.get_attributes" href="#scenariogeneration.xosc.utils.Environment.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.get_element" href="#scenariogeneration.xosc.utils.Environment.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.parse" href="#scenariogeneration.xosc.utils.Environment.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.FileHeader" href="#scenariogeneration.xosc.utils.FileHeader">FileHeader</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.get_attributes" href="#scenariogeneration.xosc.utils.FileHeader.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.get_element" href="#scenariogeneration.xosc.utils.FileHeader.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.parse" href="#scenariogeneration.xosc.utils.FileHeader.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Fog" href="#scenariogeneration.xosc.utils.Fog">Fog</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Fog.get_attributes" href="#scenariogeneration.xosc.utils.Fog.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Fog.get_element" href="#scenariogeneration.xosc.utils.Fog.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Fog.parse" href="#scenariogeneration.xosc.utils.Fog.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.License" href="#scenariogeneration.xosc.utils.License">License</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.License.get_attributes" href="#scenariogeneration.xosc.utils.License.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.License.get_element" href="#scenariogeneration.xosc.utils.License.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.License.parse" href="#scenariogeneration.xosc.utils.License.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Orientation" href="#scenariogeneration.xosc.utils.Orientation">Orientation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Orientation.get_attributes" href="#scenariogeneration.xosc.utils.Orientation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.get_element" href="#scenariogeneration.xosc.utils.Orientation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.is_filled" href="#scenariogeneration.xosc.utils.Orientation.is_filled">is_filled</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.parse" href="#scenariogeneration.xosc.utils.Orientation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Parameter" href="#scenariogeneration.xosc.utils.Parameter">Parameter</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Parameter.add_value_constraint_group" href="#scenariogeneration.xosc.utils.Parameter.add_value_constraint_group">add_value_constraint_group</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.get_attributes" href="#scenariogeneration.xosc.utils.Parameter.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.get_element" href="#scenariogeneration.xosc.utils.Parameter.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.parse" href="#scenariogeneration.xosc.utils.Parameter.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ParameterAssignment" href="#scenariogeneration.xosc.utils.ParameterAssignment">ParameterAssignment</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.get_attributes" href="#scenariogeneration.xosc.utils.ParameterAssignment.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.get_element" href="#scenariogeneration.xosc.utils.ParameterAssignment.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.parse" href="#scenariogeneration.xosc.utils.ParameterAssignment.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations" href="#scenariogeneration.xosc.utils.ParameterDeclarations">ParameterDeclarations</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter" href="#scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter">add_parameter</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.get_element" href="#scenariogeneration.xosc.utils.ParameterDeclarations.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.parse" href="#scenariogeneration.xosc.utils.ParameterDeclarations.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.PedestrianAnimation" href="#scenariogeneration.xosc.utils.PedestrianAnimation">PedestrianAnimation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.PedestrianAnimation.add_gesture" href="#scenariogeneration.xosc.utils.PedestrianAnimation.add_gesture">add_gesture</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.PedestrianAnimation.get_attributes" href="#scenariogeneration.xosc.utils.PedestrianAnimation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.PedestrianAnimation.get_element" href="#scenariogeneration.xosc.utils.PedestrianAnimation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.PedestrianAnimation.parse" href="#scenariogeneration.xosc.utils.PedestrianAnimation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Phase" href="#scenariogeneration.xosc.utils.Phase">Phase</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Phase.add_signal_state" href="#scenariogeneration.xosc.utils.Phase.add_signal_state">add_signal_state</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.get_attributes" href="#scenariogeneration.xosc.utils.Phase.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.get_element" href="#scenariogeneration.xosc.utils.Phase.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.parse" href="#scenariogeneration.xosc.utils.Phase.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Precipitation" href="#scenariogeneration.xosc.utils.Precipitation">Precipitation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.get_attributes" href="#scenariogeneration.xosc.utils.Precipitation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.get_element" href="#scenariogeneration.xosc.utils.Precipitation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.parse" href="#scenariogeneration.xosc.utils.Precipitation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Properties" href="#scenariogeneration.xosc.utils.Properties">Properties</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Properties.add_file" href="#scenariogeneration.xosc.utils.Properties.add_file">add_file</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.add_property" href="#scenariogeneration.xosc.utils.Properties.add_property">add_property</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.get_element" href="#scenariogeneration.xosc.utils.Properties.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.parse" href="#scenariogeneration.xosc.utils.Properties.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster">RelativeSpeedToMaster</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.RoadCondition" href="#scenariogeneration.xosc.utils.RoadCondition">RoadCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.get_attributes" href="#scenariogeneration.xosc.utils.RoadCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.get_element" href="#scenariogeneration.xosc.utils.RoadCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.parse" href="#scenariogeneration.xosc.utils.RoadCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Sun" href="#scenariogeneration.xosc.utils.Sun">Sun</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Sun.get_attributes" href="#scenariogeneration.xosc.utils.Sun.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Sun.get_element" href="#scenariogeneration.xosc.utils.Sun.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Sun.parse" href="#scenariogeneration.xosc.utils.Sun.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState">TargetDistanceSteadyState</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState">TargetTimeSteadyState</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.parse" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TimeOfDay" href="#scenariogeneration.xosc.utils.TimeOfDay">TimeOfDay</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.get_attributes" href="#scenariogeneration.xosc.utils.TimeOfDay.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.get_element" href="#scenariogeneration.xosc.utils.TimeOfDay.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.parse" href="#scenariogeneration.xosc.utils.TimeOfDay.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TimeReference" href="#scenariogeneration.xosc.utils.TimeReference">TimeReference</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.get_attributes" href="#scenariogeneration.xosc.utils.TimeReference.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.get_element" href="#scenariogeneration.xosc.utils.TimeReference.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.parse" href="#scenariogeneration.xosc.utils.TimeReference.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TrafficDefinition" href="#scenariogeneration.xosc.utils.TrafficDefinition">TrafficDefinition</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.add_controller" href="#scenariogeneration.xosc.utils.TrafficDefinition.add_controller">add_controller</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle" href="#scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle">add_vehicle</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle_role" href="#scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle_role">add_vehicle_role</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.get_attributes" href="#scenariogeneration.xosc.utils.TrafficDefinition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.get_element" href="#scenariogeneration.xosc.utils.TrafficDefinition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.parse" href="#scenariogeneration.xosc.utils.TrafficDefinition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TrafficSignalController" href="#scenariogeneration.xosc.utils.TrafficSignalController">TrafficSignalController</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.add_phase" href="#scenariogeneration.xosc.utils.TrafficSignalController.add_phase">add_phase</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.get_attributes" href="#scenariogeneration.xosc.utils.TrafficSignalController.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.get_element" href="#scenariogeneration.xosc.utils.TrafficSignalController.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.parse" href="#scenariogeneration.xosc.utils.TrafficSignalController.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TransitionDynamics" href="#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.get_attributes" href="#scenariogeneration.xosc.utils.TransitionDynamics.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.get_element" href="#scenariogeneration.xosc.utils.TransitionDynamics.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.parse" href="#scenariogeneration.xosc.utils.TransitionDynamics.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.UserDefinedAnimation" href="#scenariogeneration.xosc.utils.UserDefinedAnimation">UserDefinedAnimation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedAnimation.get_attributes" href="#scenariogeneration.xosc.utils.UserDefinedAnimation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedAnimation.get_element" href="#scenariogeneration.xosc.utils.UserDefinedAnimation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedAnimation.parse" href="#scenariogeneration.xosc.utils.UserDefinedAnimation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.UserDefinedComponent" href="#scenariogeneration.xosc.utils.UserDefinedComponent">UserDefinedComponent</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedComponent.get_attributes" href="#scenariogeneration.xosc.utils.UserDefinedComponent.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedComponent.get_element" href="#scenariogeneration.xosc.utils.UserDefinedComponent.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedComponent.parse" href="#scenariogeneration.xosc.utils.UserDefinedComponent.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.UserDefinedLight" href="#scenariogeneration.xosc.utils.UserDefinedLight">UserDefinedLight</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedLight.get_element" href="#scenariogeneration.xosc.utils.UserDefinedLight.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.UserDefinedLight.parse" href="#scenariogeneration.xosc.utils.UserDefinedLight.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ValueConstraint" href="#scenariogeneration.xosc.utils.ValueConstraint">ValueConstraint</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.get_attributes" href="#scenariogeneration.xosc.utils.ValueConstraint.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.get_element" href="#scenariogeneration.xosc.utils.ValueConstraint.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.parse" href="#scenariogeneration.xosc.utils.ValueConstraint.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup" href="#scenariogeneration.xosc.utils.ValueConstraintGroup">ValueConstraintGroup</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint">add_value_constraint</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.get_element" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.parse" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Variable" href="#scenariogeneration.xosc.utils.Variable">Variable</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Variable.get_attributes" href="#scenariogeneration.xosc.utils.Variable.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Variable.get_element" href="#scenariogeneration.xosc.utils.Variable.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Variable.parse" href="#scenariogeneration.xosc.utils.Variable.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.VariableDeclarations" href="#scenariogeneration.xosc.utils.VariableDeclarations">VariableDeclarations</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.VariableDeclarations.add_variable" href="#scenariogeneration.xosc.utils.VariableDeclarations.add_variable">add_variable</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.VariableDeclarations.get_element" href="#scenariogeneration.xosc.utils.VariableDeclarations.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.VariableDeclarations.parse" href="#scenariogeneration.xosc.utils.VariableDeclarations.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Weather" href="#scenariogeneration.xosc.utils.Weather">Weather</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Weather.get_attributes" href="#scenariogeneration.xosc.utils.Weather.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Weather.get_element" href="#scenariogeneration.xosc.utils.Weather.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Weather.parse" href="#scenariogeneration.xosc.utils.Weather.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Wind" href="#scenariogeneration.xosc.utils.Wind">Wind</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Wind.get_attributes" href="#scenariogeneration.xosc.utils.Wind.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Wind.get_element" href="#scenariogeneration.xosc.utils.Wind.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Wind.parse" href="#scenariogeneration.xosc.utils.Wind.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
