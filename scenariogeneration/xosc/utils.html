<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>scenariogeneration.xosc.utils API documentation</title>
<meta name="description" content="The utils module contains the rest of the classes, such as Parameters, Environment, Routes and so on." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xosc.utils</code></h1>
</header>
<section id="section-intro">
<p>The utils module contains the rest of the classes, such as Parameters, Environment, Routes and so on.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; The utils module contains the rest of the classes, such as Parameters, Environment, Routes and so on.

&#34;&#34;&#34;
from abc import abstractstaticmethod
import os
from attr import attrib

from numpy.lib.arraysetops import isin
from .exceptions import OpenSCENARIOVersionError
import xml.etree.ElementTree as ET
from ..helpers import printToFile

from .enumerations import ParameterType, Rule, ReferenceContext, DynamicsShapes, DynamicsDimension, RouteStrategy,XSI,XMLNS, VehicleCategory,PrecipitationType,CloudState, VersionBase, SpeedTargetValueType
import datetime as dt

class _StochasticDistributionType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass

class _PositionType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass

    def get_element(self, param):
        pass


class _TriggerType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass

class _ValueTriggerType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass

class _EntityTriggerType(VersionBase):
    &#34;&#34;&#34; helper class for typesetting
    &#34;&#34;&#34;
    pass

class ParameterDeclarations(VersionBase):
    &#34;&#34;&#34; The ParameterDeclarations class creates the ParameterDeclaration of OpenScenario
                    
        Attributes
        ----------
            parameters: list of Parameter objects

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            add_parameter(Parameter)
                adds a Parameter to the ParameterDeclarations
            
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalizes the ParameterDeclarations

        &#34;&#34;&#34;
        self.parameters = []

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ParameterDeclarations

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)

            Returns
            -------
                parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object
                
        &#34;&#34;&#34;
        parameter_declarations = ParameterDeclarations()
        declarations = element.findall(&#39;ParameterDeclaration&#39;)
        for declaration in declarations:
            parameter_declaration = Parameter.parse(declaration)
            parameter_declarations.add_parameter(parameter_declaration)
        return parameter_declarations

    def __eq__(self,other):
        if isinstance(other,ParameterDeclarations):
            if self.parameters == other.parameters:
                return True
        return False

    def add_parameter(self,parameter):
        &#34;&#34;&#34; add_parameter adds a Parameter to the ParameterDeclarations

        Parameters
        ----------
            parameter (Parameter): a new parameter


        &#34;&#34;&#34;
        if not isinstance(parameter,Parameter):
            raise TypeError(&#39;parameter input is not of type Parameter&#39;)
        self.parameters.append(parameter)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterDeclarations

        &#34;&#34;&#34;
        element = ET.Element(&#39;ParameterDeclarations&#39;)
        for p in self.parameters:
            element.append(p.get_element())
        return element

class EntityRef(VersionBase):
    &#34;&#34;&#34; EntityRef creates an EntityRef element of openscenario
        
        Parameters
        ----------
            entity (str): name of the entity

        Attributes
        ----------
            entity (str): name of the entity

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,entity):
        &#34;&#34;&#34; initalize the EntityRef

            Parameters
            ----------
                entity (str): name of the entity
                
        &#34;&#34;&#34;
        self.entity = entity

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of EntityRef

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)

            Returns
            -------
                entityref (EntityRef): a EntityRef object

        &#34;&#34;&#34;
        entity = element.attrib[&#39;entityRef&#39;]
        return EntityRef(entity)

    def __eq__(self,other):
        if isinstance(other,EntityRef):
            if self.entity == other.entity:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the EntityRef as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entity}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the EntityRef

        &#34;&#34;&#34;
        return ET.Element(&#39;EntityRef&#39;,attrib=self.get_attributes())

class Parameter(VersionBase):
    &#34;&#34;&#34; Parameter is a declaration of a ParameterDeclaration for declarations
        
        Parameters
        ----------
            name (str): name of parameter

            parameter_type (ParameterType): type of the parameter 

            value (str): value of the parameter

        Attributes
        ----------
            name (str): name of parameter

            parameter_type (ParameterType): type of the parameter

            value (str): value of the parameter

            constraint_group (ValueConstraintGroup) constraint groups to the parameter value

        Methods
        -------
            add_parameter ???

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_value_constraint_group(constraint_group)
                adds a value constraint group to the Parameter

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self,name,parameter_type,value):
        &#34;&#34;&#34; initalize the Parameter 

            Parameters
            ----------
                name (str): name of parameter

                parameter_type (ParameterType): type of the parameter

                value (str): value of the parameter

        &#34;&#34;&#34;
        self.name = name
        if not hasattr(ParameterType,str(parameter_type)):
            raise ValueError(&#39;parameter_type not a valid type.&#39;)
        self.parameter_type = parameter_type
        self.value = value
        self.constraint_groups = []

    def __eq__(self,other):
        if isinstance(other,Parameter):
            if self.get_attributes() == other.get_attributes() and\
                self.constraint_groups == other.constraint_groups:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Parameter

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)

            Returns
            -------
                parameter (Parameter): Parameter object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        value = element.attrib[&#39;value&#39;]
        parameter_type = getattr(ParameterType, element.attrib[&#39;parameterType&#39;])
        parameter = Parameter(name, parameter_type, value)
        constraint_groups = element.findall(&#39;ValueConstraintGroup&#39;)
        for constraint_group in constraint_groups:
            parameter.add_value_constraint_group(ValueConstraintGroup.parse(constraint_group))
        return parameter
    
    def add_value_constraint_group(self,constraint_group):
        &#34;&#34;&#34; adds a value constraint to the value constraint group

        Parameters
        ----------
            constraint_group (ValueConstraintGroup): the value constraint group to be added 

        &#34;&#34;&#34;
        if not isinstance(constraint_group,ValueConstraintGroup):
            raise TypeError(&#39;value_conatraint input is not of type ValueConstraintGroup&#39;)
        self.constraint_groups.append(constraint_group)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Parameter as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name,&#39;parameterType&#39;:self.parameter_type.get_name(),&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Parameter

        &#34;&#34;&#34;
        element = ET.Element(&#39;ParameterDeclaration&#39;,attrib=self.get_attributes())
        if self.constraint_groups:
            for constraint_group in self.constraint_groups:
                element.append(constraint_group.get_element())
        return element

class Orientation(VersionBase):
    &#34;&#34;&#34; Orientation describes the angular orientation of an entity
        
        Parameters
        ----------
            h (float): header 

            p (float): pitch

            r (float): roll

            reference (ReferenceContext): absolute or relative

        Attributes
        ----------
            h (float): header 

            p (float): pitch

            r (float): roll

            reference (ReferenceContext): absolute or relative

        Methods
        -------
            is_filled()
                check is any orientations are set

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,h=None,p=None,r=None,reference = None):
        &#34;&#34;&#34; initalize Orientation 
        
            Parameters
            ----------
                h (float): header 

                p (float): pitch

                r (float): roll

                reference (ReferenceContext): absolute or relative
        &#34;&#34;&#34;
        self.h = convert_float(h)
        self.p = convert_float(p)
        self.r = convert_float(r)
        if reference is not None and not hasattr(ReferenceContext,str(reference)):
            raise TypeError(&#39;reference input is not of type ReferenceContext&#39;)
        self.ref = reference

    def __eq__(self,other):
        if isinstance(other,Orientation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Orientation

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

            Returns
            -------
                orientation (Orientation): a Orientation object

        &#34;&#34;&#34;
        h = None
        p = None
        r = None
        reference = None
        if &#39;h&#39; in element.attrib:
            h = convert_float(element.attrib[&#39;h&#39;])
        if &#39;p&#39; in element.attrib:
            p = convert_float(element.attrib[&#39;p&#39;])
        if &#39;r&#39; in element.attrib:
            r = convert_float(element.attrib[&#39;r&#39;])
        if &#39;type&#39; in element.attrib:
            reference_str = element.attrib[&#39;type&#39;]
            reference = getattr(ReferenceContext,reference_str)

        return Orientation(h ,p ,r ,reference)

    def is_filled(self):
        &#34;&#34;&#34; is_filled check is any orientations are  set

            Returns: boolean

        &#34;&#34;&#34;
        if self.h is not None or self.p is not None or self.r is not None or self.ref is not None:
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Orientation as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.h is not None:
            retdict[&#39;h&#39;] = str(self.h)

        if self.p is not None:
            retdict[&#39;p&#39;] = str(self.p)

        if self.r is not None:
            retdict[&#39;r&#39;] = str(self.r)

        if self.ref is not None:
            retdict[&#39;type&#39;] = self.ref.get_name()

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Orientation

        &#34;&#34;&#34;
        return ET.Element(&#39;Orientation&#39;,attrib=self.get_attributes())

class TransitionDynamics(VersionBase):
    &#34;&#34;&#34; TransitionDynamics is used to define how the dynamics of a change
        
        Parameters
        ----------
            shape (DynamicsShapes): shape of the transition

            dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

            value (float): the value of the dynamics (time rate or distance)


        Attributes
        ----------
            shape (DynamicsShapes): shape of the transition

            dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

            value (float): the value of the dynamics (time rate or distance)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,shape,dimension,value:float):
        &#34;&#34;&#34;
            Parameters
            ----------
                shape (DynamicsShapes): shape of the transition

                dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

                value (float): the value of the dynamics (time rate or distance)

        &#34;&#34;&#34;
        if not hasattr(DynamicsShapes,str(shape)):
            raise TypeError(shape + &#39;; is not a valid shape.&#39;)

        self.shape = shape
        if not hasattr(DynamicsDimension,str(dimension)):
            raise ValueError(dimension + &#39; is not a valid dynamics dimension&#39;)
        self.dimension = dimension
        self.value = convert_float(value)

    def __eq__(self,other):
        if isinstance(other,TransitionDynamics):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TransitionDynamics

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)

            Returns
            -------
                transitiondynamics (TransitionDynamics): a TransitionDynamics object

        &#34;&#34;&#34;
        shape = getattr(DynamicsShapes,element.attrib[&#39;dynamicsShape&#39;])
        dimension = getattr(DynamicsDimension,element.attrib[&#39;dynamicsDimension&#39;])
        value = convert_float(element.attrib[&#39;value&#39;])

        return TransitionDynamics(shape,dimension,value)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TransitionDynamics as a dict

        &#34;&#34;&#34;
        return {&#39;dynamicsShape&#39;:self.shape.get_name(),&#39;value&#39;:str(self.value),&#39;dynamicsDimension&#39;:self.dimension.get_name()}

    def get_element(self,name=&#39;TransitionDynamics&#39;):
        &#34;&#34;&#34; returns the elementTree of the TransitionDynamics

        &#34;&#34;&#34;
        return ET.Element(name,self.get_attributes())

class DynamicsConstraints(VersionBase):
    &#34;&#34;&#34; DynamicsConstraints is used by triggers
        
        Parameters
        ----------
            max_acceleration (float): maximum acceleration allowed

            max_deceleration (float): maximum deceleration allowed

            max_speed (float): maximum speed allowed

        Attributes
        ----------
            max_acceleration (float): maximum acceleration allowed

            max_deceleration (float): maximum deceleration allowed

            max_speed (float): maximum speed allowed

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            is_filled()
                check is any constraints are set

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, max_acceleration=None, max_deceleration=None, max_speed=None):
        &#34;&#34;&#34; initalize DynamicsConstrains

        &#34;&#34;&#34;

        self.max_acceleration = convert_float(max_acceleration)
        self.max_deceleration = convert_float(max_deceleration)
        self.max_speed = convert_float(max_speed)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of DynamicsConstraints

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)

            Returns
            -------
                constrains (DynamicsConstrains): a DynamicsConstrains object
                
        &#34;&#34;&#34;
        max_acceleration = None
        max_deceleration = None
        max_speed = None

        if &#39;maxAcceleration&#39; in element.attrib:
            max_acceleration = convert_float(element.attrib[&#39;maxAcceleration&#39;])
        if &#39;maxDeceleration&#39; in element.attrib:
            max_deceleration = convert_float(element.attrib[&#39;maxDeceleration&#39;])
        if &#39;maxSpeed&#39; in element.attrib:
            max_speed = convert_float(element.attrib[&#39;maxSpeed&#39;])       

        return DynamicsConstraints(max_acceleration, max_deceleration, max_speed) 

    def __eq__(self,other):
        if isinstance(other,DynamicsConstraints):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def is_filled(self):
        &#34;&#34;&#34; is_filled check is any constraints are set

            Returns: boolean

        &#34;&#34;&#34;

        if self.max_acceleration or self.max_deceleration or self.max_speed:
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the DynamicsConstrains as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.max_speed is not None:
            retdict[&#39;maxSpeed&#39;] = str(self.max_speed)
        if self.max_deceleration is not None:
            retdict[&#39;maxDeceleration&#39;] = str(self.max_deceleration)
        if self.max_acceleration is not None:
            retdict[&#39;maxAcceleration&#39;] = str(self.max_acceleration)
        return retdict

    def get_element(self,name = &#39;DynamicConstraints&#39;):
        &#34;&#34;&#34; returns the elementTree of the DynamicsConstrains

        &#34;&#34;&#34;
        return ET.Element(name,attrib=self.get_attributes())


class License(VersionBase):
    &#34;&#34;&#34; License creates the License used by FileHeader in the OpenScenario file 
        (valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            name (str): name of the License

            resource (str): link to URL
                Default: None

            spdxId (str): license identifier
                Default: None

        Attributes
        ----------
            name (str): name of the License

            resource (str): link to URL
                
            spdxId (str): license identifier

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of FileHeader

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    def __init__(self,name,resource=None,spdxId=None):
        &#34;&#34;&#34; init the License
        
        Parameters
        ----------
            name (str): name of the License

            resource (str): link to URL
                Default: None

            spdxId (str): license identifier
                Default: None
        &#34;&#34;&#34;
        self.name = name
        self.resource = resource
        self.spdxId = spdxId

    def __eq__(self,other):
        if isinstance(other,License):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    # TODO: Check Class License test string 0..1 The full license

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of License

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)

            Returns
            -------
                license (License): a License object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        resource = None
        if &#39;resource&#39; in element.attrib:
            resource = element.attrib[&#39;resource&#39;]
        spdxId = None
        if &#39;spdxId&#39; in element.attrib:
            spdxId = element.attrib[&#39;spdxId&#39;]
        
        return License(name, resource, spdxId)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the License

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        if self.resource:
            retdict[&#39;resource&#39;] = self.resource
        if self.spdxId:
            retdict[&#39;spdxId&#39;] = self.spdxId
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the License

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;License was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;License&#39;,attrib=self.get_attributes())

        return element

class FileHeader(VersionBase):
    &#34;&#34;&#34; FileHeader creates the header of the OpenScenario file1
        
        Parameters
        ----------
            name (str): name of the scenario 

            author (str): the author of the scenario

            revMinor (int): the minor revision of the standard
                Default: 1

            license (License): license (valid from OpenSCENARIO V1.1)
                Default: None

        Attributes
        ----------
            name (str): name of the scenario 

            author (str): the author of the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of FileHeader

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    def __init__(self,author,description,revMinor=1,license=None):
        self.description = description
        self.author = author
        self._revMajor = 1
        self._revMinor = revMinor
        self.setVersion(minor=revMinor)
        if license and not isinstance(license,License):
            raise TypeError(&#39;license is not of type License&#39;)
        self.license = license

    def __eq__(self,other):
        if isinstance(other,FileHeader):
            if self.description == other.description and \
            self.author == other.author and \
            self._revMajor == other._revMajor and \
            self._revMinor == other._revMinor:
            # will not compare date, since this will never be the same
                return True
        return False

    # TODO: License handling add_license ???

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of FileHeader

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)

            Returns
            -------
                header (FileHeader): a FileHeader object
                
        &#34;&#34;&#34;
        author = element.attrib[&#39;author&#39;]
        description = element.attrib[&#39;description&#39;]
        # revMinor = element.attrib[&#39;revMinor&#39;] 
        # revMajor = element.attrib[&#39;revMajor&#39;] 
        license = None
        if element.find(&#39;license&#39;) != None:
            license = License.parse(element.find(&#39;license&#39;))
        
        return FileHeader(author= author, description=description,license=license)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the FileHeader

        &#34;&#34;&#34;
        return {&#39;description&#39;:self.description,&#39;author&#39;:self.author,&#39;revMajor&#39;:str(self._revMajor),&#39;revMinor&#39;:str(self._revMinor),&#39;date&#39;:dt.datetime.now().isoformat()}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the FileHeader

        &#34;&#34;&#34;
        element = ET.Element(&#39;FileHeader&#39;,attrib=self.get_attributes())
        if self.license:
            element.append(self.license.get_element())
        return element



class TimeReference(VersionBase):
    &#34;&#34;&#34; the TimeReference class creates a TimeReference, 
        
        Parameters
        ----------
            referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
                Default: None

            scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
                Default: None

            offset (float): offset for time values (must be combined with referece_domain and scale)
                Default: None

        Attributes
        ----------
            referece_domain (ReferenceContext): absolute or relative time reference 

            scale (float): scalefactor of the timeings 

            offset (float): offset for time values 

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, reference_domain=None,scale=None,offset=None):
        &#34;&#34;&#34; initalize the TimeReference

            Parameters
            ----------
            referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
                Default: None

            scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
                Default: None

            offset (float): offset for time values (must be combined with referece_domain and scale)
                Default: None

        &#34;&#34;&#34;
        nones = [reference_domain == None, scale == None, offset == None]
        if sum(nones) == 3:
            self._only_nones = True
        elif sum(nones) == 0:
            self._only_nones = False
        else:
            raise ValueError(&#39;missing inputs for time reference&#39;)
        if reference_domain is not None and not hasattr(ReferenceContext,str(reference_domain)):
            raise TypeError(&#39;input reference_domain is not of type ReferenceContext&#39;)

        self.reference_domain = reference_domain
        self.scale = convert_float(scale)
        self.offset = convert_float(offset)

    def __eq__(self,other):
        if isinstance(other,TimeReference):
            if not self._only_nones and not other._only_nones:
                if self.get_attributes() == other.get_attributes():
                    return True
            elif (self._only_nones == other._only_nones):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TimeReference

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)

            Returns
            -------
                timing (TimeReference): a TimeReference object
                
        &#34;&#34;&#34;
        if element.find(&#39;None&#39;) != None:
            return TimeReference()

        timing_element = element.find(&#39;Timing&#39;) 
        scale = None
        offset = None
        reference_domain = None

        if &#39;offset&#39; in timing_element.attrib:
            offset = timing_element.attrib[&#39;offset&#39;]
        if &#39;scale&#39; in timing_element.attrib:
            scale = timing_element.attrib[&#39;scale&#39;]
        if &#39;domainAbsoluteRelative&#39; in timing_element.attrib:
            reference_domain = getattr(ReferenceContext, timing_element.attrib[&#39;domainAbsoluteRelative&#39;])
        
        return TimeReference(reference_domain, scale, offset)



    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TimeReference as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;domainAbsoluteRelative&#39;] = self.reference_domain.get_name()
        retdict[&#39;scale&#39;] = str(self.scale)
        retdict[&#39;offset&#39;] = str(self.offset)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TimeReference

        &#34;&#34;&#34;

        element = ET.Element(&#39;TimeReference&#39;)
        if self._only_nones:
            ET.SubElement(element,&#39;None&#39;)
        else:
            ET.SubElement(element,&#39;Timing&#39;,self.get_attributes())

        return element


class _TrafficSignalState(VersionBase):
    &#34;&#34;&#34; crates a _TrafficSignalState used by Phase
        
        Parameters
        ----------
            signal_id (str): id of the traffic signal

            state (str): state of the signal
                
        Attributes
        ----------
            signal_id (str): id of the traffic signal

            state (str): state of the signal

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;


    def __init__(self, signal_id, state):
        &#34;&#34;&#34; initalize the _TrafficSignalState 
        
        Parameters
        ----------
            signal_id (str): id of the traffic signal

            state (str): state of the signal

        &#34;&#34;&#34;

        self.signal_id = signal_id
        self.state = state

    def __eq__(self,other):
        if isinstance(other,_TrafficSignalState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of _TrafficSignalState

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A traffice signal state element (same as generated by the class itself)

            Returns
            -------
                ts_state (_TrafficSignalState): a _TrafficSignalState object
                
        &#34;&#34;&#34;
        signal_id = element.attrib[&#39;trafficSignalId&#39;]
        state = element.attrib[&#39;state&#39;]
        return _TrafficSignalState(signal_id=signal_id,state=state)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the _TrafficSignalState
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;trafficSignalId&#39;] = self.signal_id
        retdict[&#39;state&#39;] = self.state
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the _TrafficSignalState

        &#34;&#34;&#34;
        return ET.Element(&#39;TrafficSignalState&#39;,attrib=self.get_attributes())



class Phase(VersionBase):
    &#34;&#34;&#34; crates a Traffic light phase
        
        Parameters
        ----------
            name (str): if of the phase

            duration (float): duration of the phase
                
        Attributes
        ----------
            name (str): if of the phase

            duration (float): duration of the phase

            signalstates (list of _TrafficSignalState): traffic signal states

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_stignal_state(signal_id,state)
                add a traffic signal state
    &#34;&#34;&#34;

    def __init__(self, name, duration):
        &#34;&#34;&#34; initalize the Phase 
        
        Parameters
        ----------
            name (str): if of the phase

            duration (float): duration of the phase

        &#34;&#34;&#34;

        self.name = name
        self.duration = convert_float(duration)
        self.signalstates = []

    def __eq__(self,other):
        if isinstance(other,Phase):
            if self.get_attributes() == other.get_attributes() and self.signalstates == other.signalstates:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Phase

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)

            Returns
            -------
                phase (Phase): a Phase object
                
        &#34;&#34;&#34;
        duration = convert_float(element.attrib[&#39;duration&#39;])
        name = element.attrib[&#39;name&#39;]
        phase = Phase(name, duration)
        signalstates = element.findall(&#39;TrafficSignalState&#39;)
        if signalstates != None:
            for signalstate in signalstates:
                traffic_signal_state = _TrafficSignalState.parse(signalstate)
                phase.signalstates.append(traffic_signal_state)

        return phase

    def add_signal_state(self,signal_id,state):
        &#34;&#34;&#34; Adds a phase of the traffic signal

            Parameters
            ----------
                signal_id (str): id of the traffic signal in the road network

                state (str): state of the signal defined in the road network

        &#34;&#34;&#34;
        self.signalstates.append(_TrafficSignalState(signal_id,state))

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalController
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        retdict[&#39;duration&#39;] = str(self.duration)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Polyline

        &#34;&#34;&#34;
        element = ET.Element(&#39;Phase&#39;,attrib=self.get_attributes())
        for s in self.signalstates:
            element.append(s.get_element())
        return element


class TrafficSignalController(VersionBase):
    &#34;&#34;&#34; the TrafficSignalController class creates a polyline of (minimum 2) positions
        
        Parameters
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None

            reference (string): id to the controller in the roadnetwork
                Default: None

        Attributes
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None
            reference (string): id to the controller in the roadnetwork
                Default: None

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_phase(Phase)
                add a phase to the trafficsitnal controller
    &#34;&#34;&#34;

    def __init__(self, name, delay = None,reference = None):
        &#34;&#34;&#34; initalize the TrafficSignalController 
        
        Parameters
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None

            reference (string): id to the controller in the RoadNetwork
                Default: None

        &#34;&#34;&#34;

        self.name = name
        self.delay = delay
        self.reference = reference
        self.phases = []

    def __eq__(self,other):
        if isinstance(other,TrafficSignalController):
            if self.get_attributes() == other.get_attributes() and self.phases == other.phases:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TrafficSignalController

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)

            Returns
            -------
                tsc (TrafficSignalController): a TrafficSignalController object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        
        delay = None
        if &#39;delay&#39; in element.attrib:
            delay = element.attrib[&#39;delay&#39;]
        
        reference  = None
        if &#39;reference&#39; in element.attrib:
            reference = element.attrib[&#39;reference&#39;]
        
        tsc = TrafficSignalController(name,delay,reference)
        
        phases = element.findall(&#39;Phase&#39;)
        if phases != None:
            for phase in phases:
              tsc.phases.append(Phase.parse(phase))  

        return tsc

    def add_phase(self,phase):
        &#34;&#34;&#34; Adds a phase of the traffic signal

            Parameters
            ----------
                phase (Phase): a phase of the trafficsignal

        &#34;&#34;&#34;
        if not isinstance(phase,Phase):
            raise TypeError(&#39;phase input is not of type Phase&#39;)
        self.phases.append(phase)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalController
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        if self.delay is not None:
            retdict[&#39;delay&#39;] = str(self.delay)
        if self.reference:
            retdict[&#39;reference&#39;] = self.reference
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalController

        &#34;&#34;&#34;
        element = ET.Element(&#39;TrafficSignalController&#39;,attrib=self.get_attributes())
        for ph in self.phases:
            element.append(ph.get_element())
        return element



class TrafficDefinition(VersionBase):
    &#34;&#34;&#34; the TrafficDefinition class creates a TrafficDefinition used by the different TrafficActions
        
        Parameters
        ----------
            name (str): name of the traffic definition
       

        Attributes
        ----------
            name (str): name of the traffic definition

            vehicleweights (list of floats): The weights of the vehicle categories (VehicleCategoryDistribution-weight)

            vehiclecategories (list of VehicleCategory): the vehicle category ((VehicleCategoryDistribution-category))

            controllerweights (list of floats): The weights of the controllers

            controllers (list of Controller/CatalogReference): The controllers for the traffic


        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_vehicle(vehiclecategory,weight)
                Adds a vehicle to the traffic definition

            add_controller(controller,weight)
                Adds a controller to the traffic definition
                
    &#34;&#34;&#34;

    def __init__(self, name):
        &#34;&#34;&#34; initalize the TrafficDefinition 
        
        Parameters
        ----------
            name (str): name of the traffic definition

        &#34;&#34;&#34;

        self.name = name
        self.vehicleweights = []
        self.vehiclecategories = []
        self.controllerweights = []
        self.controllers = []


    def __eq__(self,other):
        if isinstance(other,TrafficDefinition):
            if self.get_attributes() == other.get_attributes() and \
            self.vehicleweights == other.vehicleweights and \
            self.vehiclecategories == other.vehiclecategories and \
            self.controllerweights == other.controllerweights and \
            self.controllers == other.controllers:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TrafficDefinition

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)

            Returns
            -------
                td (TrafficDefinition): a TrafficDefinition object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        td = TrafficDefinition(name)

        vehicle_distributions = element.find(&#39;VehicleCategoryDistribution&#39;)
        vehicle_entries = vehicle_distributions.findall(&#39;VehicleCategoryDistributionEntry&#39;)
        for entry in vehicle_entries:
            weight = convert_float(entry.attrib[&#39;weight&#39;])
            category = getattr(VehicleCategory, entry.attrib[&#39;category&#39;])
            td.add_vehicle(category,weight)
        
        controller_distributions = element.find(&#39;ControllerDistribution&#39;)
        controller_entries = controller_distributions.findall(&#39;ControllerDistributionEntry&#39;)
        for controller_dist in controller_entries:
            weight = convert_float(controller_dist.attrib[&#39;weight&#39;])
            if controller_dist.find(&#39;Controller&#39;):
                controller = Controller.parse(controller_dist.find(&#39;Controller&#39;))
                td.add_controller(controller, weight)
            else:
                catalog_reference = CatalogReference.parse(controller_dist.find(&#39;CatalogReference&#39;))
                td.add_controller(catalog_reference,weight)

        return td        

    def add_vehicle(self,vehiclecategory,weight):
        &#34;&#34;&#34; Adds a vehicle to the traffic distribution

            Parameters
            ----------
                vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

                weight (float): the corresponding weight for the distribution of the vehicle category

        &#34;&#34;&#34;
        if not hasattr(VehicleCategory,str(vehiclecategory)):
            raise TypeError(&#39;vehcilecategory input is not of type VehcileCategory&#39;)
        self.vehiclecategories.append(vehiclecategory)
        self.vehicleweights.append(weight)

    def add_controller(self,controller,weight):
        &#34;&#34;&#34; Adds a controller to the traffic distribution

            Parameters
            ----------
                controller (Controller or CatalogReference): a controller or catalog reference to a controller

                weight (float): the corresponding weight for the controller

        &#34;&#34;&#34;
        if not ( isinstance(controller,Controller) or isinstance(controller,CatalogReference)):
            raise TypeError(&#39;controller input not of type Controller or CatalogReference&#39;)
        self.controllers.append(controller)
        self.controllerweights.append(weight)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficDefinition
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficDefinition

        &#34;&#34;&#34;
        if not self.controllers:
            ValueError(&#39;No controllers defined for the TrafficDefinition&#39;)
        if not self.vehiclecategories:
            ValueError(&#39;No Vehicles defined for the TrafficDefinition&#39;)

        element = ET.Element(&#39;TrafficDefinition&#39;,attrib=self.get_attributes())

        veh_element = ET.SubElement(element,&#39;VehicleCategoryDistribution&#39;)
        for i in range(len(self.vehiclecategories)):
            ET.SubElement(veh_element,&#39;VehicleCategoryDistributionEntry&#39;,attrib={&#39;category&#39;: self.vehiclecategories[i].get_name(),&#39;weight&#39;: str(self.vehicleweights[i])})

        cnt_element = ET.SubElement(element,&#39;ControllerDistribution&#39;)
        for i in range(len(self.controllers)):
            tmp_controller = ET.SubElement(cnt_element,&#39;ControllerDistributionEntry&#39;,attrib={&#39;weight&#39;:str(self.controllerweights[i])})
            tmp_controller.append(self.controllers[i].get_element())

        return element




class CatalogFile(VersionBase):
    &#34;&#34;&#34; The CatalogFile class handles any catalogs in open scenario, such as writing, and updating them
        
        Parameters
        ----------
            prettyprint (boolean): if the final file should have prettyprint or not
                Default: True

        Attributes
        ----------
            prettyprint: if the final file should have prettyprint or not

            catalog_element (Element): the element that is worked with

            filename (str): path to the file to be written to

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            add_catalog(catalogname, path)
                Adds a new catalog 
    &#34;&#34;&#34;

    def __init__(self,prettyprint = True):
        &#34;&#34;&#34; initalize the CatalogFile class

            Parameters
            ----------
                prettyprint (boolean): if the final file should have prettyprint or not
                    Default: True
        &#34;&#34;&#34;
        self.prettyprint = prettyprint
        self.catalog_element = None
        self.filename = &#39;&#39;

    def add_to_catalog(self,obj,osc_minor_version=1):
        &#34;&#34;&#34; add_to_catalog adds an element to the catalog
            
            Parameters
            ----------
                obj (*pyoscx): any pyoscx object (should be matching with the catalog)
                
                osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
                    Default: 1
        &#34;&#34;&#34;
        if self.catalog_element == None:
            OSError(&#39;No file has been created or opened&#39;)
        fileheader = self.catalog_element.find(&#39;FileHeader&#39;)
        self.version_minor = osc_minor_version
        if fileheader.attrib[&#39;revMinor&#39;] != osc_minor_version:
            Warning(&#39;The Catalog and the added object does not have the same OpenSCENARIO version.&#39;)
        catalogs = self.catalog_element.find(&#39;Catalog&#39;)
        catalogs.append(obj.get_element())

    def open_catalog(self,filename):
        &#34;&#34;&#34; open_catalog reads an existing catalog file
            
            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        self.filename = filename
        tree = ET.parse(self.filename)
        self.catalog_element = tree.getroot()

    def create_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        self.filename = filename
        self.catalog_element = self.create_catalog_element(catalogtype,description,author)


    def create_catalog_element(self,catalogtype,description,author):
        &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
            
            Parameters
            ----------
                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:&#39;../../&#39;+XSI})
        header = FileHeader(description,author)
        element.append(header.get_element())
        ET.SubElement(element,&#39;Catalog&#39;,attrib={&#39;name&#39;:catalogtype})

        return element

    def dump(self):
        &#34;&#34;&#34; writes the new/updated catalog file

        &#34;&#34;&#34;
        printToFile(self.catalog_element,self.filename,self.prettyprint)

class Catalog(VersionBase):
    &#34;&#34;&#34; The Catalog class creates the CatalogLocation of the OpenScenario input
        
        Parameters
        ----------

        Attributes
        ----------
            catalogs: dict of catalogs to add, and their path
        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            add_catalog(catalogname, path)
                Adds a new catalog 
    &#34;&#34;&#34;
    _CATALOGS = [\
        &#39;VehicleCatalog&#39;,
        &#39;ControllerCatalog&#39;,
        &#39;PedestrianCatalog&#39;,
        &#39;MiscObjectCatalog&#39;,
        &#39;EnvironmentCatalog&#39;,
        &#39;ManeuverCatalog&#39;,
        &#39;TrajectoryCatalog&#39;,
        &#39;RouteCatalog&#39;]

    def __init__(self):
        &#34;&#34;&#34; initalize the Catalog class

        &#34;&#34;&#34;
        self.catalogs = {}

    def __eq__(self,other):
        if isinstance(other,Catalog):
            if self.catalogs == other.catalogs:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Catalog

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)

            Returns
            -------
                catalog (Catalog): a Catalog object
                
        &#34;&#34;&#34;
        catalog = Catalog()

        vc_element = element.find(&#39;VehicleCatalog&#39;)
        if vc_element is not None:
            path = vc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;VehicleCatalog&#39;, path)
        
        cc_element = element.find(&#39;ControllerCatalog&#39;)
        if cc_element is not None:
            path = cc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;ControllerCatalog&#39;, path)
        
        pc_element = element.find(&#39;PedestrianCatalog&#39;)
        if pc_element is not None:
            path = pc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;PedestrianCatalog&#39;, path)
        
        moc_element = element.find(&#39;MiscObjectCatalog&#39;)
        if moc_element is not None:
            path = moc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;MiscObjectCatalog&#39;, path)
        
        ec_element = element.find(&#39;EnvironmentCatalog&#39;)
        if ec_element is not None:
            path = ec_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;EnvironmentCatalog&#39;, path)
        
        mc_element = element.find(&#39;ManeuverCatalog&#39;)
        if mc_element is not None:
            path = mc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;ManeuverCatalog&#39;, path)
        
        tc_element = element.find(&#39;TrajectoryCatalog&#39;)
        if tc_element is not None:
            path = tc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;TrajectoryCatalog&#39;, path)
        
        rc_element = element.find(&#39;RouteCatalog&#39;)
        if rc_element is not None:
            path = rc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;RouteCatalog&#39;, path)

        return catalog
        

    def add_catalog(self,catalogname,path):
        &#34;&#34;&#34; add new catalog to be used

        Parameters
        ----------
            catalogname (str): name of the catalog

            path (str): path to the catalog
        
        &#34;&#34;&#34;


        if catalogname not in self._CATALOGS:
            raise ValueError(&#39;Not a correct catalog, approved catalogs are:&#39; &#39;&#39;.join(self._CATALOGS))

        self.catalogs[catalogname] = path


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Catalog

        &#34;&#34;&#34;

        catloc = ET.Element(&#39;CatalogLocations&#39;)

        for i in self.catalogs:
            tmpel = ET.SubElement(catloc,i)
            ET.SubElement(tmpel,&#39;Directory&#39;,{&#39;path&#39;: self.catalogs[i]})
        return catloc

class CatalogReference(VersionBase):
    &#34;&#34;&#34; CatalogReference creates an CatalogReference element of openscenario
        
        Parameters
        ----------
            catalogname (str): name of the catalog

            entryname (str): name of the entry in the catalog            

        Attributes
        ----------
            catalogname (str): name of the catalog

            entryname (str): name of the entry in the catalog 

            parameterassignments (list of ParameterAssignment): the parameter assignments for the given catalogreference

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_parameter_assignment(parameterref,value)
                Assigns a parameter with a value

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,catalogname,entryname):
        &#34;&#34;&#34; initalize the CatalogReference

            Parameters
            ----------
                catalogname (str): name of the catalog

                entryname (str): name of the entry in the catalog    
                
        &#34;&#34;&#34;
        self.catalogname = catalogname
        self.entryname = entryname
        self.parameterassignments = []

    def __eq__(self,other):
        if isinstance(other,CatalogReference):
            if self.get_attributes() == other.get_attributes() and \
            self.parameterassignments == other.parameterassignments:
                return True
        return False

    # TODO: CatalogElement???

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of CatalogReference

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)

            Returns
            -------
                reference (CatalogReference): a catalog reference object

        &#34;&#34;&#34;
        catalogname =  element.attrib[&#39;catalogName&#39;]
        entryname = element.attrib[&#39;entryName&#39;]
        reference = CatalogReference(catalogname, entryname)
        
        parameter_assignments = element.find(&#39;ParameterAssignments&#39;)
        if parameter_assignments != None:
            parameters = parameter_assignments.findall(&#39;ParameterAssignment&#39;)
            for parameter in parameters:
                parameter_assignment = ParameterAssignment.parse(parameter)
                reference.parameterassignments.append(parameter_assignment)
                
        return reference


    def add_parameter_assignment(self,parameterref,value):
        &#34;&#34;&#34; add_parameter_assignment adds a parameter and value to the catalog reference

            Parameters
            ----------
                parameterref (str): name of the parameter

                value (str): assigned value of the parameter
        &#34;&#34;&#34;
        self.parameterassignments.append(ParameterAssignment(parameterref,value))

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the CatalogReference as a dict

        &#34;&#34;&#34;
        return {&#39;catalogName&#39;:self.catalogname,&#39;entryName&#39;:self.entryname}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the CatalogReference

        &#34;&#34;&#34;
        element = ET.Element(&#39;CatalogReference&#39;,attrib=self.get_attributes())
        if self.parameterassignments:
            parameterassigns = ET.SubElement(element,&#39;ParameterAssignments&#39;)
        for parass in self.parameterassignments:
            parameterassigns.append(parass.get_element())
        return element



class ParameterAssignment(VersionBase):
    &#34;&#34;&#34; ParameterAssignment creates an ParameterAssignment element of openscenario
        
        Parameters
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter


        Attributes
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class
                
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,parameterref,value):
        &#34;&#34;&#34; initalize the ParameterAssignment

            Parameters
            ----------
                parameterref (str): name of the parameter

                value (str): assigned value of the parameter   
                
        &#34;&#34;&#34;
        self.parameterref = parameterref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterAssignment):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ParameterAssignment

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)

            Returns
            -------
                parameterassignment (ParameterAssignment): a ParameterAssignment object

        &#34;&#34;&#34;

        value = element.attrib[&#39;value&#39;]
        parameterref = element.attrib[&#39;parameterRef&#39;]
    
        return ParameterAssignment(parameterref, value)


    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterAssignment as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;parameterRef&#39;] = self.parameterref
        retdict[&#39;value&#39;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterAssignment

        &#34;&#34;&#34;
        return ET.Element(&#39;ParameterAssignment&#39;,attrib=self.get_attributes())

class TimeOfDay(VersionBase):
    &#34;&#34;&#34; TimeOfDay creates an TimeOfDay element of openscenario
        
        Parameters
        ----------
            animation (bool): if animation should be used

            year (int): year

            month (int): month

            day (int): day

            hour (int): hour

            minute (int): minute

            second (int): second

        Attributes
        ----------
            animation (bool): if animation should be used

            year (int): year

            month (int): month

            day (int): day

            hour (int): hour

            minute (int): minute

            second (int): second

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,animation,year,month,day,hour,minute,second):
        &#34;&#34;&#34; initalize the TimeOfDay

            Parameters
            ----------
                animation (bool): if animation should be used

                year (int): year

                month (int): month

                day (int): day

                hour (int): hour

                minute (int): minute

                second (int): second   
                
        &#34;&#34;&#34;
        self.animation = animation
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def __eq__(self,other):
        if isinstance(other,TimeOfDay):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TimeOfDay

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)

            Returns
            -------
                timeofday (TimeOfDay): a TimeOfDay object
        &#34;&#34;&#34;
        animation = element.attrib[&#39;animation&#39;]        
        var = element.attrib[&#39;dateTime&#39;]
        year = convert_int(var[0:4])
        month = convert_int(var[5:7])
        day = convert_int(var[8:10])

        hour = convert_int(var[11:13])
        minute = convert_int(var[14:16])
        second = convert_int(var[17:19])
 
        return TimeOfDay(animation,year,month,day,hour,minute,second) 

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TimeOfDay as a dict

        &#34;&#34;&#34;
        dt = str(self.year) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.month) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.day) + &#39;T&#39; + &#39;{:0&gt;2}&#39;.format(self.hour) + &#39;:&#39; + &#39;{:0&gt;2}&#39;.format(self.minute) + &#39;:&#39; +&#39;{:0&gt;2}&#39;.format(self.second)
        return {&#39;animation&#39;:str(self.animation),&#39;dateTime&#39;:dt}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TimeOfDay

        &#34;&#34;&#34;
        return ET.Element(&#39;TimeOfDay&#39;,attrib=self.get_attributes())



class Weather(VersionBase):
    &#34;&#34;&#34; Weather creates an Weather element of openscenario
        
        Parameters
        ----------
            cloudstate (CloudState): cloudstate of the weather
                Default: None

            atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
                Default: None

            temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
                Default: None

            sun (Sun): the sun position
                Default: None

            fog (Fog): fot state
                Default: None

            precipitation (Precipitation): the precipitation state
                Default: None

            wind (Wind): the wind (valid from OpenSCENARIO V1.1)
                Default: None

        Attributes
        ----------
            cloudstate (CloudState): cloudstate of the weather

            atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)

            temperature (float): outside temperature (valid from OpenSCENARIO V1.1)

            sun (Sun): the sun position

            fog (Fog): fot state

            precipitation (Precipitation): the precipitation state

            wind (Wind): the wind (valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,cloudstate=None,atmosphericPressure=None,temperature=None,sun=None,fog=None,precipitation=None,wind=None):
        &#34;&#34;&#34; initalize the Weather

            Parameters
            ----------
                cloudstate (CloudState): cloudstate of the weather
                    Default: None

                atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
                    Default: None

                temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
                    Default: None

                sun (Sun): the sun position
                    Default: None

                fog (Fog): fot state
                    Default: None

                precipitation (Precipitation): the precipitation state
                    Default: None

                wind (Wind): the wind (valid from OpenSCENARIO V1.1)
                    Default: None
                
        &#34;&#34;&#34;
        if cloudstate and not hasattr(CloudState,str(cloudstate)):
            raise TypeError(&#39;cloudstate input is not of type CloudState&#39;)
        if precipitation and not isinstance(precipitation,Precipitation):
            raise TypeError(&#39;precipitation input is not of type Precipitation&#39;)
        if fog and not isinstance(fog,Fog):
            raise TypeError(&#39;fog input is not of type Fog&#39;)
        if wind and not isinstance(wind,Wind):
            raise TypeError(&#39;wind input is not of type Wind&#39;)
        if sun and not isinstance(sun,Sun):
            raise TypeError(&#39;sun input is not of type Sun&#39;)

        self.cloudstate = cloudstate
        self.atmosphericPressure = atmosphericPressure
        self.temperature = temperature
        self.fog = fog
        self.sun = sun
        self.wind = wind
        self.precipitation = precipitation


    def __eq__(self,other):
        if isinstance(other,Weather):
            if self.get_attributes() == other.get_attributes() and \
            self.fog == other.fog and \
            self.wind == other.wind and \
            self.sun == other.sun and \
            self.precipitation == other.precipitation:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Weather

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)

            Returns
            -------
                weather (Weather): a Weather object

        &#34;&#34;&#34;
        temperature = None
        atmosphericPressure = None
        cloudstate = None
        fog = None
        sun = None
        wind= None
        precipitation = None

        if &#39;temperature&#39; in element.attrib:
            temperature = element.attrib[&#39;temperature&#39;]
        if &#39;atmosphericPressure&#39; in element.attrib:
            atmosphericPressure = element.attrib[&#39;atmosphericPressure&#39;]
        if &#39;cloudState&#39; in element.attrib:
            cloudstate = getattr(CloudState, element.attrib[&#39;cloudState&#39;])
        if element.find(&#39;Sun&#39;) != None:
            sun = Sun.parse(element.find(&#39;Sun&#39;))
        if element.find(&#39;Fog&#39;) != None:
            fog = Fog.parse(element.find(&#39;Fog&#39;))
        if element.find(&#39;Precipitation&#39;) != None:
            precipitation = Precipitation.parse(element.find(&#39;Precipitation&#39;))
        if element.find(&#39;Wind&#39;) != None:
            wind = Wind.parse(element.find(&#39;Wind&#39;))

        return Weather(cloudstate,atmosphericPressure,temperature,sun,fog,precipitation,wind)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Weather as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.cloudstate:
            retdict[&#39;cloudState&#39;] = self.cloudstate.get_name()
        if self.temperature is not None and not self.isVersion(minor=0):
            retdict[&#39;temperature&#39;] = str(self.temperature)
        elif self.temperature is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;temperature was introduced in OpenSCENARIO V1.1&#39;)
        if self.atmosphericPressure is not None and not self.isVersion(minor=0):
            retdict[&#39;atmosphericPressure&#39;] = str(self.atmosphericPressure)
        elif self.atmosphericPressure is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;atmosphericPressure was introduced in OpenSCENARIO V1.1&#39;)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Weather

        &#34;&#34;&#34;
        element = ET.Element(&#39;Weather&#39;,attrib=self.get_attributes())
        if self.sun:
            element.append(self.sun.get_element())
        if self.fog:
            element.append(self.fog.get_element())
        if self.precipitation:
            element.append(self.precipitation.get_element())
        if self.wind and not self.isVersion(minor=0):
            element.append(self.wind.get_element())
        if self.wind and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;Wind was introduced in OpenSCENARIO V1.1&#39;)
        return element

class Fog(VersionBase):
    &#34;&#34;&#34; Fog creates an Fog element used by the Weather element of openscenario
        
        Parameters
        ----------
            visual_range (int): visual range of fog

            bounding_box (BoundingBox): bounding box of fog
                Default: None

        Attributes
        ----------
            visual_range (int): visual range of fog

            bounding_box (BoundingBox): bounding box of fog

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,visual_range,bounding_box=None):
        &#34;&#34;&#34; initalize the Fog

            Parameters
            ----------
                visual_range (int): visual range of fog

                bounding_box (BoundingBox): bounding box of fog
                    Default: None
                
        &#34;&#34;&#34;

        self.visual_range = visual_range
        self.bounding_box = bounding_box


    def __eq__(self,other):
        if isinstance(other,Fog):
            if self.get_attributes() == other.get_attributes() and \
               self.bounding_box == other.bounding_box:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Fog

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)

            Returns
            -------
                fog (Fog): a Fog object

        &#34;&#34;&#34; 

        visual_range = element.attrib[&#39;visualRange&#39;]
        bounding_box = None
        if element.find(&#39;BoundingBox&#39;) != None:
            bounding_box = BoundingBox.parse(element.find(&#39;BoundingBox&#39;))
        
        return Fog(visual_range, bounding_box)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;visualRange&#39;] = str(self.visual_range)

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Fog

        &#34;&#34;&#34;
        element = ET.Element(&#39;Fog&#39;,attrib=self.get_attributes())
        if self.bounding_box is not None:
            element.append(self.bounding_box.get_element())

        return element


class Sun(VersionBase):
    &#34;&#34;&#34; Sun creates an Sun element used by the Weather element of openscenario
        
        Parameters
        ----------
            intensity (float): intensity of the sun (in lux)

            azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

            elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

        Attributes
        ----------
            intensity (float): intensity of the sun (in lux)

            azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

            elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,intensity,azimuth,elevation):
        &#34;&#34;&#34; initalize the Sun

            Parameters
            ----------
                intensity (float): intensity of the sun (in lux)

                azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

                elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
                
        &#34;&#34;&#34;

        self.azimuth = azimuth
        self.intensity = intensity
        self.elevation = elevation

    def __eq__(self,other):
        if isinstance(other,Sun):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Sun

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)

            Returns
            -------
                sun (Sun): a Sun object

        &#34;&#34;&#34; 
        azimuth = element.attrib[&#39;azimuth&#39;]
        elevation = element.attrib[&#39;elevation&#39;]
        intensity = element.attrib[&#39;intensity&#39;]

        return Sun(intensity,azimuth,elevation)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;azimuth&#39;] = str(self.azimuth)
        retdict[&#39;intensity&#39;] = str(self.intensity)
        retdict[&#39;elevation&#39;] = str(self.elevation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Sun

        &#34;&#34;&#34;
        element = ET.Element(&#39;Sun&#39;,attrib=self.get_attributes())

        return element


class Precipitation(VersionBase):
    &#34;&#34;&#34; Precipitation creates an Precipitation element used by the Weather element of openscenario
        
        Parameters
        ----------
            precipitation (PrecipitationType): dry, rain or snow

            intensity (float): intensity of precipitation (0...1)

        Attributes
        ----------
            precipitation (PrecipitationType): dry, rain or snow

            intensity (float): intensity of precipitation (0...1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,precipitation,intensity):
        &#34;&#34;&#34; initalize the Precipitation

            Parameters
            ----------
                precipitation (PrecipitationType): dry, rain or snow

                intensity (float): intensity of precipitation (0...1)
                
        &#34;&#34;&#34;
        if not hasattr(PrecipitationType,str(precipitation)):
            raise TypeError(&#39;precipitation input is not of type PrecipitationType&#39;)
        self.precipitation = precipitation
        self.intensity = convert_float(intensity)

    def __eq__(self,other):
        if isinstance(other,Precipitation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Precipitation

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)

            Returns
            -------
                precipitation (Precipitation): a Precipitation object

        &#34;&#34;&#34; 
        intesity = None
        if &#39;precipitationIntensity&#39; in element.attrib:
            intesity = element.attrib[&#39;precipitationIntensity&#39;]
        elif &#39;intensity&#39; in element.attrib: 
            intesity = element.attrib[&#39;intensity&#39;]
        precipitation = getattr(PrecipitationType, element.attrib[&#39;precipitationType&#39;])

        return Precipitation(precipitation, intesity)
        
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;precipitationType&#39;] = self.precipitation.get_name()
        if self.isVersion(minor=0):
            retdict[&#39;intensity&#39;] = str(self.intensity)
        else:
            retdict[&#39;precipitationIntensity&#39;] = str(self.intensity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Precipitation

        &#34;&#34;&#34;
        element = ET.Element(&#39;Precipitation&#39;,attrib=self.get_attributes())

        return element


class Wind(VersionBase):
    &#34;&#34;&#34; Wind creates an Wind element used by the Weather element of openscenario
        
        Parameters
        ----------
            direction (float): wind direction (radians)

            speed (float): wind speed (m/s)

        Attributes
        ----------
            direction (float): wind direction (radians)

            speed (float): wind speed (m/s)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,direction,speed):
        &#34;&#34;&#34; initalize the Wind

            Parameters
            ----------
                direction (float): wind direction (radians)

                speed (float): wind speed (m/s)
                
        &#34;&#34;&#34;
        self.direction = direction
        self.speed = speed

    def __eq__(self,other):
        if isinstance(other,Wind):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Wind

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)

            Returns
            -------
                wind (Wind): a Wind object

        &#34;&#34;&#34; 
        direction = element.attrib[&#39;direction&#39;]
        speed = element.attrib[&#39;speed&#39;]

        return Wind(direction,speed)
    
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Wind as a dict

        &#34;&#34;&#34;
        return {&#39;direction&#39;:str(self.direction),&#39;speed&#39;:str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Wind

        &#34;&#34;&#34;
        element = ET.Element(&#39;Wind&#39;,attrib=self.get_attributes())

        return element

class RoadCondition(VersionBase):
    &#34;&#34;&#34; Weather creates an Weather element of openscenario
        
        Parameters
        ----------
            friction_scale_factor (float): scale factor of the friction

            properties (Properties): properties of the roadcondition
                Default: None

        Attributes
        ----------
            friction_scale_factor (float): scale factor of the friction

            properties (Properties): properties of the roadcondition

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,friction_scale_factor,properties = None):
        &#34;&#34;&#34; initalize the Weather

            Parameters
            ----------
                friction_scale_factor (float): scale factor of the friction

                properties (Properties): properties of the roadcondition
                    Default: None
                
        &#34;&#34;&#34;
        self.friction_scale_factor = friction_scale_factor
        if properties is not None and not isinstance(properties,Properties):
            raise TypeError(&#39;properties input is not of type Properties&#39;)
        self.properties = properties

    def __eq__(self,other):
        if isinstance(other,RoadCondition):
            if self.get_attributes() == other.get_attributes() and self.properties == other.properties:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of RoadCondition

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)

            Returns
            -------
                roadcondition (RoadCondition): a RoadCondition object

        &#34;&#34;&#34; 
        friction_scale_factor = element.attrib[&#39;frictionScaleFactor&#39;]
        properties = None
        if element.find(&#39;Properties&#39;) != None:
            properties = Properties.parse(element.find(&#39;Properties&#39;))

        return RoadCondition(friction_scale_factor, properties)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RoadCondition as a dict

        &#34;&#34;&#34;
        return {&#39;frictionScaleFactor&#39;:str(self.friction_scale_factor)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RoadCondition

        &#34;&#34;&#34;
        element = ET.Element(&#39;RoadCondition&#39;,attrib=self.get_attributes())
        if self.properties:
            element.append(self.properties.get_element())
        return element

# TODO: add name (string)
class Environment(VersionBase):
    &#34;&#34;&#34; The Environment class creates a environment used by Environment
        
        Parameters
        ----------
            name (string): Name of the environment. If used in catalog name is required.

            timeofday (TimeOfDay): time of day for the environment

            weather (Weather): weather of the environment

            roadcondition (RoadCondition): road condition of the environment

            parameters (ParameterDeclarations): the parameters to be used in the scenario
                Default: None

        Attributes
        ----------
            name (string): Name of the environment. If used in catalog name is required.

            timeofday (TimeOfDay): time of day for the environment

            weather (Weather): weather of the environment

            roadcondition (RoadCondition): road condition of the environment

            parameters (ParameterDeclarations): the parameters to be used in the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            append_to_catalog(filename)
                adds the vehicle to an existing catalog

            dump_to_catalog(filename,name,description,author)
                crates a new catalog with the vehicle

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, name, timeofday=None, weather=None, roadcondition=None, parameters = None):
        &#34;&#34;&#34; initalize the Environment

            Parameters
            ----------
                name (string): Name of the environment. If used in catalog name is required.

                timeofday (TimeOfDay): time of day for the environment

                weather (Weather): weather of the environment

                roadcondition (RoadCondition): road condition of the environment

                parameters (ParameterDeclarations): the parameters to be used in the scenario
                    Default: None
        &#34;&#34;&#34;
        self.name = name
        if timeofday is not None and not isinstance(timeofday,TimeOfDay):
            raise TypeError(&#39;timeofday input is not of type TimeOfDay&#39;)
        if weather is not None and not isinstance(weather,Weather):
            raise TypeError(&#39;weather input is not of type Weather&#39;)
        if roadcondition is not None and not isinstance(roadcondition,RoadCondition):
            raise TypeError(&#39;roadcondition input is not of type RoadCondition&#39;)
        if parameters is not None and not isinstance(parameters,ParameterDeclarations):
            raise TypeError(&#39;parameters input is not of type ParameterDeclarations&#39;)
        self.timeofday = timeofday
        self.weather = weather
        self.roadcondition = roadcondition
        self.parameters = parameters

    def __eq__(self,other):
        if isinstance(other,Environment):
            if self.get_attributes() == other.get_attributes() and\
            self.timeofday == other.timeofday and \
            self.weather == other.weather and \
            self.roadcondition == other.roadcondition and \
            self.parameters == other.parameters:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Environment

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)

            Returns
            -------
                environment (Environment): a Environment object

        &#34;&#34;&#34; 
        name = element.attrib[&#39;name&#39;]
        parameters = None
        weather = None
        timeofday = None
        roadcondition = None

        if element.find(&#39;ParameterDeclarations&#39;) != None:
            parameters = ParameterAssignment.parse(element.find(&#39;ParamterDeclarations&#39;))
        if element.find(&#39;TimeOfDay&#39;) != None:
            timeofday = TimeOfDay.parse(element.find(&#39;TimeOfDay&#39;))
        if element.find(&#39;Weather&#39;) != None:
            weather = Weather.parse(element.find(&#39;Weather&#39;))
        if element.find(&#39;RoadCondition&#39;) != None:
            roadcondition = RoadCondition.parse(element.find(&#39;RoadCondition&#39;))
        
        return Environment(name, timeofday, weather, roadcondition, parameters)

    def dump_to_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the environment to it
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.create_catalog(filename,catalogtype,description,author)
        cf.add_to_catalog(self)
        cf.dump()

    def append_to_catalog(self,filename):
        &#34;&#34;&#34; adds the environment to an existing catalog

            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.open_catalog(filename)
        cf.add_to_catalog(self)
        cf.dump()

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Environment as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:str(self.name)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Environment

        &#34;&#34;&#34;
        element = ET.Element(&#39;Environment&#39;, attrib=self.get_attributes())
        if self.timeofday:
            element.append(self.timeofday.get_element())
        if self.weather:
            element.append(self.weather.get_element())
        if self.roadcondition:
            element.append(self.roadcondition.get_element())
        if self.parameters:
            element.append(self.parameters.get_element())
        return element

class Controller(VersionBase):
    &#34;&#34;&#34; the Controller class creates a controller of openScenario

        Parameters
        ----------
            name (str): name of the object

            properties (Properties): properties of the controller
                
        Attributes
        ----------
            parameters (ParameterDeclaration): Parameter declarations of the vehicle

            properties (Properties): additional properties of the vehicle

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_parameter(parameter)
                adds a parameter declaration to the Controller

            append_to_catalog(filename)
                adds the vehicle to an existing catalog

            dump_to_catalog(filename,name,description,author)
                crates a new catalog with the vehicle

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self ,name ,properties):
        &#34;&#34;&#34; initalzie the Controller Class

        Parameters
        ----------
            name (str): name of the object

            properties (Properties): properties of the Controller
        
        &#34;&#34;&#34;
        self.name = name

        self.parameters = ParameterDeclarations()
        if not isinstance(properties,Properties):
            raise TypeError(&#39;properties input is not of type Properties&#39;)
        self.properties = properties

    def __eq__(self,other):
        if isinstance(other,Controller):
            if self.properties == other.properties and \
            self.parameters == other.parameters and \
            self.name == other.name:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Controller

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)

            Returns
            -------
                controller (Controller): a Controller object

        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        properties_element = element.find(&#39;Properties&#39;)
        properties = Properties.parse(properties_element)
        controller = Controller(name,properties)

        parameters_element = element.find(&#39;ParameterDeclarations&#39;)
        controller.parameters = ParameterDeclarations.parse(parameters_element)

        return controller        
            



    def dump_to_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the Controller to it
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.create_catalog(filename,catalogtype,description,author)
        cf.add_to_catalog(self)
        cf.dump()

    def append_to_catalog(self,filename):
        &#34;&#34;&#34; adds the Controller to an existing catalog

            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.open_catalog(filename)
        cf.add_to_catalog(self)
        cf.dump()

    def add_parameter(self,parameter):
        &#34;&#34;&#34; adds a parameter declaration to the Controller

            Parameters
            ----------
                parameter (Parameter): A new parameter declaration for the Controller

        &#34;&#34;&#34;
        if not isinstance(parameter,Parameter):
            raise TypeError(&#39;parameter input is not of type Parameter&#39;)
        self.parameters.add_parameter(parameter)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Controller as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Controller

        &#34;&#34;&#34;
        element = ET.Element(&#39;Controller&#39;,attrib=self.get_attributes())
        element.append(self.parameters.get_element())
        element.append(self.properties.get_element())

        return element


class BoundingBox(VersionBase):
    &#34;&#34;&#34; the Dimensions describes the size of an entity

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

            x_center (float): x distance from back axel to center

            y_center (float): y distance from back axel to clas

            z_center (float): z distance from back axel to center
                

        Attributes
        ----------
            dimensions (Dimensions): the dimensions of the entity

            center (Center): the center of the object relative the the back axel

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself


    &#34;&#34;&#34;
    def __init__(self,width,length,height,x_center,y_center,z_center):
        &#34;&#34;&#34; initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

            x_center (float): x distance from back axel to center

            y_center (float): y distance from back axel to center

            z_center (float): z distance from back axel to center
        
        &#34;&#34;&#34;
        self.boundingbox = Dimensions(width,length,height)
        self.center = Center(x_center,y_center,z_center)

    def __eq__(self,other):
        if isinstance(other,BoundingBox):
            if self.boundingbox == other.boundingbox and \
            self.center == other.center:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Dimensions

        &#34;&#34;&#34;
        element = ET.Element(&#39;BoundingBox&#39;)
        element.append(self.center.get_element())
        element.append(self.boundingbox.get_element())
        return element

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of BoundingBox

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

            Returns
            -------
                boundingBox (BoundingBox): a BoundingBox object

        &#34;&#34;&#34;
        center = Center.parse(element.find(&#39;Center&#39;))
        cen_dict = center.get_attributes()
        dimension = Dimensions.parse(element.find(&#39;Dimensions&#39;))
        dim_dict =dimension.get_attributes()
        return BoundingBox(dim_dict[&#39;width&#39;],dim_dict[&#39;length&#39;], dim_dict[&#39;height&#39;], cen_dict[&#39;x&#39;], cen_dict[&#39;y&#39;], cen_dict[&#39;z&#39;]) 
        
class Center(VersionBase):
    &#34;&#34;&#34; the Center Class creates a centerpoint for a bounding box, reference point of a vehicle is the back axel

        Parameters
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center
                

        Attributes
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;
    def __init__(self,x,y,z):
        &#34;&#34;&#34; initalzie the Center Class

        Parameters
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center
        
        &#34;&#34;&#34;
        self.x = convert_float(x)
        self.y = convert_float(y)
        self.z = convert_float(z)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to Center

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)

            Returns
            ------
                center (Center): a Center object

        &#34;&#34;&#34;
        x = convert_float(element.attrib[&#39;x&#39;])
        y = convert_float(element.attrib[&#39;y&#39;])
        z = convert_float(element.attrib[&#39;z&#39;])
        return Center(x, y, z)


    def __eq__(self,other):
        if isinstance(other,Center):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the Center

        &#34;&#34;&#34;
        return {&#39;x&#39;:str(self.x),&#39;y&#39;:str(self.y),&#39;z&#39;:str(self.z)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Center

        &#34;&#34;&#34;
        element = ET.Element(&#39;Center&#39;,attrib=self.get_attributes())
        return element

class Dimensions(VersionBase):
    &#34;&#34;&#34; the Dimensions describes the size of an entity

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity
                

        Attributes
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;
    def __init__(self,width,length,height):
        &#34;&#34;&#34; initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity
        
        &#34;&#34;&#34;
        self.width = convert_float(width)
        self.length = convert_float(length)
        self.height = convert_float(height)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to Dimensions

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)

            Returns
            ------
                dimension (Dimensions): a Dimensions object

        &#34;&#34;&#34;
        width = convert_float(element.attrib[&#39;width&#39;])
        height = convert_float(element.attrib[&#39;height&#39;])
        length = convert_float(element.attrib[&#39;length&#39;])
        return Dimensions(width, length, height)

    def __eq__(self,other):
        if isinstance(other,Dimensions):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the Dimensions

        &#34;&#34;&#34;
        return {&#39;width&#39;:str(self.width),&#39;length&#39;:str(self.length),&#39;height&#39;:str(self.height)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Dimensions

        &#34;&#34;&#34;
        element = ET.Element(&#39;Dimensions&#39;,attrib=self.get_attributes())
        return element

class Properties(VersionBase):
    &#34;&#34;&#34; the Properties contains are for user defined properties of an object               

        Attributes
        ----------
            files (list of str): arbitrary files with properties

            properties (list of tuple(str,str)): properties in name/value pairs

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_file(file)
                adds a file with properties

            add_property(name,value)
                adds a property pair, with name and value

            get_element()
                Returns the full ElementTree of the class

            
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalzie the Properties

        &#34;&#34;&#34;
        self.files = []
        self.properties = []

    def __eq__(self,other):
        if isinstance(other,Properties):
            if self.files == other.files and \
            self.properties == other.properties:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of class Properties:


            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

            Returns
            -------
                properties (Properties): a Properties object
                
        &#34;&#34;&#34;
        properties = Properties()
        files = element.findall(&#39;File&#39;)
        if files != None:
            for file in files:
                filepath = file.attrib[&#39;filepath&#39;]
                properties.add_file(filepath)
        props = element.findall(&#39;Property&#39;)
        if props != None:
            for property in props:
                name = property.attrib[&#39;name&#39;]
                value = property.attrib[&#39;value&#39;]
                properties.add_property(name, value)
        
        return properties

    def add_file(self,filename):
        &#34;&#34;&#34; adds a property file

        Parameters
        ----------
            filename (str): name of the file

        &#34;&#34;&#34;

        self.files.append(filename)

    def add_property(self,name,value):
        &#34;&#34;&#34; adds a property pair

        Parameters
        ----------
            name (str): name of the property

            value (str): value of the property

        &#34;&#34;&#34;
        self.properties.append((name,value))

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Properties

        &#34;&#34;&#34;
        element = ET.Element(&#39;Properties&#39;)
        for p in self.properties:
            ET.SubElement(element,&#39;Property&#39;,attrib={&#39;name&#39;:p[0],&#39;value&#39;:p[1]})
        for f in self.files:
            ET.SubElement(element,&#39;File&#39;,attrib={&#39;filepath&#39;:f})

        return element


class AbsoluteSpeed(VersionBase):
    &#34;&#34;&#34;
        Parameters
        ----------
            value (float): absolute speed [m/s]
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

        Attributes
        ----------
            value (float): absolute speed [m/s]
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class
                
            get_attributes()
                Returns the attributes of the class
    &#34;&#34;&#34;
    def __init__(self, value, steadyState=None):
        &#34;&#34;&#34;initalzie the AbsoluteSpeed

        Parameters
        ----------
            value (float): absolute speed [m/s]
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState) Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (isinstance(steadyState, TargetTimeSteadyState) or isinstance(steadyState, TargetDistanceSteadyState)):
                raise TypeError(&#39;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#39;)
        self.steadyState = steadyState

    def __eq__(self,other):
        if isinstance(other,AbsoluteSpeed):
            if self.get_attributes() == other.get_attributes() and \
               self.steadyState == other.steadyState:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of AbsoluteSpeed

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)

            Returns
            -------
                absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object
                
        &#34;&#34;&#34;
        absolute_speed_element = element.find(&#39;AbsoluteSpeed&#39;)
        value = absolute_speed_element.attrib[&#39;value&#39;]

        state = None
        if absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
            state = TargetDistanceSteadyState.parse(absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;))
        elif absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
            state = TargetTimeSteadyState.parse(absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;))
        
        return AbsoluteSpeed(value, state)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeed

        &#34;&#34;&#34;
        return {&#39;value&#39;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeed

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;AbsoluteSpeed was introduced in OpenSCENARIO V1.1&#39;)
        elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
        elementAbsoluteSpeed = ET.SubElement(elementFinalSpeed, &#39;AbsoluteSpeed&#39;, attrib=self.get_attributes())
        if self.steadyState:
            if self.isVersion(1, 0):
                raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
            ET.SubElement(elementAbsoluteSpeed, self.steadyState.__class__.__name__, attrib=self.steadyState.get_attributes())

        return elementFinalSpeed


class RelativeSpeedToMaster(VersionBase):
    &#34;&#34;&#34;
        Parameters
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

        Attributes
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the attributes of the class
    &#34;&#34;&#34;
    def __init__(self, value, speedTargetValueType, steadyState=None):
        &#34;&#34;&#34;

        Parameters
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed.
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (isinstance(steadyState, TargetTimeSteadyState) or isinstance(steadyState,
                                                                                 TargetDistanceSteadyState)):
                raise TypeError(&#39;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#39;)
        self.steadyState = steadyState
        if not speedTargetValueType.classname == &#34;SpeedTargetValueType&#34;:
            raise TypeError(&#39;speedTargetValueType input is not a valid SpeedTargetValueType&#39;)
        self.speedTargetValueType = speedTargetValueType

    def __eq__(self,other):
        if isinstance(other,RelativeSpeedToMaster):
            if self.get_attributes() == other.get_attributes() and\
                self.steadyState == other.steadyState:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to RelativeSpeedToMaster

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)

            Returns
            ------
                rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object

        &#34;&#34;&#34;
        speed_element = element.find(&#39;RelativeSpeedToMaster&#39;)

        value = speed_element.attrib[&#39;value&#39;]
        speedTargetValueType = getattr(SpeedTargetValueType, speed_element.attrib[&#39;speedTargetValueType&#39;])
        state = None 
        if speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
            state = TargetDistanceSteadyState.parse(speed_element.find(&#39;TargetDistanceSteadyState&#39;))
        elif speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
            state = TargetTimeSteadyState.parse(speed_element.find(&#39;TargetTimeSteadyState&#39;))
        
        return RelativeSpeedToMaster(value,speedTargetValueType,state)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeSpeedToMaster

        &#34;&#34;&#34;
        return {&#39;speedTargetValueType&#39;: str(self.speedTargetValueType), &#39;value&#39;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeSpeedToMaster

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;RelativeSpeedToMaster was introduced in OpenSCENARIO V1.1&#39;)
        elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
        elementRelativeSpeed = ET.SubElement(elementFinalSpeed, &#39;RelativeSpeedToMaster&#39;, attrib=self.get_attributes())
        if self.steadyState:
            if self.isVersion(1, 0):
                raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
            ET.SubElement(elementRelativeSpeed, self.steadyState.__class__.__name__,
                          attrib=self.steadyState.get_attributes())
        return elementFinalSpeed


class TargetDistanceSteadyState(VersionBase):
    &#34;&#34;&#34; the TargetDistanceSteadyState describes a SteadyState of type TargetDistanceSteadyState
        (Valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            distance (float): distance to target for the steady state

        Attributes
        ----------
            distance (float): distance to target for the steady state

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,distance):
        &#34;&#34;&#34; initalzie the TargetDistanceSteadyState

        Parameters
        ----------
            distance (float): distance to target for the steady state
        
        &#34;&#34;&#34;
        self.distance = distance

    def __eq__(self,other):
        if isinstance(other,TargetDistanceSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TargetDistanceSteadyState

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)

            Returns
            -------
                tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object
                
        &#34;&#34;&#34; 
        distance = element.attrib[&#39;distance&#39;]
        return TargetDistanceSteadyState(distance)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TargetDistanceSteadyState
        
        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return {&#39;distance&#39;:str(self.distance)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TargetDistanceSteadyState

        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return ET.Element(&#39;TargetDistanceSteadyState&#39;,attrib=self.get_attributes())


class TargetTimeSteadyState(VersionBase):
    &#34;&#34;&#34; the TargetTimeSteadyState describes a SteadyState of type TargetTimeSteadyState
        (Valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            time_gap (float): time_gap to target for the steady state

        Attributes
        ----------
            time_gap (float): time_gap to target for the steady state

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,time_gap):
        &#34;&#34;&#34; initalzie the TargetTimeSteadyState

        Parameters
        ----------
            time_gap (float): time_gap to target for the steady state
        
        &#34;&#34;&#34;
        self.time_gap = time_gap

    def __eq__(self,other):
        if isinstance(other,TargetTimeSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TargetTimeSteadyState

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)

            Returns
            -------
                ttss (TargetTimeSteadyState): a TargetTimeSteadyState object
                
        &#34;&#34;&#34;
        time = element.attrib[&#39;time&#39;]
        return TargetTimeSteadyState(time)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TargetTimeSteadyState
        
        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return {&#39;time&#39;:str(self.time_gap)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TargetTimeSteadyState

        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return ET.Element(&#39;TargetTimeSteadyState&#39;,attrib=self.get_attributes())


def merge_dicts(*dict_args):
    &#34;&#34;&#34; Funciton to merge dicts 
    
    &#34;&#34;&#34;
    retdict = {}
    for d in dict_args:
        retdict.update(d)

    return retdict

def convert_bool(value):
    &#34;&#34;&#34; Method to transform booleans to correct xml version (lower case)

        Parameter
        ---------
            value (bool): the boolean

        Return
        ------
            boolean (str)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value == &#39;true&#39;:
            return True
        elif value == &#39;false&#39;:
            return False
        elif value[0] == &#39;$&#39;:
            return value
        else:
            raise ValueError(value + &#39;is not a valid type of float input to openscenario, if a string is used as a float value (parameter or expression), it should have a $ as the first char..&#39;)

    if value:
        return &#39;true&#39;
    else:
        return &#39;false&#39;

def convert_float(value):
    &#34;&#34;&#34; Method to ensure floats are floats, will take care of None values aswell

        Parameter
        ---------
            value (float/str/int/None): a value to transform to float

        Return
        ------
            value (float/None)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value[0] == &#39;$&#39;:
            return value
        try:
            float(value)
        except ValueError:
            raise ValueError(value + &#39;is not a valid type of float input to openscenario, if a string is used as a float value (parameter or expression), it should have a $ as the first char..&#39;)

    if value is not None:
        return float(value)
    else:
        return None

def convert_int(value):
    &#34;&#34;&#34; Method to ensure ints are ints, will take care of None values aswell

        Parameter
        ---------
            value (float/str/int/None): a value to transform to int

        Return
        ------
            value (int/None)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value[0] == &#39;$&#39;:
            return value
        try:
            int(value)
        except ValueError:
            raise ValueError(value + &#39;is not a valid type of int input to openscenario, if a string is used as a int value (parameter or expression), it should have a $ as the first char.&#39;)

    if value is not None:
        return int(value)
    else:
        return None

class ValueConstraintGroup(VersionBase):
    &#34;&#34;&#34; Creates the the ValueConstraintGroup file for open scenario
        
        Parameters
        ----------
            None

        Attributes
        ----------
            value_constraint (ValueConstraint): logical constraint, needed to evaluate to true for a defined parameter to start the simulation.


        Methods
        -------
            add_value_constraint(value_constraint)
                adds value constraint to the value constraint group

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element(elementname)
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self):
        self.value_constraints = []

    def __eq__(self,other):
        if isinstance(other,ValueConstraintGroup):
            if  self.value_constraints == other.value_constraints:
               return True
        return False

    def add_value_constraint(self,value_constraint):
        &#34;&#34;&#34; adds a value constraint to the value constraint group

        Parameters
        ----------
            value_constraint (ValueConstraint): the value constraint to be added 

        &#34;&#34;&#34;
        if not isinstance(value_constraint,ValueConstraint):
            raise TypeError(&#39;value_conatraint input is not of type ValueConstraint&#39;)
        self.value_constraints.append(value_constraint)
    
    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ValueConstraintGroup

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)

            Returns
            -------
                group (ValueConstraintGroup): a ValueConstraintGroup object
                
        &#34;&#34;&#34;
        value_constraints = ValueConstraintGroup()
        constraints = element.findall(&#39;ValueConstraint&#39;)
        for constraint in constraints:
            value_constraint = ValueConstraint.parse(constraint)
            value_constraints.add_value_constraint(value_constraint)
        return value_constraints
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ValueConstraintGroup

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;ValueConstraintGroup was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;ValueConstraintGroup&#39;)
        if not self.value_constraints:
            raise ValueError(&#39;No Value Constraints in the Value Contraint Group&#39;)
        for value_constraint in self.value_constraints:
            element.append(value_constraint.get_element())
        return element


class ValueConstraint(VersionBase):
    &#34;&#34;&#34; Creates the the ValueConstraint file for open scenario
        
        Parameters
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.

        Attributes
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.


        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    # TODO: Only equalTo and notEqualTo test
    def __init__(self, rule, value):
        &#34;&#34;&#34; initalzie the ValueConstraint Class

        Parameters
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule,str(rule)):
            raise TypeError(str(rule) + &#39; is not a valid ValueConstraint type&#39;)    
        self.rule = rule

    def __eq__(self,other):
        if isinstance(other,ValueConstraint):
            if self.get_attributes() == other.get_attributes():
               return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ValueConstraint

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

            Returns
            -------
                constraint (ValueConstraint): ValueConstraint object
                
        &#34;&#34;&#34;
        value = element.attrib[&#39;value&#39;]
        rule = getattr(Rule, element.attrib[&#39;rule&#39;])
        return ValueConstraint(rule, value)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ValueConstraint as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;rule&#39;] = self.rule.get_name()
        retdict[&#39;value&#39;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ValueConstraint

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;ValueConstraint was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;ValueConstraint&#39; ,attrib=self.get_attributes())
        return element</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenariogeneration.xosc.utils.convert_bool"><code class="name flex">
<span>def <span class="ident">convert_bool</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to transform booleans to correct xml version (lower case)</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (bool): the boolean
</code></pre>
<h2 id="return">Return</h2>
<pre><code>boolean (str)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bool(value):
    &#34;&#34;&#34; Method to transform booleans to correct xml version (lower case)

        Parameter
        ---------
            value (bool): the boolean

        Return
        ------
            boolean (str)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value == &#39;true&#39;:
            return True
        elif value == &#39;false&#39;:
            return False
        elif value[0] == &#39;$&#39;:
            return value
        else:
            raise ValueError(value + &#39;is not a valid type of float input to openscenario, if a string is used as a float value (parameter or expression), it should have a $ as the first char..&#39;)

    if value:
        return &#39;true&#39;
    else:
        return &#39;false&#39;</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.convert_float"><code class="name flex">
<span>def <span class="ident">convert_float</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to ensure floats are floats, will take care of None values aswell</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (float/str/int/None): a value to transform to float
</code></pre>
<h2 id="return">Return</h2>
<pre><code>value (float/None)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_float(value):
    &#34;&#34;&#34; Method to ensure floats are floats, will take care of None values aswell

        Parameter
        ---------
            value (float/str/int/None): a value to transform to float

        Return
        ------
            value (float/None)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value[0] == &#39;$&#39;:
            return value
        try:
            float(value)
        except ValueError:
            raise ValueError(value + &#39;is not a valid type of float input to openscenario, if a string is used as a float value (parameter or expression), it should have a $ as the first char..&#39;)

    if value is not None:
        return float(value)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.convert_int"><code class="name flex">
<span>def <span class="ident">convert_int</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to ensure ints are ints, will take care of None values aswell</p>
<h2 id="parameter">Parameter</h2>
<pre><code>value (float/str/int/None): a value to transform to int
</code></pre>
<h2 id="return">Return</h2>
<pre><code>value (int/None)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_int(value):
    &#34;&#34;&#34; Method to ensure ints are ints, will take care of None values aswell

        Parameter
        ---------
            value (float/str/int/None): a value to transform to int

        Return
        ------
            value (int/None)
    &#34;&#34;&#34;
    if isinstance(value,str):
        if value[0] == &#39;$&#39;:
            return value
        try:
            int(value)
        except ValueError:
            raise ValueError(value + &#39;is not a valid type of int input to openscenario, if a string is used as a int value (parameter or expression), it should have a $ as the first char.&#39;)

    if value is not None:
        return int(value)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.merge_dicts"><code class="name flex">
<span>def <span class="ident">merge_dicts</span></span>(<span>*dict_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Funciton to merge dicts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_dicts(*dict_args):
    &#34;&#34;&#34; Funciton to merge dicts 
    
    &#34;&#34;&#34;
    retdict = {}
    for d in dict_args:
        retdict.update(d)

    return retdict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed"><code class="flex name class">
<span>class <span class="ident">AbsoluteSpeed</span></span>
<span>(</span><span>value, steadyState=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>value (float): absolute speed [m/s]

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): absolute speed [m/s]

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the attributes of the class
</code></pre>
<p>initalzie the AbsoluteSpeed</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): absolute speed [m/s]
steadyState (TargetTimeSteadyState / TargetDistanceSteadyState) Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsoluteSpeed(VersionBase):
    &#34;&#34;&#34;
        Parameters
        ----------
            value (float): absolute speed [m/s]
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

        Attributes
        ----------
            value (float): absolute speed [m/s]
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class
                
            get_attributes()
                Returns the attributes of the class
    &#34;&#34;&#34;
    def __init__(self, value, steadyState=None):
        &#34;&#34;&#34;initalzie the AbsoluteSpeed

        Parameters
        ----------
            value (float): absolute speed [m/s]
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState) Final phase of constant (final) speed, start of which defined by distance or time. (Valid from OpenSCENARIO V1.1)
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (isinstance(steadyState, TargetTimeSteadyState) or isinstance(steadyState, TargetDistanceSteadyState)):
                raise TypeError(&#39;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#39;)
        self.steadyState = steadyState

    def __eq__(self,other):
        if isinstance(other,AbsoluteSpeed):
            if self.get_attributes() == other.get_attributes() and \
               self.steadyState == other.steadyState:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of AbsoluteSpeed

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)

            Returns
            -------
                absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object
                
        &#34;&#34;&#34;
        absolute_speed_element = element.find(&#39;AbsoluteSpeed&#39;)
        value = absolute_speed_element.attrib[&#39;value&#39;]

        state = None
        if absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
            state = TargetDistanceSteadyState.parse(absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;))
        elif absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
            state = TargetTimeSteadyState.parse(absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;))
        
        return AbsoluteSpeed(value, state)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the AbsoluteSpeed

        &#34;&#34;&#34;
        return {&#39;value&#39;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeed

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;AbsoluteSpeed was introduced in OpenSCENARIO V1.1&#39;)
        elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
        elementAbsoluteSpeed = ET.SubElement(elementFinalSpeed, &#39;AbsoluteSpeed&#39;, attrib=self.get_attributes())
        if self.steadyState:
            if self.isVersion(1, 0):
                raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
            ET.SubElement(elementAbsoluteSpeed, self.steadyState.__class__.__name__, attrib=self.steadyState.get_attributes())

        return elementFinalSpeed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of AbsoluteSpeed</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of AbsoluteSpeed

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A absolute speed element (same as generated by the class itself)

        Returns
        -------
            absolutespeed (AbsoluteSpeed): a AbsoluteSpeed object
            
    &#34;&#34;&#34;
    absolute_speed_element = element.find(&#39;AbsoluteSpeed&#39;)
    value = absolute_speed_element.attrib[&#39;value&#39;]

    state = None
    if absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
        state = TargetDistanceSteadyState.parse(absolute_speed_element.find(&#39;TargetDistanceSteadyState&#39;))
    elif absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
        state = TargetTimeSteadyState.parse(absolute_speed_element.find(&#39;TargetTimeSteadyState&#39;))
    
    return AbsoluteSpeed(value, state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the AbsoluteSpeed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the AbsoluteSpeed

    &#34;&#34;&#34;
    return {&#39;value&#39;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.AbsoluteSpeed.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the AbsoluteSpeed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the AbsoluteSpeed

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;AbsoluteSpeed was introduced in OpenSCENARIO V1.1&#39;)
    elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
    elementAbsoluteSpeed = ET.SubElement(elementFinalSpeed, &#39;AbsoluteSpeed&#39;, attrib=self.get_attributes())
    if self.steadyState:
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
        ET.SubElement(elementAbsoluteSpeed, self.steadyState.__class__.__name__, attrib=self.steadyState.get_attributes())

    return elementFinalSpeed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.BoundingBox"><code class="flex name class">
<span>class <span class="ident">BoundingBox</span></span>
<span>(</span><span>width, length, height, x_center, y_center, z_center)</span>
</code></dt>
<dd>
<div class="desc"><p>the Dimensions describes the size of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity

x_center (float): x distance from back axel to center

y_center (float): y distance from back axel to clas

z_center (float): z distance from back axel to center
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>dimensions (Dimensions): the dimensions of the entity

center (Center): the center of the object relative the the back axel
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Dimensions</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity

x_center (float): x distance from back axel to center

y_center (float): y distance from back axel to center

z_center (float): z distance from back axel to center
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundingBox(VersionBase):
    &#34;&#34;&#34; the Dimensions describes the size of an entity

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

            x_center (float): x distance from back axel to center

            y_center (float): y distance from back axel to clas

            z_center (float): z distance from back axel to center
                

        Attributes
        ----------
            dimensions (Dimensions): the dimensions of the entity

            center (Center): the center of the object relative the the back axel

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself


    &#34;&#34;&#34;
    def __init__(self,width,length,height,x_center,y_center,z_center):
        &#34;&#34;&#34; initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

            x_center (float): x distance from back axel to center

            y_center (float): y distance from back axel to center

            z_center (float): z distance from back axel to center
        
        &#34;&#34;&#34;
        self.boundingbox = Dimensions(width,length,height)
        self.center = Center(x_center,y_center,z_center)

    def __eq__(self,other):
        if isinstance(other,BoundingBox):
            if self.boundingbox == other.boundingbox and \
            self.center == other.center:
                return True
        return False

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Dimensions

        &#34;&#34;&#34;
        element = ET.Element(&#39;BoundingBox&#39;)
        element.append(self.center.get_element())
        element.append(self.boundingbox.get_element())
        return element

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of BoundingBox

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

            Returns
            -------
                boundingBox (BoundingBox): a BoundingBox object

        &#34;&#34;&#34;
        center = Center.parse(element.find(&#39;Center&#39;))
        cen_dict = center.get_attributes()
        dimension = Dimensions.parse(element.find(&#39;Dimensions&#39;))
        dim_dict =dimension.get_attributes()
        return BoundingBox(dim_dict[&#39;width&#39;],dim_dict[&#39;length&#39;], dim_dict[&#39;height&#39;], cen_dict[&#39;x&#39;], cen_dict[&#39;y&#39;], cen_dict[&#39;z&#39;]) </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.BoundingBox.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of BoundingBox</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>boundingBox (BoundingBox): a BoundingBox object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of BoundingBox

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            boundingBox (BoundingBox): a BoundingBox object

    &#34;&#34;&#34;
    center = Center.parse(element.find(&#39;Center&#39;))
    cen_dict = center.get_attributes()
    dimension = Dimensions.parse(element.find(&#39;Dimensions&#39;))
    dim_dict =dimension.get_attributes()
    return BoundingBox(dim_dict[&#39;width&#39;],dim_dict[&#39;length&#39;], dim_dict[&#39;height&#39;], cen_dict[&#39;x&#39;], cen_dict[&#39;y&#39;], cen_dict[&#39;z&#39;]) </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.BoundingBox.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Dimensions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Dimensions

    &#34;&#34;&#34;
    element = ET.Element(&#39;BoundingBox&#39;)
    element.append(self.center.get_element())
    element.append(self.boundingbox.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Catalog"><code class="flex name class">
<span>class <span class="ident">Catalog</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Catalog class creates the CatalogLocation of the OpenScenario input</p>
<h2 id="parameters">Parameters</h2>
<h2 id="attributes">Attributes</h2>
<pre><code>catalogs: dict of catalogs to add, and their path
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

add_catalog(catalogname, path)
    Adds a new catalog
</code></pre>
<p>initalize the Catalog class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Catalog(VersionBase):
    &#34;&#34;&#34; The Catalog class creates the CatalogLocation of the OpenScenario input
        
        Parameters
        ----------

        Attributes
        ----------
            catalogs: dict of catalogs to add, and their path
        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            add_catalog(catalogname, path)
                Adds a new catalog 
    &#34;&#34;&#34;
    _CATALOGS = [\
        &#39;VehicleCatalog&#39;,
        &#39;ControllerCatalog&#39;,
        &#39;PedestrianCatalog&#39;,
        &#39;MiscObjectCatalog&#39;,
        &#39;EnvironmentCatalog&#39;,
        &#39;ManeuverCatalog&#39;,
        &#39;TrajectoryCatalog&#39;,
        &#39;RouteCatalog&#39;]

    def __init__(self):
        &#34;&#34;&#34; initalize the Catalog class

        &#34;&#34;&#34;
        self.catalogs = {}

    def __eq__(self,other):
        if isinstance(other,Catalog):
            if self.catalogs == other.catalogs:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Catalog

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)

            Returns
            -------
                catalog (Catalog): a Catalog object
                
        &#34;&#34;&#34;
        catalog = Catalog()

        vc_element = element.find(&#39;VehicleCatalog&#39;)
        if vc_element is not None:
            path = vc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;VehicleCatalog&#39;, path)
        
        cc_element = element.find(&#39;ControllerCatalog&#39;)
        if cc_element is not None:
            path = cc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;ControllerCatalog&#39;, path)
        
        pc_element = element.find(&#39;PedestrianCatalog&#39;)
        if pc_element is not None:
            path = pc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;PedestrianCatalog&#39;, path)
        
        moc_element = element.find(&#39;MiscObjectCatalog&#39;)
        if moc_element is not None:
            path = moc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;MiscObjectCatalog&#39;, path)
        
        ec_element = element.find(&#39;EnvironmentCatalog&#39;)
        if ec_element is not None:
            path = ec_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;EnvironmentCatalog&#39;, path)
        
        mc_element = element.find(&#39;ManeuverCatalog&#39;)
        if mc_element is not None:
            path = mc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;ManeuverCatalog&#39;, path)
        
        tc_element = element.find(&#39;TrajectoryCatalog&#39;)
        if tc_element is not None:
            path = tc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;TrajectoryCatalog&#39;, path)
        
        rc_element = element.find(&#39;RouteCatalog&#39;)
        if rc_element is not None:
            path = rc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
            catalog.add_catalog(&#39;RouteCatalog&#39;, path)

        return catalog
        

    def add_catalog(self,catalogname,path):
        &#34;&#34;&#34; add new catalog to be used

        Parameters
        ----------
            catalogname (str): name of the catalog

            path (str): path to the catalog
        
        &#34;&#34;&#34;


        if catalogname not in self._CATALOGS:
            raise ValueError(&#39;Not a correct catalog, approved catalogs are:&#39; &#39;&#39;.join(self._CATALOGS))

        self.catalogs[catalogname] = path


    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Catalog

        &#34;&#34;&#34;

        catloc = ET.Element(&#39;CatalogLocations&#39;)

        for i in self.catalogs:
            tmpel = ET.SubElement(catloc,i)
            ET.SubElement(tmpel,&#39;Directory&#39;,{&#39;path&#39;: self.catalogs[i]})
        return catloc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Catalog.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>catalog (Catalog): a Catalog object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Catalog

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Catalog element (same as generated by the class itself)

        Returns
        -------
            catalog (Catalog): a Catalog object
            
    &#34;&#34;&#34;
    catalog = Catalog()

    vc_element = element.find(&#39;VehicleCatalog&#39;)
    if vc_element is not None:
        path = vc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;VehicleCatalog&#39;, path)
    
    cc_element = element.find(&#39;ControllerCatalog&#39;)
    if cc_element is not None:
        path = cc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;ControllerCatalog&#39;, path)
    
    pc_element = element.find(&#39;PedestrianCatalog&#39;)
    if pc_element is not None:
        path = pc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;PedestrianCatalog&#39;, path)
    
    moc_element = element.find(&#39;MiscObjectCatalog&#39;)
    if moc_element is not None:
        path = moc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;MiscObjectCatalog&#39;, path)
    
    ec_element = element.find(&#39;EnvironmentCatalog&#39;)
    if ec_element is not None:
        path = ec_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;EnvironmentCatalog&#39;, path)
    
    mc_element = element.find(&#39;ManeuverCatalog&#39;)
    if mc_element is not None:
        path = mc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;ManeuverCatalog&#39;, path)
    
    tc_element = element.find(&#39;TrajectoryCatalog&#39;)
    if tc_element is not None:
        path = tc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;TrajectoryCatalog&#39;, path)
    
    rc_element = element.find(&#39;RouteCatalog&#39;)
    if rc_element is not None:
        path = rc_element.find(&#39;Directory&#39;).attrib[&#39;path&#39;]
        catalog.add_catalog(&#39;RouteCatalog&#39;, path)

    return catalog</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Catalog.add_catalog"><code class="name flex">
<span>def <span class="ident">add_catalog</span></span>(<span>self, catalogname, path)</span>
</code></dt>
<dd>
<div class="desc"><p>add new catalog to be used</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

path (str): path to the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_catalog(self,catalogname,path):
    &#34;&#34;&#34; add new catalog to be used

    Parameters
    ----------
        catalogname (str): name of the catalog

        path (str): path to the catalog
    
    &#34;&#34;&#34;


    if catalogname not in self._CATALOGS:
        raise ValueError(&#39;Not a correct catalog, approved catalogs are:&#39; &#39;&#39;.join(self._CATALOGS))

    self.catalogs[catalogname] = path</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Catalog.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Catalog</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Catalog

    &#34;&#34;&#34;

    catloc = ET.Element(&#39;CatalogLocations&#39;)

    for i in self.catalogs:
        tmpel = ET.SubElement(catloc,i)
        ET.SubElement(tmpel,&#39;Directory&#39;,{&#39;path&#39;: self.catalogs[i]})
    return catloc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile"><code class="flex name class">
<span>class <span class="ident">CatalogFile</span></span>
<span>(</span><span>prettyprint=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The CatalogFile class handles any catalogs in open scenario, such as writing, and updating them</p>
<h2 id="parameters">Parameters</h2>
<pre><code>prettyprint (boolean): if the final file should have prettyprint or not
    Default: True
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>prettyprint: if the final file should have prettyprint or not

catalog_element (Element): the element that is worked with

filename (str): path to the file to be written to
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_catalog(catalogname, path)
    Adds a new catalog
</code></pre>
<p>initalize the CatalogFile class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>prettyprint (boolean): if the final file should have prettyprint or not
    Default: True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatalogFile(VersionBase):
    &#34;&#34;&#34; The CatalogFile class handles any catalogs in open scenario, such as writing, and updating them
        
        Parameters
        ----------
            prettyprint (boolean): if the final file should have prettyprint or not
                Default: True

        Attributes
        ----------
            prettyprint: if the final file should have prettyprint or not

            catalog_element (Element): the element that is worked with

            filename (str): path to the file to be written to

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            add_catalog(catalogname, path)
                Adds a new catalog 
    &#34;&#34;&#34;

    def __init__(self,prettyprint = True):
        &#34;&#34;&#34; initalize the CatalogFile class

            Parameters
            ----------
                prettyprint (boolean): if the final file should have prettyprint or not
                    Default: True
        &#34;&#34;&#34;
        self.prettyprint = prettyprint
        self.catalog_element = None
        self.filename = &#39;&#39;

    def add_to_catalog(self,obj,osc_minor_version=1):
        &#34;&#34;&#34; add_to_catalog adds an element to the catalog
            
            Parameters
            ----------
                obj (*pyoscx): any pyoscx object (should be matching with the catalog)
                
                osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
                    Default: 1
        &#34;&#34;&#34;
        if self.catalog_element == None:
            OSError(&#39;No file has been created or opened&#39;)
        fileheader = self.catalog_element.find(&#39;FileHeader&#39;)
        self.version_minor = osc_minor_version
        if fileheader.attrib[&#39;revMinor&#39;] != osc_minor_version:
            Warning(&#39;The Catalog and the added object does not have the same OpenSCENARIO version.&#39;)
        catalogs = self.catalog_element.find(&#39;Catalog&#39;)
        catalogs.append(obj.get_element())

    def open_catalog(self,filename):
        &#34;&#34;&#34; open_catalog reads an existing catalog file
            
            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        self.filename = filename
        tree = ET.parse(self.filename)
        self.catalog_element = tree.getroot()

    def create_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        self.filename = filename
        self.catalog_element = self.create_catalog_element(catalogtype,description,author)


    def create_catalog_element(self,catalogtype,description,author):
        &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
            
            Parameters
            ----------
                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:&#39;../../&#39;+XSI})
        header = FileHeader(description,author)
        element.append(header.get_element())
        ET.SubElement(element,&#39;Catalog&#39;,attrib={&#39;name&#39;:catalogtype})

        return element

    def dump(self):
        &#34;&#34;&#34; writes the new/updated catalog file

        &#34;&#34;&#34;
        printToFile(self.catalog_element,self.filename,self.prettyprint)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogFile.add_to_catalog"><code class="name flex">
<span>def <span class="ident">add_to_catalog</span></span>(<span>self, obj, osc_minor_version=1)</span>
</code></dt>
<dd>
<div class="desc"><p>add_to_catalog adds an element to the catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>obj (*pyoscx): any pyoscx object (should be matching with the catalog)

osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
    Default: 1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_catalog(self,obj,osc_minor_version=1):
    &#34;&#34;&#34; add_to_catalog adds an element to the catalog
        
        Parameters
        ----------
            obj (*pyoscx): any pyoscx object (should be matching with the catalog)
            
            osc_minor_version (int): the minor version of OpenSCENARIO to write to the catalog
                Default: 1
    &#34;&#34;&#34;
    if self.catalog_element == None:
        OSError(&#39;No file has been created or opened&#39;)
    fileheader = self.catalog_element.find(&#39;FileHeader&#39;)
    self.version_minor = osc_minor_version
    if fileheader.attrib[&#39;revMinor&#39;] != osc_minor_version:
        Warning(&#39;The Catalog and the added object does not have the same OpenSCENARIO version.&#39;)
    catalogs = self.catalog_element.find(&#39;Catalog&#39;)
    catalogs.append(obj.get_element())</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.create_catalog"><code class="name flex">
<span>def <span class="ident">create_catalog</span></span>(<span>self, filename, catalogtype, description, author)</span>
</code></dt>
<dd>
<div class="desc"><p>create_catalog_element creates an empty catalog of a desiered type, </p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path of the new catalog file

catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_catalog(self,filename,catalogtype,description,author):
    &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
        
        Parameters
        ----------
            filename (str): path of the new catalog file

            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog
    
    &#34;&#34;&#34;
    self.filename = filename
    self.catalog_element = self.create_catalog_element(catalogtype,description,author)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.create_catalog_element"><code class="name flex">
<span>def <span class="ident">create_catalog_element</span></span>(<span>self, catalogtype, description, author)</span>
</code></dt>
<dd>
<div class="desc"><p>create_catalog_element creates an empty catalog of a desiered type, </p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_catalog_element(self,catalogtype,description,author):
    &#34;&#34;&#34; create_catalog_element creates an empty catalog of a desiered type, 
        
        Parameters
        ----------
            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog
    
    &#34;&#34;&#34;
    element = ET.Element(&#39;OpenSCENARIO&#39;,attrib={&#39;xmlns:xsi&#39;:XMLNS,&#39;xsi:noNamespaceSchemaLocation&#39;:&#39;../../&#39;+XSI})
    header = FileHeader(description,author)
    element.append(header.get_element())
    ET.SubElement(element,&#39;Catalog&#39;,attrib={&#39;name&#39;:catalogtype})

    return element</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>writes the new/updated catalog file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self):
    &#34;&#34;&#34; writes the new/updated catalog file

    &#34;&#34;&#34;
    printToFile(self.catalog_element,self.filename,self.prettyprint)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogFile.open_catalog"><code class="name flex">
<span>def <span class="ident">open_catalog</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>open_catalog reads an existing catalog file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path to the catalog file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_catalog(self,filename):
    &#34;&#34;&#34; open_catalog reads an existing catalog file
        
        Parameters
        ----------
            filename (str): path to the catalog file

    &#34;&#34;&#34;
    self.filename = filename
    tree = ET.parse(self.filename)
    self.catalog_element = tree.getroot()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference"><code class="flex name class">
<span>class <span class="ident">CatalogReference</span></span>
<span>(</span><span>catalogname, entryname)</span>
</code></dt>
<dd>
<div class="desc"><p>CatalogReference creates an CatalogReference element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog

parameterassignments (list of ParameterAssignment): the parameter assignments for the given catalogreference
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_parameter_assignment(parameterref,value)
    Assigns a parameter with a value

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the CatalogReference</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>catalogname (str): name of the catalog

entryname (str): name of the entry in the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatalogReference(VersionBase):
    &#34;&#34;&#34; CatalogReference creates an CatalogReference element of openscenario
        
        Parameters
        ----------
            catalogname (str): name of the catalog

            entryname (str): name of the entry in the catalog            

        Attributes
        ----------
            catalogname (str): name of the catalog

            entryname (str): name of the entry in the catalog 

            parameterassignments (list of ParameterAssignment): the parameter assignments for the given catalogreference

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_parameter_assignment(parameterref,value)
                Assigns a parameter with a value

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,catalogname,entryname):
        &#34;&#34;&#34; initalize the CatalogReference

            Parameters
            ----------
                catalogname (str): name of the catalog

                entryname (str): name of the entry in the catalog    
                
        &#34;&#34;&#34;
        self.catalogname = catalogname
        self.entryname = entryname
        self.parameterassignments = []

    def __eq__(self,other):
        if isinstance(other,CatalogReference):
            if self.get_attributes() == other.get_attributes() and \
            self.parameterassignments == other.parameterassignments:
                return True
        return False

    # TODO: CatalogElement???

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of CatalogReference

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)

            Returns
            -------
                reference (CatalogReference): a catalog reference object

        &#34;&#34;&#34;
        catalogname =  element.attrib[&#39;catalogName&#39;]
        entryname = element.attrib[&#39;entryName&#39;]
        reference = CatalogReference(catalogname, entryname)
        
        parameter_assignments = element.find(&#39;ParameterAssignments&#39;)
        if parameter_assignments != None:
            parameters = parameter_assignments.findall(&#39;ParameterAssignment&#39;)
            for parameter in parameters:
                parameter_assignment = ParameterAssignment.parse(parameter)
                reference.parameterassignments.append(parameter_assignment)
                
        return reference


    def add_parameter_assignment(self,parameterref,value):
        &#34;&#34;&#34; add_parameter_assignment adds a parameter and value to the catalog reference

            Parameters
            ----------
                parameterref (str): name of the parameter

                value (str): assigned value of the parameter
        &#34;&#34;&#34;
        self.parameterassignments.append(ParameterAssignment(parameterref,value))

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the CatalogReference as a dict

        &#34;&#34;&#34;
        return {&#39;catalogName&#39;:self.catalogname,&#39;entryName&#39;:self.entryname}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the CatalogReference

        &#34;&#34;&#34;
        element = ET.Element(&#39;CatalogReference&#39;,attrib=self.get_attributes())
        if self.parameterassignments:
            parameterassigns = ET.SubElement(element,&#39;ParameterAssignments&#39;)
        for parass in self.parameterassignments:
            parameterassigns.append(parass.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogReference.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of CatalogReference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>reference (CatalogReference): a catalog reference object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of CatalogReference

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A catalog reference element (same as generated by the class itself)

        Returns
        -------
            reference (CatalogReference): a catalog reference object

    &#34;&#34;&#34;
    catalogname =  element.attrib[&#39;catalogName&#39;]
    entryname = element.attrib[&#39;entryName&#39;]
    reference = CatalogReference(catalogname, entryname)
    
    parameter_assignments = element.find(&#39;ParameterAssignments&#39;)
    if parameter_assignments != None:
        parameters = parameter_assignments.findall(&#39;ParameterAssignment&#39;)
        for parameter in parameters:
            parameter_assignment = ParameterAssignment.parse(parameter)
            reference.parameterassignments.append(parameter_assignment)
            
    return reference</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment"><code class="name flex">
<span>def <span class="ident">add_parameter_assignment</span></span>(<span>self, parameterref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>add_parameter_assignment adds a parameter and value to the catalog reference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter_assignment(self,parameterref,value):
    &#34;&#34;&#34; add_parameter_assignment adds a parameter and value to the catalog reference

        Parameters
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter
    &#34;&#34;&#34;
    self.parameterassignments.append(ParameterAssignment(parameterref,value))</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the CatalogReference as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the CatalogReference as a dict

    &#34;&#34;&#34;
    return {&#39;catalogName&#39;:self.catalogname,&#39;entryName&#39;:self.entryname}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.CatalogReference.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the CatalogReference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the CatalogReference

    &#34;&#34;&#34;
    element = ET.Element(&#39;CatalogReference&#39;,attrib=self.get_attributes())
    if self.parameterassignments:
        parameterassigns = ET.SubElement(element,&#39;ParameterAssignments&#39;)
    for parass in self.parameterassignments:
        parameterassigns.append(parass.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Center"><code class="flex name class">
<span>class <span class="ident">Center</span></span>
<span>(</span><span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>the Center Class creates a centerpoint for a bounding box, reference point of a vehicle is the back axel</p>
<h2 id="parameters">Parameters</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Center Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>x (float): x distance from back axel to center

y (float): y distance from back axel to center

z (float): z distance from back axel to center
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Center(VersionBase):
    &#34;&#34;&#34; the Center Class creates a centerpoint for a bounding box, reference point of a vehicle is the back axel

        Parameters
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center
                

        Attributes
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;
    def __init__(self,x,y,z):
        &#34;&#34;&#34; initalzie the Center Class

        Parameters
        ----------
            x (float): x distance from back axel to center

            y (float): y distance from back axel to center

            z (float): z distance from back axel to center
        
        &#34;&#34;&#34;
        self.x = convert_float(x)
        self.y = convert_float(y)
        self.z = convert_float(z)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to Center

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)

            Returns
            ------
                center (Center): a Center object

        &#34;&#34;&#34;
        x = convert_float(element.attrib[&#39;x&#39;])
        y = convert_float(element.attrib[&#39;y&#39;])
        z = convert_float(element.attrib[&#39;z&#39;])
        return Center(x, y, z)


    def __eq__(self,other):
        if isinstance(other,Center):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the Center

        &#34;&#34;&#34;
        return {&#39;x&#39;:str(self.x),&#39;y&#39;:str(self.y),&#39;z&#39;:str(self.z)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Center

        &#34;&#34;&#34;
        element = ET.Element(&#39;Center&#39;,attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Center.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element to Center</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>center (Center): a Center object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element to Center

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A center element (same as generated by the class itself)

        Returns
        ------
            center (Center): a Center object

    &#34;&#34;&#34;
    x = convert_float(element.attrib[&#39;x&#39;])
    y = convert_float(element.attrib[&#39;y&#39;])
    z = convert_float(element.attrib[&#39;z&#39;])
    return Center(x, y, z)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Center.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes as a dict of the Center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes as a dict of the Center

    &#34;&#34;&#34;
    return {&#39;x&#39;:str(self.x),&#39;y&#39;:str(self.y),&#39;z&#39;:str(self.z)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Center.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Center

    &#34;&#34;&#34;
    element = ET.Element(&#39;Center&#39;,attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
<span>(</span><span>name, properties)</span>
</code></dt>
<dd>
<div class="desc"><p>the Controller class creates a controller of openScenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the object

properties (Properties): properties of the controller
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameters (ParameterDeclaration): Parameter declarations of the vehicle

properties (Properties): additional properties of the vehicle
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_parameter(parameter)
    adds a parameter declaration to the Controller

append_to_catalog(filename)
    adds the vehicle to an existing catalog

dump_to_catalog(filename,name,description,author)
    crates a new catalog with the vehicle

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the Controller Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the object

properties (Properties): properties of the Controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller(VersionBase):
    &#34;&#34;&#34; the Controller class creates a controller of openScenario

        Parameters
        ----------
            name (str): name of the object

            properties (Properties): properties of the controller
                
        Attributes
        ----------
            parameters (ParameterDeclaration): Parameter declarations of the vehicle

            properties (Properties): additional properties of the vehicle

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_parameter(parameter)
                adds a parameter declaration to the Controller

            append_to_catalog(filename)
                adds the vehicle to an existing catalog

            dump_to_catalog(filename,name,description,author)
                crates a new catalog with the vehicle

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self ,name ,properties):
        &#34;&#34;&#34; initalzie the Controller Class

        Parameters
        ----------
            name (str): name of the object

            properties (Properties): properties of the Controller
        
        &#34;&#34;&#34;
        self.name = name

        self.parameters = ParameterDeclarations()
        if not isinstance(properties,Properties):
            raise TypeError(&#39;properties input is not of type Properties&#39;)
        self.properties = properties

    def __eq__(self,other):
        if isinstance(other,Controller):
            if self.properties == other.properties and \
            self.parameters == other.parameters and \
            self.name == other.name:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Controller

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)

            Returns
            -------
                controller (Controller): a Controller object

        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        properties_element = element.find(&#39;Properties&#39;)
        properties = Properties.parse(properties_element)
        controller = Controller(name,properties)

        parameters_element = element.find(&#39;ParameterDeclarations&#39;)
        controller.parameters = ParameterDeclarations.parse(parameters_element)

        return controller        
            



    def dump_to_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the Controller to it
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.create_catalog(filename,catalogtype,description,author)
        cf.add_to_catalog(self)
        cf.dump()

    def append_to_catalog(self,filename):
        &#34;&#34;&#34; adds the Controller to an existing catalog

            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.open_catalog(filename)
        cf.add_to_catalog(self)
        cf.dump()

    def add_parameter(self,parameter):
        &#34;&#34;&#34; adds a parameter declaration to the Controller

            Parameters
            ----------
                parameter (Parameter): A new parameter declaration for the Controller

        &#34;&#34;&#34;
        if not isinstance(parameter,Parameter):
            raise TypeError(&#39;parameter input is not of type Parameter&#39;)
        self.parameters.add_parameter(parameter)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Controller as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Controller

        &#34;&#34;&#34;
        element = ET.Element(&#39;Controller&#39;,attrib=self.get_attributes())
        element.append(self.parameters.get_element())
        element.append(self.properties.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Controller.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Controller</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>controller (Controller): a Controller object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Controller

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A controller element (same as generated by the class itself)

        Returns
        -------
            controller (Controller): a Controller object

    &#34;&#34;&#34;
    name = element.attrib[&#39;name&#39;]
    properties_element = element.find(&#39;Properties&#39;)
    properties = Properties.parse(properties_element)
    controller = Controller(name,properties)

    parameters_element = element.find(&#39;ParameterDeclarations&#39;)
    controller.parameters = ParameterDeclarations.parse(parameters_element)

    return controller        </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Controller.add_parameter"><code class="name flex">
<span>def <span class="ident">add_parameter</span></span>(<span>self, parameter)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a parameter declaration to the Controller</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter (Parameter): A new parameter declaration for the Controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter(self,parameter):
    &#34;&#34;&#34; adds a parameter declaration to the Controller

        Parameters
        ----------
            parameter (Parameter): A new parameter declaration for the Controller

    &#34;&#34;&#34;
    if not isinstance(parameter,Parameter):
        raise TypeError(&#39;parameter input is not of type Parameter&#39;)
    self.parameters.add_parameter(parameter)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller.append_to_catalog"><code class="name flex">
<span>def <span class="ident">append_to_catalog</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>adds the Controller to an existing catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path to the catalog file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_to_catalog(self,filename):
    &#34;&#34;&#34; adds the Controller to an existing catalog

        Parameters
        ----------
            filename (str): path to the catalog file

    &#34;&#34;&#34;
    cf = CatalogFile()
    cf.open_catalog(filename)
    cf.add_to_catalog(self)
    cf.dump()</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller.dump_to_catalog"><code class="name flex">
<span>def <span class="ident">dump_to_catalog</span></span>(<span>self, filename, catalogtype, description, author)</span>
</code></dt>
<dd>
<div class="desc"><p>dump_to_catalog creates a new catalog and adds the Controller to it</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path of the new catalog file

catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_to_catalog(self,filename,catalogtype,description,author):
    &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the Controller to it
        
        Parameters
        ----------
            filename (str): path of the new catalog file

            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog
    
    &#34;&#34;&#34;
    cf = CatalogFile()
    cf.create_catalog(filename,catalogtype,description,author)
    cf.add_to_catalog(self)
    cf.dump()</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Controller as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Controller as a dict

    &#34;&#34;&#34;
    return {&#39;name&#39;:self.name}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Controller.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Controller</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Controller

    &#34;&#34;&#34;
    element = ET.Element(&#39;Controller&#39;,attrib=self.get_attributes())
    element.append(self.parameters.get_element())
    element.append(self.properties.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Dimensions"><code class="flex name class">
<span>class <span class="ident">Dimensions</span></span>
<span>(</span><span>width, length, height)</span>
</code></dt>
<dd>
<div class="desc"><p>the Dimensions describes the size of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself
</code></pre>
<p>initalzie the Dimensions</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): the width of the entity

length (float): the lenght of the entity

height (float): the height of the entity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dimensions(VersionBase):
    &#34;&#34;&#34; the Dimensions describes the size of an entity

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity
                

        Attributes
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

    &#34;&#34;&#34;
    def __init__(self,width,length,height):
        &#34;&#34;&#34; initalzie the Dimensions

        Parameters
        ----------
            width (float): the width of the entity

            length (float): the lenght of the entity

            height (float): the height of the entity
        
        &#34;&#34;&#34;
        self.width = convert_float(width)
        self.length = convert_float(length)
        self.height = convert_float(height)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to Dimensions

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)

            Returns
            ------
                dimension (Dimensions): a Dimensions object

        &#34;&#34;&#34;
        width = convert_float(element.attrib[&#39;width&#39;])
        height = convert_float(element.attrib[&#39;height&#39;])
        length = convert_float(element.attrib[&#39;length&#39;])
        return Dimensions(width, length, height)

    def __eq__(self,other):
        if isinstance(other,Dimensions):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the Dimensions

        &#34;&#34;&#34;
        return {&#39;width&#39;:str(self.width),&#39;length&#39;:str(self.length),&#39;height&#39;:str(self.height)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Dimensions

        &#34;&#34;&#34;
        element = ET.Element(&#39;Dimensions&#39;,attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Dimensions.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element to Dimensions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>dimension (Dimensions): a Dimensions object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element to Dimensions

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A MiscObject element (same as generated by the class itself)

        Returns
        ------
            dimension (Dimensions): a Dimensions object

    &#34;&#34;&#34;
    width = convert_float(element.attrib[&#39;width&#39;])
    height = convert_float(element.attrib[&#39;height&#39;])
    length = convert_float(element.attrib[&#39;length&#39;])
    return Dimensions(width, length, height)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Dimensions.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes as a dict of the Dimensions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes as a dict of the Dimensions

    &#34;&#34;&#34;
    return {&#39;width&#39;:str(self.width),&#39;length&#39;:str(self.length),&#39;height&#39;:str(self.height)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Dimensions.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Dimensions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Dimensions

    &#34;&#34;&#34;
    element = ET.Element(&#39;Dimensions&#39;,attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints"><code class="flex name class">
<span>class <span class="ident">DynamicsConstraints</span></span>
<span>(</span><span>max_acceleration=None, max_deceleration=None, max_speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>DynamicsConstraints is used by triggers</p>
<h2 id="parameters">Parameters</h2>
<pre><code>max_acceleration (float): maximum acceleration allowed

max_deceleration (float): maximum deceleration allowed

max_speed (float): maximum speed allowed
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>max_acceleration (float): maximum acceleration allowed

max_deceleration (float): maximum deceleration allowed

max_speed (float): maximum speed allowed
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

is_filled()
    check is any constraints are set

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize DynamicsConstrains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicsConstraints(VersionBase):
    &#34;&#34;&#34; DynamicsConstraints is used by triggers
        
        Parameters
        ----------
            max_acceleration (float): maximum acceleration allowed

            max_deceleration (float): maximum deceleration allowed

            max_speed (float): maximum speed allowed

        Attributes
        ----------
            max_acceleration (float): maximum acceleration allowed

            max_deceleration (float): maximum deceleration allowed

            max_speed (float): maximum speed allowed

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            is_filled()
                check is any constraints are set

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self, max_acceleration=None, max_deceleration=None, max_speed=None):
        &#34;&#34;&#34; initalize DynamicsConstrains

        &#34;&#34;&#34;

        self.max_acceleration = convert_float(max_acceleration)
        self.max_deceleration = convert_float(max_deceleration)
        self.max_speed = convert_float(max_speed)

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of DynamicsConstraints

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)

            Returns
            -------
                constrains (DynamicsConstrains): a DynamicsConstrains object
                
        &#34;&#34;&#34;
        max_acceleration = None
        max_deceleration = None
        max_speed = None

        if &#39;maxAcceleration&#39; in element.attrib:
            max_acceleration = convert_float(element.attrib[&#39;maxAcceleration&#39;])
        if &#39;maxDeceleration&#39; in element.attrib:
            max_deceleration = convert_float(element.attrib[&#39;maxDeceleration&#39;])
        if &#39;maxSpeed&#39; in element.attrib:
            max_speed = convert_float(element.attrib[&#39;maxSpeed&#39;])       

        return DynamicsConstraints(max_acceleration, max_deceleration, max_speed) 

    def __eq__(self,other):
        if isinstance(other,DynamicsConstraints):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def is_filled(self):
        &#34;&#34;&#34; is_filled check is any constraints are set

            Returns: boolean

        &#34;&#34;&#34;

        if self.max_acceleration or self.max_deceleration or self.max_speed:
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the DynamicsConstrains as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.max_speed is not None:
            retdict[&#39;maxSpeed&#39;] = str(self.max_speed)
        if self.max_deceleration is not None:
            retdict[&#39;maxDeceleration&#39;] = str(self.max_deceleration)
        if self.max_acceleration is not None:
            retdict[&#39;maxAcceleration&#39;] = str(self.max_acceleration)
        return retdict

    def get_element(self,name = &#39;DynamicConstraints&#39;):
        &#34;&#34;&#34; returns the elementTree of the DynamicsConstrains

        &#34;&#34;&#34;
        return ET.Element(name,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of DynamicsConstraints</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>constrains (DynamicsConstrains): a DynamicsConstrains object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of DynamicsConstraints

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A dynamics constraint element (same as generated by the class itself)

        Returns
        -------
            constrains (DynamicsConstrains): a DynamicsConstrains object
            
    &#34;&#34;&#34;
    max_acceleration = None
    max_deceleration = None
    max_speed = None

    if &#39;maxAcceleration&#39; in element.attrib:
        max_acceleration = convert_float(element.attrib[&#39;maxAcceleration&#39;])
    if &#39;maxDeceleration&#39; in element.attrib:
        max_deceleration = convert_float(element.attrib[&#39;maxDeceleration&#39;])
    if &#39;maxSpeed&#39; in element.attrib:
        max_speed = convert_float(element.attrib[&#39;maxSpeed&#39;])       

    return DynamicsConstraints(max_acceleration, max_deceleration, max_speed) </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the DynamicsConstrains as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the DynamicsConstrains as a dict

    &#34;&#34;&#34;
    retdict = {}
    if self.max_speed is not None:
        retdict[&#39;maxSpeed&#39;] = str(self.max_speed)
    if self.max_deceleration is not None:
        retdict[&#39;maxDeceleration&#39;] = str(self.max_deceleration)
    if self.max_acceleration is not None:
        retdict[&#39;maxAcceleration&#39;] = str(self.max_acceleration)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, name='DynamicConstraints')</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the DynamicsConstrains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self,name = &#39;DynamicConstraints&#39;):
    &#34;&#34;&#34; returns the elementTree of the DynamicsConstrains

    &#34;&#34;&#34;
    return ET.Element(name,attrib=self.get_attributes())</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.DynamicsConstraints.is_filled"><code class="name flex">
<span>def <span class="ident">is_filled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>is_filled check is any constraints are set</p>
<p>Returns: boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_filled(self):
    &#34;&#34;&#34; is_filled check is any constraints are set

        Returns: boolean

    &#34;&#34;&#34;

    if self.max_acceleration or self.max_deceleration or self.max_speed:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.EntityRef"><code class="flex name class">
<span>class <span class="ident">EntityRef</span></span>
<span>(</span><span>entity)</span>
</code></dt>
<dd>
<div class="desc"><p>EntityRef creates an EntityRef element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>entity (str): name of the entity
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>entity (str): name of the entity
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the EntityRef</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>entity (str): name of the entity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntityRef(VersionBase):
    &#34;&#34;&#34; EntityRef creates an EntityRef element of openscenario
        
        Parameters
        ----------
            entity (str): name of the entity

        Attributes
        ----------
            entity (str): name of the entity

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,entity):
        &#34;&#34;&#34; initalize the EntityRef

            Parameters
            ----------
                entity (str): name of the entity
                
        &#34;&#34;&#34;
        self.entity = entity

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of EntityRef

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)

            Returns
            -------
                entityref (EntityRef): a EntityRef object

        &#34;&#34;&#34;
        entity = element.attrib[&#39;entityRef&#39;]
        return EntityRef(entity)

    def __eq__(self,other):
        if isinstance(other,EntityRef):
            if self.entity == other.entity:
                return True
        return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the EntityRef as a dict

        &#34;&#34;&#34;
        return {&#39;entityRef&#39;:self.entity}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the EntityRef

        &#34;&#34;&#34;
        return ET.Element(&#39;EntityRef&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.EntityRef.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of EntityRef</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>entityref (EntityRef): a EntityRef object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of EntityRef

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A entityref element (same as generated by the class itself)

        Returns
        -------
            entityref (EntityRef): a EntityRef object

    &#34;&#34;&#34;
    entity = element.attrib[&#39;entityRef&#39;]
    return EntityRef(entity)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.EntityRef.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the EntityRef as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the EntityRef as a dict

    &#34;&#34;&#34;
    return {&#39;entityRef&#39;:self.entity}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.EntityRef.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the EntityRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the EntityRef

    &#34;&#34;&#34;
    return ET.Element(&#39;EntityRef&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>name, timeofday=None, weather=None, roadcondition=None, parameters=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Environment class creates a environment used by Environment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

append_to_catalog(filename)
    adds the vehicle to an existing catalog

dump_to_catalog(filename,name,description,author)
    crates a new catalog with the vehicle

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalize the Environment</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (string): Name of the environment. If used in catalog name is required.

timeofday (TimeOfDay): time of day for the environment

weather (Weather): weather of the environment

roadcondition (RoadCondition): road condition of the environment

parameters (ParameterDeclarations): the parameters to be used in the scenario
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment(VersionBase):
    &#34;&#34;&#34; The Environment class creates a environment used by Environment
        
        Parameters
        ----------
            name (string): Name of the environment. If used in catalog name is required.

            timeofday (TimeOfDay): time of day for the environment

            weather (Weather): weather of the environment

            roadcondition (RoadCondition): road condition of the environment

            parameters (ParameterDeclarations): the parameters to be used in the scenario
                Default: None

        Attributes
        ----------
            name (string): Name of the environment. If used in catalog name is required.

            timeofday (TimeOfDay): time of day for the environment

            weather (Weather): weather of the environment

            roadcondition (RoadCondition): road condition of the environment

            parameters (ParameterDeclarations): the parameters to be used in the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            append_to_catalog(filename)
                adds the vehicle to an existing catalog

            dump_to_catalog(filename,name,description,author)
                crates a new catalog with the vehicle

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;

    def __init__(self, name, timeofday=None, weather=None, roadcondition=None, parameters = None):
        &#34;&#34;&#34; initalize the Environment

            Parameters
            ----------
                name (string): Name of the environment. If used in catalog name is required.

                timeofday (TimeOfDay): time of day for the environment

                weather (Weather): weather of the environment

                roadcondition (RoadCondition): road condition of the environment

                parameters (ParameterDeclarations): the parameters to be used in the scenario
                    Default: None
        &#34;&#34;&#34;
        self.name = name
        if timeofday is not None and not isinstance(timeofday,TimeOfDay):
            raise TypeError(&#39;timeofday input is not of type TimeOfDay&#39;)
        if weather is not None and not isinstance(weather,Weather):
            raise TypeError(&#39;weather input is not of type Weather&#39;)
        if roadcondition is not None and not isinstance(roadcondition,RoadCondition):
            raise TypeError(&#39;roadcondition input is not of type RoadCondition&#39;)
        if parameters is not None and not isinstance(parameters,ParameterDeclarations):
            raise TypeError(&#39;parameters input is not of type ParameterDeclarations&#39;)
        self.timeofday = timeofday
        self.weather = weather
        self.roadcondition = roadcondition
        self.parameters = parameters

    def __eq__(self,other):
        if isinstance(other,Environment):
            if self.get_attributes() == other.get_attributes() and\
            self.timeofday == other.timeofday and \
            self.weather == other.weather and \
            self.roadcondition == other.roadcondition and \
            self.parameters == other.parameters:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Environment

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)

            Returns
            -------
                environment (Environment): a Environment object

        &#34;&#34;&#34; 
        name = element.attrib[&#39;name&#39;]
        parameters = None
        weather = None
        timeofday = None
        roadcondition = None

        if element.find(&#39;ParameterDeclarations&#39;) != None:
            parameters = ParameterAssignment.parse(element.find(&#39;ParamterDeclarations&#39;))
        if element.find(&#39;TimeOfDay&#39;) != None:
            timeofday = TimeOfDay.parse(element.find(&#39;TimeOfDay&#39;))
        if element.find(&#39;Weather&#39;) != None:
            weather = Weather.parse(element.find(&#39;Weather&#39;))
        if element.find(&#39;RoadCondition&#39;) != None:
            roadcondition = RoadCondition.parse(element.find(&#39;RoadCondition&#39;))
        
        return Environment(name, timeofday, weather, roadcondition, parameters)

    def dump_to_catalog(self,filename,catalogtype,description,author):
        &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the environment to it
            
            Parameters
            ----------
                filename (str): path of the new catalog file

                catalogtype (str): name of the catalog

                description (str): description of the catalog

                author (str): author of the catalog
        
        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.create_catalog(filename,catalogtype,description,author)
        cf.add_to_catalog(self)
        cf.dump()

    def append_to_catalog(self,filename):
        &#34;&#34;&#34; adds the environment to an existing catalog

            Parameters
            ----------
                filename (str): path to the catalog file

        &#34;&#34;&#34;
        cf = CatalogFile()
        cf.open_catalog(filename)
        cf.add_to_catalog(self)
        cf.dump()

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Environment as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:str(self.name)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Environment

        &#34;&#34;&#34;
        element = ET.Element(&#39;Environment&#39;, attrib=self.get_attributes())
        if self.timeofday:
            element.append(self.timeofday.get_element())
        if self.weather:
            element.append(self.weather.get_element())
        if self.roadcondition:
            element.append(self.roadcondition.get_element())
        if self.parameters:
            element.append(self.parameters.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Environment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Environment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>environment (Environment): a Environment object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Environment

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A environment element (same as generated by the class itself)

        Returns
        -------
            environment (Environment): a Environment object

    &#34;&#34;&#34; 
    name = element.attrib[&#39;name&#39;]
    parameters = None
    weather = None
    timeofday = None
    roadcondition = None

    if element.find(&#39;ParameterDeclarations&#39;) != None:
        parameters = ParameterAssignment.parse(element.find(&#39;ParamterDeclarations&#39;))
    if element.find(&#39;TimeOfDay&#39;) != None:
        timeofday = TimeOfDay.parse(element.find(&#39;TimeOfDay&#39;))
    if element.find(&#39;Weather&#39;) != None:
        weather = Weather.parse(element.find(&#39;Weather&#39;))
    if element.find(&#39;RoadCondition&#39;) != None:
        roadcondition = RoadCondition.parse(element.find(&#39;RoadCondition&#39;))
    
    return Environment(name, timeofday, weather, roadcondition, parameters)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Environment.append_to_catalog"><code class="name flex">
<span>def <span class="ident">append_to_catalog</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>adds the environment to an existing catalog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path to the catalog file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_to_catalog(self,filename):
    &#34;&#34;&#34; adds the environment to an existing catalog

        Parameters
        ----------
            filename (str): path to the catalog file

    &#34;&#34;&#34;
    cf = CatalogFile()
    cf.open_catalog(filename)
    cf.add_to_catalog(self)
    cf.dump()</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment.dump_to_catalog"><code class="name flex">
<span>def <span class="ident">dump_to_catalog</span></span>(<span>self, filename, catalogtype, description, author)</span>
</code></dt>
<dd>
<div class="desc"><p>dump_to_catalog creates a new catalog and adds the environment to it</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): path of the new catalog file

catalogtype (str): name of the catalog

description (str): description of the catalog

author (str): author of the catalog
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_to_catalog(self,filename,catalogtype,description,author):
    &#34;&#34;&#34; dump_to_catalog creates a new catalog and adds the environment to it
        
        Parameters
        ----------
            filename (str): path of the new catalog file

            catalogtype (str): name of the catalog

            description (str): description of the catalog

            author (str): author of the catalog
    
    &#34;&#34;&#34;
    cf = CatalogFile()
    cf.create_catalog(filename,catalogtype,description,author)
    cf.add_to_catalog(self)
    cf.dump()</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Environment as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Environment as a dict

    &#34;&#34;&#34;
    return {&#39;name&#39;:str(self.name)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Environment.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Environment

    &#34;&#34;&#34;
    element = ET.Element(&#39;Environment&#39;, attrib=self.get_attributes())
    if self.timeofday:
        element.append(self.timeofday.get_element())
    if self.weather:
        element.append(self.weather.get_element())
    if self.roadcondition:
        element.append(self.roadcondition.get_element())
    if self.parameters:
        element.append(self.parameters.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.FileHeader"><code class="flex name class">
<span>class <span class="ident">FileHeader</span></span>
<span>(</span><span>author, description, revMinor=1, license=None)</span>
</code></dt>
<dd>
<div class="desc"><p>FileHeader creates the header of the OpenScenario file1</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the scenario

author (str): the author of the scenario

revMinor (int): the minor revision of the standard
    Default: 1

license (License): license (valid from OpenSCENARIO V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the scenario

author (str): the author of the scenario
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of FileHeader

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileHeader(VersionBase):
    &#34;&#34;&#34; FileHeader creates the header of the OpenScenario file1
        
        Parameters
        ----------
            name (str): name of the scenario 

            author (str): the author of the scenario

            revMinor (int): the minor revision of the standard
                Default: 1

            license (License): license (valid from OpenSCENARIO V1.1)
                Default: None

        Attributes
        ----------
            name (str): name of the scenario 

            author (str): the author of the scenario

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of FileHeader

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    def __init__(self,author,description,revMinor=1,license=None):
        self.description = description
        self.author = author
        self._revMajor = 1
        self._revMinor = revMinor
        self.setVersion(minor=revMinor)
        if license and not isinstance(license,License):
            raise TypeError(&#39;license is not of type License&#39;)
        self.license = license

    def __eq__(self,other):
        if isinstance(other,FileHeader):
            if self.description == other.description and \
            self.author == other.author and \
            self._revMajor == other._revMajor and \
            self._revMinor == other._revMinor:
            # will not compare date, since this will never be the same
                return True
        return False

    # TODO: License handling add_license ???

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of FileHeader

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)

            Returns
            -------
                header (FileHeader): a FileHeader object
                
        &#34;&#34;&#34;
        author = element.attrib[&#39;author&#39;]
        description = element.attrib[&#39;description&#39;]
        # revMinor = element.attrib[&#39;revMinor&#39;] 
        # revMajor = element.attrib[&#39;revMajor&#39;] 
        license = None
        if element.find(&#39;license&#39;) != None:
            license = License.parse(element.find(&#39;license&#39;))
        
        return FileHeader(author= author, description=description,license=license)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the FileHeader

        &#34;&#34;&#34;
        return {&#39;description&#39;:self.description,&#39;author&#39;:self.author,&#39;revMajor&#39;:str(self._revMajor),&#39;revMinor&#39;:str(self._revMinor),&#39;date&#39;:dt.datetime.now().isoformat()}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the FileHeader

        &#34;&#34;&#34;
        element = ET.Element(&#39;FileHeader&#39;,attrib=self.get_attributes())
        if self.license:
            element.append(self.license.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.FileHeader.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of FileHeader</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>header (FileHeader): a FileHeader object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of FileHeader

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A file header element (same as generated by the class itself)

        Returns
        -------
            header (FileHeader): a FileHeader object
            
    &#34;&#34;&#34;
    author = element.attrib[&#39;author&#39;]
    description = element.attrib[&#39;description&#39;]
    # revMinor = element.attrib[&#39;revMinor&#39;] 
    # revMajor = element.attrib[&#39;revMajor&#39;] 
    license = None
    if element.find(&#39;license&#39;) != None:
        license = License.parse(element.find(&#39;license&#39;))
    
    return FileHeader(author= author, description=description,license=license)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.FileHeader.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes as a dict of the FileHeader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes as a dict of the FileHeader

    &#34;&#34;&#34;
    return {&#39;description&#39;:self.description,&#39;author&#39;:self.author,&#39;revMajor&#39;:str(self._revMajor),&#39;revMinor&#39;:str(self._revMinor),&#39;date&#39;:dt.datetime.now().isoformat()}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.FileHeader.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the FileHeader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the FileHeader

    &#34;&#34;&#34;
    element = ET.Element(&#39;FileHeader&#39;,attrib=self.get_attributes())
    if self.license:
        element.append(self.license.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Fog"><code class="flex name class">
<span>class <span class="ident">Fog</span></span>
<span>(</span><span>visual_range, bounding_box=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fog creates an Fog element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Fog</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>visual_range (int): visual range of fog

bounding_box (BoundingBox): bounding box of fog
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fog(VersionBase):
    &#34;&#34;&#34; Fog creates an Fog element used by the Weather element of openscenario
        
        Parameters
        ----------
            visual_range (int): visual range of fog

            bounding_box (BoundingBox): bounding box of fog
                Default: None

        Attributes
        ----------
            visual_range (int): visual range of fog

            bounding_box (BoundingBox): bounding box of fog

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,visual_range,bounding_box=None):
        &#34;&#34;&#34; initalize the Fog

            Parameters
            ----------
                visual_range (int): visual range of fog

                bounding_box (BoundingBox): bounding box of fog
                    Default: None
                
        &#34;&#34;&#34;

        self.visual_range = visual_range
        self.bounding_box = bounding_box


    def __eq__(self,other):
        if isinstance(other,Fog):
            if self.get_attributes() == other.get_attributes() and \
               self.bounding_box == other.bounding_box:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Fog

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)

            Returns
            -------
                fog (Fog): a Fog object

        &#34;&#34;&#34; 

        visual_range = element.attrib[&#39;visualRange&#39;]
        bounding_box = None
        if element.find(&#39;BoundingBox&#39;) != None:
            bounding_box = BoundingBox.parse(element.find(&#39;BoundingBox&#39;))
        
        return Fog(visual_range, bounding_box)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;visualRange&#39;] = str(self.visual_range)

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Fog

        &#34;&#34;&#34;
        element = ET.Element(&#39;Fog&#39;,attrib=self.get_attributes())
        if self.bounding_box is not None:
            element.append(self.bounding_box.get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Fog.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Fog</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>fog (Fog): a Fog object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Fog

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A fog element (same as generated by the class itself)

        Returns
        -------
            fog (Fog): a Fog object

    &#34;&#34;&#34; 

    visual_range = element.attrib[&#39;visualRange&#39;]
    bounding_box = None
    if element.find(&#39;BoundingBox&#39;) != None:
        bounding_box = BoundingBox.parse(element.find(&#39;BoundingBox&#39;))
    
    return Fog(visual_range, bounding_box)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Fog.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;visualRange&#39;] = str(self.visual_range)

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Fog.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Fog</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Fog

    &#34;&#34;&#34;
    element = ET.Element(&#39;Fog&#39;,attrib=self.get_attributes())
    if self.bounding_box is not None:
        element.append(self.bounding_box.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.License"><code class="flex name class">
<span>class <span class="ident">License</span></span>
<span>(</span><span>name, resource=None, spdxId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>License creates the License used by FileHeader in the OpenScenario file
(valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the License

resource (str): link to URL
    Default: None

spdxId (str): license identifier
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the License

resource (str): link to URL

spdxId (str): license identifier
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of FileHeader

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre>
<p>init the License</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the License

resource (str): link to URL
    Default: None

spdxId (str): license identifier
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class License(VersionBase):
    &#34;&#34;&#34; License creates the License used by FileHeader in the OpenScenario file 
        (valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            name (str): name of the License

            resource (str): link to URL
                Default: None

            spdxId (str): license identifier
                Default: None

        Attributes
        ----------
            name (str): name of the License

            resource (str): link to URL
                
            spdxId (str): license identifier

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of FileHeader

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    def __init__(self,name,resource=None,spdxId=None):
        &#34;&#34;&#34; init the License
        
        Parameters
        ----------
            name (str): name of the License

            resource (str): link to URL
                Default: None

            spdxId (str): license identifier
                Default: None
        &#34;&#34;&#34;
        self.name = name
        self.resource = resource
        self.spdxId = spdxId

    def __eq__(self,other):
        if isinstance(other,License):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    # TODO: Check Class License test string 0..1 The full license

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of License

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)

            Returns
            -------
                license (License): a License object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        resource = None
        if &#39;resource&#39; in element.attrib:
            resource = element.attrib[&#39;resource&#39;]
        spdxId = None
        if &#39;spdxId&#39; in element.attrib:
            spdxId = element.attrib[&#39;spdxId&#39;]
        
        return License(name, resource, spdxId)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes as a dict of the License

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        if self.resource:
            retdict[&#39;resource&#39;] = self.resource
        if self.spdxId:
            retdict[&#39;spdxId&#39;] = self.spdxId
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the License

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;License was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;License&#39;,attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.License.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of License</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>license (License): a License object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of License

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A license element (same as generated by the class itself)

        Returns
        -------
            license (License): a License object
            
    &#34;&#34;&#34;
    name = element.attrib[&#39;name&#39;]
    resource = None
    if &#39;resource&#39; in element.attrib:
        resource = element.attrib[&#39;resource&#39;]
    spdxId = None
    if &#39;spdxId&#39; in element.attrib:
        spdxId = element.attrib[&#39;spdxId&#39;]
    
    return License(name, resource, spdxId)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.License.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes as a dict of the License</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes as a dict of the License

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;name&#39;] = self.name
    if self.resource:
        retdict[&#39;resource&#39;] = self.resource
    if self.spdxId:
        retdict[&#39;spdxId&#39;] = self.spdxId
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.License.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the License</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the License

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;License was introduced in OpenSCENARIO V1.1&#39;)
    element = ET.Element(&#39;License&#39;,attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation"><code class="flex name class">
<span>class <span class="ident">Orientation</span></span>
<span>(</span><span>h=None, p=None, r=None, reference=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Orientation describes the angular orientation of an entity</p>
<h2 id="parameters">Parameters</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>is_filled()
    check is any orientations are set

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize Orientation </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>h (float): header

p (float): pitch

r (float): roll

reference (ReferenceContext): absolute or relative
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orientation(VersionBase):
    &#34;&#34;&#34; Orientation describes the angular orientation of an entity
        
        Parameters
        ----------
            h (float): header 

            p (float): pitch

            r (float): roll

            reference (ReferenceContext): absolute or relative

        Attributes
        ----------
            h (float): header 

            p (float): pitch

            r (float): roll

            reference (ReferenceContext): absolute or relative

        Methods
        -------
            is_filled()
                check is any orientations are set

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,h=None,p=None,r=None,reference = None):
        &#34;&#34;&#34; initalize Orientation 
        
            Parameters
            ----------
                h (float): header 

                p (float): pitch

                r (float): roll

                reference (ReferenceContext): absolute or relative
        &#34;&#34;&#34;
        self.h = convert_float(h)
        self.p = convert_float(p)
        self.r = convert_float(r)
        if reference is not None and not hasattr(ReferenceContext,str(reference)):
            raise TypeError(&#39;reference input is not of type ReferenceContext&#39;)
        self.ref = reference

    def __eq__(self,other):
        if isinstance(other,Orientation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Orientation

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

            Returns
            -------
                orientation (Orientation): a Orientation object

        &#34;&#34;&#34;
        h = None
        p = None
        r = None
        reference = None
        if &#39;h&#39; in element.attrib:
            h = convert_float(element.attrib[&#39;h&#39;])
        if &#39;p&#39; in element.attrib:
            p = convert_float(element.attrib[&#39;p&#39;])
        if &#39;r&#39; in element.attrib:
            r = convert_float(element.attrib[&#39;r&#39;])
        if &#39;type&#39; in element.attrib:
            reference_str = element.attrib[&#39;type&#39;]
            reference = getattr(ReferenceContext,reference_str)

        return Orientation(h ,p ,r ,reference)

    def is_filled(self):
        &#34;&#34;&#34; is_filled check is any orientations are  set

            Returns: boolean

        &#34;&#34;&#34;
        if self.h is not None or self.p is not None or self.r is not None or self.ref is not None:
            return True
        else:
            return False

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Orientation as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.h is not None:
            retdict[&#39;h&#39;] = str(self.h)

        if self.p is not None:
            retdict[&#39;p&#39;] = str(self.p)

        if self.r is not None:
            retdict[&#39;r&#39;] = str(self.r)

        if self.ref is not None:
            retdict[&#39;type&#39;] = self.ref.get_name()

        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Orientation

        &#34;&#34;&#34;
        return ET.Element(&#39;Orientation&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Orientation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Orientation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>orientation (Orientation): a Orientation object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Orientation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A orientation element (same as generated by the class itself)

        Returns
        -------
            orientation (Orientation): a Orientation object

    &#34;&#34;&#34;
    h = None
    p = None
    r = None
    reference = None
    if &#39;h&#39; in element.attrib:
        h = convert_float(element.attrib[&#39;h&#39;])
    if &#39;p&#39; in element.attrib:
        p = convert_float(element.attrib[&#39;p&#39;])
    if &#39;r&#39; in element.attrib:
        r = convert_float(element.attrib[&#39;r&#39;])
    if &#39;type&#39; in element.attrib:
        reference_str = element.attrib[&#39;type&#39;]
        reference = getattr(ReferenceContext,reference_str)

    return Orientation(h ,p ,r ,reference)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Orientation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Orientation as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Orientation as a dict

    &#34;&#34;&#34;
    retdict = {}
    if self.h is not None:
        retdict[&#39;h&#39;] = str(self.h)

    if self.p is not None:
        retdict[&#39;p&#39;] = str(self.p)

    if self.r is not None:
        retdict[&#39;r&#39;] = str(self.r)

    if self.ref is not None:
        retdict[&#39;type&#39;] = self.ref.get_name()

    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Orientation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Orientation

    &#34;&#34;&#34;
    return ET.Element(&#39;Orientation&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Orientation.is_filled"><code class="name flex">
<span>def <span class="ident">is_filled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>is_filled check is any orientations are
set</p>
<p>Returns: boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_filled(self):
    &#34;&#34;&#34; is_filled check is any orientations are  set

        Returns: boolean

    &#34;&#34;&#34;
    if self.h is not None or self.p is not None or self.r is not None or self.ref is not None:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter"><code class="flex name class">
<span>class <span class="ident">Parameter</span></span>
<span>(</span><span>name, parameter_type, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameter is a declaration of a ParameterDeclaration for declarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter

constraint_group (ValueConstraintGroup) constraint groups to the parameter value
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_parameter ???

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_value_constraint_group(constraint_group)
    adds a value constraint group to the Parameter

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Parameter </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of parameter

parameter_type (ParameterType): type of the parameter

value (str): value of the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parameter(VersionBase):
    &#34;&#34;&#34; Parameter is a declaration of a ParameterDeclaration for declarations
        
        Parameters
        ----------
            name (str): name of parameter

            parameter_type (ParameterType): type of the parameter 

            value (str): value of the parameter

        Attributes
        ----------
            name (str): name of parameter

            parameter_type (ParameterType): type of the parameter

            value (str): value of the parameter

            constraint_group (ValueConstraintGroup) constraint groups to the parameter value

        Methods
        -------
            add_parameter ???

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_value_constraint_group(constraint_group)
                adds a value constraint group to the Parameter

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;

    def __init__(self,name,parameter_type,value):
        &#34;&#34;&#34; initalize the Parameter 

            Parameters
            ----------
                name (str): name of parameter

                parameter_type (ParameterType): type of the parameter

                value (str): value of the parameter

        &#34;&#34;&#34;
        self.name = name
        if not hasattr(ParameterType,str(parameter_type)):
            raise ValueError(&#39;parameter_type not a valid type.&#39;)
        self.parameter_type = parameter_type
        self.value = value
        self.constraint_groups = []

    def __eq__(self,other):
        if isinstance(other,Parameter):
            if self.get_attributes() == other.get_attributes() and\
                self.constraint_groups == other.constraint_groups:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Parameter

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)

            Returns
            -------
                parameter (Parameter): Parameter object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        value = element.attrib[&#39;value&#39;]
        parameter_type = getattr(ParameterType, element.attrib[&#39;parameterType&#39;])
        parameter = Parameter(name, parameter_type, value)
        constraint_groups = element.findall(&#39;ValueConstraintGroup&#39;)
        for constraint_group in constraint_groups:
            parameter.add_value_constraint_group(ValueConstraintGroup.parse(constraint_group))
        return parameter
    
    def add_value_constraint_group(self,constraint_group):
        &#34;&#34;&#34; adds a value constraint to the value constraint group

        Parameters
        ----------
            constraint_group (ValueConstraintGroup): the value constraint group to be added 

        &#34;&#34;&#34;
        if not isinstance(constraint_group,ValueConstraintGroup):
            raise TypeError(&#39;value_conatraint input is not of type ValueConstraintGroup&#39;)
        self.constraint_groups.append(constraint_group)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Parameter as a dict

        &#34;&#34;&#34;
        return {&#39;name&#39;:self.name,&#39;parameterType&#39;:self.parameter_type.get_name(),&#39;value&#39;:str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Parameter

        &#34;&#34;&#34;
        element = ET.Element(&#39;ParameterDeclaration&#39;,attrib=self.get_attributes())
        if self.constraint_groups:
            for constraint_group in self.constraint_groups:
                element.append(constraint_group.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Parameter.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Parameter</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameter (Parameter): Parameter object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Parameter

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameter element (same as generated by the class itself)

        Returns
        -------
            parameter (Parameter): Parameter object
            
    &#34;&#34;&#34;
    name = element.attrib[&#39;name&#39;]
    value = element.attrib[&#39;value&#39;]
    parameter_type = getattr(ParameterType, element.attrib[&#39;parameterType&#39;])
    parameter = Parameter(name, parameter_type, value)
    constraint_groups = element.findall(&#39;ValueConstraintGroup&#39;)
    for constraint_group in constraint_groups:
        parameter.add_value_constraint_group(ValueConstraintGroup.parse(constraint_group))
    return parameter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Parameter.add_value_constraint_group"><code class="name flex">
<span>def <span class="ident">add_value_constraint_group</span></span>(<span>self, constraint_group)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a value constraint to the value constraint group</p>
<h2 id="parameters">Parameters</h2>
<pre><code>constraint_group (ValueConstraintGroup): the value constraint group to be added
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_value_constraint_group(self,constraint_group):
    &#34;&#34;&#34; adds a value constraint to the value constraint group

    Parameters
    ----------
        constraint_group (ValueConstraintGroup): the value constraint group to be added 

    &#34;&#34;&#34;
    if not isinstance(constraint_group,ValueConstraintGroup):
        raise TypeError(&#39;value_conatraint input is not of type ValueConstraintGroup&#39;)
    self.constraint_groups.append(constraint_group)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Parameter as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Parameter as a dict

    &#34;&#34;&#34;
    return {&#39;name&#39;:self.name,&#39;parameterType&#39;:self.parameter_type.get_name(),&#39;value&#39;:str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Parameter.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Parameter

    &#34;&#34;&#34;
    element = ET.Element(&#39;ParameterDeclaration&#39;,attrib=self.get_attributes())
    if self.constraint_groups:
        for constraint_group in self.constraint_groups:
            element.append(constraint_group.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment"><code class="flex name class">
<span>class <span class="ident">ParameterAssignment</span></span>
<span>(</span><span>parameterref, value)</span>
</code></dt>
<dd>
<div class="desc"><p>ParameterAssignment creates an ParameterAssignment element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the ParameterAssignment</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>parameterref (str): name of the parameter

value (str): assigned value of the parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterAssignment(VersionBase):
    &#34;&#34;&#34; ParameterAssignment creates an ParameterAssignment element of openscenario
        
        Parameters
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter


        Attributes
        ----------
            parameterref (str): name of the parameter

            value (str): assigned value of the parameter

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class
                
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,parameterref,value):
        &#34;&#34;&#34; initalize the ParameterAssignment

            Parameters
            ----------
                parameterref (str): name of the parameter

                value (str): assigned value of the parameter   
                
        &#34;&#34;&#34;
        self.parameterref = parameterref
        self.value = value

    def __eq__(self,other):
        if isinstance(other,ParameterAssignment):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ParameterAssignment

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)

            Returns
            -------
                parameterassignment (ParameterAssignment): a ParameterAssignment object

        &#34;&#34;&#34;

        value = element.attrib[&#39;value&#39;]
        parameterref = element.attrib[&#39;parameterRef&#39;]
    
        return ParameterAssignment(parameterref, value)


    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ParameterAssignment as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;parameterRef&#39;] = self.parameterref
        retdict[&#39;value&#39;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterAssignment

        &#34;&#34;&#34;
        return ET.Element(&#39;ParameterAssignment&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterAssignment</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameterassignment (ParameterAssignment): a ParameterAssignment object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of ParameterAssignment

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameter assignment element (same as generated by the class itself)

        Returns
        -------
            parameterassignment (ParameterAssignment): a ParameterAssignment object

    &#34;&#34;&#34;

    value = element.attrib[&#39;value&#39;]
    parameterref = element.attrib[&#39;parameterRef&#39;]

    return ParameterAssignment(parameterref, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ParameterAssignment as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the ParameterAssignment as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;parameterRef&#39;] = self.parameterref
    retdict[&#39;value&#39;] = str(self.value)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterAssignment.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterAssignment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ParameterAssignment

    &#34;&#34;&#34;
    return ET.Element(&#39;ParameterAssignment&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations"><code class="flex name class">
<span>class <span class="ident">ParameterDeclarations</span></span>
</code></dt>
<dd>
<div class="desc"><p>The ParameterDeclarations class creates the ParameterDeclaration of OpenScenario</p>
<h2 id="attributes">Attributes</h2>
<pre><code>parameters: list of Parameter objects
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

add_parameter(Parameter)
    adds a Parameter to the ParameterDeclarations

parse(element)
    parses a ElementTree created by the class and returns an instance of the class
</code></pre>
<p>initalizes the ParameterDeclarations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterDeclarations(VersionBase):
    &#34;&#34;&#34; The ParameterDeclarations class creates the ParameterDeclaration of OpenScenario
                    
        Attributes
        ----------
            parameters: list of Parameter objects

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            add_parameter(Parameter)
                adds a Parameter to the ParameterDeclarations
            
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalizes the ParameterDeclarations

        &#34;&#34;&#34;
        self.parameters = []

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ParameterDeclarations

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)

            Returns
            -------
                parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object
                
        &#34;&#34;&#34;
        parameter_declarations = ParameterDeclarations()
        declarations = element.findall(&#39;ParameterDeclaration&#39;)
        for declaration in declarations:
            parameter_declaration = Parameter.parse(declaration)
            parameter_declarations.add_parameter(parameter_declaration)
        return parameter_declarations

    def __eq__(self,other):
        if isinstance(other,ParameterDeclarations):
            if self.parameters == other.parameters:
                return True
        return False

    def add_parameter(self,parameter):
        &#34;&#34;&#34; add_parameter adds a Parameter to the ParameterDeclarations

        Parameters
        ----------
            parameter (Parameter): a new parameter


        &#34;&#34;&#34;
        if not isinstance(parameter,Parameter):
            raise TypeError(&#39;parameter input is not of type Parameter&#39;)
        self.parameters.append(parameter)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ParameterDeclarations

        &#34;&#34;&#34;
        element = ET.Element(&#39;ParameterDeclarations&#39;)
        for p in self.parameters:
            element.append(p.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ParameterDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of ParameterDeclarations

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A parameterdeclarations element (same as generated by the class itself)

        Returns
        -------
            parameterdeclaration (ParameterDeclaration): a ParameterDeclarationn object
            
    &#34;&#34;&#34;
    parameter_declarations = ParameterDeclarations()
    declarations = element.findall(&#39;ParameterDeclaration&#39;)
    for declaration in declarations:
        parameter_declaration = Parameter.parse(declaration)
        parameter_declarations.add_parameter(parameter_declaration)
    return parameter_declarations</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter"><code class="name flex">
<span>def <span class="ident">add_parameter</span></span>(<span>self, parameter)</span>
</code></dt>
<dd>
<div class="desc"><p>add_parameter adds a Parameter to the ParameterDeclarations</p>
<h2 id="parameters">Parameters</h2>
<pre><code>parameter (Parameter): a new parameter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter(self,parameter):
    &#34;&#34;&#34; add_parameter adds a Parameter to the ParameterDeclarations

    Parameters
    ----------
        parameter (Parameter): a new parameter


    &#34;&#34;&#34;
    if not isinstance(parameter,Parameter):
        raise TypeError(&#39;parameter input is not of type Parameter&#39;)
    self.parameters.append(parameter)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.ParameterDeclarations.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ParameterDeclarations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ParameterDeclarations

    &#34;&#34;&#34;
    element = ET.Element(&#39;ParameterDeclarations&#39;)
    for p in self.parameters:
        element.append(p.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase"><code class="flex name class">
<span>class <span class="ident">Phase</span></span>
<span>(</span><span>name, duration)</span>
</code></dt>
<dd>
<div class="desc"><p>crates a Traffic light phase</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase

signalstates (list of _TrafficSignalState): traffic signal states
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_stignal_state(signal_id,state)
    add a traffic signal state
</code></pre>
<p>initalize the Phase </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): if of the phase

duration (float): duration of the phase
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Phase(VersionBase):
    &#34;&#34;&#34; crates a Traffic light phase
        
        Parameters
        ----------
            name (str): if of the phase

            duration (float): duration of the phase
                
        Attributes
        ----------
            name (str): if of the phase

            duration (float): duration of the phase

            signalstates (list of _TrafficSignalState): traffic signal states

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_stignal_state(signal_id,state)
                add a traffic signal state
    &#34;&#34;&#34;

    def __init__(self, name, duration):
        &#34;&#34;&#34; initalize the Phase 
        
        Parameters
        ----------
            name (str): if of the phase

            duration (float): duration of the phase

        &#34;&#34;&#34;

        self.name = name
        self.duration = convert_float(duration)
        self.signalstates = []

    def __eq__(self,other):
        if isinstance(other,Phase):
            if self.get_attributes() == other.get_attributes() and self.signalstates == other.signalstates:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Phase

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)

            Returns
            -------
                phase (Phase): a Phase object
                
        &#34;&#34;&#34;
        duration = convert_float(element.attrib[&#39;duration&#39;])
        name = element.attrib[&#39;name&#39;]
        phase = Phase(name, duration)
        signalstates = element.findall(&#39;TrafficSignalState&#39;)
        if signalstates != None:
            for signalstate in signalstates:
                traffic_signal_state = _TrafficSignalState.parse(signalstate)
                phase.signalstates.append(traffic_signal_state)

        return phase

    def add_signal_state(self,signal_id,state):
        &#34;&#34;&#34; Adds a phase of the traffic signal

            Parameters
            ----------
                signal_id (str): id of the traffic signal in the road network

                state (str): state of the signal defined in the road network

        &#34;&#34;&#34;
        self.signalstates.append(_TrafficSignalState(signal_id,state))

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalController
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        retdict[&#39;duration&#39;] = str(self.duration)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Polyline

        &#34;&#34;&#34;
        element = ET.Element(&#39;Phase&#39;,attrib=self.get_attributes())
        for s in self.signalstates:
            element.append(s.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Phase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Phase</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>phase (Phase): a Phase object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Phase

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A phase element (same as generated by the class itself)

        Returns
        -------
            phase (Phase): a Phase object
            
    &#34;&#34;&#34;
    duration = convert_float(element.attrib[&#39;duration&#39;])
    name = element.attrib[&#39;name&#39;]
    phase = Phase(name, duration)
    signalstates = element.findall(&#39;TrafficSignalState&#39;)
    if signalstates != None:
        for signalstate in signalstates:
            traffic_signal_state = _TrafficSignalState.parse(signalstate)
            phase.signalstates.append(traffic_signal_state)

    return phase</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Phase.add_signal_state"><code class="name flex">
<span>def <span class="ident">add_signal_state</span></span>(<span>self, signal_id, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a phase of the traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>signal_id (str): id of the traffic signal in the road network

state (str): state of the signal defined in the road network
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal_state(self,signal_id,state):
    &#34;&#34;&#34; Adds a phase of the traffic signal

        Parameters
        ----------
            signal_id (str): id of the traffic signal in the road network

            state (str): state of the signal defined in the road network

    &#34;&#34;&#34;
    self.signalstates.append(_TrafficSignalState(signal_id,state))</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalController</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSignalController
    
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;name&#39;] = self.name
    retdict[&#39;duration&#39;] = str(self.duration)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Phase.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Polyline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Polyline

    &#34;&#34;&#34;
    element = ET.Element(&#39;Phase&#39;,attrib=self.get_attributes())
    for s in self.signalstates:
        element.append(s.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Precipitation"><code class="flex name class">
<span>class <span class="ident">Precipitation</span></span>
<span>(</span><span>precipitation, intensity)</span>
</code></dt>
<dd>
<div class="desc"><p>Precipitation creates an Precipitation element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Precipitation</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>precipitation (PrecipitationType): dry, rain or snow

intensity (float): intensity of precipitation (0...1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Precipitation(VersionBase):
    &#34;&#34;&#34; Precipitation creates an Precipitation element used by the Weather element of openscenario
        
        Parameters
        ----------
            precipitation (PrecipitationType): dry, rain or snow

            intensity (float): intensity of precipitation (0...1)

        Attributes
        ----------
            precipitation (PrecipitationType): dry, rain or snow

            intensity (float): intensity of precipitation (0...1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,precipitation,intensity):
        &#34;&#34;&#34; initalize the Precipitation

            Parameters
            ----------
                precipitation (PrecipitationType): dry, rain or snow

                intensity (float): intensity of precipitation (0...1)
                
        &#34;&#34;&#34;
        if not hasattr(PrecipitationType,str(precipitation)):
            raise TypeError(&#39;precipitation input is not of type PrecipitationType&#39;)
        self.precipitation = precipitation
        self.intensity = convert_float(intensity)

    def __eq__(self,other):
        if isinstance(other,Precipitation):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Precipitation

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)

            Returns
            -------
                precipitation (Precipitation): a Precipitation object

        &#34;&#34;&#34; 
        intesity = None
        if &#39;precipitationIntensity&#39; in element.attrib:
            intesity = element.attrib[&#39;precipitationIntensity&#39;]
        elif &#39;intensity&#39; in element.attrib: 
            intesity = element.attrib[&#39;intensity&#39;]
        precipitation = getattr(PrecipitationType, element.attrib[&#39;precipitationType&#39;])

        return Precipitation(precipitation, intesity)
        
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;precipitationType&#39;] = self.precipitation.get_name()
        if self.isVersion(minor=0):
            retdict[&#39;intensity&#39;] = str(self.intensity)
        else:
            retdict[&#39;precipitationIntensity&#39;] = str(self.intensity)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Precipitation

        &#34;&#34;&#34;
        element = ET.Element(&#39;Precipitation&#39;,attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Precipitation.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Precipitation</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>precipitation (Precipitation): a Precipitation object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Precipitation

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A precipitation element (same as generated by the class itself)

        Returns
        -------
            precipitation (Precipitation): a Precipitation object

    &#34;&#34;&#34; 
    intesity = None
    if &#39;precipitationIntensity&#39; in element.attrib:
        intesity = element.attrib[&#39;precipitationIntensity&#39;]
    elif &#39;intensity&#39; in element.attrib: 
        intesity = element.attrib[&#39;intensity&#39;]
    precipitation = getattr(PrecipitationType, element.attrib[&#39;precipitationType&#39;])

    return Precipitation(precipitation, intesity)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Precipitation.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;precipitationType&#39;] = self.precipitation.get_name()
    if self.isVersion(minor=0):
        retdict[&#39;intensity&#39;] = str(self.intensity)
    else:
        retdict[&#39;precipitationIntensity&#39;] = str(self.intensity)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Precipitation.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Precipitation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Precipitation

    &#34;&#34;&#34;
    element = ET.Element(&#39;Precipitation&#39;,attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties"><code class="flex name class">
<span>class <span class="ident">Properties</span></span>
</code></dt>
<dd>
<div class="desc"><p>the Properties contains are for user defined properties of an object
</p>
<h2 id="attributes">Attributes</h2>
<pre><code>files (list of str): arbitrary files with properties

properties (list of tuple(str,str)): properties in name/value pairs
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

add_file(file)
    adds a file with properties

add_property(name,value)
    adds a property pair, with name and value

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the Properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Properties(VersionBase):
    &#34;&#34;&#34; the Properties contains are for user defined properties of an object               

        Attributes
        ----------
            files (list of str): arbitrary files with properties

            properties (list of tuple(str,str)): properties in name/value pairs

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            add_file(file)
                adds a file with properties

            add_property(name,value)
                adds a property pair, with name and value

            get_element()
                Returns the full ElementTree of the class

            
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalzie the Properties

        &#34;&#34;&#34;
        self.files = []
        self.properties = []

    def __eq__(self,other):
        if isinstance(other,Properties):
            if self.files == other.files and \
            self.properties == other.properties:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of class Properties:


            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

            Returns
            -------
                properties (Properties): a Properties object
                
        &#34;&#34;&#34;
        properties = Properties()
        files = element.findall(&#39;File&#39;)
        if files != None:
            for file in files:
                filepath = file.attrib[&#39;filepath&#39;]
                properties.add_file(filepath)
        props = element.findall(&#39;Property&#39;)
        if props != None:
            for property in props:
                name = property.attrib[&#39;name&#39;]
                value = property.attrib[&#39;value&#39;]
                properties.add_property(name, value)
        
        return properties

    def add_file(self,filename):
        &#34;&#34;&#34; adds a property file

        Parameters
        ----------
            filename (str): name of the file

        &#34;&#34;&#34;

        self.files.append(filename)

    def add_property(self,name,value):
        &#34;&#34;&#34; adds a property pair

        Parameters
        ----------
            name (str): name of the property

            value (str): value of the property

        &#34;&#34;&#34;
        self.properties.append((name,value))

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Properties

        &#34;&#34;&#34;
        element = ET.Element(&#39;Properties&#39;)
        for p in self.properties:
            ET.SubElement(element,&#39;Property&#39;,attrib={&#39;name&#39;:p[0],&#39;value&#39;:p[1]})
        for f in self.files:
            ET.SubElement(element,&#39;File&#39;,attrib={&#39;filepath&#39;:f})

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Properties.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of class Properties:</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>properties (Properties): a Properties object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of class Properties:


        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A position element (same as generated by the class itself)

        Returns
        -------
            properties (Properties): a Properties object
            
    &#34;&#34;&#34;
    properties = Properties()
    files = element.findall(&#39;File&#39;)
    if files != None:
        for file in files:
            filepath = file.attrib[&#39;filepath&#39;]
            properties.add_file(filepath)
    props = element.findall(&#39;Property&#39;)
    if props != None:
        for property in props:
            name = property.attrib[&#39;name&#39;]
            value = property.attrib[&#39;value&#39;]
            properties.add_property(name, value)
    
    return properties</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Properties.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a property file</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): name of the file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self,filename):
    &#34;&#34;&#34; adds a property file

    Parameters
    ----------
        filename (str): name of the file

    &#34;&#34;&#34;

    self.files.append(filename)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a property pair</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the property

value (str): value of the property
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self,name,value):
    &#34;&#34;&#34; adds a property pair

    Parameters
    ----------
        name (str): name of the property

        value (str): value of the property

    &#34;&#34;&#34;
    self.properties.append((name,value))</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Properties.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Properties

    &#34;&#34;&#34;
    element = ET.Element(&#39;Properties&#39;)
    for p in self.properties:
        ET.SubElement(element,&#39;Property&#39;,attrib={&#39;name&#39;:p[0],&#39;value&#39;:p[1]})
    for f in self.files:
        ET.SubElement(element,&#39;File&#39;,attrib={&#39;filepath&#39;:f})

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster"><code class="flex name class">
<span>class <span class="ident">RelativeSpeedToMaster</span></span>
<span>(</span><span>value, speedTargetValueType, steadyState=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class itself

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns the attributes of the class
</code></pre>
<h2 id="parameters_1">Parameters</h2>
<pre><code>value (float): Relative speed. Unit: m/s.

speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).

steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeSpeedToMaster(VersionBase):
    &#34;&#34;&#34;
        Parameters
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

        Attributes
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed. (Valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class itself

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns the attributes of the class
    &#34;&#34;&#34;
    def __init__(self, value, speedTargetValueType, steadyState=None):
        &#34;&#34;&#34;

        Parameters
        ----------
            value (float): Relative speed. Unit: m/s.
            
            speedTargetValueType (SpeedTargetValueType): The semantics of the value (delta, offset, factor).
            
            steadyState (TargetTimeSteadyState / TargetDistanceSteadyState): Optional final phase of constant (final) speed.
        &#34;&#34;&#34;
        self.value = value
        if steadyState:
            if not (isinstance(steadyState, TargetTimeSteadyState) or isinstance(steadyState,
                                                                                 TargetDistanceSteadyState)):
                raise TypeError(&#39;steadyState input is not an TargetTimeSteadyState or TargetDistanceSteadyState input&#39;)
        self.steadyState = steadyState
        if not speedTargetValueType.classname == &#34;SpeedTargetValueType&#34;:
            raise TypeError(&#39;speedTargetValueType input is not a valid SpeedTargetValueType&#39;)
        self.speedTargetValueType = speedTargetValueType

    def __eq__(self,other):
        if isinstance(other,RelativeSpeedToMaster):
            if self.get_attributes() == other.get_attributes() and\
                self.steadyState == other.steadyState:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element to RelativeSpeedToMaster

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)

            Returns
            ------
                rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object

        &#34;&#34;&#34;
        speed_element = element.find(&#39;RelativeSpeedToMaster&#39;)

        value = speed_element.attrib[&#39;value&#39;]
        speedTargetValueType = getattr(SpeedTargetValueType, speed_element.attrib[&#39;speedTargetValueType&#39;])
        state = None 
        if speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
            state = TargetDistanceSteadyState.parse(speed_element.find(&#39;TargetDistanceSteadyState&#39;))
        elif speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
            state = TargetTimeSteadyState.parse(speed_element.find(&#39;TargetTimeSteadyState&#39;))
        
        return RelativeSpeedToMaster(value,speedTargetValueType,state)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RelativeSpeedToMaster

        &#34;&#34;&#34;
        return {&#39;speedTargetValueType&#39;: str(self.speedTargetValueType), &#39;value&#39;: str(self.value)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RelativeSpeedToMaster

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;RelativeSpeedToMaster was introduced in OpenSCENARIO V1.1&#39;)
        elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
        elementRelativeSpeed = ET.SubElement(elementFinalSpeed, &#39;RelativeSpeedToMaster&#39;, attrib=self.get_attributes())
        if self.steadyState:
            if self.isVersion(1, 0):
                raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
            ET.SubElement(elementRelativeSpeed, self.steadyState.__class__.__name__,
                          attrib=self.steadyState.get_attributes())
        return elementFinalSpeed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element to RelativeSpeedToMaster</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element to RelativeSpeedToMaster

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A RelativeSpeedToMaster element (same as generated by the class itself)

        Returns
        ------
            rstm (RelativeSpeedToMaster): a RelativeSpeedToMaster object

    &#34;&#34;&#34;
    speed_element = element.find(&#39;RelativeSpeedToMaster&#39;)

    value = speed_element.attrib[&#39;value&#39;]
    speedTargetValueType = getattr(SpeedTargetValueType, speed_element.attrib[&#39;speedTargetValueType&#39;])
    state = None 
    if speed_element.find(&#39;TargetDistanceSteadyState&#39;) != None:
        state = TargetDistanceSteadyState.parse(speed_element.find(&#39;TargetDistanceSteadyState&#39;))
    elif speed_element.find(&#39;TargetTimeSteadyState&#39;) != None:
        state = TargetTimeSteadyState.parse(speed_element.find(&#39;TargetTimeSteadyState&#39;))
    
    return RelativeSpeedToMaster(value,speedTargetValueType,state)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RelativeSpeedToMaster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the RelativeSpeedToMaster

    &#34;&#34;&#34;
    return {&#39;speedTargetValueType&#39;: str(self.speedTargetValueType), &#39;value&#39;: str(self.value)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RelativeSpeedToMaster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RelativeSpeedToMaster

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;RelativeSpeedToMaster was introduced in OpenSCENARIO V1.1&#39;)
    elementFinalSpeed = ET.Element(&#39;FinalSpeed&#39;)
    elementRelativeSpeed = ET.SubElement(elementFinalSpeed, &#39;RelativeSpeedToMaster&#39;, attrib=self.get_attributes())
    if self.steadyState:
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;steadyState was introduced in OpenSCENARIO V1.1&#39;)
        ET.SubElement(elementRelativeSpeed, self.steadyState.__class__.__name__,
                      attrib=self.steadyState.get_attributes())
    return elementFinalSpeed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.RoadCondition"><code class="flex name class">
<span>class <span class="ident">RoadCondition</span></span>
<span>(</span><span>friction_scale_factor, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Weather creates an Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Weather</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>friction_scale_factor (float): scale factor of the friction

properties (Properties): properties of the roadcondition
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadCondition(VersionBase):
    &#34;&#34;&#34; Weather creates an Weather element of openscenario
        
        Parameters
        ----------
            friction_scale_factor (float): scale factor of the friction

            properties (Properties): properties of the roadcondition
                Default: None

        Attributes
        ----------
            friction_scale_factor (float): scale factor of the friction

            properties (Properties): properties of the roadcondition

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,friction_scale_factor,properties = None):
        &#34;&#34;&#34; initalize the Weather

            Parameters
            ----------
                friction_scale_factor (float): scale factor of the friction

                properties (Properties): properties of the roadcondition
                    Default: None
                
        &#34;&#34;&#34;
        self.friction_scale_factor = friction_scale_factor
        if properties is not None and not isinstance(properties,Properties):
            raise TypeError(&#39;properties input is not of type Properties&#39;)
        self.properties = properties

    def __eq__(self,other):
        if isinstance(other,RoadCondition):
            if self.get_attributes() == other.get_attributes() and self.properties == other.properties:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of RoadCondition

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)

            Returns
            -------
                roadcondition (RoadCondition): a RoadCondition object

        &#34;&#34;&#34; 
        friction_scale_factor = element.attrib[&#39;frictionScaleFactor&#39;]
        properties = None
        if element.find(&#39;Properties&#39;) != None:
            properties = Properties.parse(element.find(&#39;Properties&#39;))

        return RoadCondition(friction_scale_factor, properties)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the RoadCondition as a dict

        &#34;&#34;&#34;
        return {&#39;frictionScaleFactor&#39;:str(self.friction_scale_factor)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the RoadCondition

        &#34;&#34;&#34;
        element = ET.Element(&#39;RoadCondition&#39;,attrib=self.get_attributes())
        if self.properties:
            element.append(self.properties.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RoadCondition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of RoadCondition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>roadcondition (RoadCondition): a RoadCondition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of RoadCondition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A road condition element (same as generated by the class itself)

        Returns
        -------
            roadcondition (RoadCondition): a RoadCondition object

    &#34;&#34;&#34; 
    friction_scale_factor = element.attrib[&#39;frictionScaleFactor&#39;]
    properties = None
    if element.find(&#39;Properties&#39;) != None:
        properties = Properties.parse(element.find(&#39;Properties&#39;))

    return RoadCondition(friction_scale_factor, properties)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.RoadCondition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the RoadCondition as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the RoadCondition as a dict

    &#34;&#34;&#34;
    return {&#39;frictionScaleFactor&#39;:str(self.friction_scale_factor)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.RoadCondition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the RoadCondition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the RoadCondition

    &#34;&#34;&#34;
    element = ET.Element(&#39;RoadCondition&#39;,attrib=self.get_attributes())
    if self.properties:
        element.append(self.properties.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Sun"><code class="flex name class">
<span>class <span class="ident">Sun</span></span>
<span>(</span><span>intensity, azimuth, elevation)</span>
</code></dt>
<dd>
<div class="desc"><p>Sun creates an Sun element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Sun</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>intensity (float): intensity of the sun (in lux)

azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sun(VersionBase):
    &#34;&#34;&#34; Sun creates an Sun element used by the Weather element of openscenario
        
        Parameters
        ----------
            intensity (float): intensity of the sun (in lux)

            azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

            elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

        Attributes
        ----------
            intensity (float): intensity of the sun (in lux)

            azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

            elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,intensity,azimuth,elevation):
        &#34;&#34;&#34; initalize the Sun

            Parameters
            ----------
                intensity (float): intensity of the sun (in lux)

                azimuth (float): azimuth of the sun 0 north, pi/2 east, pi south, 3/2pi west

                elevation (float): sun elevation angle 0 x/y plane, pi/2 zenith
                
        &#34;&#34;&#34;

        self.azimuth = azimuth
        self.intensity = intensity
        self.elevation = elevation

    def __eq__(self,other):
        if isinstance(other,Sun):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Sun

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)

            Returns
            -------
                sun (Sun): a Sun object

        &#34;&#34;&#34; 
        azimuth = element.attrib[&#39;azimuth&#39;]
        elevation = element.attrib[&#39;elevation&#39;]
        intensity = element.attrib[&#39;intensity&#39;]

        return Sun(intensity,azimuth,elevation)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;azimuth&#39;] = str(self.azimuth)
        retdict[&#39;intensity&#39;] = str(self.intensity)
        retdict[&#39;elevation&#39;] = str(self.elevation)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Sun

        &#34;&#34;&#34;
        element = ET.Element(&#39;Sun&#39;,attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Sun.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Sun</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>sun (Sun): a Sun object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Sun

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A sun element (same as generated by the class itself)

        Returns
        -------
            sun (Sun): a Sun object

    &#34;&#34;&#34; 
    azimuth = element.attrib[&#39;azimuth&#39;]
    elevation = element.attrib[&#39;elevation&#39;]
    intensity = element.attrib[&#39;intensity&#39;]

    return Sun(intensity,azimuth,elevation)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Sun.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Precipitation as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Precipitation as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;azimuth&#39;] = str(self.azimuth)
    retdict[&#39;intensity&#39;] = str(self.intensity)
    retdict[&#39;elevation&#39;] = str(self.elevation)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Sun.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Sun</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Sun

    &#34;&#34;&#34;
    element = ET.Element(&#39;Sun&#39;,attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState"><code class="flex name class">
<span>class <span class="ident">TargetDistanceSteadyState</span></span>
<span>(</span><span>distance)</span>
</code></dt>
<dd>
<div class="desc"><p>the TargetDistanceSteadyState describes a SteadyState of type TargetDistanceSteadyState
(Valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the TargetDistanceSteadyState</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>distance (float): distance to target for the steady state
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetDistanceSteadyState(VersionBase):
    &#34;&#34;&#34; the TargetDistanceSteadyState describes a SteadyState of type TargetDistanceSteadyState
        (Valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            distance (float): distance to target for the steady state

        Attributes
        ----------
            distance (float): distance to target for the steady state

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,distance):
        &#34;&#34;&#34; initalzie the TargetDistanceSteadyState

        Parameters
        ----------
            distance (float): distance to target for the steady state
        
        &#34;&#34;&#34;
        self.distance = distance

    def __eq__(self,other):
        if isinstance(other,TargetDistanceSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TargetDistanceSteadyState

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)

            Returns
            -------
                tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object
                
        &#34;&#34;&#34; 
        distance = element.attrib[&#39;distance&#39;]
        return TargetDistanceSteadyState(distance)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TargetDistanceSteadyState
        
        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return {&#39;distance&#39;:str(self.distance)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TargetDistanceSteadyState

        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return ET.Element(&#39;TargetDistanceSteadyState&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TargetDistanceSteadyState</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TargetDistanceSteadyState

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TargetDistanceSteadyState element (same as generated by the class itself)

        Returns
        -------
            tdss (TargetDistanceSteadyState): a TargetDistanceSteadyState object
            
    &#34;&#34;&#34; 
    distance = element.attrib[&#39;distance&#39;]
    return TargetDistanceSteadyState(distance)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TargetDistanceSteadyState</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TargetDistanceSteadyState
    
    &#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
    return {&#39;distance&#39;:str(self.distance)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TargetDistanceSteadyState</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TargetDistanceSteadyState

    &#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(&#39;TargetDistanceSteadyState was introduced in OpenSCENARIO V1.1&#39;)
    return ET.Element(&#39;TargetDistanceSteadyState&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState"><code class="flex name class">
<span>class <span class="ident">TargetTimeSteadyState</span></span>
<span>(</span><span>time_gap)</span>
</code></dt>
<dd>
<div class="desc"><p>the TargetTimeSteadyState describes a SteadyState of type TargetTimeSteadyState
(Valid from OpenSCENARIO V1.1)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class
</code></pre>
<p>initalzie the TargetTimeSteadyState</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>time_gap (float): time_gap to target for the steady state
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetTimeSteadyState(VersionBase):
    &#34;&#34;&#34; the TargetTimeSteadyState describes a SteadyState of type TargetTimeSteadyState
        (Valid from OpenSCENARIO V1.1)
        
        Parameters
        ----------
            time_gap (float): time_gap to target for the steady state

        Attributes
        ----------
            time_gap (float): time_gap to target for the steady state

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self,time_gap):
        &#34;&#34;&#34; initalzie the TargetTimeSteadyState

        Parameters
        ----------
            time_gap (float): time_gap to target for the steady state
        
        &#34;&#34;&#34;
        self.time_gap = time_gap

    def __eq__(self,other):
        if isinstance(other,TargetTimeSteadyState):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TargetTimeSteadyState

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)

            Returns
            -------
                ttss (TargetTimeSteadyState): a TargetTimeSteadyState object
                
        &#34;&#34;&#34;
        time = element.attrib[&#39;time&#39;]
        return TargetTimeSteadyState(time)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TargetTimeSteadyState
        
        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return {&#39;time&#39;:str(self.time_gap)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TargetTimeSteadyState

        &#34;&#34;&#34;
        if self.isVersion(1, 0):
            raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
        return ET.Element(&#39;TargetTimeSteadyState&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TargetTimeSteadyState</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>ttss (TargetTimeSteadyState): a TargetTimeSteadyState object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TargetTimeSteadyState

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TargetTimeSteadyState element (same as generated by the class itself)

        Returns
        -------
            ttss (TargetTimeSteadyState): a TargetTimeSteadyState object
            
    &#34;&#34;&#34;
    time = element.attrib[&#39;time&#39;]
    return TargetTimeSteadyState(time)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TargetTimeSteadyState</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TargetTimeSteadyState
    
    &#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
    return {&#39;time&#39;:str(self.time_gap)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TargetTimeSteadyState</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TargetTimeSteadyState

    &#34;&#34;&#34;
    if self.isVersion(1, 0):
        raise OpenSCENARIOVersionError(&#39;TargetTimeSteadyState was introduced in OpenSCENARIO V1.1&#39;)
    return ET.Element(&#39;TargetTimeSteadyState&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeOfDay"><code class="flex name class">
<span>class <span class="ident">TimeOfDay</span></span>
<span>(</span><span>animation, year, month, day, hour, minute, second)</span>
</code></dt>
<dd>
<div class="desc"><p>TimeOfDay creates an TimeOfDay element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeOfDay</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>animation (bool): if animation should be used

year (int): year

month (int): month

day (int): day

hour (int): hour

minute (int): minute

second (int): second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeOfDay(VersionBase):
    &#34;&#34;&#34; TimeOfDay creates an TimeOfDay element of openscenario
        
        Parameters
        ----------
            animation (bool): if animation should be used

            year (int): year

            month (int): month

            day (int): day

            hour (int): hour

            minute (int): minute

            second (int): second

        Attributes
        ----------
            animation (bool): if animation should be used

            year (int): year

            month (int): month

            day (int): day

            hour (int): hour

            minute (int): minute

            second (int): second

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,animation,year,month,day,hour,minute,second):
        &#34;&#34;&#34; initalize the TimeOfDay

            Parameters
            ----------
                animation (bool): if animation should be used

                year (int): year

                month (int): month

                day (int): day

                hour (int): hour

                minute (int): minute

                second (int): second   
                
        &#34;&#34;&#34;
        self.animation = animation
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def __eq__(self,other):
        if isinstance(other,TimeOfDay):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TimeOfDay

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)

            Returns
            -------
                timeofday (TimeOfDay): a TimeOfDay object
        &#34;&#34;&#34;
        animation = element.attrib[&#39;animation&#39;]        
        var = element.attrib[&#39;dateTime&#39;]
        year = convert_int(var[0:4])
        month = convert_int(var[5:7])
        day = convert_int(var[8:10])

        hour = convert_int(var[11:13])
        minute = convert_int(var[14:16])
        second = convert_int(var[17:19])
 
        return TimeOfDay(animation,year,month,day,hour,minute,second) 

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TimeOfDay as a dict

        &#34;&#34;&#34;
        dt = str(self.year) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.month) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.day) + &#39;T&#39; + &#39;{:0&gt;2}&#39;.format(self.hour) + &#39;:&#39; + &#39;{:0&gt;2}&#39;.format(self.minute) + &#39;:&#39; +&#39;{:0&gt;2}&#39;.format(self.second)
        return {&#39;animation&#39;:str(self.animation),&#39;dateTime&#39;:dt}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TimeOfDay

        &#34;&#34;&#34;
        return ET.Element(&#39;TimeOfDay&#39;,attrib=self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TimeOfDay</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>timeofday (TimeOfDay): a TimeOfDay object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TimeOfDay

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A time of day element (same as generated by the class itself)

        Returns
        -------
            timeofday (TimeOfDay): a TimeOfDay object
    &#34;&#34;&#34;
    animation = element.attrib[&#39;animation&#39;]        
    var = element.attrib[&#39;dateTime&#39;]
    year = convert_int(var[0:4])
    month = convert_int(var[5:7])
    day = convert_int(var[8:10])

    hour = convert_int(var[11:13])
    minute = convert_int(var[14:16])
    second = convert_int(var[17:19])

    return TimeOfDay(animation,year,month,day,hour,minute,second) </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TimeOfDay as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TimeOfDay as a dict

    &#34;&#34;&#34;
    dt = str(self.year) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.month) + &#39;-&#39; + &#39;{:0&gt;2}&#39;.format(self.day) + &#39;T&#39; + &#39;{:0&gt;2}&#39;.format(self.hour) + &#39;:&#39; + &#39;{:0&gt;2}&#39;.format(self.minute) + &#39;:&#39; +&#39;{:0&gt;2}&#39;.format(self.second)
    return {&#39;animation&#39;:str(self.animation),&#39;dateTime&#39;:dt}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeOfDay.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TimeOfDay</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TimeOfDay

    &#34;&#34;&#34;
    return ET.Element(&#39;TimeOfDay&#39;,attrib=self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeReference"><code class="flex name class">
<span>class <span class="ident">TimeReference</span></span>
<span>(</span><span>reference_domain=None, scale=None, offset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the TimeReference class creates a TimeReference, </p>
<h2 id="parameters">Parameters</h2>
<pre><code>referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
    Default: None

scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
    Default: None

offset (float): offset for time values (must be combined with referece_domain and scale)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>referece_domain (ReferenceContext): absolute or relative time reference

scale (float): scalefactor of the timeings

offset (float): offset for time values
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the TimeReference</p>
<h2 id="parameters_1">Parameters</h2>
<p>referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
Default: None</p>
<p>scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
Default: None</p>
<p>offset (float): offset for time values (must be combined with referece_domain and scale)
Default: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeReference(VersionBase):
    &#34;&#34;&#34; the TimeReference class creates a TimeReference, 
        
        Parameters
        ----------
            referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
                Default: None

            scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
                Default: None

            offset (float): offset for time values (must be combined with referece_domain and scale)
                Default: None

        Attributes
        ----------
            referece_domain (ReferenceContext): absolute or relative time reference 

            scale (float): scalefactor of the timeings 

            offset (float): offset for time values 

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class
    &#34;&#34;&#34;

    def __init__(self, reference_domain=None,scale=None,offset=None):
        &#34;&#34;&#34; initalize the TimeReference

            Parameters
            ----------
            referece_domain (ReferenceContext): absolute or relative time reference (must be combined with scale and offset)
                Default: None

            scale (float): scalefactor of the timeings (must be combined with referece_domain and offset)
                Default: None

            offset (float): offset for time values (must be combined with referece_domain and scale)
                Default: None

        &#34;&#34;&#34;
        nones = [reference_domain == None, scale == None, offset == None]
        if sum(nones) == 3:
            self._only_nones = True
        elif sum(nones) == 0:
            self._only_nones = False
        else:
            raise ValueError(&#39;missing inputs for time reference&#39;)
        if reference_domain is not None and not hasattr(ReferenceContext,str(reference_domain)):
            raise TypeError(&#39;input reference_domain is not of type ReferenceContext&#39;)

        self.reference_domain = reference_domain
        self.scale = convert_float(scale)
        self.offset = convert_float(offset)

    def __eq__(self,other):
        if isinstance(other,TimeReference):
            if not self._only_nones and not other._only_nones:
                if self.get_attributes() == other.get_attributes():
                    return True
            elif (self._only_nones == other._only_nones):
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TimeReference

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)

            Returns
            -------
                timing (TimeReference): a TimeReference object
                
        &#34;&#34;&#34;
        if element.find(&#39;None&#39;) != None:
            return TimeReference()

        timing_element = element.find(&#39;Timing&#39;) 
        scale = None
        offset = None
        reference_domain = None

        if &#39;offset&#39; in timing_element.attrib:
            offset = timing_element.attrib[&#39;offset&#39;]
        if &#39;scale&#39; in timing_element.attrib:
            scale = timing_element.attrib[&#39;scale&#39;]
        if &#39;domainAbsoluteRelative&#39; in timing_element.attrib:
            reference_domain = getattr(ReferenceContext, timing_element.attrib[&#39;domainAbsoluteRelative&#39;])
        
        return TimeReference(reference_domain, scale, offset)



    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TimeReference as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;domainAbsoluteRelative&#39;] = self.reference_domain.get_name()
        retdict[&#39;scale&#39;] = str(self.scale)
        retdict[&#39;offset&#39;] = str(self.offset)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TimeReference

        &#34;&#34;&#34;

        element = ET.Element(&#39;TimeReference&#39;)
        if self._only_nones:
            ET.SubElement(element,&#39;None&#39;)
        else:
            ET.SubElement(element,&#39;Timing&#39;,self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeReference.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TimeReference</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>timing (TimeReference): a TimeReference object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TimeReference

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A time reference element (same as generated by the class itself)

        Returns
        -------
            timing (TimeReference): a TimeReference object
            
    &#34;&#34;&#34;
    if element.find(&#39;None&#39;) != None:
        return TimeReference()

    timing_element = element.find(&#39;Timing&#39;) 
    scale = None
    offset = None
    reference_domain = None

    if &#39;offset&#39; in timing_element.attrib:
        offset = timing_element.attrib[&#39;offset&#39;]
    if &#39;scale&#39; in timing_element.attrib:
        scale = timing_element.attrib[&#39;scale&#39;]
    if &#39;domainAbsoluteRelative&#39; in timing_element.attrib:
        reference_domain = getattr(ReferenceContext, timing_element.attrib[&#39;domainAbsoluteRelative&#39;])
    
    return TimeReference(reference_domain, scale, offset)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TimeReference.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TimeReference as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TimeReference as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;domainAbsoluteRelative&#39;] = self.reference_domain.get_name()
    retdict[&#39;scale&#39;] = str(self.scale)
    retdict[&#39;offset&#39;] = str(self.offset)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TimeReference.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TimeReference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TimeReference

    &#34;&#34;&#34;

    element = ET.Element(&#39;TimeReference&#39;)
    if self._only_nones:
        ET.SubElement(element,&#39;None&#39;)
    else:
        ET.SubElement(element,&#39;Timing&#39;,self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition"><code class="flex name class">
<span>class <span class="ident">TrafficDefinition</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>the TrafficDefinition class creates a TrafficDefinition used by the different TrafficActions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): name of the traffic definition
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): name of the traffic definition

vehicleweights (list of floats): The weights of the vehicle categories (VehicleCategoryDistribution-weight)

vehiclecategories (list of VehicleCategory): the vehicle category ((VehicleCategoryDistribution-category))

controllerweights (list of floats): The weights of the controllers

controllers (list of Controller/CatalogReference): The controllers for the traffic
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_vehicle(vehiclecategory,weight)
    Adds a vehicle to the traffic definition

add_controller(controller,weight)
    Adds a controller to the traffic definition
</code></pre>
<p>initalize the TrafficDefinition </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): name of the traffic definition
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficDefinition(VersionBase):
    &#34;&#34;&#34; the TrafficDefinition class creates a TrafficDefinition used by the different TrafficActions
        
        Parameters
        ----------
            name (str): name of the traffic definition
       

        Attributes
        ----------
            name (str): name of the traffic definition

            vehicleweights (list of floats): The weights of the vehicle categories (VehicleCategoryDistribution-weight)

            vehiclecategories (list of VehicleCategory): the vehicle category ((VehicleCategoryDistribution-category))

            controllerweights (list of floats): The weights of the controllers

            controllers (list of Controller/CatalogReference): The controllers for the traffic


        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_vehicle(vehiclecategory,weight)
                Adds a vehicle to the traffic definition

            add_controller(controller,weight)
                Adds a controller to the traffic definition
                
    &#34;&#34;&#34;

    def __init__(self, name):
        &#34;&#34;&#34; initalize the TrafficDefinition 
        
        Parameters
        ----------
            name (str): name of the traffic definition

        &#34;&#34;&#34;

        self.name = name
        self.vehicleweights = []
        self.vehiclecategories = []
        self.controllerweights = []
        self.controllers = []


    def __eq__(self,other):
        if isinstance(other,TrafficDefinition):
            if self.get_attributes() == other.get_attributes() and \
            self.vehicleweights == other.vehicleweights and \
            self.vehiclecategories == other.vehiclecategories and \
            self.controllerweights == other.controllerweights and \
            self.controllers == other.controllers:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TrafficDefinition

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)

            Returns
            -------
                td (TrafficDefinition): a TrafficDefinition object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        td = TrafficDefinition(name)

        vehicle_distributions = element.find(&#39;VehicleCategoryDistribution&#39;)
        vehicle_entries = vehicle_distributions.findall(&#39;VehicleCategoryDistributionEntry&#39;)
        for entry in vehicle_entries:
            weight = convert_float(entry.attrib[&#39;weight&#39;])
            category = getattr(VehicleCategory, entry.attrib[&#39;category&#39;])
            td.add_vehicle(category,weight)
        
        controller_distributions = element.find(&#39;ControllerDistribution&#39;)
        controller_entries = controller_distributions.findall(&#39;ControllerDistributionEntry&#39;)
        for controller_dist in controller_entries:
            weight = convert_float(controller_dist.attrib[&#39;weight&#39;])
            if controller_dist.find(&#39;Controller&#39;):
                controller = Controller.parse(controller_dist.find(&#39;Controller&#39;))
                td.add_controller(controller, weight)
            else:
                catalog_reference = CatalogReference.parse(controller_dist.find(&#39;CatalogReference&#39;))
                td.add_controller(catalog_reference,weight)

        return td        

    def add_vehicle(self,vehiclecategory,weight):
        &#34;&#34;&#34; Adds a vehicle to the traffic distribution

            Parameters
            ----------
                vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

                weight (float): the corresponding weight for the distribution of the vehicle category

        &#34;&#34;&#34;
        if not hasattr(VehicleCategory,str(vehiclecategory)):
            raise TypeError(&#39;vehcilecategory input is not of type VehcileCategory&#39;)
        self.vehiclecategories.append(vehiclecategory)
        self.vehicleweights.append(weight)

    def add_controller(self,controller,weight):
        &#34;&#34;&#34; Adds a controller to the traffic distribution

            Parameters
            ----------
                controller (Controller or CatalogReference): a controller or catalog reference to a controller

                weight (float): the corresponding weight for the controller

        &#34;&#34;&#34;
        if not ( isinstance(controller,Controller) or isinstance(controller,CatalogReference)):
            raise TypeError(&#39;controller input not of type Controller or CatalogReference&#39;)
        self.controllers.append(controller)
        self.controllerweights.append(weight)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficDefinition
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficDefinition

        &#34;&#34;&#34;
        if not self.controllers:
            ValueError(&#39;No controllers defined for the TrafficDefinition&#39;)
        if not self.vehiclecategories:
            ValueError(&#39;No Vehicles defined for the TrafficDefinition&#39;)

        element = ET.Element(&#39;TrafficDefinition&#39;,attrib=self.get_attributes())

        veh_element = ET.SubElement(element,&#39;VehicleCategoryDistribution&#39;)
        for i in range(len(self.vehiclecategories)):
            ET.SubElement(veh_element,&#39;VehicleCategoryDistributionEntry&#39;,attrib={&#39;category&#39;: self.vehiclecategories[i].get_name(),&#39;weight&#39;: str(self.vehicleweights[i])})

        cnt_element = ET.SubElement(element,&#39;ControllerDistribution&#39;)
        for i in range(len(self.controllers)):
            tmp_controller = ET.SubElement(cnt_element,&#39;ControllerDistributionEntry&#39;,attrib={&#39;weight&#39;:str(self.controllerweights[i])})
            tmp_controller.append(self.controllers[i].get_element())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficDefinition</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>td (TrafficDefinition): a TrafficDefinition object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TrafficDefinition

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A traffic definition element (same as generated by the class itself)

        Returns
        -------
            td (TrafficDefinition): a TrafficDefinition object
            
    &#34;&#34;&#34;
    name = element.attrib[&#39;name&#39;]
    td = TrafficDefinition(name)

    vehicle_distributions = element.find(&#39;VehicleCategoryDistribution&#39;)
    vehicle_entries = vehicle_distributions.findall(&#39;VehicleCategoryDistributionEntry&#39;)
    for entry in vehicle_entries:
        weight = convert_float(entry.attrib[&#39;weight&#39;])
        category = getattr(VehicleCategory, entry.attrib[&#39;category&#39;])
        td.add_vehicle(category,weight)
    
    controller_distributions = element.find(&#39;ControllerDistribution&#39;)
    controller_entries = controller_distributions.findall(&#39;ControllerDistributionEntry&#39;)
    for controller_dist in controller_entries:
        weight = convert_float(controller_dist.attrib[&#39;weight&#39;])
        if controller_dist.find(&#39;Controller&#39;):
            controller = Controller.parse(controller_dist.find(&#39;Controller&#39;))
            td.add_controller(controller, weight)
        else:
            catalog_reference = CatalogReference.parse(controller_dist.find(&#39;CatalogReference&#39;))
            td.add_controller(catalog_reference,weight)

    return td        </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.add_controller"><code class="name flex">
<span>def <span class="ident">add_controller</span></span>(<span>self, controller, weight)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a controller to the traffic distribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>controller (Controller or CatalogReference): a controller or catalog reference to a controller

weight (float): the corresponding weight for the controller
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_controller(self,controller,weight):
    &#34;&#34;&#34; Adds a controller to the traffic distribution

        Parameters
        ----------
            controller (Controller or CatalogReference): a controller or catalog reference to a controller

            weight (float): the corresponding weight for the controller

    &#34;&#34;&#34;
    if not ( isinstance(controller,Controller) or isinstance(controller,CatalogReference)):
        raise TypeError(&#39;controller input not of type Controller or CatalogReference&#39;)
    self.controllers.append(controller)
    self.controllerweights.append(weight)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle"><code class="name flex">
<span>def <span class="ident">add_vehicle</span></span>(<span>self, vehiclecategory, weight)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a vehicle to the traffic distribution</p>
<h2 id="parameters">Parameters</h2>
<pre><code>vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

weight (float): the corresponding weight for the distribution of the vehicle category
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vehicle(self,vehiclecategory,weight):
    &#34;&#34;&#34; Adds a vehicle to the traffic distribution

        Parameters
        ----------
            vehiclecategory (VehicleCategory): vehicle category of the entity in the traffic

            weight (float): the corresponding weight for the distribution of the vehicle category

    &#34;&#34;&#34;
    if not hasattr(VehicleCategory,str(vehiclecategory)):
        raise TypeError(&#39;vehcilecategory input is not of type VehcileCategory&#39;)
    self.vehiclecategories.append(vehiclecategory)
    self.vehicleweights.append(weight)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficDefinition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficDefinition
    
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;name&#39;] = self.name
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficDefinition.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficDefinition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficDefinition

    &#34;&#34;&#34;
    if not self.controllers:
        ValueError(&#39;No controllers defined for the TrafficDefinition&#39;)
    if not self.vehiclecategories:
        ValueError(&#39;No Vehicles defined for the TrafficDefinition&#39;)

    element = ET.Element(&#39;TrafficDefinition&#39;,attrib=self.get_attributes())

    veh_element = ET.SubElement(element,&#39;VehicleCategoryDistribution&#39;)
    for i in range(len(self.vehiclecategories)):
        ET.SubElement(veh_element,&#39;VehicleCategoryDistributionEntry&#39;,attrib={&#39;category&#39;: self.vehiclecategories[i].get_name(),&#39;weight&#39;: str(self.vehicleweights[i])})

    cnt_element = ET.SubElement(element,&#39;ControllerDistribution&#39;)
    for i in range(len(self.controllers)):
        tmp_controller = ET.SubElement(cnt_element,&#39;ControllerDistributionEntry&#39;,attrib={&#39;weight&#39;:str(self.controllerweights[i])})
        tmp_controller.append(self.controllers[i].get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController"><code class="flex name class">
<span>class <span class="ident">TrafficSignalController</span></span>
<span>(</span><span>name, delay=None, reference=None)</span>
</code></dt>
<dd>
<div class="desc"><p>the TrafficSignalController class creates a polyline of (minimum 2) positions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None

reference (string): id to the controller in the roadnetwork
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None
reference (string): id to the controller in the roadnetwork
    Default: None
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class

add_phase(Phase)
    add a phase to the trafficsitnal controller
</code></pre>
<p>initalize the TrafficSignalController </p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>name (str): if of the trafic signal

delay (float): delay of the phase shift
    Default: None

reference (string): id to the controller in the RoadNetwork
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrafficSignalController(VersionBase):
    &#34;&#34;&#34; the TrafficSignalController class creates a polyline of (minimum 2) positions
        
        Parameters
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None

            reference (string): id to the controller in the roadnetwork
                Default: None

        Attributes
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None
            reference (string): id to the controller in the roadnetwork
                Default: None

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

            add_phase(Phase)
                add a phase to the trafficsitnal controller
    &#34;&#34;&#34;

    def __init__(self, name, delay = None,reference = None):
        &#34;&#34;&#34; initalize the TrafficSignalController 
        
        Parameters
        ----------
            name (str): if of the trafic signal

            delay (float): delay of the phase shift
                Default: None

            reference (string): id to the controller in the RoadNetwork
                Default: None

        &#34;&#34;&#34;

        self.name = name
        self.delay = delay
        self.reference = reference
        self.phases = []

    def __eq__(self,other):
        if isinstance(other,TrafficSignalController):
            if self.get_attributes() == other.get_attributes() and self.phases == other.phases:
                return True
        return False

    @staticmethod
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TrafficSignalController

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)

            Returns
            -------
                tsc (TrafficSignalController): a TrafficSignalController object
                
        &#34;&#34;&#34;
        name = element.attrib[&#39;name&#39;]
        
        delay = None
        if &#39;delay&#39; in element.attrib:
            delay = element.attrib[&#39;delay&#39;]
        
        reference  = None
        if &#39;reference&#39; in element.attrib:
            reference = element.attrib[&#39;reference&#39;]
        
        tsc = TrafficSignalController(name,delay,reference)
        
        phases = element.findall(&#39;Phase&#39;)
        if phases != None:
            for phase in phases:
              tsc.phases.append(Phase.parse(phase))  

        return tsc

    def add_phase(self,phase):
        &#34;&#34;&#34; Adds a phase of the traffic signal

            Parameters
            ----------
                phase (Phase): a phase of the trafficsignal

        &#34;&#34;&#34;
        if not isinstance(phase,Phase):
            raise TypeError(&#39;phase input is not of type Phase&#39;)
        self.phases.append(phase)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TrafficSignalController
        
        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;name&#39;] = self.name
        if self.delay is not None:
            retdict[&#39;delay&#39;] = str(self.delay)
        if self.reference:
            retdict[&#39;reference&#39;] = self.reference
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the TrafficSignalController

        &#34;&#34;&#34;
        element = ET.Element(&#39;TrafficSignalController&#39;,attrib=self.get_attributes())
        for ph in self.phases:
            element.append(ph.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TrafficSignalController</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>tsc (TrafficSignalController): a TrafficSignalController object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TrafficSignalController

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A traffice signal controller element (same as generated by the class itself)

        Returns
        -------
            tsc (TrafficSignalController): a TrafficSignalController object
            
    &#34;&#34;&#34;
    name = element.attrib[&#39;name&#39;]
    
    delay = None
    if &#39;delay&#39; in element.attrib:
        delay = element.attrib[&#39;delay&#39;]
    
    reference  = None
    if &#39;reference&#39; in element.attrib:
        reference = element.attrib[&#39;reference&#39;]
    
    tsc = TrafficSignalController(name,delay,reference)
    
    phases = element.findall(&#39;Phase&#39;)
    if phases != None:
        for phase in phases:
          tsc.phases.append(Phase.parse(phase))  

    return tsc</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.add_phase"><code class="name flex">
<span>def <span class="ident">add_phase</span></span>(<span>self, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a phase of the traffic signal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>phase (Phase): a phase of the trafficsignal
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_phase(self,phase):
    &#34;&#34;&#34; Adds a phase of the traffic signal

        Parameters
        ----------
            phase (Phase): a phase of the trafficsignal

    &#34;&#34;&#34;
    if not isinstance(phase,Phase):
        raise TypeError(&#39;phase input is not of type Phase&#39;)
    self.phases.append(phase)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TrafficSignalController</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TrafficSignalController
    
    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;name&#39;] = self.name
    if self.delay is not None:
        retdict[&#39;delay&#39;] = str(self.delay)
    if self.reference:
        retdict[&#39;reference&#39;] = self.reference
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TrafficSignalController.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TrafficSignalController</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the TrafficSignalController

    &#34;&#34;&#34;
    element = ET.Element(&#39;TrafficSignalController&#39;,attrib=self.get_attributes())
    for ph in self.phases:
        element.append(ph.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics"><code class="flex name class">
<span>class <span class="ident">TransitionDynamics</span></span>
<span>(</span><span>shape, dimension, value:float)</span>
</code></dt>
<dd>
<div class="desc"><p>TransitionDynamics is used to define how the dynamics of a change</p>
<h2 id="parameters">Parameters</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<h2 id="parameters_1">Parameters</h2>
<pre><code>shape (DynamicsShapes): shape of the transition

dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

value (float): the value of the dynamics (time rate or distance)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransitionDynamics(VersionBase):
    &#34;&#34;&#34; TransitionDynamics is used to define how the dynamics of a change
        
        Parameters
        ----------
            shape (DynamicsShapes): shape of the transition

            dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

            value (float): the value of the dynamics (time rate or distance)


        Attributes
        ----------
            shape (DynamicsShapes): shape of the transition

            dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

            value (float): the value of the dynamics (time rate or distance)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,shape,dimension,value:float):
        &#34;&#34;&#34;
            Parameters
            ----------
                shape (DynamicsShapes): shape of the transition

                dimension (DynamicsDimension): the dimension of the transition (rate, time or distance)

                value (float): the value of the dynamics (time rate or distance)

        &#34;&#34;&#34;
        if not hasattr(DynamicsShapes,str(shape)):
            raise TypeError(shape + &#39;; is not a valid shape.&#39;)

        self.shape = shape
        if not hasattr(DynamicsDimension,str(dimension)):
            raise ValueError(dimension + &#39; is not a valid dynamics dimension&#39;)
        self.dimension = dimension
        self.value = convert_float(value)

    def __eq__(self,other):
        if isinstance(other,TransitionDynamics):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of TransitionDynamics

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)

            Returns
            -------
                transitiondynamics (TransitionDynamics): a TransitionDynamics object

        &#34;&#34;&#34;
        shape = getattr(DynamicsShapes,element.attrib[&#39;dynamicsShape&#39;])
        dimension = getattr(DynamicsDimension,element.attrib[&#39;dynamicsDimension&#39;])
        value = convert_float(element.attrib[&#39;value&#39;])

        return TransitionDynamics(shape,dimension,value)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the TransitionDynamics as a dict

        &#34;&#34;&#34;
        return {&#39;dynamicsShape&#39;:self.shape.get_name(),&#39;value&#39;:str(self.value),&#39;dynamicsDimension&#39;:self.dimension.get_name()}

    def get_element(self,name=&#39;TransitionDynamics&#39;):
        &#34;&#34;&#34; returns the elementTree of the TransitionDynamics

        &#34;&#34;&#34;
        return ET.Element(name,self.get_attributes())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of TransitionDynamics</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>transitiondynamics (TransitionDynamics): a TransitionDynamics object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of TransitionDynamics

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A TransitionDynamics element (same as generated by the class itself)

        Returns
        -------
            transitiondynamics (TransitionDynamics): a TransitionDynamics object

    &#34;&#34;&#34;
    shape = getattr(DynamicsShapes,element.attrib[&#39;dynamicsShape&#39;])
    dimension = getattr(DynamicsDimension,element.attrib[&#39;dynamicsDimension&#39;])
    value = convert_float(element.attrib[&#39;value&#39;])

    return TransitionDynamics(shape,dimension,value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the TransitionDynamics as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the TransitionDynamics as a dict

    &#34;&#34;&#34;
    return {&#39;dynamicsShape&#39;:self.shape.get_name(),&#39;value&#39;:str(self.value),&#39;dynamicsDimension&#39;:self.dimension.get_name()}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.TransitionDynamics.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, name='TransitionDynamics')</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the TransitionDynamics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self,name=&#39;TransitionDynamics&#39;):
    &#34;&#34;&#34; returns the elementTree of the TransitionDynamics

    &#34;&#34;&#34;
    return ET.Element(name,self.get_attributes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraint"><code class="flex name class">
<span>class <span class="ident">ValueConstraint</span></span>
<span>(</span><span>rule, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the the ValueConstraint file for open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalzie the ValueConstraint Class</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>rule (Rule): available operators for the validation of the constraint. Note that either "equalTo" or "notEqualTo" must be used in the parameter declaration of type "string"

value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueConstraint(VersionBase):
    &#34;&#34;&#34; Creates the the ValueConstraint file for open scenario
        
        Parameters
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.

        Attributes
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.


        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    # TODO: Only equalTo and notEqualTo test
    def __init__(self, rule, value):
        &#34;&#34;&#34; initalzie the ValueConstraint Class

        Parameters
        ----------
            rule (Rule): available operators for the validation of the constraint. Note that either &#34;equalTo&#34; or &#34;notEqualTo&#34; must be used in the parameter declaration of type &#34;string&#34; 

            value (string): a constant value, parameter or parameter expression. The value must match the enclosing parameter declaration.
        &#34;&#34;&#34;
        self.value = value
        if not hasattr(Rule,str(rule)):
            raise TypeError(str(rule) + &#39; is not a valid ValueConstraint type&#39;)    
        self.rule = rule

    def __eq__(self,other):
        if isinstance(other,ValueConstraint):
            if self.get_attributes() == other.get_attributes():
               return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ValueConstraint

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

            Returns
            -------
                constraint (ValueConstraint): ValueConstraint object
                
        &#34;&#34;&#34;
        value = element.attrib[&#39;value&#39;]
        rule = getattr(Rule, element.attrib[&#39;rule&#39;])
        return ValueConstraint(rule, value)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the ValueConstraint as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;rule&#39;] = self.rule.get_name()
        retdict[&#39;value&#39;] = str(self.value)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ValueConstraint

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;ValueConstraint was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;ValueConstraint&#39; ,attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ValueConstraint</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>constraint (ValueConstraint): ValueConstraint object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of ValueConstraint

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A value constraint element (same as generated by the class itself)

        Returns
        -------
            constraint (ValueConstraint): ValueConstraint object
            
    &#34;&#34;&#34;
    value = element.attrib[&#39;value&#39;]
    rule = getattr(Rule, element.attrib[&#39;rule&#39;])
    return ValueConstraint(rule, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the ValueConstraint as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the ValueConstraint as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;rule&#39;] = self.rule.get_name()
    retdict[&#39;value&#39;] = str(self.value)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraint.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ValueConstraint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ValueConstraint

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;ValueConstraint was introduced in OpenSCENARIO V1.1&#39;)
    element = ET.Element(&#39;ValueConstraint&#39; ,attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup"><code class="flex name class">
<span>class <span class="ident">ValueConstraintGroup</span></span>
</code></dt>
<dd>
<div class="desc"><p>Creates the the ValueConstraintGroup file for open scenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>value_constraint (ValueConstraint): logical constraint, needed to evaluate to true for a defined parameter to start the simulation.
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>add_value_constraint(value_constraint)
    adds value constraint to the value constraint group

parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element(elementname)
    Returns the full ElementTree of the class
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueConstraintGroup(VersionBase):
    &#34;&#34;&#34; Creates the the ValueConstraintGroup file for open scenario
        
        Parameters
        ----------
            None

        Attributes
        ----------
            value_constraint (ValueConstraint): logical constraint, needed to evaluate to true for a defined parameter to start the simulation.


        Methods
        -------
            add_value_constraint(value_constraint)
                adds value constraint to the value constraint group

            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element(elementname)
                Returns the full ElementTree of the class

    &#34;&#34;&#34;
    def __init__(self):
        self.value_constraints = []

    def __eq__(self,other):
        if isinstance(other,ValueConstraintGroup):
            if  self.value_constraints == other.value_constraints:
               return True
        return False

    def add_value_constraint(self,value_constraint):
        &#34;&#34;&#34; adds a value constraint to the value constraint group

        Parameters
        ----------
            value_constraint (ValueConstraint): the value constraint to be added 

        &#34;&#34;&#34;
        if not isinstance(value_constraint,ValueConstraint):
            raise TypeError(&#39;value_conatraint input is not of type ValueConstraint&#39;)
        self.value_constraints.append(value_constraint)
    
    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of ValueConstraintGroup

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)

            Returns
            -------
                group (ValueConstraintGroup): a ValueConstraintGroup object
                
        &#34;&#34;&#34;
        value_constraints = ValueConstraintGroup()
        constraints = element.findall(&#39;ValueConstraint&#39;)
        for constraint in constraints:
            value_constraint = ValueConstraint.parse(constraint)
            value_constraints.add_value_constraint(value_constraint)
        return value_constraints
        
    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the ValueConstraintGroup

        &#34;&#34;&#34;
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;ValueConstraintGroup was introduced in OpenSCENARIO V1.1&#39;)
        element = ET.Element(&#39;ValueConstraintGroup&#39;)
        if not self.value_constraints:
            raise ValueError(&#39;No Value Constraints in the Value Contraint Group&#39;)
        for value_constraint in self.value_constraints:
            element.append(value_constraint.get_element())
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of ValueConstraintGroup</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>group (ValueConstraintGroup): a ValueConstraintGroup object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of ValueConstraintGroup

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ValueConstraintGroup element (same as generated by the class itself)

        Returns
        -------
            group (ValueConstraintGroup): a ValueConstraintGroup object
            
    &#34;&#34;&#34;
    value_constraints = ValueConstraintGroup()
    constraints = element.findall(&#39;ValueConstraint&#39;)
    for constraint in constraints:
        value_constraint = ValueConstraint.parse(constraint)
        value_constraints.add_value_constraint(value_constraint)
    return value_constraints</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint"><code class="name flex">
<span>def <span class="ident">add_value_constraint</span></span>(<span>self, value_constraint)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a value constraint to the value constraint group</p>
<h2 id="parameters">Parameters</h2>
<pre><code>value_constraint (ValueConstraint): the value constraint to be added
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_value_constraint(self,value_constraint):
    &#34;&#34;&#34; adds a value constraint to the value constraint group

    Parameters
    ----------
        value_constraint (ValueConstraint): the value constraint to be added 

    &#34;&#34;&#34;
    if not isinstance(value_constraint,ValueConstraint):
        raise TypeError(&#39;value_conatraint input is not of type ValueConstraint&#39;)
    self.value_constraints.append(value_constraint)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.ValueConstraintGroup.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the ValueConstraintGroup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the ValueConstraintGroup

    &#34;&#34;&#34;
    if self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;ValueConstraintGroup was introduced in OpenSCENARIO V1.1&#39;)
    element = ET.Element(&#39;ValueConstraintGroup&#39;)
    if not self.value_constraints:
        raise ValueError(&#39;No Value Constraints in the Value Contraint Group&#39;)
    for value_constraint in self.value_constraints:
        element.append(value_constraint.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Weather"><code class="flex name class">
<span>class <span class="ident">Weather</span></span>
<span>(</span><span>cloudstate=None, atmosphericPressure=None, temperature=None, sun=None, fog=None, precipitation=None, wind=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Weather creates an Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>cloudstate (CloudState): cloudstate of the weather
    Default: None

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
    Default: None

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
    Default: None

sun (Sun): the sun position
    Default: None

fog (Fog): fot state
    Default: None

precipitation (Precipitation): the precipitation state
    Default: None

wind (Wind): the wind (valid from OpenSCENARIO V1.1)
    Default: None
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>cloudstate (CloudState): cloudstate of the weather

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)

sun (Sun): the sun position

fog (Fog): fot state

precipitation (Precipitation): the precipitation state

wind (Wind): the wind (valid from OpenSCENARIO V1.1)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Weather</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>cloudstate (CloudState): cloudstate of the weather
    Default: None

atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
    Default: None

temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
    Default: None

sun (Sun): the sun position
    Default: None

fog (Fog): fot state
    Default: None

precipitation (Precipitation): the precipitation state
    Default: None

wind (Wind): the wind (valid from OpenSCENARIO V1.1)
    Default: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Weather(VersionBase):
    &#34;&#34;&#34; Weather creates an Weather element of openscenario
        
        Parameters
        ----------
            cloudstate (CloudState): cloudstate of the weather
                Default: None

            atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
                Default: None

            temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
                Default: None

            sun (Sun): the sun position
                Default: None

            fog (Fog): fot state
                Default: None

            precipitation (Precipitation): the precipitation state
                Default: None

            wind (Wind): the wind (valid from OpenSCENARIO V1.1)
                Default: None

        Attributes
        ----------
            cloudstate (CloudState): cloudstate of the weather

            atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)

            temperature (float): outside temperature (valid from OpenSCENARIO V1.1)

            sun (Sun): the sun position

            fog (Fog): fot state

            precipitation (Precipitation): the precipitation state

            wind (Wind): the wind (valid from OpenSCENARIO V1.1)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,cloudstate=None,atmosphericPressure=None,temperature=None,sun=None,fog=None,precipitation=None,wind=None):
        &#34;&#34;&#34; initalize the Weather

            Parameters
            ----------
                cloudstate (CloudState): cloudstate of the weather
                    Default: None

                atmosphericPressure (float): atmospheric pressure in Pa (valid from OpenSCENARIO V1.1)
                    Default: None

                temperature (float): outside temperature (valid from OpenSCENARIO V1.1)
                    Default: None

                sun (Sun): the sun position
                    Default: None

                fog (Fog): fot state
                    Default: None

                precipitation (Precipitation): the precipitation state
                    Default: None

                wind (Wind): the wind (valid from OpenSCENARIO V1.1)
                    Default: None
                
        &#34;&#34;&#34;
        if cloudstate and not hasattr(CloudState,str(cloudstate)):
            raise TypeError(&#39;cloudstate input is not of type CloudState&#39;)
        if precipitation and not isinstance(precipitation,Precipitation):
            raise TypeError(&#39;precipitation input is not of type Precipitation&#39;)
        if fog and not isinstance(fog,Fog):
            raise TypeError(&#39;fog input is not of type Fog&#39;)
        if wind and not isinstance(wind,Wind):
            raise TypeError(&#39;wind input is not of type Wind&#39;)
        if sun and not isinstance(sun,Sun):
            raise TypeError(&#39;sun input is not of type Sun&#39;)

        self.cloudstate = cloudstate
        self.atmosphericPressure = atmosphericPressure
        self.temperature = temperature
        self.fog = fog
        self.sun = sun
        self.wind = wind
        self.precipitation = precipitation


    def __eq__(self,other):
        if isinstance(other,Weather):
            if self.get_attributes() == other.get_attributes() and \
            self.fog == other.fog and \
            self.wind == other.wind and \
            self.sun == other.sun and \
            self.precipitation == other.precipitation:
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Weather

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)

            Returns
            -------
                weather (Weather): a Weather object

        &#34;&#34;&#34;
        temperature = None
        atmosphericPressure = None
        cloudstate = None
        fog = None
        sun = None
        wind= None
        precipitation = None

        if &#39;temperature&#39; in element.attrib:
            temperature = element.attrib[&#39;temperature&#39;]
        if &#39;atmosphericPressure&#39; in element.attrib:
            atmosphericPressure = element.attrib[&#39;atmosphericPressure&#39;]
        if &#39;cloudState&#39; in element.attrib:
            cloudstate = getattr(CloudState, element.attrib[&#39;cloudState&#39;])
        if element.find(&#39;Sun&#39;) != None:
            sun = Sun.parse(element.find(&#39;Sun&#39;))
        if element.find(&#39;Fog&#39;) != None:
            fog = Fog.parse(element.find(&#39;Fog&#39;))
        if element.find(&#39;Precipitation&#39;) != None:
            precipitation = Precipitation.parse(element.find(&#39;Precipitation&#39;))
        if element.find(&#39;Wind&#39;) != None:
            wind = Wind.parse(element.find(&#39;Wind&#39;))

        return Weather(cloudstate,atmosphericPressure,temperature,sun,fog,precipitation,wind)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Weather as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.cloudstate:
            retdict[&#39;cloudState&#39;] = self.cloudstate.get_name()
        if self.temperature is not None and not self.isVersion(minor=0):
            retdict[&#39;temperature&#39;] = str(self.temperature)
        elif self.temperature is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;temperature was introduced in OpenSCENARIO V1.1&#39;)
        if self.atmosphericPressure is not None and not self.isVersion(minor=0):
            retdict[&#39;atmosphericPressure&#39;] = str(self.atmosphericPressure)
        elif self.atmosphericPressure is not None and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;atmosphericPressure was introduced in OpenSCENARIO V1.1&#39;)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Weather

        &#34;&#34;&#34;
        element = ET.Element(&#39;Weather&#39;,attrib=self.get_attributes())
        if self.sun:
            element.append(self.sun.get_element())
        if self.fog:
            element.append(self.fog.get_element())
        if self.precipitation:
            element.append(self.precipitation.get_element())
        if self.wind and not self.isVersion(minor=0):
            element.append(self.wind.get_element())
        if self.wind and self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(&#39;Wind was introduced in OpenSCENARIO V1.1&#39;)
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Weather.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Weather</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>weather (Weather): a Weather object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Weather

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A weather element (same as generated by the class itself)

        Returns
        -------
            weather (Weather): a Weather object

    &#34;&#34;&#34;
    temperature = None
    atmosphericPressure = None
    cloudstate = None
    fog = None
    sun = None
    wind= None
    precipitation = None

    if &#39;temperature&#39; in element.attrib:
        temperature = element.attrib[&#39;temperature&#39;]
    if &#39;atmosphericPressure&#39; in element.attrib:
        atmosphericPressure = element.attrib[&#39;atmosphericPressure&#39;]
    if &#39;cloudState&#39; in element.attrib:
        cloudstate = getattr(CloudState, element.attrib[&#39;cloudState&#39;])
    if element.find(&#39;Sun&#39;) != None:
        sun = Sun.parse(element.find(&#39;Sun&#39;))
    if element.find(&#39;Fog&#39;) != None:
        fog = Fog.parse(element.find(&#39;Fog&#39;))
    if element.find(&#39;Precipitation&#39;) != None:
        precipitation = Precipitation.parse(element.find(&#39;Precipitation&#39;))
    if element.find(&#39;Wind&#39;) != None:
        wind = Wind.parse(element.find(&#39;Wind&#39;))

    return Weather(cloudstate,atmosphericPressure,temperature,sun,fog,precipitation,wind)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Weather.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Weather as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Weather as a dict

    &#34;&#34;&#34;
    retdict = {}
    if self.cloudstate:
        retdict[&#39;cloudState&#39;] = self.cloudstate.get_name()
    if self.temperature is not None and not self.isVersion(minor=0):
        retdict[&#39;temperature&#39;] = str(self.temperature)
    elif self.temperature is not None and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;temperature was introduced in OpenSCENARIO V1.1&#39;)
    if self.atmosphericPressure is not None and not self.isVersion(minor=0):
        retdict[&#39;atmosphericPressure&#39;] = str(self.atmosphericPressure)
    elif self.atmosphericPressure is not None and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;atmosphericPressure was introduced in OpenSCENARIO V1.1&#39;)
    return retdict</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Weather.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Weather</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Weather

    &#34;&#34;&#34;
    element = ET.Element(&#39;Weather&#39;,attrib=self.get_attributes())
    if self.sun:
        element.append(self.sun.get_element())
    if self.fog:
        element.append(self.fog.get_element())
    if self.precipitation:
        element.append(self.precipitation.get_element())
    if self.wind and not self.isVersion(minor=0):
        element.append(self.wind.get_element())
    if self.wind and self.isVersion(minor=0):
        raise OpenSCENARIOVersionError(&#39;Wind was introduced in OpenSCENARIO V1.1&#39;)
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenariogeneration.xosc.utils.Wind"><code class="flex name class">
<span>class <span class="ident">Wind</span></span>
<span>(</span><span>direction, speed)</span>
</code></dt>
<dd>
<div class="desc"><p>Wind creates an Wind element used by the Weather element of openscenario</p>
<h2 id="parameters">Parameters</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>parse(element)
    parses a ElementTree created by the class and returns an instance of the class

get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of the class
</code></pre>
<p>initalize the Wind</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>direction (float): wind direction (radians)

speed (float): wind speed (m/s)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wind(VersionBase):
    &#34;&#34;&#34; Wind creates an Wind element used by the Weather element of openscenario
        
        Parameters
        ----------
            direction (float): wind direction (radians)

            speed (float): wind speed (m/s)

        Attributes
        ----------
            direction (float): wind direction (radians)

            speed (float): wind speed (m/s)

        Methods
        -------
            parse(element)
                parses a ElementTree created by the class and returns an instance of the class

            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of the class

    &#34;&#34;&#34;
    def __init__(self,direction,speed):
        &#34;&#34;&#34; initalize the Wind

            Parameters
            ----------
                direction (float): wind direction (radians)

                speed (float): wind speed (m/s)
                
        &#34;&#34;&#34;
        self.direction = direction
        self.speed = speed

    def __eq__(self,other):
        if isinstance(other,Wind):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod 
    def parse(element):
        &#34;&#34;&#34; Parses the xml element of Wind

            Parameters
            ----------
                element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)

            Returns
            -------
                wind (Wind): a Wind object

        &#34;&#34;&#34; 
        direction = element.attrib[&#39;direction&#39;]
        speed = element.attrib[&#39;speed&#39;]

        return Wind(direction,speed)
    
    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Wind as a dict

        &#34;&#34;&#34;
        return {&#39;direction&#39;:str(self.direction),&#39;speed&#39;:str(self.speed)}

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the Wind

        &#34;&#34;&#34;
        element = ET.Element(&#39;Wind&#39;,attrib=self.get_attributes())

        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenariogeneration.xosc.enumerations.VersionBase" href="enumerations.html#scenariogeneration.xosc.enumerations.VersionBase">VersionBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Wind.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml element of Wind</p>
<h2 id="parameters">Parameters</h2>
<pre><code>element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>wind (Wind): a Wind object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def parse(element):
    &#34;&#34;&#34; Parses the xml element of Wind

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A wind element (same as generated by the class itself)

        Returns
        -------
            wind (Wind): a Wind object

    &#34;&#34;&#34; 
    direction = element.attrib[&#39;direction&#39;]
    speed = element.attrib[&#39;speed&#39;]

    return Wind(direction,speed)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenariogeneration.xosc.utils.Wind.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Wind as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Wind as a dict

    &#34;&#34;&#34;
    return {&#39;direction&#39;:str(self.direction),&#39;speed&#39;:str(self.speed)}</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xosc.utils.Wind.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the Wind</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the Wind

    &#34;&#34;&#34;
    element = ET.Element(&#39;Wind&#39;,attrib=self.get_attributes())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xosc" href="index.html">scenariogeneration.xosc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.convert_bool" href="#scenariogeneration.xosc.utils.convert_bool">convert_bool</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.convert_float" href="#scenariogeneration.xosc.utils.convert_float">convert_float</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.convert_int" href="#scenariogeneration.xosc.utils.convert_int">convert_int</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.merge_dicts" href="#scenariogeneration.xosc.utils.merge_dicts">merge_dicts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed" href="#scenariogeneration.xosc.utils.AbsoluteSpeed">AbsoluteSpeed</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.get_element" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.AbsoluteSpeed.parse" href="#scenariogeneration.xosc.utils.AbsoluteSpeed.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.BoundingBox" href="#scenariogeneration.xosc.utils.BoundingBox">BoundingBox</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.BoundingBox.get_element" href="#scenariogeneration.xosc.utils.BoundingBox.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.BoundingBox.parse" href="#scenariogeneration.xosc.utils.BoundingBox.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Catalog" href="#scenariogeneration.xosc.utils.Catalog">Catalog</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Catalog.add_catalog" href="#scenariogeneration.xosc.utils.Catalog.add_catalog">add_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Catalog.get_element" href="#scenariogeneration.xosc.utils.Catalog.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Catalog.parse" href="#scenariogeneration.xosc.utils.Catalog.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.CatalogFile" href="#scenariogeneration.xosc.utils.CatalogFile">CatalogFile</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.add_to_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.add_to_catalog">add_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.create_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.create_catalog">create_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.create_catalog_element" href="#scenariogeneration.xosc.utils.CatalogFile.create_catalog_element">create_catalog_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.dump" href="#scenariogeneration.xosc.utils.CatalogFile.dump">dump</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogFile.open_catalog" href="#scenariogeneration.xosc.utils.CatalogFile.open_catalog">open_catalog</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.CatalogReference" href="#scenariogeneration.xosc.utils.CatalogReference">CatalogReference</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment" href="#scenariogeneration.xosc.utils.CatalogReference.add_parameter_assignment">add_parameter_assignment</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.get_attributes" href="#scenariogeneration.xosc.utils.CatalogReference.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.get_element" href="#scenariogeneration.xosc.utils.CatalogReference.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.CatalogReference.parse" href="#scenariogeneration.xosc.utils.CatalogReference.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Center" href="#scenariogeneration.xosc.utils.Center">Center</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Center.get_attributes" href="#scenariogeneration.xosc.utils.Center.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Center.get_element" href="#scenariogeneration.xosc.utils.Center.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Center.parse" href="#scenariogeneration.xosc.utils.Center.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Controller" href="#scenariogeneration.xosc.utils.Controller">Controller</a></code></h4>
<ul class="two-column">
<li><code><a title="scenariogeneration.xosc.utils.Controller.add_parameter" href="#scenariogeneration.xosc.utils.Controller.add_parameter">add_parameter</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.append_to_catalog" href="#scenariogeneration.xosc.utils.Controller.append_to_catalog">append_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.dump_to_catalog" href="#scenariogeneration.xosc.utils.Controller.dump_to_catalog">dump_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.get_attributes" href="#scenariogeneration.xosc.utils.Controller.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.get_element" href="#scenariogeneration.xosc.utils.Controller.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Controller.parse" href="#scenariogeneration.xosc.utils.Controller.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Dimensions" href="#scenariogeneration.xosc.utils.Dimensions">Dimensions</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.get_attributes" href="#scenariogeneration.xosc.utils.Dimensions.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.get_element" href="#scenariogeneration.xosc.utils.Dimensions.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Dimensions.parse" href="#scenariogeneration.xosc.utils.Dimensions.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints" href="#scenariogeneration.xosc.utils.DynamicsConstraints">DynamicsConstraints</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes" href="#scenariogeneration.xosc.utils.DynamicsConstraints.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.get_element" href="#scenariogeneration.xosc.utils.DynamicsConstraints.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.is_filled" href="#scenariogeneration.xosc.utils.DynamicsConstraints.is_filled">is_filled</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.DynamicsConstraints.parse" href="#scenariogeneration.xosc.utils.DynamicsConstraints.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.EntityRef" href="#scenariogeneration.xosc.utils.EntityRef">EntityRef</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.get_attributes" href="#scenariogeneration.xosc.utils.EntityRef.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.get_element" href="#scenariogeneration.xosc.utils.EntityRef.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.EntityRef.parse" href="#scenariogeneration.xosc.utils.EntityRef.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Environment" href="#scenariogeneration.xosc.utils.Environment">Environment</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Environment.append_to_catalog" href="#scenariogeneration.xosc.utils.Environment.append_to_catalog">append_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.dump_to_catalog" href="#scenariogeneration.xosc.utils.Environment.dump_to_catalog">dump_to_catalog</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.get_attributes" href="#scenariogeneration.xosc.utils.Environment.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.get_element" href="#scenariogeneration.xosc.utils.Environment.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Environment.parse" href="#scenariogeneration.xosc.utils.Environment.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.FileHeader" href="#scenariogeneration.xosc.utils.FileHeader">FileHeader</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.get_attributes" href="#scenariogeneration.xosc.utils.FileHeader.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.get_element" href="#scenariogeneration.xosc.utils.FileHeader.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.FileHeader.parse" href="#scenariogeneration.xosc.utils.FileHeader.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Fog" href="#scenariogeneration.xosc.utils.Fog">Fog</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Fog.get_attributes" href="#scenariogeneration.xosc.utils.Fog.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Fog.get_element" href="#scenariogeneration.xosc.utils.Fog.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Fog.parse" href="#scenariogeneration.xosc.utils.Fog.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.License" href="#scenariogeneration.xosc.utils.License">License</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.License.get_attributes" href="#scenariogeneration.xosc.utils.License.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.License.get_element" href="#scenariogeneration.xosc.utils.License.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.License.parse" href="#scenariogeneration.xosc.utils.License.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Orientation" href="#scenariogeneration.xosc.utils.Orientation">Orientation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Orientation.get_attributes" href="#scenariogeneration.xosc.utils.Orientation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.get_element" href="#scenariogeneration.xosc.utils.Orientation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.is_filled" href="#scenariogeneration.xosc.utils.Orientation.is_filled">is_filled</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Orientation.parse" href="#scenariogeneration.xosc.utils.Orientation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Parameter" href="#scenariogeneration.xosc.utils.Parameter">Parameter</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Parameter.add_value_constraint_group" href="#scenariogeneration.xosc.utils.Parameter.add_value_constraint_group">add_value_constraint_group</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.get_attributes" href="#scenariogeneration.xosc.utils.Parameter.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.get_element" href="#scenariogeneration.xosc.utils.Parameter.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Parameter.parse" href="#scenariogeneration.xosc.utils.Parameter.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ParameterAssignment" href="#scenariogeneration.xosc.utils.ParameterAssignment">ParameterAssignment</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.get_attributes" href="#scenariogeneration.xosc.utils.ParameterAssignment.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.get_element" href="#scenariogeneration.xosc.utils.ParameterAssignment.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterAssignment.parse" href="#scenariogeneration.xosc.utils.ParameterAssignment.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations" href="#scenariogeneration.xosc.utils.ParameterDeclarations">ParameterDeclarations</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter" href="#scenariogeneration.xosc.utils.ParameterDeclarations.add_parameter">add_parameter</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.get_element" href="#scenariogeneration.xosc.utils.ParameterDeclarations.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ParameterDeclarations.parse" href="#scenariogeneration.xosc.utils.ParameterDeclarations.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Phase" href="#scenariogeneration.xosc.utils.Phase">Phase</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Phase.add_signal_state" href="#scenariogeneration.xosc.utils.Phase.add_signal_state">add_signal_state</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.get_attributes" href="#scenariogeneration.xosc.utils.Phase.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.get_element" href="#scenariogeneration.xosc.utils.Phase.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Phase.parse" href="#scenariogeneration.xosc.utils.Phase.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Precipitation" href="#scenariogeneration.xosc.utils.Precipitation">Precipitation</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.get_attributes" href="#scenariogeneration.xosc.utils.Precipitation.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.get_element" href="#scenariogeneration.xosc.utils.Precipitation.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Precipitation.parse" href="#scenariogeneration.xosc.utils.Precipitation.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Properties" href="#scenariogeneration.xosc.utils.Properties">Properties</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Properties.add_file" href="#scenariogeneration.xosc.utils.Properties.add_file">add_file</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.add_property" href="#scenariogeneration.xosc.utils.Properties.add_property">add_property</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.get_element" href="#scenariogeneration.xosc.utils.Properties.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Properties.parse" href="#scenariogeneration.xosc.utils.Properties.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster">RelativeSpeedToMaster</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse" href="#scenariogeneration.xosc.utils.RelativeSpeedToMaster.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.RoadCondition" href="#scenariogeneration.xosc.utils.RoadCondition">RoadCondition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.get_attributes" href="#scenariogeneration.xosc.utils.RoadCondition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.get_element" href="#scenariogeneration.xosc.utils.RoadCondition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.RoadCondition.parse" href="#scenariogeneration.xosc.utils.RoadCondition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Sun" href="#scenariogeneration.xosc.utils.Sun">Sun</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Sun.get_attributes" href="#scenariogeneration.xosc.utils.Sun.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Sun.get_element" href="#scenariogeneration.xosc.utils.Sun.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Sun.parse" href="#scenariogeneration.xosc.utils.Sun.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState">TargetDistanceSteadyState</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse" href="#scenariogeneration.xosc.utils.TargetDistanceSteadyState.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState">TargetTimeSteadyState</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TargetTimeSteadyState.parse" href="#scenariogeneration.xosc.utils.TargetTimeSteadyState.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TimeOfDay" href="#scenariogeneration.xosc.utils.TimeOfDay">TimeOfDay</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.get_attributes" href="#scenariogeneration.xosc.utils.TimeOfDay.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.get_element" href="#scenariogeneration.xosc.utils.TimeOfDay.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeOfDay.parse" href="#scenariogeneration.xosc.utils.TimeOfDay.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TimeReference" href="#scenariogeneration.xosc.utils.TimeReference">TimeReference</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.get_attributes" href="#scenariogeneration.xosc.utils.TimeReference.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.get_element" href="#scenariogeneration.xosc.utils.TimeReference.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TimeReference.parse" href="#scenariogeneration.xosc.utils.TimeReference.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TrafficDefinition" href="#scenariogeneration.xosc.utils.TrafficDefinition">TrafficDefinition</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.add_controller" href="#scenariogeneration.xosc.utils.TrafficDefinition.add_controller">add_controller</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle" href="#scenariogeneration.xosc.utils.TrafficDefinition.add_vehicle">add_vehicle</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.get_attributes" href="#scenariogeneration.xosc.utils.TrafficDefinition.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.get_element" href="#scenariogeneration.xosc.utils.TrafficDefinition.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficDefinition.parse" href="#scenariogeneration.xosc.utils.TrafficDefinition.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TrafficSignalController" href="#scenariogeneration.xosc.utils.TrafficSignalController">TrafficSignalController</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.add_phase" href="#scenariogeneration.xosc.utils.TrafficSignalController.add_phase">add_phase</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.get_attributes" href="#scenariogeneration.xosc.utils.TrafficSignalController.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.get_element" href="#scenariogeneration.xosc.utils.TrafficSignalController.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TrafficSignalController.parse" href="#scenariogeneration.xosc.utils.TrafficSignalController.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.TransitionDynamics" href="#scenariogeneration.xosc.utils.TransitionDynamics">TransitionDynamics</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.get_attributes" href="#scenariogeneration.xosc.utils.TransitionDynamics.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.get_element" href="#scenariogeneration.xosc.utils.TransitionDynamics.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.TransitionDynamics.parse" href="#scenariogeneration.xosc.utils.TransitionDynamics.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ValueConstraint" href="#scenariogeneration.xosc.utils.ValueConstraint">ValueConstraint</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.get_attributes" href="#scenariogeneration.xosc.utils.ValueConstraint.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.get_element" href="#scenariogeneration.xosc.utils.ValueConstraint.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraint.parse" href="#scenariogeneration.xosc.utils.ValueConstraint.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup" href="#scenariogeneration.xosc.utils.ValueConstraintGroup">ValueConstraintGroup</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.add_value_constraint">add_value_constraint</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.get_element" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.ValueConstraintGroup.parse" href="#scenariogeneration.xosc.utils.ValueConstraintGroup.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Weather" href="#scenariogeneration.xosc.utils.Weather">Weather</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Weather.get_attributes" href="#scenariogeneration.xosc.utils.Weather.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Weather.get_element" href="#scenariogeneration.xosc.utils.Weather.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Weather.parse" href="#scenariogeneration.xosc.utils.Weather.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenariogeneration.xosc.utils.Wind" href="#scenariogeneration.xosc.utils.Wind">Wind</a></code></h4>
<ul class="">
<li><code><a title="scenariogeneration.xosc.utils.Wind.get_attributes" href="#scenariogeneration.xosc.utils.Wind.get_attributes">get_attributes</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Wind.get_element" href="#scenariogeneration.xosc.utils.Wind.get_element">get_element</a></code></li>
<li><code><a title="scenariogeneration.xosc.utils.Wind.parse" href="#scenariogeneration.xosc.utils.Wind.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>